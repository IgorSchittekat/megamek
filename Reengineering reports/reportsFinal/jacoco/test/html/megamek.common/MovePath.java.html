<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MovePath.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">megamek</a> &gt; <a href="index.source.html" class="el_package">megamek.common</a> &gt; <span class="el_source">MovePath.java</span></div><h1>MovePath.java</h1><pre class="source lang-java linenums">/**
 * MegaMek -
 * Copyright (C) 2000,2001,2002,2003,2004,2005 Ben Mazur (bmazur@sev.org)
 *
 *  This program is free software; you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by the Free
 *  Software Foundation; either version 2 of the License, or (at your option)
 *  any later version.
 *
 *  This program is distributed in the hope that it will be useful, but
 *  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 *  for more details.
 */

package megamek.common;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.PriorityQueue;
import java.util.Set;
import java.util.TreeMap;
import java.util.Vector;

import megamek.client.bot.princess.CardinalEdge;
import megamek.client.bot.princess.Princess;
import megamek.common.annotations.Nullable;
import megamek.common.logging.LogLevel;
import megamek.common.options.OptionsConstants;
import megamek.common.pathfinder.AbstractPathFinder;
import megamek.common.pathfinder.CachedEntityState;
import megamek.common.pathfinder.DestructionAwareDestinationPathfinder;
import megamek.common.pathfinder.ShortestPathFinder;
import megamek.common.preference.PreferenceManager;

/**
 * Holds movement path for an entity.
 */
public class MovePath implements Cloneable, Serializable {
    private static final long serialVersionUID = -4258296679177532986L;

<span class="fc" id="L49">    private Set&lt;Coords&gt; coordsSet = null;</span>
<span class="fc" id="L50">    private final transient Object COORD_SET_LOCK = new Object();</span>
    private transient CachedEntityState cachedEntityState;

    public IGame getGame() {
<span class="fc" id="L54">        return game;</span>
    }

    public void setGame(IGame game) {
<span class="fc" id="L58">        this.game = game;</span>
<span class="fc" id="L59">    }</span>

    public void setEntity(Entity entity) {
<span class="fc" id="L62">        this.entity = entity;</span>
<span class="fc" id="L63">        cachedEntityState = new CachedEntityState(entity);</span>
<span class="fc" id="L64">    }</span>

<span class="fc" id="L66">    public enum MoveStepType {</span>
<span class="fc" id="L67">        NONE, FORWARDS, BACKWARDS, TURN_LEFT, TURN_RIGHT, GET_UP, GO_PRONE, START_JUMP, CHARGE, DFA,</span>
<span class="fc" id="L68">        FLEE, LATERAL_LEFT, LATERAL_RIGHT, LATERAL_LEFT_BACKWARDS, LATERAL_RIGHT_BACKWARDS, UNJAM_RAC,</span>
<span class="fc" id="L69">        LOAD, UNLOAD, EJECT, CLEAR_MINEFIELD, UP, DOWN, SEARCHLIGHT, LAY_MINE, HULL_DOWN, CLIMB_MODE_ON,</span>
<span class="fc" id="L70">        CLIMB_MODE_OFF, SWIM, DIG_IN, FORTIFY, SHAKE_OFF_SWARMERS, TAKEOFF, VTAKEOFF, LAND, ACC, DEC, EVADE,</span>
<span class="fc" id="L71">        SHUTDOWN, STARTUP, SELF_DESTRUCT, ACCN, DECN, ROLL, OFF, RETURN, LAUNCH, THRUST, YAW, CRASH, RECOVER,</span>
<span class="fc" id="L72">        RAM, HOVER, MANEUVER, LOOP, CAREFUL_STAND, JOIN, DROP, VLAND, MOUNT, UNDOCK, TAKE_COVER,</span>
<span class="fc" id="L73">        CONVERT_MODE, BOOTLEGGER, TOW, DISCONNECT;</span>
    }

    public static class Key {
        private final Coords coords;
        private final int facing;
        private final int type;

<span class="nc" id="L81">        public Key(final Coords coords, final int facing, final int type) {</span>
<span class="nc" id="L82">            this.coords = coords;</span>
<span class="nc" id="L83">            this.facing = facing;</span>
<span class="nc" id="L84">            this.type = type;</span>
<span class="nc" id="L85">        }</span>

        @Override
        public boolean equals(final Object obj) {
<span class="nc bnc" id="L89" title="All 2 branches missed.">            if (!(obj instanceof Key)) {</span>
<span class="nc" id="L90">                return false;</span>
            }
<span class="nc" id="L92">            final Key s1 = (Key) obj;</span>
<span class="nc bnc" id="L93" title="All 6 branches missed.">            return (type == s1.type) &amp;&amp; (facing == s1.facing) &amp;&amp; coords.equals(s1.coords);</span>
        }

        @Override
        public int hashCode() {
<span class="nc" id="L98">            return type + (7 * (facing + (31 * coords.hashCode())));</span>
        }
    }

<span class="fc" id="L102">    private Vector&lt;MoveStep&gt; steps = new Vector&lt;&gt;();</span>

    private transient IGame game;
    private transient Entity entity;
    
    // holds the types of steps present in this movement 
<span class="fc" id="L108">    private Set&lt;MoveStepType&gt; containedStepTypes = new HashSet&lt;&gt;();</span>
    
    // whether this movePath take us directly over an enemy unit
    // useful for aircraft
    private boolean fliesOverEnemy;

    public static final int DEFAULT_PATHFINDER_TIME_LIMIT = 500;

    // is this move path being done using careful movement?
<span class="fc" id="L117">    private boolean careful = true;</span>

    /**
     * Generates a new, empty, movement path object.
     */
<span class="fc" id="L122">    public MovePath(final IGame game, final Entity entity) {</span>
<span class="fc" id="L123">        this.setEntity(entity);</span>
<span class="fc" id="L124">        this.setGame(game);</span>
<span class="fc" id="L125">    }</span>

    public Entity getEntity() {
<span class="fc" id="L128">        return entity;</span>
    }
    
    public CachedEntityState getCachedEntityState() {
<span class="fc" id="L132">        return cachedEntityState;</span>
    }

    public Key getKey() {
<span class="nc bnc" id="L136" title="All 4 branches missed.">        return new Key(getFinalCoords(), getFinalFacing(), getFinalProne() ? 0 : isJumping() ? 1 : 2);</span>
    }

    @Override
    public String toString() {
<span class="nc" id="L141">        final StringBuffer sb = new StringBuffer();</span>
<span class="nc" id="L142">        sb.append(&quot;MOVE PATH:&quot;);</span>
<span class="nc" id="L143">        sb.append(this.getKey().hashCode());</span>
<span class="nc" id="L144">        sb.append(' '); // it's useful to know for debugging purposes which path you're looking at.</span>
<span class="nc" id="L145">        sb.append(&quot;Length: &quot; + this.length());</span>
<span class="nc" id="L146">        sb.append(&quot;Final Coords: &quot; + this.getFinalCoords());</span>
<span class="nc" id="L147">        sb.append(System.lineSeparator());</span>
        
<span class="nc bnc" id="L149" title="All 2 branches missed.">        for (final Enumeration&lt;MoveStep&gt; i = steps.elements(); i.hasMoreElements(); ) {</span>
<span class="nc" id="L150">            sb.append(i.nextElement().toString());</span>
<span class="nc" id="L151">            sb.append(' ');</span>
        }
        
<span class="nc bnc" id="L154" title="All 2 branches missed.">        if(!getGame().getBoard().contains(this.getFinalCoords())) {</span>
<span class="nc" id="L155">            sb.append(&quot;OUT!&quot;);</span>
        }
        
<span class="nc bnc" id="L158" title="All 2 branches missed.">        if(this.getFliesOverEnemy()) {</span>
<span class="nc" id="L159">            sb.append(&quot;E! &quot;);</span>
        }
        
<span class="nc" id="L162">        return sb.toString();</span>
    }

    /**
     * Returns the number of steps in this movement
     */
    public int length() {
<span class="nc" id="L169">        return steps.size();</span>
    }

    /**
     * Add a new step to the movement path.
     *
     * @param type the type of movement.
     */
    public MovePath addStep(final MoveStepType type) {
        // TODO : detect steps off the map *here*.
<span class="fc" id="L179">        return addStep(new MoveStep(this, type));</span>
    }

    /**
     * Add a new step to the movement path with the given target.
     *
     * @param type   the type of movement.
     * @param target the &lt;code&gt;Targetable&lt;/code&gt; object that is the target of this
     *               step. For example, the enemy being charged.
     */
    public MovePath addStep(final MoveStepType type, final Targetable target) {
<span class="nc" id="L190">        return addStep(new MoveStep(this, type, target));</span>
    }

    public MovePath addStep(final MoveStepType type, final Targetable target, final Coords pos) {
<span class="nc" id="L194">        return addStep(new MoveStep(this, type, target, pos));</span>
    }

    public MovePath addStep(final MoveStepType type, final int mineToLay) {
<span class="nc" id="L198">        return addStep(type, -1, mineToLay);</span>
    }

    public MovePath addStep(final MoveStepType type, final int recover, final int mineToLay) {
<span class="nc" id="L202">        return addStep(new MoveStep(this, type, recover, mineToLay));</span>
    }

    public MovePath addStep(MoveStepType type, TreeMap&lt;Integer, Vector&lt;Integer&gt;&gt; targets) {
<span class="nc" id="L206">        return addStep(new MoveStep(this, type, targets));</span>
    }

    public MovePath addStep(final MoveStepType type, final boolean noCost) {
<span class="nc" id="L210">        return addStep(new MoveStep(this, type, noCost));</span>
    }

    public MovePath addStep(final MoveStepType type, final boolean noCost, final boolean isManeuver) {
<span class="nc" id="L214">        return addStep(new MoveStep(this, type, noCost, isManeuver));</span>
    }

    public MovePath addStep(final MoveStepType type, final Minefield mf) {
<span class="nc" id="L218">        return addStep(new MoveStep(this, type, mf));</span>
    }

    public MovePath addManeuver(final int manType) {
<span class="nc" id="L222">        return addStep(new MoveStep(this, MoveStepType.MANEUVER, -1, -1, manType));</span>
    }

    public boolean canShift() {
<span class="nc bnc" id="L226" title="All 2 branches missed.">        return ((getEntity() instanceof QuadMech</span>
                // QuadVee cannot shift in vee mode
<span class="nc bnc" id="L228" title="All 2 branches missed.">                &amp;&amp; !(getEntity() instanceof QuadVee</span>
<span class="nc bnc" id="L229" title="All 2 branches missed.">                        &amp;&amp; (entity.getConversionMode() == QuadVee.CONV_MODE_VEHICLE</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">                            || getEntity().isConvertingNow())))</span>
                // Maneuvering Ace allows Bipeds and VTOLs moving at cruise
                //  speed to perform a lateral shift
<span class="nc bnc" id="L233" title="All 2 branches missed.">                || (getEntity().isUsingManAce()</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">                    &amp;&amp; ((getEntity() instanceof BipedMech)</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">                        || ((getEntity() instanceof VTOL)</span>
<span class="nc bnc" id="L236" title="All 2 branches missed.">                        &amp;&amp; (getMpUsed() &lt;= getCachedEntityState().getWalkMP()))))</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">                || (game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_VEHICLE_ADVANCED_MANEUVERS)</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">                        &amp;&amp; getEntity() instanceof Tank</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">                        &amp;&amp; (getEntity().getMovementMode() == EntityMovementMode.VTOL</span>
<span class="nc bnc" id="L240" title="All 2 branches missed.">                        || getEntity().getMovementMode() == EntityMovementMode.HOVER))</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">                || ((getEntity() instanceof TripodMech)</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">                    &amp;&amp; (((Mech) getEntity()).countBadLegs() == 0)))</span>
<span class="nc bnc" id="L243" title="All 2 branches missed.">                &amp;&amp; !isJumping();</span>
    }

    /**
     * Returns true if this MovePath contains a lateral shift
     * @return
     */
    public boolean containsLateralShift() {
<span class="pc bpc" id="L251" title="1 of 2 branches missed.">        return this.contains(MoveStepType.LATERAL_LEFT)</span>
<span class="pc bpc" id="L252" title="1 of 2 branches missed.">                || this.contains(MoveStepType.LATERAL_RIGHT)</span>
<span class="pc bpc" id="L253" title="1 of 2 branches missed.">                || this.contains(MoveStepType.LATERAL_LEFT_BACKWARDS)</span>
<span class="pc bpc" id="L254" title="1 of 2 branches missed.">                || this.contains(MoveStepType.LATERAL_RIGHT_BACKWARDS);</span>
    }

    public boolean containsVTOLBomb() {
<span class="nc bnc" id="L258" title="All 2 branches missed.">        for (MoveStep step : steps) {</span>
<span class="nc bnc" id="L259" title="All 2 branches missed.">            if (step.isVTOLBombingStep()) {</span>
<span class="nc" id="L260">                return true;</span>
            }
<span class="nc" id="L262">        }</span>
<span class="nc" id="L263">        return false;</span>
    }

    protected MovePath addStep(final MoveStep step) {
<span class="fc" id="L267">        return addStep(step, true);</span>
    }

    public Set&lt;Coords&gt; getCoordsSet() {
<span class="nc bnc" id="L271" title="All 2 branches missed.">        if (coordsSet != null) {</span>
<span class="nc" id="L272">            return coordsSet;</span>
        }

<span class="nc" id="L275">        synchronized (COORD_SET_LOCK) {</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">            if (coordsSet != null) {</span>
<span class="nc" id="L277">                return coordsSet;</span>
            }

<span class="nc" id="L280">            coordsSet = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">            for (MoveStep step : getStepVector()) {</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">                if (step.getPosition() == null) {</span>
<span class="nc" id="L283">                    continue;</span>
                }
<span class="nc" id="L285">                coordsSet.add(step.getPosition());</span>
<span class="nc" id="L286">            }</span>
<span class="nc" id="L287">        }</span>
<span class="nc" id="L288">        return coordsSet;</span>
    }

    /**
     * Initializes a step as part of this movement path. Then adds it to the
     * list.
     *
     * @param step
     */
    protected MovePath addStep(final MoveStep step, boolean compile) {
<span class="pc bpc" id="L298" title="1 of 2 branches missed.">        if (step == null) {</span>
<span class="nc" id="L299">            System.err.println(new RuntimeException(&quot;Received NULL MoveStep&quot;));</span>
<span class="nc" id="L300">            return this;</span>
        }

<span class="fc" id="L303">        steps.addElement(step);</span>
<span class="fc" id="L304">        containedStepTypes.add(step.getType());</span>
        
<span class="fc" id="L306">        final MoveStep prev = getStep(steps.size() - 2);</span>

<span class="pc bpc" id="L308" title="1 of 2 branches missed.">        if (compile) {</span>
            try {
<span class="fc" id="L310">                step.compile(getGame(), getEntity(), prev, getCachedEntityState());</span>
<span class="fc" id="L311">            } catch (final RuntimeException re) {</span>
                // // N.B. the pathfinding will try steps off the map.
                // re.printStackTrace();
<span class="fc" id="L314">                step.setMovementType(EntityMovementType.MOVE_ILLEGAL);</span>
<span class="fc" id="L315">            }</span>
        }


        // check for illegal jumps
<span class="fc" id="L320">        final Coords start = getEntity().getPosition();</span>
<span class="fc" id="L321">        final Coords land = step.getPosition();</span>
<span class="pc bpc" id="L322" title="3 of 4 branches missed.">        if ((start == null) || (land == null)) {</span>
            // If we have null for either coordinate then we know the step
            // isn't legal.
<span class="fc" id="L325">            step.setMovementType(EntityMovementType.MOVE_ILLEGAL);</span>
        } else {
            // if we're jumping without a mechanical jump booster (?)
            // or we're acting like a spheroid dropship in the atmosphere
<span class="nc bnc" id="L329" title="All 4 branches missed.">            if ((isJumping() &amp;&amp; (getEntity().getJumpType() != Mech.JUMP_BOOSTER)) ||</span>
<span class="nc bnc" id="L330" title="All 4 branches missed.">                    (Compute.useSpheroidAtmosphere(game, getEntity()) &amp;&amp; (step.getType() != MoveStepType.HOVER))) {</span>
<span class="nc" id="L331">                int distance = start.distance(land);</span>
                
<span class="nc bnc" id="L333" title="All 4 branches missed.">                if (step.isThisStepBackwards() || (step.getDistance() &gt; distance)) {</span>
<span class="nc" id="L334">                    step.setMovementType(EntityMovementType.MOVE_ILLEGAL);</span>
                }
            }
        }
        
        // Can't move backwards and Evade
<span class="pc bpc" id="L340" title="1 of 4 branches missed.">        if (!entity.isAirborne() &amp;&amp; contains(MoveStepType.BACKWARDS)</span>
<span class="nc bnc" id="L341" title="All 2 branches missed.">                &amp;&amp; contains(MoveStepType.EVADE)) {</span>
<span class="nc" id="L342">            step.setMovementType(EntityMovementType.MOVE_ILLEGAL);</span>
        }
        
        // If jumpships turn, they can't do anything else 
<span class="pc bpc" id="L346" title="5 of 6 branches missed.">        if (game.getBoard().inSpace()</span>
                &amp;&amp; (entity instanceof Jumpship)
                &amp;&amp; !(entity instanceof Warship)
<span class="nc bnc" id="L349" title="All 2 branches missed.">                &amp;&amp; !step.isFirstStep()</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">                &amp;&amp; (contains(MoveStepType.TURN_LEFT) </span>
<span class="nc bnc" id="L351" title="All 2 branches missed.">                        || contains(MoveStepType.TURN_RIGHT))) {</span>
<span class="nc" id="L352">            step.setMovementType(EntityMovementType.MOVE_ILLEGAL);</span>
        }
        
        // Ensure we only lay one mine
<span class="pc bpc" id="L356" title="1 of 2 branches missed.">        if ((step.getType() == MoveStepType.LAY_MINE)) {</span>
<span class="nc" id="L357">            boolean containsOtherLayMineStep = false;</span>
<span class="nc bnc" id="L358" title="All 2 branches missed.">            for (int i = 0; i &lt; steps.size() - 1; i++) {</span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">                if (steps.get(i).getType() == MoveStepType.LAY_MINE) {</span>
<span class="nc" id="L360">                    containsOtherLayMineStep = true;</span>
                }
            }
<span class="nc bnc" id="L363" title="All 2 branches missed.">            if (containsOtherLayMineStep) {</span>
<span class="nc" id="L364">                step.setMovementType(EntityMovementType.MOVE_ILLEGAL);</span>
            }
        }

        // Ensure we only bomb one hex
<span class="pc bpc" id="L369" title="1 of 2 branches missed.">        if (step.isVTOLBombingStep()) {</span>
<span class="nc" id="L370">            boolean containsOtherBombStep = false;</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">            for (int i = 0; i &lt; steps.size() - 1; i++) {</span>
<span class="nc bnc" id="L372" title="All 2 branches missed.">                if (steps.get(i).isVTOLBombingStep()) {</span>
<span class="nc" id="L373">                    containsOtherBombStep = true;</span>
                }
            }
<span class="nc bnc" id="L376" title="All 2 branches missed.">            if (containsOtherBombStep) {</span>
<span class="nc" id="L377">                step.setMovementType(EntityMovementType.MOVE_ILLEGAL);</span>
            }
        }
        
        // Make sure we are not turning or changing elevation while strafing, and that we are not
        // starting a second group of hexes during the same round
<span class="pc bpc" id="L383" title="3 of 4 branches missed.">        if (step.isStrafingStep() &amp;&amp; steps.size() &gt; 1) {</span>
<span class="nc" id="L384">            MoveStep last = steps.get(steps.size() - 2);</span>
            // If the previous step is a strafing step, make sure we have the same facing and elevation
            // and we are not exceeding the maximum five hexes.
<span class="nc bnc" id="L387" title="All 2 branches missed.">            if (last.isStrafingStep()) {</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">                if (step.getFacing() != last.getFacing()</span>
<span class="nc" id="L389">                        || (step.getElevation() + getGame().getBoard().getHex(step.getPosition()).floor()</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">                            != last.getElevation() + getGame().getBoard().getHex(last.getPosition()).floor())</span>
<span class="nc bnc" id="L391" title="All 2 branches missed.">                        || steps.stream().filter(s -&gt; s.isStrafingStep()).count() &gt; 5) {</span>
<span class="nc" id="L392">                    step.setMovementType(EntityMovementType.MOVE_ILLEGAL);</span>
                }
            } else {
                // If the previous step is not a strafing step, make sure that the new step is the only strafing
                // step we have in the path.
<span class="nc bnc" id="L397" title="All 2 branches missed.">                for (int i = 0; i &lt; steps.size() - 2; i++) {</span>
<span class="nc bnc" id="L398" title="All 2 branches missed.">                    if (steps.get(i).isStrafingStep()) {</span>
<span class="nc" id="L399">                        step.setMovementType(EntityMovementType.MOVE_ILLEGAL);</span>
                    }
                }
            }
        }

        // jumping into heavy woods is danger
<span class="pc bpc" id="L406" title="1 of 2 branches missed.">        if (game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_PSR_JUMP_HEAVY_WOODS)) {</span>
<span class="nc" id="L407">            IHex hex = game.getBoard().getHex(step.getPosition());</span>
<span class="nc bnc" id="L408" title="All 6 branches missed.">            if ((hex != null) &amp;&amp; isJumping() &amp;&amp; step.isEndPos(this)) {</span>
<span class="nc" id="L409">                PilotingRollData psr = entity.checkLandingInHeavyWoods(step.getMovementType(false), hex);</span>
<span class="nc bnc" id="L410" title="All 2 branches missed.">                if (psr.getValue() != PilotingRollData.CHECK_FALSE) {</span>
<span class="nc" id="L411">                    step.setDanger(true);</span>
                }
            }
        }

        // VTOLs using maneuvering ace to make lateral shifts can't flank
        // unless using controlled sideslip
<span class="pc bpc" id="L418" title="3 of 4 branches missed.">        if (containsLateralShift() &amp;&amp; getEntity().isUsingManAce()</span>
<span class="nc bnc" id="L419" title="All 2 branches missed.">                &amp;&amp; (getEntity() instanceof VTOL)</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">                &amp;&amp; getMpUsed() &gt; getCachedEntityState().getWalkMP()</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">                &amp;&amp; !game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_VEHICLE_ADVANCED_MANEUVERS)) {</span>
<span class="nc" id="L422">            step.setMovementType(EntityMovementType.MOVE_ILLEGAL);</span>
        }
        
<span class="pc bpc" id="L425" title="1 of 2 branches missed.">        if (shouldMechanicalJumpCauseFallDamage()) {</span>
<span class="nc" id="L426">            step.setDanger(true);</span>
        }
       
        // If a tractor connects a new trailer this round, it can't do anything but add more trailers
        // This prevents the tractor from moving before its MP, stacking limitations and prohibited terrain can be updated by its trailers
        // It makes sense, too. You can't just connect a trailer and drive off with it in &lt;10 seconds. 
<span class="pc bpc" id="L432" title="3 of 4 branches missed.">        if (contains(MoveStepType.TOW) &amp;&amp; !(step.getType() == MoveStepType.TOW)) {</span>
<span class="nc" id="L433">            step.setMovementType(EntityMovementType.MOVE_ILLEGAL);</span>
        }
        
        // If the new step is legal and is a different position than
        // the previous step, then update the older steps, letting
        // them know that they are no longer the end of the path.
<span class="pc bpc" id="L439" title="5 of 6 branches missed.">        if (step.isLegal(this) &amp;&amp; (null != prev) &amp;&amp; !land.equals(prev.getPosition())) {</span>

            // Loop through the steps from back to front.
            // Stop looping when the step says to, or we run out of steps.
<span class="nc" id="L443">            int index = steps.size() - 2;</span>
<span class="nc bnc" id="L444" title="All 4 branches missed.">            while ((index &gt;= 0) &amp;&amp; getStep(index).setEndPos(false)) {</span>
<span class="nc" id="L445">                index--;</span>
            }

        } // End step-is-legal

        // If using TacOps reverse gear option, cannot mix forward and backward movement
        // in the same round except VTOLs.
<span class="pc bpc" id="L452" title="7 of 8 branches missed.">        if (game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_REVERSE_GEAR)</span>
                &amp;&amp; ((entity instanceof Tank &amp;&amp; !(entity instanceof VTOL))
                        || (entity instanceof QuadVee
<span class="nc bnc" id="L455" title="All 2 branches missed.">                                &amp;&amp; entity.getConversionMode() == QuadVee.CONV_MODE_VEHICLE))) {</span>
<span class="nc" id="L456">            boolean fwd = false;</span>
<span class="nc" id="L457">            boolean rev = false;</span>
<span class="nc bnc" id="L458" title="All 2 branches missed.">            for (MoveStep s : steps) {</span>
<span class="nc bnc" id="L459" title="All 2 branches missed.">                fwd |=  s.getType() == MoveStepType.FORWARDS</span>
<span class="nc bnc" id="L460" title="All 2 branches missed.">                        || s.getType() == MoveStepType.LATERAL_LEFT</span>
<span class="nc bnc" id="L461" title="All 2 branches missed.">                        || s.getType() == MoveStepType.LATERAL_RIGHT;</span>
<span class="nc bnc" id="L462" title="All 2 branches missed.">                rev |=  s.getType() == MoveStepType.BACKWARDS</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">                        || s.getType() == MoveStepType.LATERAL_LEFT_BACKWARDS</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">                        || s.getType() == MoveStepType.LATERAL_RIGHT_BACKWARDS;</span>
<span class="nc" id="L465">            }</span>
<span class="nc bnc" id="L466" title="All 4 branches missed.">            if (fwd &amp;&amp; rev) {</span>
<span class="nc" id="L467">                step.setMovementType(EntityMovementType.MOVE_ILLEGAL);</span>
            }
        }
                
        // If we are using turn modes, go back through the path and mark danger for any turn
        // that now exceeds turn mode requirement. We want to show danger on the previous step
        // so the StepSprite will show danger. Hiding the previous step instead would make turning costs
        // show in the turning hex for units tracking turn mode, unlike other units.
<span class="pc bpc" id="L475" title="3 of 4 branches missed.">        if (entity.usesTurnMode() &amp;&amp; getMpUsed() &gt; 5) {</span>
<span class="nc" id="L476">            int turnMode = getMpUsed() / 5;</span>
<span class="nc" id="L477">            int nStraight = 0;</span>
<span class="nc" id="L478">            MoveStep prevStep = steps.get(0);</span>
<span class="nc bnc" id="L479" title="All 2 branches missed.">            for (MoveStep s : steps) {</span>
<span class="nc bnc" id="L480" title="All 4 branches missed.">                if (s.isTurning() &amp;&amp; nStraight &lt; turnMode) {</span>
<span class="nc" id="L481">                    prevStep.setDanger(true);</span>
                }
<span class="nc" id="L483">                nStraight = s.getNStraight();</span>
<span class="nc" id="L484">                prevStep = s;</span>
<span class="nc" id="L485">            }</span>
        }
        
        // If running on pavement we don't know to mark the danger steps if we turn before expending
        // enough MP to require running movement.
<span class="pc bpc" id="L490" title="1 of 2 branches missed.">        if (steps.size() &gt; 1) {</span>
<span class="nc" id="L491">            MoveStep lastStep = steps.get(steps.size() - 1);</span>
<span class="nc" id="L492">            MoveStep prevStep = steps.get(0);</span>
<span class="nc bnc" id="L493" title="All 2 branches missed.">            for (MoveStep s : steps) {</span>
<span class="nc bnc" id="L494" title="All 2 branches missed.">                if (s.getMovementType(false) == EntityMovementType.MOVE_ILLEGAL) {</span>
<span class="nc" id="L495">                    break;</span>
                }
<span class="nc bnc" id="L497" title="All 4 branches missed.">                s.setDanger(s.isDanger() || Compute.isPilotingSkillNeeded(game, entity.getId(),</span>
<span class="nc" id="L498">                        prevStep.getPosition(), s.getPosition(), lastStep.getMovementType(true),</span>
<span class="nc" id="L499">                        prevStep.isTurning(), prevStep.isPavementStep(), prevStep.getElevation(),</span>
<span class="nc" id="L500">                                s.getElevation(), s));</span>
<span class="nc bnc" id="L501" title="All 4 branches missed.">                s.setPastDanger(s.isPastDanger() || s.isDanger());</span>
<span class="nc" id="L502">                prevStep = s;</span>
<span class="nc" id="L503">            }</span>
        }
        
<span class="fc bfc" id="L506" title="All 2 branches covered.">        if(step.useAeroAtmosphere(game, entity) </span>
<span class="pc bpc" id="L507" title="1 of 2 branches missed.">        		&amp;&amp; game.getBoard().onGround()											//we're an aerospace unit on a ground map</span>
<span class="pc bpc" id="L508" title="1 of 2 branches missed.">        		&amp;&amp; step.getPosition() != null  											//null</span>
<span class="nc bnc" id="L509" title="All 2 branches missed.">        		&amp;&amp; game.getFirstEnemyEntity(step.getPosition(), entity) != null) {</span>
<span class="nc" id="L510">        	fliesOverEnemy = true;</span>
        }

<span class="fc" id="L513">        return this;</span>
    }

    public void compile(final IGame g, final Entity en) {
<span class="nc" id="L517">        compile(g, en, true);</span>
<span class="nc" id="L518">    }</span>

    public void compile(final IGame g, final Entity en, boolean clip) {
<span class="nc" id="L521">        setGame(g);</span>
<span class="nc" id="L522">        setEntity(en);</span>
<span class="nc" id="L523">        final Vector&lt;MoveStep&gt; temp = new Vector&lt;MoveStep&gt;(steps);</span>
<span class="nc" id="L524">        steps.removeAllElements();</span>
<span class="nc bnc" id="L525" title="All 2 branches missed.">        for (int i = 0; i &lt; temp.size(); i++) {</span>
<span class="nc" id="L526">            MoveStep step = temp.elementAt(i);</span>
<span class="nc bnc" id="L527" title="All 4 branches missed.">            if ((step.getTargetPosition() != null) &amp;&amp; (step.getTarget(getGame()) != null)) {</span>
<span class="nc" id="L528">                step = new MoveStep(this, step.getType(), step.getTarget(getGame()), step.getTargetPosition());</span>
<span class="nc bnc" id="L529" title="All 2 branches missed.">            } else if (step.getTarget(getGame()) != null) {</span>
<span class="nc" id="L530">                step = new MoveStep(this, step.getType(), step.getTarget(getGame()));</span>
<span class="nc bnc" id="L531" title="All 2 branches missed.">            } else if (step.getRecoveryUnit() != -1) {</span>
<span class="nc" id="L532">                step = new MoveStep(this, step.getType(), step.getRecoveryUnit(), -1);</span>
<span class="nc bnc" id="L533" title="All 2 branches missed.">            } else if (step.getMineToLay() != -1) {</span>
<span class="nc" id="L534">                step = new MoveStep(this, step.getType(), step.getMineToLay());</span>
<span class="nc bnc" id="L535" title="All 2 branches missed.">            } else if (step.getLaunched().size() &gt; 0) {</span>
<span class="nc" id="L536">                step = new MoveStep(this, step.getType(), step.getLaunched());</span>
<span class="nc bnc" id="L537" title="All 2 branches missed.">            } else if (step.getManeuverType() != ManeuverType.MAN_NONE) {</span>
<span class="nc" id="L538">                step = new MoveStep(this, step.getType(), -1, -1, step.getManeuverType());</span>
<span class="nc bnc" id="L539" title="All 2 branches missed.">            } else if (step.isManeuver()) {</span>
<span class="nc" id="L540">                step = new MoveStep(this, step.getType(), step.hasNoCost(), step.isManeuver());</span>
<span class="nc bnc" id="L541" title="All 2 branches missed.">            } else if (step.hasNoCost()) {</span>
<span class="nc" id="L542">                step = new MoveStep(this, step.getType(), step.hasNoCost());</span>
<span class="nc bnc" id="L543" title="All 2 branches missed.">            } else if (null != step.getMinefield()) {</span>
<span class="nc" id="L544">                step = new MoveStep(this, step.getType(), step.getMinefield());</span>
            } else {
<span class="nc" id="L546">                step = new MoveStep(this, step.getType());</span>
            }
<span class="nc" id="L548">            this.addStep(step);</span>
        }

        // Can't move out of a hex with an enemy unit unless we started
        // there, BUT we're allowed to turn, unload/disconnect, or go prone.
<span class="nc" id="L553">        Coords pos = getEntity().getPosition();</span>
<span class="nc" id="L554">        boolean isMech = getEntity() instanceof Mech;</span>
<span class="nc" id="L555">        int elev = getEntity().getElevation();</span>
<span class="nc bnc" id="L556" title="All 2 branches missed.">        if (Compute.isEnemyIn(getGame(), getEntity(), pos, false, isMech, elev)) {</span>
            // There is an enemy, can't go out and back in, and go out again
<span class="nc" id="L558">            boolean left = false;</span>
<span class="nc" id="L559">            boolean returned = false;</span>
<span class="nc bnc" id="L560" title="All 2 branches missed.">            for (MoveStep step : steps) {</span>
<span class="nc bnc" id="L561" title="All 2 branches missed.">                if (!left) {</span>
<span class="nc bnc" id="L562" title="All 2 branches missed.">                    if (!step.getPosition().equals(getEntity().getPosition())</span>
<span class="nc bnc" id="L563" title="All 2 branches missed.">                        || !(step.getElevation() == getEntity().getElevation())) {</span>
                        // we left the location
<span class="nc" id="L565">                        left = true;</span>
<span class="nc" id="L566">                        continue;</span>
                    }
                    continue;
                }
<span class="nc bnc" id="L570" title="All 2 branches missed.">                if (!returned) {</span>
<span class="nc bnc" id="L571" title="All 2 branches missed.">                    if (step.getPosition().equals(getEntity().getPosition())</span>
<span class="nc bnc" id="L572" title="All 2 branches missed.">                        &amp;&amp; (step.getElevation() == getEntity().getElevation())) {</span>
                        // we returned to the location
<span class="nc" id="L574">                        returned = true;</span>
<span class="nc" id="L575">                        continue;</span>
                    }
                    continue;
                }
                // We've returned, only following 5 types are legal
<span class="nc bnc" id="L580" title="All 2 branches missed.">                if ((step.getType() != MovePath.MoveStepType.TURN_LEFT)</span>
<span class="nc bnc" id="L581" title="All 2 branches missed.">                        &amp;&amp; (step.getType() != MovePath.MoveStepType.TURN_RIGHT)</span>
<span class="nc bnc" id="L582" title="All 2 branches missed.">                        &amp;&amp; (step.getType() != MovePath.MoveStepType.UNLOAD)</span>
<span class="nc bnc" id="L583" title="All 2 branches missed.">                        &amp;&amp; (step.getType() != MovePath.MoveStepType.DISCONNECT)</span>
<span class="nc bnc" id="L584" title="All 2 branches missed.">                        &amp;&amp; (step.getType() != MovePath.MoveStepType.GO_PRONE)) {</span>
                    // we only need to identify the first illegal move
<span class="nc" id="L586">                    step.setMovementType(EntityMovementType.MOVE_ILLEGAL);</span>
<span class="nc" id="L587">                    break;</span>
                }
<span class="nc" id="L589">            }</span>
        }
        
<span class="nc bnc" id="L592" title="All 2 branches missed.">        if (getEntity() instanceof LandAirMech</span>
<span class="nc bnc" id="L593" title="All 2 branches missed.">                &amp;&amp; !((LandAirMech)getEntity()).canConvertTo(getFinalConversionMode())) {</span>
<span class="nc" id="L594">            steps.forEach(s -&gt; {</span>
<span class="nc bnc" id="L595" title="All 2 branches missed.">                if (s.getType() == MoveStepType.CONVERT_MODE) {</span>
<span class="nc" id="L596">                    s.setMovementType(EntityMovementType.MOVE_ILLEGAL);</span>
                }
<span class="nc" id="L598">            });</span>
        }

<span class="nc bnc" id="L601" title="All 2 branches missed.">        if (clip) {</span>
<span class="nc" id="L602">            clipToPossible();</span>
        }
<span class="nc" id="L604">    }</span>

    public void removeLastStep() {
<span class="nc bnc" id="L607" title="All 2 branches missed.">        if (steps.size() &gt; 0) {</span>
<span class="nc" id="L608">            final MoveStep step1 = getStep(steps.size() - 1);</span>

<span class="nc bnc" id="L610" title="All 2 branches missed.">            if (step1.getType() == MovePath.MoveStepType.START_JUMP) {</span>
<span class="nc" id="L611">                getEntity().setIsJumpingNow(false);</span>
            }
            
<span class="nc" id="L614">            steps.removeElementAt(steps.size() - 1);</span>
            
<span class="nc bnc" id="L616" title="All 4 branches missed.">            if (getEntity().isConvertingNow() &amp;&amp; !this.contains(MovePath.MoveStepType.CONVERT_MODE)) {</span>
<span class="nc" id="L617">                getEntity().setConvertingNow(false);</span>
                //Mechs using tracks have the movement mode set at the beginning of the turn, so
                //it will need to be reset.
<span class="nc bnc" id="L620" title="All 4 branches missed.">                if (getEntity() instanceof Mech &amp;&amp; ((Mech)getEntity()).hasTracks()) {</span>
<span class="nc" id="L621">                    getEntity().toggleConversionMode();</span>
                }
            }
            
            //Treat multiple convert steps as a single command
<span class="nc bnc" id="L626" title="All 2 branches missed.">            if (step1.getType() == MovePath.MoveStepType.CONVERT_MODE)</span>
<span class="nc bnc" id="L627" title="All 2 branches missed.">                while (steps.size() &gt; 0</span>
<span class="nc bnc" id="L628" title="All 2 branches missed.">                    &amp;&amp; steps.get(steps.size() - 1).getType() == MovePath.MoveStepType.CONVERT_MODE) {</span>
<span class="nc" id="L629">                steps.removeElementAt(steps.size() - 1);</span>
            }
            
            // if this step is part of a manuever, undo the whole manuever, all the way to the beginning.
<span class="nc bnc" id="L633" title="All 2 branches missed.">            if(step1.isManeuver()) {</span>
<span class="nc" id="L634">                int stepIndex = steps.size() - 1;</span>
                
<span class="nc bnc" id="L636" title="All 4 branches missed.">                while (steps.size() &gt; 0 &amp;&amp; steps.get(stepIndex).isManeuver()) {</span>
<span class="nc" id="L637">                    steps.removeElementAt(stepIndex);</span>
<span class="nc" id="L638">                    stepIndex--;</span>
                }
                
                // a maneuver begins with a &quot;maneuver&quot; step, so get rid of that as well
<span class="nc" id="L642">                steps.removeElementAt(stepIndex);</span>
            }
        }

        // Find the new last step in the path.
<span class="nc" id="L647">        int index = steps.size() - 1;</span>
<span class="nc bnc" id="L648" title="All 4 branches missed.">        while ((index &gt;= 0) &amp;&amp; getStep(index).setEndPos(true)</span>
<span class="nc bnc" id="L649" title="All 2 branches missed.">                &amp;&amp; !getStep(index).isLegal(this)) {</span>
<span class="nc" id="L650">            index--;</span>
        }
        
        // we may have removed a lot of steps - recalculate the contained step types
<span class="nc" id="L654">        regenerateStepTypes();</span>
<span class="nc" id="L655">    }</span>

    public void clear() {
<span class="nc" id="L658">        steps.removeAllElements();</span>
<span class="nc" id="L659">    }</span>

    public Enumeration&lt;MoveStep&gt; getSteps() {
<span class="nc" id="L662">        return steps.elements();</span>
    }

    public MoveStep getStep(final int index) {
<span class="pc bpc" id="L666" title="3 of 4 branches missed.">        if ((index &lt; 0) || (index &gt;= steps.size())) {</span>
<span class="fc" id="L667">            return null;</span>
        }
<span class="nc" id="L669">        return steps.elementAt(index);</span>
    }

    /**
     * Helper function that rebuilds the &quot;contained step types&quot; from scratch.
     * Loops over all the steps in the path, so should only be used when removing or replacing steps.
     */
    private void regenerateStepTypes() {
<span class="nc" id="L677">        containedStepTypes.clear();</span>
<span class="nc bnc" id="L678" title="All 2 branches missed.">        for(MoveStep step : steps) {</span>
<span class="nc" id="L679">            containedStepTypes.add(step.getType());</span>
<span class="nc" id="L680">        }</span>
<span class="nc" id="L681">    }</span>
    
    /**
     * Check for any of the specified type of step in the path
     * @param type The step type to check for
     * @return Whether or not this step type is contained within this path 
     */
    public boolean contains(final MoveStepType type) {
<span class="fc" id="L689">        return containedStepTypes.contains(type);</span>
    }
    
    /**
     * Convenience function to determine whether this path results in the unit explicitly moving off board
     * More relevant for aircraft
     * @return Whether or not this path will result in the unit moving off board
     */
    public boolean fliesOffBoard() {
<span class="nc bnc" id="L698" title="All 2 branches missed.">    	return contains(MoveStepType.OFF) || </span>
<span class="nc bnc" id="L699" title="All 2 branches missed.">    	        contains(MoveStepType.RETURN) || </span>
<span class="nc bnc" id="L700" title="All 2 branches missed.">    	        contains(MoveStepType.FLEE);</span>
    }
    
    /**
     * Whether any of the steps in the path (except for the last one, based on experimentation)
     * pass over an enemy unit eligible for targeting. Useful for aerotech units.
     * Note that this is only useful for debugging against stationary targets, as it &quot;may&quot; become inaccurate
     * if the target moves.
     * @return Whether or not this flight path takes us over an enemy unit
     */
    public boolean getFliesOverEnemy() {
<span class="nc" id="L711">    	return fliesOverEnemy;</span>
    }
    
    /**
     * Method that determines whether a given path goes through a given set of x/y coordinates
     * Useful for debugging mainly.
     * Note that battletech map coordinates begin at 1, while the internal representation begins at 0
     * so subtract 1 from each axis to get the actual coordinates.
     * @param x X-coordinate
     * @param y Y-coordinate
     * @return Whether this path goes through the set of coordinates.
     */
    public boolean goesThroughCoords(int x, int y) {
<span class="nc" id="L724">        Enumeration&lt;MoveStep&gt; steps = getSteps();</span>
<span class="nc bnc" id="L725" title="All 2 branches missed.">        while(steps.hasMoreElements()) {</span>
<span class="nc" id="L726">            MoveStep step = steps.nextElement();</span>
<span class="nc bnc" id="L727" title="All 4 branches missed.">            if(step.getPosition().getX() == x &amp;&amp; step.getPosition().getY() == y) {</span>
<span class="nc" id="L728">                return true;</span>
            }
<span class="nc" id="L730">        }</span>
        
<span class="nc" id="L732">        return false;</span>
    }
    
    /**
     * Check for the presence of any step type that's not the specified step type in the move path
     * @param type The step type to check for
     * @return Whether or not there are any other step types 
     */
    public boolean containsAnyOther(final MoveStepType type) {
<span class="nc bnc" id="L741" title="All 2 branches missed.">    	for(Iterator&lt;MoveStepType&gt; iter = containedStepTypes.iterator(); iter.hasNext();) {</span>
<span class="nc bnc" id="L742" title="All 2 branches missed.">    		if(iter.next() != type)</span>
<span class="nc" id="L743">				return true;</span>
    	}
    	
<span class="nc" id="L746">    	return false;</span>
    }

    /**
     * Check for MASC use
     */
    public boolean hasActiveMASC() {
<span class="nc bnc" id="L753" title="All 2 branches missed.">        for (final Enumeration&lt;MoveStep&gt; i = getSteps(); i.hasMoreElements(); ) {</span>
<span class="nc" id="L754">            final MoveStep step = i.nextElement();</span>
<span class="nc bnc" id="L755" title="All 2 branches missed.">            if (step.isUsingMASC()) {</span>
<span class="nc" id="L756">                return true;</span>
            }
<span class="nc" id="L758">        }</span>
<span class="nc" id="L759">        return false;</span>
    }

    /**
     * Returns the final coordinates if a mech were to perform all the steps in
     * this path.
     */
    public Coords getFinalCoords() {
<span class="pc bpc" id="L767" title="1 of 2 branches missed.">        if(getGame().useVectorMove()) {</span>
<span class="nc" id="L768">            return Compute.getFinalPosition(getEntity().getPosition(), getFinalVectors());</span>
        }
        
<span class="pc bpc" id="L771" title="1 of 2 branches missed.">        if (getLastStep() != null) {</span>
<span class="fc" id="L772">            return getLastStep().getPosition();</span>
        }
        
<span class="nc" id="L775">        return getEntity().getPosition();</span>
    }

    /**
     * Returns the starting {@link Coords} of this path.
     */
    @Nullable
    public Coords getStartCoords() {
<span class="nc bnc" id="L783" title="All 2 branches missed.">        for (final Enumeration&lt;MoveStep&gt; e = getSteps(); e.hasMoreElements(); ) {</span>
<span class="nc" id="L784">            final MoveStep step = e.nextElement();</span>
<span class="nc" id="L785">            final Coords coords = step.getPosition();</span>
<span class="nc bnc" id="L786" title="All 2 branches missed.">            if (coords != null) {</span>
<span class="nc" id="L787">                return coords;</span>
            }
<span class="nc" id="L789">        }</span>
<span class="nc" id="L790">        return null;</span>
    }

    /**
     * Returns the final facing if a mech were to perform all the steps in this
     * path.
     */
    public int getFinalFacing() {
<span class="nc" id="L798">        MoveStep last = getLastStep();</span>
<span class="nc bnc" id="L799" title="All 2 branches missed.">        if (last != null) {</span>
<span class="nc" id="L800">            return last.getFacing();</span>
        }
<span class="nc" id="L802">        return getEntity().getFacing();</span>
    }

    /**
     * Returns whether or not a unit would end up prone after all of the steps
     */
    public boolean getFinalProne() {
<span class="nc bnc" id="L809" title="All 2 branches missed.">        if (getLastStep() != null) {</span>
<span class="nc" id="L810">            return getLastStep().isProne();</span>
        }
<span class="nc bnc" id="L812" title="All 2 branches missed.">        if (getEntity() == null) {</span>
<span class="nc" id="L813">            return false;</span>
        }
<span class="nc" id="L815">        return getEntity().isProne();</span>
    }

    /**
     * Returns whether or not a unit would end up hull-down after all of the steps
     */
    public boolean getFinalHullDown() {
<span class="nc bnc" id="L822" title="All 2 branches missed.">        if (getLastStep() != null) {</span>
<span class="nc" id="L823">            return getLastStep().isHullDown();</span>
        }
<span class="nc bnc" id="L825" title="All 2 branches missed.">        if (getEntity() == null) {</span>
<span class="nc" id="L826">            return false;</span>
        }
<span class="nc" id="L828">        return getEntity().isHullDown();</span>
    }

    /**
     * Returns whether or not a unit would be in climb mode after all the steps
     */
    public boolean getFinalClimbMode() {
<span class="nc bnc" id="L835" title="All 2 branches missed.">        if (getLastStep() != null) {</span>
<span class="nc" id="L836">            return getLastStep().climbMode();</span>
        }
<span class="nc bnc" id="L838" title="All 2 branches missed.">        if (getEntity() == null) {</span>
<span class="nc" id="L839">            return false;</span>
        }
<span class="nc" id="L841">        return getEntity().climbMode();</span>
    }

    /**
     * get final elevation relative to the hex.
     */
    public int getFinalElevation() {
<span class="nc bnc" id="L848" title="All 2 branches missed.">        if (getLastStep() != null) {</span>
<span class="nc" id="L849">            return getLastStep().getElevation();</span>
        }
<span class="nc" id="L851">        return getEntity().getElevation();</span>
    }
    
    /**
     * get final elevation relative to the tops of any buildings in the hex
     * @return
     */
    public int getFinalClearance() {
<span class="nc bnc" id="L859" title="All 2 branches missed.">        if (getLastStep() != null) {</span>
<span class="nc" id="L860">            return getLastStep().getClearance();</span>
        }
<span class="nc" id="L862">        IHex hex = entity.getGame().getBoard().getHex(getEntity().getPosition());</span>
<span class="nc bnc" id="L863" title="All 2 branches missed.">        if (hex.containsTerrain(Terrains.BLDG_ELEV)) {</span>
<span class="nc" id="L864">            return getEntity().getElevation() - hex.terrainLevel(Terrains.BLDG_ELEV);</span>
        }
<span class="nc" id="L866">        return getEntity().getElevation();</span>
    }

    /**
     * Returns the highest elevation in the current path
     *
     * @return
     */
    public int getMaxElevation() {
<span class="nc" id="L875">        int maxElev = 0;</span>
<span class="nc bnc" id="L876" title="All 2 branches missed.">        for (MoveStep step : steps) {</span>
<span class="nc" id="L877">            maxElev = Math.max(maxElev,</span>
<span class="nc" id="L878">                    getGame().getBoard().getHex(step.getPosition()).getLevel());</span>
<span class="nc" id="L879">        }</span>
<span class="nc" id="L880">        return maxElev;</span>
    }

    /**
     * get final altitude
     */
    public int getFinalAltitude() {
<span class="nc bnc" id="L887" title="All 2 branches missed.">        if (getLastStep() != null) {</span>
<span class="nc" id="L888">            return getLastStep().getAltitude();</span>
        }
<span class="nc" id="L890">        return getEntity().getAltitude();</span>
    }

    public int getFinalVelocity() {
<span class="nc bnc" id="L894" title="All 2 branches missed.">        if (getLastStep() != null) {</span>
<span class="nc" id="L895">            return getLastStep().getVelocity();</span>
        }
<span class="nc bnc" id="L897" title="All 2 branches missed.">        if (getEntity().isAero()) {</span>
<span class="nc" id="L898">            return ((IAero) getEntity()).getCurrentVelocity();</span>
        }
<span class="nc" id="L900">        return 0;</span>
    }
    
    public int getFinalVelocityLeft() {
<span class="nc bnc" id="L904" title="All 2 branches missed.">        if (getLastStep() != null) {</span>
<span class="nc" id="L905">            return getLastStep().getVelocityLeft();</span>
        }
<span class="nc bnc" id="L907" title="All 2 branches missed.">        if (getEntity().isAero()) {</span>
<span class="nc" id="L908">            return ((IAero) getEntity()).getCurrentVelocity();</span>
        }
<span class="nc" id="L910">        return 0;</span>
    }

    public int getFinalNDown() {
<span class="nc bnc" id="L914" title="All 2 branches missed.">        if (getLastStep() != null) {</span>
<span class="nc" id="L915">            return getLastStep().getNDown();</span>
        }

<span class="nc" id="L918">        return 0;</span>
    }
    
    /**
     * If the path contains mode conversions, this will determine the movement mode at the end
     * of movement. Note that LAMs converting from AirMech to Biped mode require two convert commands.
     * 
     * @return The movement mode resulting from any mode conversions in the path.
     */
    public EntityMovementMode getFinalConversionMode() {
<span class="nc bnc" id="L928" title="All 2 branches missed.">        if (getLastStep() != null) {</span>
<span class="nc" id="L929">            return getLastStep().getMovementMode();</span>
        }
<span class="nc" id="L931">        return getEntity().getMovementMode();</span>
    }

    /**
     * Returns the final vector for advanced movement
     */
    public int[] getFinalVectors() {
<span class="nc bnc" id="L938" title="All 2 branches missed.">        if (getLastStep() != null) {</span>
<span class="nc" id="L939">            return getLastStep().getVectors();</span>
        }
<span class="nc" id="L941">        return getEntity().getVectors();</span>
    }

    public EntityMovementType getLastStepMovementType() {
<span class="pc bpc" id="L945" title="1 of 2 branches missed.">        if (getLastStep() == null) {</span>
<span class="fc" id="L946">            return EntityMovementType.MOVE_NONE;</span>
        }
<span class="nc" id="L948">        return getLastStep().getMovementType(true);</span>
    }

    public Vector&lt;MoveStep&gt; getStepVector() {
<span class="fc" id="L952">        return steps;</span>
    }

    public MoveStep getLastStep() {
<span class="fc bfc" id="L956" title="All 2 branches covered.">        for (int i = getStepVector().size() - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L957">            MoveStep last = getStepVector().get(i);</span>
<span class="fc bfc" id="L958" title="All 2 branches covered.">            if (last != null) {</span>
<span class="fc" id="L959">                return last;</span>
            }
        }
<span class="fc" id="L962">        return null;</span>
    }

    public MoveStep getSecondLastStep() {
<span class="nc bnc" id="L966" title="All 2 branches missed.">        if (steps.size() &gt; 1) {</span>
<span class="nc" id="L967">            return getStep(steps.size() - 2);</span>
        }
<span class="nc" id="L969">        return getLastStep();</span>
    }

    /* Debug method */
    public void printAllSteps() {
<span class="nc" id="L974">        System.out.println(&quot;*Steps*&quot;);</span>
<span class="nc bnc" id="L975" title="All 2 branches missed.">        for (int i = 0; i &lt; steps.size(); i++) {</span>
<span class="nc bnc" id="L976" title="All 2 branches missed.">            System.out.println(&quot;  &quot; + i + &quot;: &quot; + getStep(i) + &quot;, &quot; + getStep(i).getMovementType(i == (steps.size() - 1)));</span>
        }
<span class="nc" id="L978">    }</span>

    /**
     * Removes impossible steps.
     */
    public void clipToPossible() {
<span class="nc bnc" id="L984" title="All 2 branches missed.">        if (steps.size() == 0) {</span>
            // nothing to clip
<span class="nc" id="L986">            return;</span>
        }
        // Do final check for bad moves, and clip movement after first bad one
        // also clear and re-constitute &quot;contained steps&quot; cache
<span class="nc" id="L990">        containedStepTypes = new HashSet&lt;&gt;();</span>
<span class="nc" id="L991">        final Vector&lt;MoveStep&gt; goodSteps = new Vector&lt;&gt;();</span>
<span class="nc bnc" id="L992" title="All 2 branches missed.">        for (MoveStep step : steps) {</span>
<span class="nc bnc" id="L993" title="All 2 branches missed.">            if (step.getMovementType(isEndStep(step)) != EntityMovementType.MOVE_ILLEGAL) {</span>
<span class="nc" id="L994">                containedStepTypes.add(step.getType());</span>
<span class="nc" id="L995">                goodSteps.addElement(step);</span>
            } else {
                break;
            }

<span class="nc" id="L1000">        }</span>
<span class="nc" id="L1001">        steps = goodSteps;</span>
<span class="nc" id="L1002">    }</span>

    /**
     * Changes turn-forwards-opposite-turn sequences into quad lateral shifts.
     * &lt;p/&gt;
     * Finds the sequence of three steps that can be transformed, then removes
     * all three and replaces them with the lateral shift step.
     */
    @SuppressWarnings(&quot;unused&quot;)
    private void transformLateralShift() {
<span class="nc bnc" id="L1012" title="All 2 branches missed.">        if (steps.size() &lt; 3) {</span>
<span class="nc" id="L1013">            return;</span>
        }
<span class="nc" id="L1015">        final int index = steps.size() - 3;</span>
<span class="nc" id="L1016">        final MoveStep step1 = getStep(index);</span>
<span class="nc" id="L1017">        final MoveStep step2 = getStep(index + 1);</span>
<span class="nc" id="L1018">        final MoveStep step3 = getStep(index + 2);</span>

<span class="nc bnc" id="L1020" title="All 2 branches missed.">        if (step1.oppositeTurn(step3)</span>
<span class="nc bnc" id="L1021" title="All 4 branches missed.">                &amp;&amp; ((step2.getType() == MovePath.MoveStepType.BACKWARDS) || (step2.getType() == MovePath.MoveStepType.FORWARDS))) {</span>
<span class="nc" id="L1022">            final MoveStepType stepType = step1.getType();</span>
<span class="nc" id="L1023">            final MoveStepType direction = step2.getType();</span>
            // remove all old steps
<span class="nc" id="L1025">            steps.removeElementAt(index);</span>
<span class="nc" id="L1026">            steps.removeElementAt(index);</span>
<span class="nc" id="L1027">            steps.removeElementAt(index);</span>
            // add new step
<span class="nc" id="L1029">            final MoveStep shift = new MoveStep(this, lateralShiftForTurn(stepType, direction));</span>
<span class="nc" id="L1030">            addStep(shift);</span>
        }
<span class="nc" id="L1032">    }</span>

    /**
     * Returns the lateral shift that corresponds to the turn direction
     */
    public static MoveStepType lateralShiftForTurn(final MoveStepType turn, final MoveStepType direction) {
<span class="nc bnc" id="L1038" title="All 2 branches missed.">        if (direction == MoveStepType.FORWARDS) {</span>
<span class="nc bnc" id="L1039" title="All 3 branches missed.">            switch (turn) {</span>
                case TURN_LEFT:
<span class="nc" id="L1041">                    return MoveStepType.LATERAL_LEFT;</span>
                case TURN_RIGHT:
<span class="nc" id="L1043">                    return MoveStepType.LATERAL_RIGHT;</span>
                default:
<span class="nc" id="L1045">                    return turn;</span>
            }
        }
<span class="nc bnc" id="L1048" title="All 3 branches missed.">        switch (turn) {</span>
            case TURN_LEFT:
<span class="nc" id="L1050">                return MoveStepType.LATERAL_LEFT_BACKWARDS;</span>
            case TURN_RIGHT:
<span class="nc" id="L1052">                return MoveStepType.LATERAL_RIGHT_BACKWARDS;</span>
            default:
<span class="nc" id="L1054">                return turn;</span>
        }
    }

    /**
     * Returns the turn direction that corresponds to the lateral shift
     */
    static MoveStepType turnForLateralShift(final MoveStepType shift) {
<span class="nc bnc" id="L1062" title="All 5 branches missed.">        switch (shift) {</span>
            case LATERAL_LEFT:
<span class="nc" id="L1064">                return MoveStepType.TURN_LEFT;</span>
            case LATERAL_RIGHT:
<span class="nc" id="L1066">                return MoveStepType.TURN_RIGHT;</span>
            case LATERAL_LEFT_BACKWARDS:
<span class="nc" id="L1068">                return MoveStepType.TURN_LEFT;</span>
            case LATERAL_RIGHT_BACKWARDS:
<span class="nc" id="L1070">                return MoveStepType.TURN_RIGHT;</span>
            default:
<span class="nc" id="L1072">                return shift;</span>
        }
    }

    /**
     * Returns the direction (either MovePath.MoveStepType.TURN_LEFT or
     * MoveStepType.TURN_RIGHT) that the destination facing lies in.
     */
    public static MoveStepType getDirection(final int facing, final int destFacing) {
<span class="nc" id="L1081">        final int rotate = (destFacing + (6 - facing)) % 6;</span>
<span class="nc bnc" id="L1082" title="All 2 branches missed.">        return rotate &gt;= 3 ? MoveStepType.TURN_LEFT : MoveStepType.TURN_RIGHT;</span>
    }

    /**
     * Returns the adjusted facing, given the start facing.
     */
    public static int getAdjustedFacing(final int facing, final MoveStepType movement) {
<span class="nc bnc" id="L1089" title="All 2 branches missed.">        if (movement == MoveStepType.TURN_RIGHT) {</span>
<span class="nc" id="L1090">            return (facing + 1) % 6;</span>
<span class="nc bnc" id="L1091" title="All 2 branches missed.">        } else if (movement == MoveStepType.TURN_LEFT) {</span>
<span class="nc" id="L1092">            return (facing + 5) % 6;</span>
        }
<span class="nc" id="L1094">        return facing;</span>
    }

    /**
     * Returns the number of MPs used in the path
     */
    public int getMpUsed() {
<span class="nc bnc" id="L1101" title="All 2 branches missed.">        if (getLastStep() != null) {</span>
<span class="nc" id="L1102">            return getLastStep().getMpUsed();</span>
        }
<span class="nc" id="L1104">        return 0;</span>
    }

    /**
     * Returns the logical number of hexes moved the path (does not count turns,
     * etc).
     */
    public int getHexesMoved() {
<span class="nc bnc" id="L1112" title="All 2 branches missed.">        if (getLastStep() == null) {</span>
<span class="nc" id="L1113">            return 0;</span>
        }
<span class="nc" id="L1115">        return getLastStep().getDistance();</span>
    }

    /**
     * Returns true if the entity is jumping or if it's a flying lam.
     */
    public boolean isJumping() {
<span class="fc" id="L1122">        return contains(MoveStepType.START_JUMP);</span>
    }
    
    /**
     * @return true if the entity is a QuadVee or LAM changing movement mode
     */
    public boolean isChangingMode() {
<span class="nc" id="L1129">        return contains(MoveStepType.CONVERT_MODE);</span>
    }

    /**
     * Extend the current path to the destination &lt;code&gt;Coords&lt;/code&gt;, moving
     * only in one direction.  This method works by applying the supplied move
     * step as long as it moves closer to the destination.  If the destination
     * cannot be reached solely by the provided movestep, the pathfinder will
     * quit once it gets as closer as it can.
     *
     * @param dest      the destination &lt;code&gt;Coords&lt;/code&gt; of the move.
     * @param type      the type of movement step required.
     * @param direction the direction of movement.
     */
    public void findSimplePathTo(final Coords dest, final MoveStepType type,
                                 int direction, int facing) {
<span class="nc" id="L1145">        Coords src = getFinalCoords();</span>
<span class="nc" id="L1146">        Coords currStep = src;</span>
<span class="nc" id="L1147">        Coords nextStep = currStep.translated(direction);</span>
<span class="nc bnc" id="L1148" title="All 2 branches missed.">        while (dest.distance(nextStep) &lt; dest.distance(currStep)) {</span>
<span class="nc" id="L1149">            addStep(type);</span>
<span class="nc" id="L1150">            currStep = nextStep;</span>
<span class="nc" id="L1151">            nextStep = currStep.translated(direction);</span>
        }

        // Did we reach the destination?  If not, try another direction
<span class="nc bnc" id="L1155" title="All 2 branches missed.">        if (!currStep.equals(dest)) {</span>
<span class="nc" id="L1156">            int dir = currStep.direction(dest);</span>
            // Java does mod different from how we want...
<span class="nc" id="L1158">            dir = (((dir - facing) % 6) + 6) % 6;</span>
<span class="nc bnc" id="L1159" title="All 7 branches missed.">            switch (dir) {</span>
                case 0:
<span class="nc" id="L1161">                    findSimplePathTo(dest, MoveStepType.FORWARDS, currStep.direction(dest), facing);</span>
<span class="nc" id="L1162">                    break;</span>
                case 1:
<span class="nc" id="L1164">                    findSimplePathTo(dest, MoveStepType.LATERAL_RIGHT, currStep.direction(dest), facing);</span>
<span class="nc" id="L1165">                    break;</span>
                case 2:
                    // TODO: backwards lateral shifts are switched:
                    //  LATERAL_LEFT_BACKWARDS moves back+right and vice-versa
<span class="nc" id="L1169">                    findSimplePathTo(dest, MoveStepType.LATERAL_LEFT_BACKWARDS, currStep.direction(dest), facing);</span>
<span class="nc" id="L1170">                    break;</span>
                case 3:
<span class="nc" id="L1172">                    findSimplePathTo(dest, MoveStepType.BACKWARDS, currStep.direction(dest), facing);</span>
<span class="nc" id="L1173">                    break;</span>
                case 4:
                    // TODO: backwards lateral shifts are switched:
                    //  LATERAL_LEFT_BACKWARDS moves back+right and vice-versa
<span class="nc" id="L1177">                    findSimplePathTo(dest, MoveStepType.LATERAL_RIGHT_BACKWARDS, currStep.direction(dest), facing);</span>
<span class="nc" id="L1178">                    break;</span>
                case 5:
<span class="nc" id="L1180">                    findSimplePathTo(dest, MoveStepType.LATERAL_LEFT, currStep.direction(dest), facing);</span>
                    break;
            }
        }
<span class="nc" id="L1184">    }</span>

    /**
     * Extend the current path to the destination &lt;code&gt;Coords&lt;/code&gt;.
     *
     * @param dest the destination &lt;code&gt;Coords&lt;/code&gt; of the move.
     * @param type the type of movement step required.
     */
    public void findPathTo(final Coords dest, final MoveStepType type) {
<span class="nc" id="L1193">        final int timeLimit = PreferenceManager.getClientPreferences().getMaxPathfinderTime();</span>

<span class="nc" id="L1195">        ShortestPathFinder pf = ShortestPathFinder.newInstanceOfAStar(dest, type, game);</span>

<span class="nc" id="L1197">        AbstractPathFinder.StopConditionTimeout&lt;MovePath&gt; timeoutCondition = new AbstractPathFinder.StopConditionTimeout&lt;&gt;(timeLimit);</span>
<span class="nc" id="L1198">        pf.addStopCondition(timeoutCondition);</span>

<span class="nc" id="L1200">        pf.run(this.clone());</span>
<span class="nc" id="L1201">        MovePath finPath = pf.getComputedPath(dest);</span>
        // this can be used for debugging the &quot;destruction aware pathfinder&quot;
        //MovePath finPath = calculateDestructionAwarePath(dest);

<span class="nc bnc" id="L1205" title="All 4 branches missed.">        if (timeoutCondition.timeoutEngaged || finPath == null) {</span>
            /*
             * Either we have forced searcher to end prematurely or no path was
             * found. Lets try to fix it by taking the path that ended closest
             * to the target and greedily extend it.
             */
<span class="nc" id="L1211">            MovePath bestMp = Collections.min(pf.getAllComputedPaths().values(), new ShortestPathFinder.MovePathGreedyComparator(dest));</span>
<span class="nc" id="L1212">            pf = ShortestPathFinder.newInstanceOfGreedy(dest, type, game);</span>
<span class="nc" id="L1213">            pf.run(bestMp);</span>
<span class="nc" id="L1214">            finPath = pf.getComputedPath(dest);</span>
            // If no path could be found, use the best one returned by A*
<span class="nc bnc" id="L1216" title="All 2 branches missed.">            if (finPath == null) {</span>
<span class="nc" id="L1217">                finPath = bestMp;</span>
            }
        }
<span class="nc bnc" id="L1220" title="All 2 branches missed.">        if (finPath != null) {</span>
<span class="nc" id="L1221">            finPath.compile(game, entity, false);</span>
<span class="nc" id="L1222">            this.steps = finPath.steps;</span>
        } else {
<span class="nc" id="L1224">            System.out.println(&quot;Error: &quot; +</span>
                    &quot;Unable to find a path to the destination hex!&quot;);
<span class="nc" id="L1226">            System.out.println(&quot;\tMoving &quot; + getEntity() + &quot;from &quot;</span>
<span class="nc" id="L1227">                    + getFinalCoords() + &quot; to &quot; + dest);</span>
        }
<span class="nc" id="L1229">    }</span>

    public boolean isMoveLegal() {
        // Moves which end up off of the board are not legal.
<span class="pc bpc" id="L1233" title="1 of 2 branches missed.">        if (!getGame().getBoard().contains(getFinalCoords())) {</span>
<span class="fc" id="L1234">            return false;</span>
        }

        // for aero units move must use up all their velocity
<span class="nc bnc" id="L1238" title="All 2 branches missed.">        if (getEntity().isAero()) {</span>
<span class="nc" id="L1239">            IAero a = (IAero) getEntity();</span>
<span class="nc bnc" id="L1240" title="All 2 branches missed.">            if (getLastStep() == null) {</span>
<span class="nc bnc" id="L1241" title="All 4 branches missed.">                if ((a.getCurrentVelocity() &gt; 0) &amp;&amp; !getGame().useVectorMove()) {</span>
<span class="nc" id="L1242">                    return false;</span>
                }
            } else {
<span class="nc bnc" id="L1245" title="All 4 branches missed.">                if ((getLastStep().getVelocityLeft() &gt; 0) &amp;&amp; !getGame().useVectorMove()</span>
<span class="nc bnc" id="L1246" title="All 2 branches missed.">                        &amp;&amp; !(getLastStep().getType() == MovePath.MoveStepType.FLEE</span>
<span class="nc bnc" id="L1247" title="All 2 branches missed.">                        || getLastStep().getType() == MovePath.MoveStepType.EJECT)) {</span>
<span class="nc" id="L1248">                    return false;</span>
                }
            }
        }

<span class="nc bnc" id="L1253" title="All 2 branches missed.">        if (getLastStep() == null) {</span>
<span class="nc" id="L1254">            return true;</span>
        }

<span class="nc bnc" id="L1257" title="All 2 branches missed.">        if (getLastStep().getType() == MoveStepType.CHARGE) {</span>
<span class="nc" id="L1258">            return getSecondLastStep().isLegal(this);</span>
        }
<span class="nc bnc" id="L1260" title="All 2 branches missed.">        if (getLastStep().getType() == MoveStepType.RAM) {</span>
<span class="nc" id="L1261">            return getSecondLastStep().isLegal(this);</span>
        }
<span class="nc" id="L1263">        return getLastStep().isLegal(this);</span>
    }

    /**
     * An A* pathfinder to get from the end of the current path (or entity's
     * position if empty) to the destination.
     *
     * @param dest      The goal hex
     * @param type      The type of move we want to do
     * @param timeLimit the maximum &lt;code&gt;int&lt;/code&gt; number of milliseconds to take
     *                  hunting for an ideal path.
     */
    @SuppressWarnings(&quot;unused&quot;)
    private void notSoLazyPathfinder(final Coords dest, final MoveStepType type,
                                     final int timeLimit) {
<span class="nc" id="L1278">        final int MAX_CANDIDATES = 100;</span>
<span class="nc" id="L1279">        final long endTime = System.currentTimeMillis() + timeLimit;</span>

<span class="nc" id="L1281">        MoveStepType step = type;</span>
<span class="nc bnc" id="L1282" title="All 2 branches missed.">        if (step != MoveStepType.BACKWARDS) {</span>
<span class="nc" id="L1283">            step = MoveStepType.FORWARDS;</span>
        }

<span class="nc bnc" id="L1286" title="All 2 branches missed.">        final MovePathComparator mpc =</span>
                new MovePathComparator(dest, step == MoveStepType.BACKWARDS);

<span class="nc" id="L1289">        MovePath bestPath = clone();</span>

        // A collection of paths we have already explored
<span class="nc" id="L1292">        final HashMap&lt;MovePath.Key, MovePath&gt; discovered =</span>
                new HashMap&lt;MovePath.Key, MovePath&gt;();
<span class="nc" id="L1294">        discovered.put(bestPath.getKey(), bestPath);</span>

        // A collection of hte possible next-moves
<span class="nc" id="L1297">        final PriorityQueue&lt;MovePath&gt; candidates =</span>
                new PriorityQueue&lt;MovePath&gt;(110, mpc);
<span class="nc" id="L1299">        candidates.add(bestPath);</span>

<span class="nc bnc" id="L1301" title="All 2 branches missed.">        boolean keepLooping = getFinalCoords().distance(dest) &gt; 1;</span>
<span class="nc" id="L1302">        int loopcount = 0;</span>

        // Keep looping while we have candidates to explore, and certain stop
        //  conditions aren't met (time-limit, destination found, etc)
<span class="nc bnc" id="L1306" title="All 4 branches missed.">        while ((candidates.size() &gt; 0) &amp;&amp; keepLooping) {</span>
<span class="nc" id="L1307">            final MovePath candidatePath = candidates.poll();</span>
<span class="nc" id="L1308">            final Coords startingPos = candidatePath.getFinalCoords();</span>
<span class="nc" id="L1309">            final int startingElev = candidatePath.getFinalElevation();</span>

            // Check to see if we have found the destination
<span class="nc bnc" id="L1312" title="All 2 branches missed.">            if (candidatePath.getFinalCoords().distance(dest) == 0) {</span>
<span class="nc" id="L1313">                bestPath = candidatePath;</span>
<span class="nc" id="L1314">                keepLooping = false;</span>
<span class="nc" id="L1315">                break;</span>
            }

            // Get next possible steps
<span class="nc bnc" id="L1319" title="All 4 branches missed.">            final Iterator&lt;MovePath&gt; adjacent =</span>
<span class="nc" id="L1320">                    candidatePath.getNextMoves(step == MoveStepType.BACKWARDS,</span>
<span class="nc" id="L1321">                            step == MoveStepType.FORWARDS).iterator();</span>
            // Evaluate possible next steps
<span class="nc bnc" id="L1323" title="All 2 branches missed.">            while (adjacent.hasNext()) {</span>
<span class="nc" id="L1324">                final MovePath expandedPath = adjacent.next();</span>

<span class="nc bnc" id="L1326" title="All 2 branches missed.">                if (expandedPath.getLastStep().isMovementPossible(getGame(),</span>
<span class="nc" id="L1327">                        startingPos, startingElev, getCachedEntityState())) {</span>

<span class="nc bnc" id="L1329" title="All 2 branches missed.">                    if (discovered.containsKey(expandedPath.getKey())) {</span>
<span class="nc" id="L1330">                        continue;</span>
                    }
                    // Make sure the candidate list doesn't get too big
<span class="nc bnc" id="L1333" title="All 2 branches missed.">                    if (candidates.size() &lt;= MAX_CANDIDATES) {</span>
<span class="nc" id="L1334">                        candidates.add(expandedPath);</span>
                    }
<span class="nc" id="L1336">                    discovered.put(expandedPath.getKey(), expandedPath);</span>
                }
<span class="nc" id="L1338">            }</span>
            // If we're doing a special movement, like charging or DFA, we will
            //  have to take extra steps to see if we can finish off the move
            //  this is because getNextMoves only considers turning and
            //  forward/backward movement
<span class="nc bnc" id="L1343" title="All 4 branches missed.">            if (type == MoveStepType.CHARGE ||</span>
                    type == MoveStepType.DFA){
<span class="nc" id="L1345">                MovePath expandedPath = candidatePath.clone();</span>
<span class="nc" id="L1346">                expandedPath.addStep(type);</span>
<span class="nc bnc" id="L1347" title="All 2 branches missed.">                if (expandedPath.getLastStep().isMovementPossible(getGame(),</span>
<span class="nc" id="L1348">                        startingPos, startingElev, getCachedEntityState())) {</span>

<span class="nc bnc" id="L1350" title="All 2 branches missed.">                    if (discovered.containsKey(expandedPath.getKey())) {</span>
<span class="nc" id="L1351">                        continue;</span>
                    }
                    // Make sure the candidate list doesn't get too big
<span class="nc bnc" id="L1354" title="All 2 branches missed.">                    if (candidates.size() &lt;= MAX_CANDIDATES) {</span>
<span class="nc" id="L1355">                        candidates.add(expandedPath);</span>
                    }
<span class="nc" id="L1357">                    discovered.put(expandedPath.getKey(), expandedPath);</span>
                }
            }


<span class="nc" id="L1362">            loopcount++;</span>
<span class="nc bnc" id="L1363" title="All 4 branches missed.">            if (((loopcount % 256) == 0) &amp;&amp; keepLooping</span>
<span class="nc bnc" id="L1364" title="All 2 branches missed.">                    &amp;&amp; (candidates.size() &gt; 0)) {</span>
<span class="nc" id="L1365">                final MovePath front = candidates.peek();</span>
<span class="nc" id="L1366">                if (front.getFinalCoords().distance(dest) &lt; bestPath</span>
<span class="nc bnc" id="L1367" title="All 2 branches missed.">                        .getFinalCoords().distance(dest)) {</span>
<span class="nc" id="L1368">                    bestPath = front;</span>
                }
<span class="nc bnc" id="L1370" title="All 2 branches missed.">                if (System.currentTimeMillis() &gt; endTime) {</span>
<span class="nc" id="L1371">                    keepLooping = false;</span>
<span class="nc" id="L1372">                    System.out.println(&quot;Time limit reached searching &quot; +</span>
                            &quot;for path!&quot;);
                }
            }
<span class="nc" id="L1376">        } // end while</span>
        //System.out.println(&quot;iteration count: &quot; + loopcount);
<span class="nc bnc" id="L1378" title="All 2 branches missed.">        if (getFinalCoords().distance(dest) &gt; bestPath.getFinalCoords().distance(dest)) {</span>
            // Make the path we found, this path.
<span class="nc" id="L1380">            steps = bestPath.steps;</span>
        }
<span class="nc bnc" id="L1382" title="All 2 branches missed.">        if (!getFinalCoords().equals(dest)) {</span>
<span class="nc" id="L1383">            lazyPathfinder(dest, type);</span>
        }
<span class="nc" id="L1385">    }</span>

    /**
     * Find the shortest path to the destination &lt;code&gt;Coords&lt;/code&gt; by hex
     * count. This right choice &lt;em&gt;only&lt;/em&gt; when making a simple move like a
     * straight line or one with a single turn.
     *
     * @param dest the destination &lt;code&gt;Coords&lt;/code&gt; of the move.
     * @param type the type of movment step required.
     */
    private void lazyPathfinder(final Coords dest, final MoveStepType type) {
<span class="nc" id="L1396">        MoveStepType step = MoveStepType.FORWARDS;</span>
<span class="nc bnc" id="L1397" title="All 2 branches missed.">        if (type == MoveStepType.BACKWARDS) {</span>
<span class="nc" id="L1398">            step = MoveStepType.BACKWARDS;</span>
        }
<span class="nc" id="L1400">        Coords subDest = dest;</span>
<span class="nc bnc" id="L1401" title="All 2 branches missed.">        if (!dest.equals(getFinalCoords())) {</span>
<span class="nc" id="L1402">            subDest = dest.translated(dest.direction(getFinalCoords()));</span>
        }

<span class="nc bnc" id="L1405" title="All 2 branches missed.">        while (!getFinalCoords().equals(subDest)) {</span>
            // adjust facing
<span class="nc bnc" id="L1407" title="All 2 branches missed.">            rotatePathfinder((getFinalCoords().direction(subDest) + (step == MoveStepType.BACKWARDS ? 3 : 0)) % 6,</span>
                    false);
            // step forwards
<span class="nc" id="L1410">            addStep(step);</span>
        }
<span class="nc bnc" id="L1412" title="All 2 branches missed.">        rotatePathfinder((getFinalCoords().direction(dest) + (step == MoveStepType.BACKWARDS ? 3 : 0)) % 6, false);</span>
<span class="nc bnc" id="L1413" title="All 2 branches missed.">        if (!dest.equals(getFinalCoords())) {</span>
<span class="nc" id="L1414">            addStep(type);</span>
        }
<span class="nc" id="L1416">    }</span>

    /**
     * Returns a list of possible moves that result in a
     * facing/position/(jumping|prone) change, special steps (mine clearing and
     * such) must be handled elsewhere.
     */
    public List&lt;MovePath&gt; getNextMoves(boolean backward, boolean forward) {
<span class="nc" id="L1424">        final ArrayList&lt;MovePath&gt; result = new ArrayList&lt;MovePath&gt;();</span>
<span class="nc" id="L1425">        final MoveStep last = getLastStep();</span>
//        if (isJumping()) {
//            final MovePath left = clone();
//            final MovePath right = clone();
//
//            // From here, we can move F, LF, RF, LLF, RRF, and RRRF.
//            result.add(clone().addStep(MovePath.MoveStepType.FORWARDS));
//            for (int turn = 0; turn &lt; 2; turn++) {
//                left.addStep(MovePath.MoveStepType.TURN_LEFT);
//                right.addStep(MovePath.MoveStepType.TURN_RIGHT);
//                result.add(left.clone().addStep(MovePath.MoveStepType.FORWARDS));
//                result.add(right.clone().addStep(MovePath.MoveStepType.FORWARDS));
//            }
//            right.addStep(MovePath.MoveStepType.TURN_RIGHT);
//            result.add(right.addStep(MovePath.MoveStepType.FORWARDS));
//
//            // We've got all our next steps.
//            return result;
//        }

        // need to do a separate section here for Aeros.
        // just like jumping for now, but I could add some other stuff
        // here later
<span class="nc bnc" id="L1448" title="All 2 branches missed.">        if (getEntity().isAero()) {</span>
<span class="nc" id="L1449">            MovePath left = clone();</span>
<span class="nc" id="L1450">            MovePath right = clone();</span>

            // From here, we can move F, LF, RF, LLF, RRF, and RRRF.
<span class="nc" id="L1453">            result.add((clone()).addStep(MovePath.MoveStepType.FORWARDS));</span>
<span class="nc bnc" id="L1454" title="All 2 branches missed.">            for (int turn = 0; turn &lt; 2; turn++) {</span>
<span class="nc" id="L1455">                left.addStep(MovePath.MoveStepType.TURN_LEFT);</span>
<span class="nc" id="L1456">                right.addStep(MovePath.MoveStepType.TURN_RIGHT);</span>
<span class="nc" id="L1457">                result.add(left.clone().addStep(MovePath.MoveStepType.FORWARDS));</span>
<span class="nc" id="L1458">                result.add(right.clone().addStep(MovePath.MoveStepType.FORWARDS));</span>
            }
<span class="nc" id="L1460">            right.addStep(MovePath.MoveStepType.TURN_RIGHT);</span>
<span class="nc" id="L1461">            result.add(right.addStep(MovePath.MoveStepType.FORWARDS));</span>

            // We've got all our next steps.
<span class="nc" id="L1464">            return result;</span>
        }

        // If the unit is prone or hull-down it limits movement options, unless
        //  it's a tank; tanks can just drive out of hull-down and they cannot
        //  be prone.
<span class="nc bnc" id="L1470" title="All 6 branches missed.">        if (getFinalProne() || (getFinalHullDown() &amp;&amp; !(getEntity() instanceof Tank))) {</span>
<span class="nc bnc" id="L1471" title="All 4 branches missed.">            if ((last != null) &amp;&amp; (last.getType() != MoveStepType.TURN_RIGHT)) {</span>
<span class="nc" id="L1472">                result.add(clone().addStep(MovePath.MoveStepType.TURN_LEFT));</span>
            }
<span class="nc bnc" id="L1474" title="All 4 branches missed.">            if ((last != null) &amp;&amp; (last.getType() != MoveStepType.TURN_LEFT)) {</span>
<span class="nc" id="L1475">                result.add(clone().addStep(MovePath.MoveStepType.TURN_RIGHT));</span>
            }

<span class="nc bnc" id="L1478" title="All 2 branches missed.">            if (getEntity().isCarefulStand()) {</span>
<span class="nc" id="L1479">                result.add(clone().addStep(MovePath.MoveStepType.CAREFUL_STAND));</span>
            } else {
<span class="nc" id="L1481">                result.add(clone().addStep(MovePath.MoveStepType.GET_UP));</span>
            }
<span class="nc" id="L1483">            return result;</span>
        }
<span class="nc bnc" id="L1485" title="All 2 branches missed.">        if (canShift()) {</span>
<span class="nc bnc" id="L1486" title="All 8 branches missed.">            if (forward &amp;&amp; (!backward || ((last == null) || (last.getType() != MovePath.MoveStepType.LATERAL_LEFT)))) {</span>
<span class="nc" id="L1487">                result.add(clone().addStep(MoveStepType.LATERAL_RIGHT));</span>
            }
<span class="nc bnc" id="L1489" title="All 8 branches missed.">            if (forward &amp;&amp; (!backward || ((last == null) || (last.getType() != MovePath.MoveStepType.LATERAL_RIGHT)))) {</span>
<span class="nc" id="L1490">                result.add(clone().addStep(MovePath.MoveStepType.LATERAL_LEFT));</span>
            }
<span class="nc bnc" id="L1492" title="All 6 branches missed.">            if (backward</span>
<span class="nc bnc" id="L1493" title="All 2 branches missed.">                    &amp;&amp; (!forward || ((last == null) || (last.getType() != MovePath.MoveStepType.LATERAL_LEFT_BACKWARDS)))) {</span>
<span class="nc" id="L1494">                result.add(clone().addStep(MovePath.MoveStepType.LATERAL_RIGHT_BACKWARDS));</span>
            }
<span class="nc bnc" id="L1496" title="All 6 branches missed.">            if (backward</span>
<span class="nc bnc" id="L1497" title="All 2 branches missed.">                    &amp;&amp; (!forward || ((last == null) || (last.getType() != MovePath.MoveStepType.LATERAL_RIGHT_BACKWARDS)))) {</span>
<span class="nc" id="L1498">                result.add(clone().addStep(MovePath.MoveStepType.LATERAL_LEFT_BACKWARDS));</span>
            }
        }
<span class="nc bnc" id="L1501" title="All 8 branches missed.">        if (forward &amp;&amp; (!backward || ((last == null) || (last.getType() != MovePath.MoveStepType.BACKWARDS)))) {</span>
<span class="nc" id="L1502">            result.add(clone().addStep(MovePath.MoveStepType.FORWARDS));</span>
        }
<span class="nc bnc" id="L1504" title="All 4 branches missed.">        if ((last == null) || (last.getType() != MovePath.MoveStepType.TURN_LEFT)) {</span>
<span class="nc" id="L1505">            result.add(clone().addStep(MovePath.MoveStepType.TURN_RIGHT));</span>
        }
<span class="nc bnc" id="L1507" title="All 4 branches missed.">        if ((last == null) || (last.getType() != MovePath.MoveStepType.TURN_RIGHT)) {</span>
<span class="nc" id="L1508">            result.add(clone().addStep(MovePath.MoveStepType.TURN_LEFT));</span>
        }
<span class="nc bnc" id="L1510" title="All 8 branches missed.">        if (backward &amp;&amp; (!forward || ((last == null) || (last.getType() != MovePath.MoveStepType.FORWARDS)))) {</span>
<span class="nc" id="L1511">            result.add(clone().addStep(MovePath.MoveStepType.BACKWARDS));</span>
        }
<span class="nc" id="L1513">        return result;</span>
    }

    /**
     * Clones this path, will contain a new clone of the steps so that the clone
     * is independent from the original.
     *
     * @return the cloned MovePath
     */
    @Override
    public MovePath clone() {
<span class="nc" id="L1524">        final MovePath copy = new MovePath(getGame(), getEntity());</span>
<span class="nc" id="L1525">        copyFields(copy);</span>
<span class="nc" id="L1526">        return copy;</span>
    }
    
    protected void copyFields(MovePath copy) {
<span class="nc" id="L1530">        copy.steps = new Vector&lt;MoveStep&gt;(steps);</span>
<span class="nc" id="L1531">        copy.careful = careful;</span>
<span class="nc" id="L1532">        copy.containedStepTypes = new HashSet&lt;&gt;(containedStepTypes);</span>
<span class="nc" id="L1533">        copy.fliesOverEnemy = fliesOverEnemy;</span>
<span class="nc" id="L1534">        copy.cachedEntityState = cachedEntityState; // intentional pointer copy</span>
<span class="nc" id="L1535">    }</span>

    /**
     * Rotate from the current facing to the destination facing.
     */
    public void rotatePathfinder(final int destFacing, final boolean isManeuver) {
<span class="nc bnc" id="L1541" title="All 2 branches missed.">        while (getFinalFacing() != destFacing) {</span>
<span class="nc" id="L1542">            final MoveStepType stepType = getDirection(getFinalFacing(), destFacing);</span>
<span class="nc" id="L1543">            addStep(stepType, isManeuver, isManeuver);</span>
<span class="nc" id="L1544">        }</span>
<span class="nc" id="L1545">    }</span>

    /**
     * Returns true if a jump using mechanical jump boosters would cause falling
     * damage.  Mechanical jump boosters are only designed to handle the stress
     * of falls from a height equal to their jumpMP; if a jump has a fall that
     * is further than the jumpMP of the unit, fall damage applies.
     *
     * @return
     */
    public boolean shouldMechanicalJumpCauseFallDamage() {
<span class="pc bpc" id="L1556" title="3 of 4 branches missed.">        if (isJumping() &amp;&amp; (getEntity().getJumpType() == Mech.JUMP_BOOSTER) &amp;&amp;</span>
<span class="nc bnc" id="L1557" title="All 2 branches missed.">            (getJumpMaxElevationChange() &gt; getEntity().getJumpMP())) {</span>
<span class="nc" id="L1558">            return true;</span>
        }
<span class="fc" id="L1560">        return false;</span>
    }

    /**
     * Returns the highest elevation along a jump path.
     *
     * @return
     */
    public Coords getJumpPathHighestPoint() {
<span class="nc" id="L1569">        Coords highestCoords = null;</span>
<span class="nc" id="L1570">        int highestElevation = 0;</span>
<span class="nc bnc" id="L1571" title="All 2 branches missed.">        for (MoveStep step : steps) {</span>
<span class="nc bnc" id="L1572" title="All 2 branches missed.">            if (getGame().getBoard().getHex(step.getPosition()).getLevel() &gt; highestElevation) {</span>
<span class="nc" id="L1573">                highestElevation = step.getElevation();</span>
<span class="nc" id="L1574">                highestCoords = step.getPosition();</span>
            }
<span class="nc" id="L1576">        }</span>
<span class="nc" id="L1577">        return highestCoords;</span>
    }

    /**
     * Returns the distance between the highest elevation in the jump path and
     * the elevation at the landing point.  This gives the largest distance the
     * unit has fallen during the jump.
     */
    public int getJumpMaxElevationChange() {
<span class="nc" id="L1586">        return getMaxElevation() -</span>
<span class="nc" id="L1587">               getGame().getBoard().getHex(getFinalCoords()).getLevel();</span>
    }

    /**
     * @return TRUE if there are any buildings in a dropship's landing zone.
     */
    public boolean willCrushBuildings() {
<span class="nc bnc" id="L1594" title="All 2 branches missed.">        for (MoveStep step : steps) {</span>
<span class="nc bnc" id="L1595" title="All 2 branches missed.">            if (!step.getCrushedBuildingLocs().isEmpty()) {</span>
<span class="nc" id="L1596">                return true;</span>
            }
<span class="nc" id="L1598">        }</span>
<span class="nc" id="L1599">        return false;</span>
    }

    /**
     * Airborne WiGEs that move less than five hexes (four for glider protomech) in a movement phase must
     * land unless it has taken off in the same phase or it is a LAM or glider ProtoMech that is using hover
     * movement.
     * 
     * @param includeMovePathHexes  Whether to include the hexes plotted in this MovePath in the total distance
     *                              moved. This should be true when plotting movement in the client and
     *                              false when the server checks for automatic landing at the end of movement. 
     * @return whether the unit is an airborne WiGE that must land at the end of movement.
     */
    public boolean automaticWiGELanding(boolean includeMovePathHexes) {
<span class="nc bnc" id="L1613" title="All 2 branches missed.">        if (getEntity().getMovementMode() != EntityMovementMode.WIGE</span>
<span class="nc bnc" id="L1614" title="All 2 branches missed.">                || getEntity().isAirborne()) {</span>
<span class="nc" id="L1615">            return false;</span>
        }
        // A LAM converting from AirMech to Mech mode automatically lands at the end of movement.
<span class="nc bnc" id="L1618" title="All 2 branches missed.">        if ((getEntity() instanceof LandAirMech)</span>
<span class="nc bnc" id="L1619" title="All 2 branches missed.">                &amp;&amp; (((LandAirMech)getEntity()).getConversionModeFor(getFinalConversionMode()) == LandAirMech.CONV_MODE_MECH)){</span>
<span class="nc bnc" id="L1620" title="All 2 branches missed.">            if (getLastStep() != null) {</span>
<span class="nc bnc" id="L1621" title="All 2 branches missed.">                return getLastStep().getClearance() &gt; 0;</span>
            } else {
<span class="nc" id="L1623">                return getEntity().isAirborneVTOLorWIGE();</span>
            }
        }
        // If movement has been interrupted (such as by a sideslip) and remaining movement points have
        // been spent, this MovePath only contains the hexes moved after the interruption. The hexes already
        // moved this turn are in delta_distance. WHen the server checks at the end of movement, delta_distance
        // already includes the hexes in this MovePath.
<span class="nc" id="L1630">        int moved = getEntity().delta_distance;</span>
<span class="nc bnc" id="L1631" title="All 2 branches missed.">        if (includeMovePathHexes) {</span>
<span class="nc" id="L1632">            moved += getHexesMoved();</span>
        }
<span class="nc bnc" id="L1634" title="All 2 branches missed.">        if ((moved &gt;= 5)</span>
<span class="nc bnc" id="L1635" title="All 4 branches missed.">                || (getEntity().hasETypeFlag(Entity.ETYPE_PROTOMECH)</span>
                        &amp;&amp; moved == 4)) {
<span class="nc" id="L1637">            return false;</span>
        }
<span class="nc bnc" id="L1639" title="All 2 branches missed.">        if (getEntity().wigeLiftoffHover() || steps.stream().map(s -&gt; s.getType())</span>
<span class="nc bnc" id="L1640" title="All 6 branches missed.">                .anyMatch(st -&gt; st == MoveStepType.UP</span>
                        || st == MoveStepType.HOVER)) {
<span class="nc" id="L1642">            return false;</span>
        }
<span class="nc bnc" id="L1644" title="All 2 branches missed.">        if (getLastStep() != null) {</span>
<span class="nc bnc" id="L1645" title="All 2 branches missed.">            return getLastStep().getClearance() &gt; 0;</span>
        } else {
<span class="nc" id="L1647">            return getEntity().isAirborneVTOLorWIGE();</span>
        }
    }
    
    protected static class MovePathComparator implements Comparator&lt;MovePath&gt; {
        private final Coords destination;
        boolean backward;

<span class="nc" id="L1655">        public MovePathComparator(final Coords destination, final boolean backward) {</span>
<span class="nc" id="L1656">            this.destination = destination;</span>
<span class="nc" id="L1657">            this.backward = backward;</span>
<span class="nc" id="L1658">        }</span>

        public int compare(final MovePath first, final MovePath second) {
<span class="nc" id="L1661">            final int firstDist = first.getMpUsed() + first.getFinalCoords().distance(destination)</span>
<span class="nc" id="L1662">                    + getFacingDiff(first);</span>
<span class="nc" id="L1663">            final int secondDist = second.getMpUsed() + second.getFinalCoords().distance(destination)</span>
<span class="nc" id="L1664">                    + getFacingDiff(second);</span>
<span class="nc" id="L1665">            return firstDist - secondDist;</span>
        }

        private int getFacingDiff(final MovePath first) {
<span class="nc bnc" id="L1669" title="All 2 branches missed.">            if (first.isJumping()) {</span>
<span class="nc" id="L1670">                return 0;</span>
            }
<span class="nc bnc" id="L1672" title="All 2 branches missed.">            if (first.getFinalCoords().equals(destination)) {</span>
<span class="nc" id="L1673">                return 0;</span>
            }
<span class="nc bnc" id="L1675" title="All 2 branches missed.">            int firstFacing = Math.abs(((first.getFinalCoords().direction(destination) + (backward ? 3 : 0)) % 6)</span>
<span class="nc" id="L1676">                    - first.getFinalFacing());</span>
<span class="nc bnc" id="L1677" title="All 2 branches missed.">            if (firstFacing &gt; 3) {</span>
<span class="nc" id="L1678">                firstFacing = 6 - firstFacing;</span>
            }
<span class="nc bnc" id="L1680" title="All 2 branches missed.">            if (first.canShift()) {</span>
<span class="nc" id="L1681">                firstFacing = Math.max(0, firstFacing - 1);</span>
            }
<span class="nc bnc" id="L1683" title="All 2 branches missed.">            if ((first.getFinalCoords().degree(destination) % 60) != 0) {</span>
<span class="nc" id="L1684">                firstFacing++;</span>
            }
<span class="nc" id="L1686">            return firstFacing;</span>
        }
    }

    /*
     * Get the position in the step immediately prior to the final position
     */
    public Coords getSecondFinalPosition(Coords startPos) {

<span class="nc" id="L1695">        Coords priorPos = startPos;</span>
<span class="nc" id="L1696">        Coords finalPos = getFinalCoords();</span>

        // if we moved one or fewer hexes, then just return starting position
<span class="nc bnc" id="L1699" title="All 2 branches missed.">        if (getHexesMoved() &lt; 2) {</span>
<span class="nc" id="L1700">            return priorPos;</span>
        }

<span class="nc bnc" id="L1703" title="All 2 branches missed.">        for (final Enumeration&lt;MoveStep&gt; i = getSteps(); i.hasMoreElements(); ) {</span>
<span class="nc" id="L1704">            final MoveStep step = i.nextElement();</span>
<span class="nc bnc" id="L1705" title="All 2 branches missed.">            if (!step.getPosition().equals(finalPos)) {</span>
<span class="nc" id="L1706">                priorPos = step.getPosition();</span>
            }
<span class="nc" id="L1708">        }</span>
<span class="nc" id="L1709">        return priorPos;</span>

    }

    public boolean isCareful() {
<span class="fc" id="L1714">        return careful;</span>
    }

    public void setCareful(boolean b) {
<span class="nc" id="L1718">        careful = b;</span>
<span class="nc" id="L1719">    }</span>

    public int countMp(boolean jumping) {
<span class="nc" id="L1722">        int mp = 0;</span>
<span class="nc bnc" id="L1723" title="All 2 branches missed.">        for (MoveStep step : steps) {</span>
<span class="nc bnc" id="L1724" title="All 4 branches missed.">            if (jumping &amp;&amp; (step.getType() != MoveStepType.TURN_LEFT) &amp;&amp;</span>
<span class="nc bnc" id="L1725" title="All 2 branches missed.">                    (step.getType() != MoveStepType.TURN_RIGHT)) {</span>
<span class="nc" id="L1726">                mp += step.getMp();</span>
<span class="nc bnc" id="L1727" title="All 2 branches missed.">            } else if (!jumping) {</span>
<span class="nc" id="L1728">                mp += step.getMp();</span>
            }
<span class="nc" id="L1730">        }</span>
<span class="nc" id="L1731">        return mp;</span>
    }

    public void addSteps(Vector&lt;MoveStep&gt; path, boolean compile) {
<span class="nc bnc" id="L1735" title="All 2 branches missed.">        for (MoveStep step : path) {</span>
<span class="nc" id="L1736">            addStep(step, compile);</span>
<span class="nc" id="L1737">        }</span>
<span class="nc" id="L1738">    }</span>

    public void replaceSteps(Vector&lt;MoveStep&gt; path) {
<span class="nc" id="L1741">        steps.clear();</span>
<span class="nc" id="L1742">        addSteps(path, true);</span>
<span class="nc" id="L1743">    }</span>
    
    public boolean isEndStep(MoveStep step) {
<span class="nc bnc" id="L1746" title="All 2 branches missed.">        if (step == null) {</span>
<span class="nc" id="L1747">            return false;</span>
        }
<span class="nc" id="L1749">        return step.isEndPos(this);</span>
    }
    
    /**
     * Convenience method to determine whether this path is happening on a ground map with an atmosphere
     */
    public boolean isOnAtmosphericGroundMap() {
<span class="nc" id="L1756">    	return getEntity().isOnAtmosphericGroundMap(); </span>
    }
    
    /**
     * Searches the movement path for the first step that has the given position and sets it as
     * a VTOL bombing step. If found, any previous bombing step is cleared. If the coordinates are not
     * part of the path nothing is changed.
     * 
     * @param pos The &lt;code&gt;Coords&lt;/code&gt; of the hex to be bombed.
     * @return Whether the position was found in the movement path
     */
    public boolean setVTOLBombStep(Coords pos) {
<span class="nc" id="L1768">        boolean foundPos = false;</span>
<span class="nc" id="L1769">        MoveStep prevBombing = null;</span>
<span class="nc bnc" id="L1770" title="All 2 branches missed.">        for (MoveStep step : steps) {</span>
<span class="nc bnc" id="L1771" title="All 2 branches missed.">            if (step.getPosition().equals(pos)) {</span>
<span class="nc bnc" id="L1772" title="All 2 branches missed.">                if (step.isVTOLBombingStep()) {</span>
<span class="nc" id="L1773">                    return true;</span>
                } else {
<span class="nc" id="L1775">                    step.setVTOLBombing(true);</span>
<span class="nc" id="L1776">                    foundPos = true;</span>
                }
<span class="nc bnc" id="L1778" title="All 2 branches missed.">            } else if (step.isVTOLBombingStep()) {</span>
<span class="nc" id="L1779">                prevBombing = step;</span>
            }
<span class="nc" id="L1781">        }</span>
<span class="nc bnc" id="L1782" title="All 4 branches missed.">        if (foundPos &amp;&amp; prevBombing != null) {</span>
<span class="nc" id="L1783">            prevBombing.setVTOLBombing(false);</span>
        }
<span class="nc" id="L1785">        return foundPos;</span>
    }
    
    /**
     * Searches the path for the first &lt;code&gt;MoveStep&lt;/code&gt; that matches the given position and sets it
     * as a strafing step. In cases where there are multiple steps with the same coordinates, we want the
     * first one because it is the one that enters the hex. In the rare case where the path crosses
     * itself, select the one closest to the end of the path.
     * 
     * FIXME: this does not deal with paths that cross themselves
     * 
     * @param pos The &lt;code&gt;Coords&lt;/code&gt; of the hex to be strafed
     * @return Whether the position was found in the path
     */
    public boolean setStrafingStep(Coords pos) {
<span class="nc" id="L1800">        MoveStep found = null;</span>
<span class="nc bnc" id="L1801" title="All 2 branches missed.">        for (int i = steps.size() - 1; i &gt;= 0; i--) {</span>
<span class="nc bnc" id="L1802" title="All 2 branches missed.">            if (steps.get(i).getPosition().equals(pos)) {</span>
<span class="nc" id="L1803">                found = steps.get(i);</span>
<span class="nc bnc" id="L1804" title="All 2 branches missed.">            } else if (found != null) {</span>
<span class="nc" id="L1805">                found.setStrafing(true);</span>
<span class="nc" id="L1806">                return true;</span>
            }
        }
<span class="nc bnc" id="L1809" title="All 2 branches missed.">        if (found != null) {</span>
<span class="nc" id="L1810">            found.setStrafing(true);</span>
<span class="nc" id="L1811">            return true;</span>
        }
<span class="nc" id="L1813">        return false;</span>
    }
    
    /**
     * @return A list of entity ids for all units that have previously be plotted to be dropped/launched.
     */
    public Set&lt;Integer&gt; getDroppedUnits() {
<span class="nc" id="L1820">        Set&lt;Integer&gt; dropped = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L1821" title="All 2 branches missed.">        for (MoveStep s : steps) {</span>
<span class="nc bnc" id="L1822" title="All 2 branches missed.">            for (Vector&lt;Integer&gt; ids : s.getLaunched().values()) {</span>
<span class="nc" id="L1823">                dropped.addAll(ids);</span>
<span class="nc" id="L1824">            }</span>
<span class="nc" id="L1825">        }</span>
<span class="nc" id="L1826">        return dropped;</span>
    }
    
    /**
     * Convenience function encapsulating logic for whether, if we continue forward 
     * along the current path in the current direction, we will run off the board
     * @return
     */
    public boolean nextForwardStepOffBoard() {
<span class="nc bnc" id="L1835" title="All 2 branches missed.">        return !game.getBoard().contains(getFinalCoords().translated(getFinalFacing()));</span>
    }
    
    /**
     * Debugging method that calculates a destruction-aware move path to the destination coordinates
     */
    @SuppressWarnings(&quot;unused&quot;)
    public MovePath calculateDestructionAwarePath(Coords dest) {
        // code that's useful to test the destruction-aware pathfinder
<span class="nc" id="L1844">        DestructionAwareDestinationPathfinder dpf = new DestructionAwareDestinationPathfinder();</span>
        // the destruction aware pathfinder takes either a CardinalEdge or an explicit set of coordinates
<span class="nc" id="L1846">        Set&lt;Coords&gt; destinationSet = new HashSet&lt;Coords&gt;();</span>
<span class="nc" id="L1847">        destinationSet.add(dest);</span>
        
        // debugging code that can be used to find a path to a specific edge
<span class="nc" id="L1850">        Princess princess = new Princess(&quot;test&quot;, &quot;test&quot;, 2020, LogLevel.OFF);</span>
        //Set&lt;Coords&gt; destinationSet = princess.getClusterTracker().getDestinationCoords(entity, CardinalEdge.WEST, true);
        
<span class="nc" id="L1853">        long marker1 = System.currentTimeMillis();</span>
<span class="nc" id="L1854">        MovePath finPath = dpf.findPathToCoords(entity, destinationSet, false, princess.getClusterTracker());</span>
<span class="nc" id="L1855">        long marker2 = System.currentTimeMillis();</span>
<span class="nc" id="L1856">        long marker3 = marker2 - marker1;</span>
        
<span class="nc" id="L1858">        return finPath;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.4.201905082037</span></div></body></html>