<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Compute.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">megamek</a> &gt; <a href="index.source.html" class="el_package">megamek.common</a> &gt; <span class="el_source">Compute.java</span></div><h1>Compute.java</h1><pre class="source lang-java linenums">/*
 * MegaMek -
 * Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005 Ben Mazur (bmazur@sev.org)
 * Copyright (C) 2018 The MegaMek Team
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation; either version 2 of the License, or (at your option) any later
 * version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 */
package megamek.common;

import java.util.ArrayList;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.Vector;

import megamek.common.Building.BasementType;
import megamek.common.MovePath.MoveStepType;
import megamek.common.actions.BAVibroClawAttackAction;
import megamek.common.actions.BreakGrappleAttackAction;
import megamek.common.actions.BrushOffAttackAction;
import megamek.common.actions.ClubAttackAction;
import megamek.common.actions.EntityAction;
import megamek.common.actions.GrappleAttackAction;
import megamek.common.actions.JumpJetAttackAction;
import megamek.common.actions.KickAttackAction;
import megamek.common.actions.LayExplosivesAttackAction;
import megamek.common.actions.ProtomechPhysicalAttackAction;
import megamek.common.actions.PunchAttackAction;
import megamek.common.actions.PushAttackAction;
import megamek.common.actions.ThrashAttackAction;
import megamek.common.actions.TripAttackAction;
import megamek.common.actions.WeaponAttackAction;
import megamek.common.annotations.Nullable;
import megamek.common.options.OptionsConstants;
import megamek.common.weapons.InfantryAttack;
import megamek.common.weapons.Weapon;
import megamek.common.weapons.artillery.ArtilleryCannonWeapon;
import megamek.common.weapons.bayweapons.BayWeapon;
import megamek.common.weapons.gaussrifles.HAGWeapon;
import megamek.common.weapons.infantry.InfantryWeapon;
import megamek.common.weapons.mgs.MGWeapon;
import megamek.common.weapons.mortars.MekMortarWeapon;
import megamek.server.Server;
import megamek.server.SmokeCloud;

/**
 * The compute class is designed to provide static methods for mechs and other
 * entities moving, firing, etc.
 */
<span class="nc" id="L62">public class Compute {</span>

    public static final int ARC_360 = 0;
    public static final int ARC_FORWARD = 1;
    public static final int ARC_LEFTARM = 2;
    public static final int ARC_RIGHTARM = 3;
    public static final int ARC_REAR = 4;
    public static final int ARC_LEFTSIDE = 5;
    public static final int ARC_RIGHTSIDE = 6;
    public static final int ARC_MAINGUN = 7;
    public static final int ARC_NORTH = 8;
    public static final int ARC_EAST = 9;
    public static final int ARC_WEST = 10;
    public static final int ARC_NOSE = 11;
    public static final int ARC_LWING = 12;
    public static final int ARC_RWING = 13;
    public static final int ARC_LWINGA = 14;
    public static final int ARC_RWINGA = 15;
    public static final int ARC_LEFTSIDE_SPHERE = 16;
    public static final int ARC_RIGHTSIDE_SPHERE = 17;
    public static final int ARC_LEFTSIDEA_SPHERE = 18;
    public static final int ARC_RIGHTSIDEA_SPHERE = 19;
    public static final int ARC_LEFT_BROADSIDE = 20;
    public static final int ARC_RIGHT_BROADSIDE = 21;
    public static final int ARC_AFT = 22;
    public static final int ARC_LEFT_SPHERE_GROUND = 23;
    public static final int ARC_RIGHT_SPHERE_GROUND = 24;
    public static final int ARC_TURRET = 25;
    public static final int ARC_SPONSON_TURRET_LEFT = 26;
    public static final int ARC_SPONSON_TURRET_RIGHT = 27;
    public static final int ARC_PINTLE_TURRET_LEFT = 28;
    public static final int ARC_PINTLE_TURRET_RIGHT = 29;
    public static final int ARC_PINTLE_TURRET_FRONT = 30;
    public static final int ARC_PINTLE_TURRET_REAR = 31;
    public static final int ARC_VGL_FRONT = 32;
    public static final int ARC_VGL_RF = 33;
    public static final int ARC_VGL_RR = 34;
    public static final int ARC_VGL_REAR = 35;
    public static final int ARC_VGL_LR = 36;
    public static final int ARC_VGL_LF = 37;
    //Expanded arcs for Waypoint Launched Capital Missiles
    public static final int ARC_NOSE_WPL = 38;
    public static final int ARC_LWING_WPL = 39;
    public static final int ARC_RWING_WPL = 40;
    public static final int ARC_LWINGA_WPL = 41;
    public static final int ARC_RWINGA_WPL = 42;
    public static final int ARC_LEFTSIDE_SPHERE_WPL = 43;
    public static final int ARC_RIGHTSIDE_SPHERE_WPL = 44;
    public static final int ARC_LEFTSIDEA_SPHERE_WPL = 45;
    public static final int ARC_RIGHTSIDEA_SPHERE_WPL = 46;
    public static final int ARC_AFT_WPL = 47;
    public static final int ARC_LEFT_BROADSIDE_WPL = 48;
    public static final int ARC_RIGHT_BROADSIDE_WPL = 49;

    /**
     * Lookup table for vehicular grenade launcher firing arc from facing
     */
<span class="fc" id="L119">    private static final int[] VGL_FIRING_ARCS = {ARC_VGL_FRONT, ARC_VGL_RF, ARC_VGL_RR,</span>
            ARC_VGL_REAR, ARC_VGL_LR, ARC_VGL_LF
    };

<span class="fc" id="L123">    private static MMRandom random = MMRandom.generate(MMRandom.R_DEFAULT);</span>

<span class="fc" id="L125">    private static final int[][] clusterHitsTable = new int[][]{</span>
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {2, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2},
            {3, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3},
            {4, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4},
            {5, 1, 2, 2, 3, 3, 3, 3, 4, 4, 5, 5},
            {6, 2, 2, 3, 3, 4, 4, 4, 5, 5, 6, 6},
            {7, 2, 2, 3, 4, 4, 4, 4, 6, 6, 7, 7},
            {8, 2, 3, 3, 4, 4, 5, 5, 6, 7, 8, 8},
            {9, 3, 3, 4, 5, 5, 5, 5, 7, 7, 9, 9},
            {10, 3, 3, 4, 6, 6, 6, 6, 8, 8, 10, 10},
            {11, 4, 4, 5, 7, 7, 7, 7, 9, 9, 11, 11},
            {12, 4, 4, 5, 8, 8, 8, 8, 10, 10, 12, 12},
            {13, 4, 4, 5, 8, 8, 8, 8, 11, 11, 13, 13},
            {14, 5, 5, 6, 9, 9, 9, 9, 11, 11, 14, 14},
            {15, 5, 5, 6, 9, 9, 9, 9, 12, 12, 15, 15},
            {16, 5, 5, 7, 10, 10, 10, 10, 13, 13, 16, 16},
            {17, 5, 5, 7, 10, 10, 10, 10, 14, 14, 17, 17},
            {18, 6, 6, 8, 11, 11, 11, 11, 14, 14, 18, 18},
            {19, 6, 6, 8, 11, 11, 11, 11, 15, 15, 19, 19},
            {20, 6, 6, 9, 12, 12, 12, 12, 16, 16, 20, 20},
            {21, 7, 7, 9, 13, 13, 13, 13, 17, 17, 21, 21},
            {22, 7, 7, 9, 14, 14, 14, 14, 18, 18, 22, 22},
            {23, 7, 7, 10, 15, 15, 15, 15, 19, 19, 23, 23},
            {24, 8, 8, 10, 16, 16, 16, 16, 20, 20, 24, 24},
            {25, 8, 8, 10, 16, 16, 16, 16, 21, 21, 25, 25},
            {26, 9, 9, 11, 17, 17, 17, 17, 21, 21, 26, 26},
            {27, 9, 9, 11, 17, 17, 17, 17, 22, 22, 27, 27},
            {28, 9, 9, 11, 17, 17, 17, 17, 23, 23, 28, 28},
            {29, 10, 10, 12, 18, 18, 18, 18, 23, 23, 29, 29},
            {30, 10, 10, 12, 18, 18, 18, 18, 24, 24, 30, 30},
            {40, 12, 12, 18, 24, 24, 24, 24, 32, 32, 40, 40}};

    /**
     * Wrapper to random#d6(n)
     */
    public static int d6(int dice) {
<span class="fc" id="L162">        Roll roll = random.d6(dice);</span>
<span class="pc bpc" id="L163" title="1 of 2 branches missed.">        if (Server.getServerInstance() != null) {</span>
<span class="nc" id="L164">            if (Server.getServerInstance().getGame().getOptions()</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">                    .booleanOption(OptionsConstants.BASE_RNG_LOG)) {</span>
<span class="nc" id="L166">                Server.getServerInstance().reportRoll(roll);</span>
            }
        }
<span class="fc" id="L169">        return roll.getIntValue();</span>
    }

    /**
     * Wrapper to random#d6(n)
     */
    public static int d6(int dice, int keep) {
<span class="nc" id="L176">        Roll roll = random.d6(dice, keep);</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">        if (Server.getServerInstance() != null) {</span>
<span class="nc" id="L178">            if (Server.getServerInstance().getGame().getOptions()</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">                    .booleanOption(OptionsConstants.BASE_RNG_LOG)) {</span>
<span class="nc" id="L180">                Server.getServerInstance().reportRoll(roll);</span>
            }
        }
<span class="nc" id="L183">        return roll.getIntValue();</span>
    }

    /**
     * Wrapper to random#d6()
     */
    public static int d6() {
<span class="nc" id="L190">        Roll roll = random.d6();</span>
<span class="nc bnc" id="L191" title="All 2 branches missed.">        if (Server.getServerInstance() != null) {</span>
<span class="nc" id="L192">            if (Server.getServerInstance().getGame().getOptions()</span>
<span class="nc bnc" id="L193" title="All 2 branches missed.">                    .booleanOption(OptionsConstants.BASE_RNG_LOG)) {</span>
<span class="nc" id="L194">                Server.getServerInstance().reportRoll(roll);</span>
            }
        }
<span class="nc" id="L197">        return roll.getIntValue();</span>
    }

    /**
     * Input is in format &quot;ndf&quot;, so this can handle 2d6 or 3d10
     *
     * @param number the number of dice to roll
     * @param faces  the number of faces on those dice
     * @return an Integer list of every dice roll, with index 0 containing the summed result
     */
    public static List&lt;Integer&gt; individualDice(final int number, final int faces) {
<span class="nc" id="L208">        final List&lt;Integer&gt; individualRolls = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L209">        int result = 0, roll;</span>
<span class="nc" id="L210">        individualRolls.add(result);</span>

<span class="nc bnc" id="L212" title="All 2 branches missed.">        for (int i = 0; i &lt; number; i++) {</span>
<span class="nc" id="L213">            roll = randomInt(faces) + 1;</span>
<span class="nc" id="L214">            individualRolls.add(roll);</span>
<span class="nc" id="L215">            result += roll;</span>
        }

<span class="nc" id="L218">        individualRolls.set(0, result);</span>

<span class="nc" id="L220">        return individualRolls;</span>
    }

    /**
     * Input is in format &quot;c ndf&quot;, so that this can handle 10 rolls of 3d6
     *
     * @param count  the count of sets of dice to roll
     * @param number the number of dice to roll per set
     * @param faces  the number of faces per die
     * @return an Integer list of every summed dice roll, with index 0 containing the summed result
     */
    public static List&lt;Integer&gt; individualRolls(int count, int number, int faces) {
<span class="nc" id="L232">        List&lt;Integer&gt; individualRolls = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L233">        int result = 0, roll;</span>
<span class="nc" id="L234">        individualRolls.add(result);</span>

<span class="nc bnc" id="L236" title="All 2 branches missed.">        for (int x = 0; x &lt; count; x++) {</span>
<span class="nc" id="L237">            roll = 0;</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">            for (int y = 0; y &lt; number; y++) {</span>
<span class="nc" id="L239">                roll += randomInt(faces) + 1;</span>
            }
<span class="nc" id="L241">            individualRolls.add(roll);</span>
<span class="nc" id="L242">            result += roll;</span>
        }

<span class="nc" id="L245">        individualRolls.set(0, result);</span>

<span class="nc" id="L247">        return individualRolls;</span>
    }

    /**
     * Wrapper to random#randomInt(n)
     */
    public static int randomInt(int maxValue) {
<span class="nc" id="L254">        Roll roll = new MMRoll(random, maxValue);</span>
<span class="nc" id="L255">        return roll.getIntValue();</span>
    }

    /**
     * Wrapper to random#randomFloat()
     */
    public static float randomFloat() {
<span class="nc" id="L262">        return random.randomFloat();</span>
    }

    /**
     * Sets the RNG to the desired type
     */
    public static void setRNG(int type) {
<span class="nc" id="L269">        random = MMRandom.generate(type);</span>
<span class="nc" id="L270">    }</span>

    /**
     * Sets the RNG to the specific instance.
     *
     * @param random A non-null instance of {@see MMRandom} to use
     *               for all random number generation.
     */
    public static void setRNG(MMRandom random) {
<span class="nc" id="L279">        Compute.random = Objects.requireNonNull(random);</span>
<span class="nc" id="L280">    }</span>

    /**
     * Returns the odds that a certain number or above will be rolled on 2d6.
     */
    public static double oddsAbove(int n) {
<span class="fc" id="L286">        return oddsAbove(n, false);</span>
    }


    /**
     * Returns the odds that a certain number or above will be rolled on 2d6,
     * or on 3d6 drop the lowest if the flag is set.
     *
     * @param n
     * @param dropLowest Flag that determines whether 2d6 or 3d6 drop the
     *                   lowest is used
     * @return
     */
    public static double oddsAbove(int n, boolean dropLowest) {
<span class="pc bpc" id="L300" title="1 of 2 branches missed.">        if (n &lt;= 2) {</span>
<span class="nc" id="L301">            return 100.0;</span>
<span class="fc bfc" id="L302" title="All 2 branches covered.">        } else if (n &gt; 12) {</span>
<span class="fc" id="L303">            return 0;</span>
        }

<span class="pc bpc" id="L306" title="1 of 2 branches missed.">        if (dropLowest) {</span>
<span class="nc" id="L307">            final double[] odds = {100.0, 100.0, 100.0, 99.54, 98.15, 94.91,</span>
                    89.35, 80.56, 68.06, 52.32, 35.65, 19.91, 7.41, 0};
<span class="nc" id="L309">            return odds[n];</span>
        } else {
<span class="fc" id="L311">            final double[] odds = {100.0, 100.0, 100.0, 97.2, 91.6, 83.3, 72.2,</span>
                    58.3, 41.6, 27.7, 16.6, 8.3, 2.78, 0};
<span class="fc" id="L313">            return odds[n];</span>
        }
    }

    /**
     * Returns an entity if the specified entity would cause a stacking
     * violation entering a hex, or returns null if it would not. The returned
     * entity is the entity causing the violation.
     * &lt;p&gt;
     * The position, and elevation for the stacking violation are derived from
     * the Entity represented by the passed Entity ID.
     */
    public static Entity stackingViolation(IGame game, int enteringId,
                                           Coords coords) {
<span class="nc" id="L327">        Entity entering = game.getEntity(enteringId);</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">        if (entering == null) {</span>
<span class="nc" id="L329">            return null;</span>
        }
<span class="nc" id="L331">        return Compute.stackingViolation(game, entering, coords, null);</span>
    }

    /**
     * When compiling an unloading step, both the transporter and the unloaded
     * unit probably occupy some other position on the board.
     * &lt;p&gt;
     * The position, and elevation for the stacking violation are derived from
     * the passed Entity.
     *
     * @param transport Represents the unit transporing entering, which may affect
     *                  stacking, can be null
     */
    public static Entity stackingViolation(IGame game, Entity entering,
                                           Coords dest, Entity transport) {
<span class="nc" id="L346">        return stackingViolation(game, entering, entering.getElevation(), dest,</span>
                transport);
    }

    /**
     * Returns an entity if the specified entity would cause a stacking
     * violation entering a hex, or returns null if it would not. The returned
     * entity is the entity causing the violation.
     * &lt;p&gt;
     * The position is derived from the passed Entity, while the elevation is
     * derived from the passed Entity parameter.
     *
     * @param transport Represents the unit transporing entering, which may affect
     *                  stacking, can be null
     */
    public static Entity stackingViolation(IGame game, Entity entering,
                                           int elevation, Coords dest, Entity transport) {
<span class="fc" id="L363">        return stackingViolation(game, entering, entering.getPosition(),</span>
                elevation, dest, transport);
    }

    /**
     * Returns an entity if the specified entity would cause a stacking
     * violation entering a hex, or returns null if it would not. The returned
     * entity is the entity causing the violation.
     * &lt;p&gt;
     * The position and elevation is derived from the passed Entity parameter.
     *
     * @param transport Represents the unit transporing entering, which may affect
     *                  stacking, can be null
     */
    public static Entity stackingViolation(IGame game, Entity entering,
                                           Coords origPosition, int elevation, Coords dest, Entity transport) {
        // no stacking violations on the low-atmosphere and space maps
<span class="pc bpc" id="L380" title="1 of 2 branches missed.">        if (!game.getBoard().onGround()) {</span>
<span class="nc" id="L381">            return null;</span>
        }

        // no stacking violations for flying aeros
<span class="fc bfc" id="L385" title="All 2 branches covered.">        if (entering.isAirborne()) {</span>
<span class="fc" id="L386">            return null;</span>
        }

<span class="pc bpc" id="L389" title="2 of 4 branches missed.">        boolean isMech = (entering instanceof Mech)</span>
                || (entering instanceof SmallCraft);
<span class="pc bpc" id="L391" title="3 of 6 branches missed.">        boolean isLargeSupport = (entering instanceof LargeSupportTank)</span>
                || (entering instanceof Dropship)
                || ((entering instanceof Mech) &amp;&amp; ((Mech) entering)
<span class="pc bnc" id="L394" title="All 2 branches missed.">                .isSuperHeavy());</span>

<span class="pc bpc" id="L396" title="1 of 2 branches missed.">        boolean isTrain = !entering.getAllTowedUnits().isEmpty();</span>
<span class="fc" id="L397">        boolean isDropship = entering instanceof Dropship;</span>
<span class="fc" id="L398">        boolean isInfantry = entering instanceof Infantry;</span>
<span class="fc" id="L399">        Entity firstEntity = transport;</span>
<span class="fc" id="L400">        int totalUnits = 1;</span>
<span class="fc" id="L401">        Vector&lt;Coords&gt; positions = new Vector&lt;Coords&gt;();</span>
<span class="fc" id="L402">        positions.add(dest);</span>
<span class="pc bpc" id="L403" title="1 of 2 branches missed.">        if (isDropship) {</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">            for (int dir = 0; dir &lt; 6; dir++) {</span>
<span class="nc" id="L405">                positions.add(dest.translated(dir));</span>
            }
        }
<span class="fc bfc" id="L408" title="All 2 branches covered.">        for (Coords coords : positions) {</span>
<span class="fc" id="L409">            int thisLowStackingLevel = elevation;</span>
<span class="pc bpc" id="L410" title="3 of 4 branches missed.">            if ((coords != null) &amp;&amp; (origPosition != null)) {</span>
<span class="nc" id="L411">                thisLowStackingLevel = entering.calcElevation(game.getBoard()</span>
<span class="nc" id="L412">                        .getHex(origPosition), game.getBoard()</span>
<span class="nc" id="L413">                        .getHex(coords), elevation, entering</span>
<span class="nc" id="L414">                        .climbMode(), false);</span>
            }
<span class="fc" id="L416">            int thisHighStackingLevel = thisLowStackingLevel;</span>
            // mechs only occupy one level of a building
<span class="pc bpc" id="L418" title="1 of 2 branches missed.">            if (!Compute.isInBuilding(game, entering, coords)) {</span>
<span class="fc" id="L419">                thisHighStackingLevel += entering.height();</span>
            }

            // Walk through the entities in the given hex.
<span class="pc bpc" id="L423" title="1 of 2 branches missed.">            for (Entity inHex : game.getEntitiesVector(coords)) {</span>

<span class="nc bnc" id="L425" title="All 2 branches missed.">                if (inHex.isAirborne()) {</span>
<span class="nc" id="L426">                    continue;</span>
                }

<span class="nc" id="L429">                int lowStackingLevel = inHex.getElevation();</span>
<span class="nc" id="L430">                int highStackingLevel = lowStackingLevel;</span>
                // units only occupy one level of a building
<span class="nc bnc" id="L432" title="All 2 branches missed.">                if (!Compute.isInBuilding(game, inHex)) {</span>
<span class="nc" id="L433">                    highStackingLevel += inHex.height();</span>
                }

                // Only do all this jazz if they're close enough together on lvl
                // to interfere.
<span class="nc bnc" id="L438" title="All 4 branches missed.">                if ((thisLowStackingLevel &lt;= highStackingLevel)</span>
                        &amp;&amp; (thisHighStackingLevel &gt;= lowStackingLevel)) {
                    // Don't compare the entering entity to itself.
<span class="nc bnc" id="L441" title="All 2 branches missed.">                    if (inHex.equals(entering)) {</span>
<span class="nc" id="L442">                        continue;</span>
                    }

                    // Ignore the transport of the entering entity.
<span class="nc bnc" id="L446" title="All 2 branches missed.">                    if (inHex.equals(transport)) {</span>
<span class="nc" id="L447">                        continue;</span>
                    }

                    //ignore the first trailer behind a non-superheavy tractor
                    //which can be in the same hex
<span class="nc bnc" id="L452" title="All 4 branches missed.">                    if (isTrain &amp;&amp; !entering.isSuperHeavy()) {</span>
<span class="nc" id="L453">                        Entity firstTrailer = game.getEntity(entering.getAllTowedUnits().get(0));</span>
<span class="nc bnc" id="L454" title="All 2 branches missed.">                        if (inHex.equals(firstTrailer)) {</span>
<span class="nc" id="L455">                            continue;</span>
                        }
                    }

                    // DFAing units don't count towards stacking
<span class="nc bnc" id="L460" title="All 2 branches missed.">                    if (inHex.isMakingDfa()) {</span>
<span class="nc" id="L461">                        continue;</span>
                    }

                    // If the entering entity is a mech,
                    // then any other mech in the hex is a violation.
                    // Unless grappled (but chain whip grapples don't count)
                    // grounded small craft are treated as mechs for purposes
                    // of stacking
<span class="nc bnc" id="L469" title="All 4 branches missed.">                    if (isMech</span>
                            &amp;&amp; (((inHex instanceof Mech) &amp;&amp; (inHex
<span class="nc bnc" id="L471" title="All 2 branches missed.">                            .getGrappled() != entering.getId() || inHex</span>
<span class="nc bnc" id="L472" title="All 4 branches missed.">                            .isChainWhipGrappled())) || (inHex instanceof SmallCraft))) {</span>
<span class="nc" id="L473">                        return inHex;</span>
                    }

                    // only inf can be in the same hex as a large support vee
                    // grounded dropships are treated as large support vees,
                    // ditto for superheavy mechs
<span class="nc bnc" id="L479" title="All 4 branches missed.">                    if (isLargeSupport &amp;&amp; !(inHex instanceof Infantry)) {</span>
<span class="nc" id="L480">                        return inHex;</span>
                    }
<span class="nc bnc" id="L482" title="All 6 branches missed.">                    if (((inHex instanceof LargeSupportTank)</span>
                            || (inHex instanceof Dropship) || ((inHex instanceof Mech) &amp;&amp; ((Mech) inHex)
<span class="nc bnc" id="L484" title="All 4 branches missed.">                            .isSuperHeavy())) &amp;&amp; !isInfantry) {</span>
<span class="nc" id="L485">                        return inHex;</span>
                    }

<span class="nc" id="L488">                    totalUnits++;</span>
                    // If the new one is the most
<span class="nc bnc" id="L490" title="All 2 branches missed.">                    if (totalUnits &gt; 4) {</span>
                        // Arbitrarily return this one, because we can, and it's
                        // simpler.
<span class="nc" id="L493">                        return inHex;</span>
                    }

                    // Otherwise, if there are two present entities controlled
                    // by this player, returns a random one of the two.
                    // Somewhat arbitrary, but how else should we resolve it?
<span class="nc bnc" id="L499" title="All 2 branches missed.">                    if (!inHex.getOwner().isEnemyOf(entering.getOwner())) {</span>
<span class="nc bnc" id="L500" title="All 2 branches missed.">                        if (firstEntity == null) {</span>
<span class="nc" id="L501">                            firstEntity = inHex;</span>
                        } else {
<span class="nc bnc" id="L503" title="All 2 branches missed.">                            return Compute.d6() &gt; 3 ? firstEntity : inHex;</span>
                        }
                    }
                }
<span class="nc" id="L507">            }</span>
<span class="fc" id="L508">        }</span>
        // okay, all clear
<span class="fc" id="L510">        return null;</span>
    }

    /**
     * Returns true if there is any unit that is an enemy of the specified unit
     * in the specified hex. This is only called for stacking purposes, and so
     * does not return true if the enemy unit is currenly making a DFA.
     */
    public static boolean isEnemyIn(IGame game, Entity entity, Coords coords,
                                    boolean onlyMechs, boolean ignoreInfantry, int enLowEl) {
<span class="nc" id="L520">        int enHighEl = enLowEl + entity.getHeight();</span>
<span class="nc bnc" id="L521" title="All 2 branches missed.">        for (Entity inHex : game.getEntitiesVector(coords)) {</span>
<span class="nc" id="L522">            int inHexEnLowEl = inHex.getElevation();</span>
<span class="nc" id="L523">            int inHexEnHighEl = inHexEnLowEl + inHex.getHeight();</span>
<span class="nc bnc" id="L524" title="All 8 branches missed.">            if ((!onlyMechs || (inHex instanceof Mech))</span>
                    &amp;&amp; !(ignoreInfantry &amp;&amp; (inHex instanceof Infantry))
<span class="nc bnc" id="L526" title="All 8 branches missed.">                    &amp;&amp; inHex.isEnemyOf(entity) &amp;&amp; !inHex.isMakingDfa()</span>
                    &amp;&amp; (enLowEl &lt;= inHexEnHighEl) &amp;&amp; (enHighEl &gt;= inHexEnLowEl)) {
<span class="nc" id="L528">                return true;</span>
            }
<span class="nc" id="L530">        }</span>
<span class="nc" id="L531">        return false;</span>
    }

    /**
     * @return true if a piloting skill roll is needed to traverse the terrain
     */
    public static boolean isPilotingSkillNeeded(IGame game, int entityId,
                                                Coords src, Coords dest, EntityMovementType movementType,
                                                boolean isTurning, boolean prevStepIsOnPavement, int srcElevation,
                                                int destElevation, MoveStep moveStep) {
<span class="nc" id="L541">        final Entity entity = game.getEntity(entityId);</span>
<span class="nc" id="L542">        final IHex srcHex = game.getBoard().getHex(src);</span>
<span class="nc" id="L543">        final IHex destHex = game.getBoard().getHex(dest);</span>
<span class="nc" id="L544">        final boolean isInfantry = (entity instanceof Infantry);</span>
<span class="nc" id="L545">        int delta_alt = (destElevation + destHex.getLevel())</span>
<span class="nc" id="L546">                - (srcElevation + srcHex.getLevel());</span>

        // arguments valid?
<span class="nc bnc" id="L549" title="All 2 branches missed.">        if (entity == null) {</span>
<span class="nc" id="L550">            throw new IllegalArgumentException(&quot;Entity invalid. ID &quot; + entityId);</span>
        }
<span class="nc bnc" id="L552" title="All 2 branches missed.">        if (src.distance(dest) &gt; 1) {</span>
<span class="nc" id="L553">            throw new IllegalArgumentException(&quot;Coordinates must be adjacent.&quot;);</span>
        }

        // let's only worry about actual movement, please
<span class="nc bnc" id="L557" title="All 2 branches missed.">        if (src.equals(dest)) {</span>
<span class="nc" id="L558">            return false;</span>
        }

        // airborne aircraft do not require pavement-related checks
<span class="nc bnc" id="L562" title="All 2 branches missed.">        final boolean isPavementStep = entity.isAirborne() ? false : Compute.canMoveOnPavement(game, src, dest, moveStep);</span>

        // check for rubble
<span class="nc bnc" id="L565" title="All 2 branches missed.">        if ((movementType != EntityMovementType.MOVE_JUMP)</span>
<span class="nc bnc" id="L566" title="All 6 branches missed.">                &amp;&amp; (destHex.terrainLevel(Terrains.RUBBLE) &gt; 0)</span>
                &amp;&amp; (destElevation == 0)
                &amp;&amp; !isPavementStep
<span class="nc bnc" id="L569" title="All 2 branches missed.">                &amp;&amp; entity.canFall()) {</span>
<span class="nc" id="L570">            return true;</span>
        }

        // check for swamp
<span class="nc bnc" id="L574" title="All 2 branches missed.">        if (destHex.containsTerrain(Terrains.SWAMP)</span>
<span class="nc bnc" id="L575" title="All 2 branches missed.">                &amp;&amp; !(entity.getElevation() &gt; destHex.getLevel())</span>
<span class="nc bnc" id="L576" title="All 2 branches missed.">                &amp;&amp; (entity.getMovementMode() != EntityMovementMode.HOVER)</span>
<span class="nc bnc" id="L577" title="All 4 branches missed.">                &amp;&amp; (entity.getMovementMode() != EntityMovementMode.VTOL)</span>
                &amp;&amp; (movementType != EntityMovementType.MOVE_JUMP)
<span class="nc bnc" id="L579" title="All 4 branches missed.">                &amp;&amp; (entity.getMovementMode() != EntityMovementMode.WIGE)</span>
                &amp;&amp; !isPavementStep) {
<span class="nc" id="L581">            return true;</span>
        }

        // check for thin ice
<span class="nc bnc" id="L585" title="All 2 branches missed.">        if (destHex.containsTerrain(Terrains.ICE)</span>
<span class="nc bnc" id="L586" title="All 2 branches missed.">                &amp;&amp; destHex.containsTerrain(Terrains.WATER)</span>
<span class="nc bnc" id="L587" title="All 6 branches missed.">                &amp;&amp; !(entity.getElevation() &gt; destHex.getLevel())</span>
                &amp;&amp; !isPavementStep
                &amp;&amp; (movementType != EntityMovementType.MOVE_JUMP)) {
<span class="nc" id="L590">            return true;</span>
        }

        // Check for water unless we're a hovercraft or naval or using a bridge
        // or flying or QuadVee in vehicle mode.
<span class="nc bnc" id="L595" title="All 2 branches missed.">        if ((movementType != EntityMovementType.MOVE_JUMP)</span>
<span class="nc bnc" id="L596" title="All 2 branches missed.">                &amp;&amp; !(entity.getElevation() &gt; destHex.surface())</span>
<span class="nc bnc" id="L597" title="All 2 branches missed.">                &amp;&amp; !((entity.getMovementMode() == EntityMovementMode.HOVER)</span>
<span class="nc bnc" id="L598" title="All 2 branches missed.">                || (entity.getMovementMode() == EntityMovementMode.NAVAL)</span>
<span class="nc bnc" id="L599" title="All 2 branches missed.">                || (entity.getMovementMode() == EntityMovementMode.HYDROFOIL)</span>
<span class="nc bnc" id="L600" title="All 2 branches missed.">                || (entity.getMovementMode() == EntityMovementMode.SUBMARINE)</span>
<span class="nc bnc" id="L601" title="All 2 branches missed.">                || (entity.getMovementMode() == EntityMovementMode.INF_UMU)</span>
<span class="nc bnc" id="L602" title="All 2 branches missed.">                || (entity.getMovementMode() == EntityMovementMode.BIPED_SWIM)</span>
<span class="nc bnc" id="L603" title="All 2 branches missed.">                || (entity.getMovementMode() == EntityMovementMode.QUAD_SWIM)</span>
<span class="nc bnc" id="L604" title="All 4 branches missed.">                || (entity.getMovementMode() == EntityMovementMode.WIGE)</span>
<span class="nc bnc" id="L605" title="All 2 branches missed.">                || (entity instanceof QuadVee &amp;&amp; entity.getConversionMode() == QuadVee.CONV_MODE_VEHICLE))</span>
<span class="nc bnc" id="L606" title="All 4 branches missed.">                &amp;&amp; (destHex.terrainLevel(Terrains.WATER) &gt; 0)</span>
                &amp;&amp; !isPavementStep) {
<span class="nc" id="L608">            return true;</span>
        }

        // Sheer Cliffs, TO p.39
        // Roads over cliffs cancel the cliff effects for units that move on roads
<span class="nc bnc" id="L613" title="All 2 branches missed.">        boolean quadveeVehMode = entity instanceof QuadVee</span>
<span class="nc bnc" id="L614" title="All 2 branches missed.">                &amp;&amp; entity.getConversionMode() == QuadVee.CONV_MODE_VEHICLE;</span>
<span class="nc bnc" id="L615" title="All 2 branches missed.">        boolean vehicleAffectedByCliff = entity instanceof Tank</span>
<span class="nc bnc" id="L616" title="All 2 branches missed.">                &amp;&amp; !entity.isAirborneVTOLorWIGE();</span>
<span class="nc bnc" id="L617" title="All 6 branches missed.">        boolean mechAffectedByCliff = (entity instanceof Mech || entity instanceof Protomech)</span>
                &amp;&amp; movementType != EntityMovementType.MOVE_JUMP
<span class="nc bnc" id="L619" title="All 2 branches missed.">                &amp;&amp; !entity.isAero(); // LAM</span>
<span class="nc" id="L620">        int stepHeight = destElevation + destHex.getLevel() - (srcElevation + srcHex.getLevel());</span>
        // Cliffs should only exist towards 1 or 2 level drops, check just to make sure
        // Everything that does not have a 1 or 2 level drop shouldn't be handled as a cliff
<span class="nc bnc" id="L623" title="All 2 branches missed.">        boolean isUpCliff = !src.equals(dest)</span>
<span class="nc bnc" id="L624" title="All 6 branches missed.">                &amp;&amp; destHex.hasCliffTopTowards(srcHex)</span>
                &amp;&amp; (stepHeight == 1 || stepHeight == 2);
<span class="nc bnc" id="L626" title="All 2 branches missed.">        boolean isDownCliff = !src.equals(dest)</span>
<span class="nc bnc" id="L627" title="All 6 branches missed.">                &amp;&amp; srcHex.hasCliffTopTowards(destHex)</span>
                &amp;&amp; (stepHeight == -1 || stepHeight == -2);

        // Mechs and Vehicles moving down a cliff
        // Quadvees in vee mode ignore PSRs to avoid falls, IO p.133 
<span class="nc bnc" id="L632" title="All 10 branches missed.">        if ((mechAffectedByCliff || vehicleAffectedByCliff)</span>
                &amp;&amp; !quadveeVehMode
                &amp;&amp; isDownCliff
                &amp;&amp; !isPavementStep) {
<span class="nc" id="L636">            return true;</span>
        }

        // Mechs moving up a cliff
<span class="nc bnc" id="L640" title="All 8 branches missed.">        if (mechAffectedByCliff</span>
                &amp;&amp; !quadveeVehMode
                &amp;&amp; isUpCliff
                &amp;&amp; !isPavementStep) {
<span class="nc" id="L644">            return true;</span>
        }

        // Check for skid. Please note, the skid will be rolled on the
        // current step, but starts from the previous step's location.
        // TODO: add check for elevation of pavement, road,
        // or bridge matches entity elevation.
        /*
         * Bug 754610: Revert fix for bug 702735. if ( (
         * srcHex.contains(Terrain.PAVEMENT) || srcHex.contains(Terrain.ROAD) ||
         * srcHex.contains(Terrain.BRIDGE) )
         */
<span class="nc bnc" id="L656" title="All 6 branches missed.">        if (((prevStepIsOnPavement</span>
                &amp;&amp; ((movementType == EntityMovementType.MOVE_RUN)
                || (movementType == EntityMovementType.MOVE_SPRINT)))
<span class="nc bnc" id="L659" title="All 4 branches missed.">                || ((srcHex.containsTerrain(Terrains.ICE))</span>
                &amp;&amp; (movementType != EntityMovementType.MOVE_JUMP)))
<span class="nc bnc" id="L661" title="All 2 branches missed.">                &amp;&amp; (entity.getMovementMode() != EntityMovementMode.HOVER)</span>
<span class="nc bnc" id="L662" title="All 6 branches missed.">                &amp;&amp; (entity.getMovementMode() != EntityMovementMode.WIGE)</span>
                &amp;&amp; isTurning &amp;&amp; !isInfantry) {
<span class="nc" id="L664">            return true;</span>
        }

        // If we entering a building, all non-infantry
        // need to make a piloting check to avoid damage.
<span class="nc bnc" id="L669" title="All 4 branches missed.">        if ((destElevation &lt; destHex.terrainLevel(Terrains.BLDG_ELEV))</span>
                &amp;&amp; !(entity instanceof Infantry)) {
<span class="nc" id="L671">            Building bldg = game.getBoard().getBuildingAt(dest);</span>
<span class="nc bnc" id="L672" title="All 2 branches missed.">            boolean insideHangar = (null != bldg)</span>
<span class="nc bnc" id="L673" title="All 2 branches missed.">                    &amp;&amp; bldg.isIn(src)</span>
<span class="nc bnc" id="L674" title="All 2 branches missed.">                    &amp;&amp; (bldg.getBldgClass() == Building.HANGAR)</span>
<span class="nc" id="L675">                    &amp;&amp; (destHex.terrainLevel(Terrains.BLDG_ELEV) &gt; entity</span>
<span class="nc bnc" id="L676" title="All 2 branches missed.">                    .height());</span>
<span class="nc bnc" id="L677" title="All 2 branches missed.">            if (!insideHangar) {</span>
<span class="nc" id="L678">                return true;</span>
            }
        }

        // check sideslips
<span class="nc bnc" id="L683" title="All 2 branches missed.">        if ((entity instanceof VTOL)</span>
<span class="nc bnc" id="L684" title="All 2 branches missed.">                || (entity.getMovementMode() == EntityMovementMode.HOVER)</span>
<span class="nc bnc" id="L685" title="All 6 branches missed.">                || (entity.getMovementMode() == EntityMovementMode.WIGE</span>
                &amp;&amp; destElevation &gt; 0 &amp;&amp; !(entity instanceof Protomech))) {
<span class="nc bnc" id="L687" title="All 10 branches missed.">            if (isTurning</span>
                    &amp;&amp; ((movementType == EntityMovementType.MOVE_RUN)
                    || (movementType == EntityMovementType.MOVE_SPRINT)
                    || (movementType == EntityMovementType.MOVE_VTOL_RUN)
                    || (movementType == EntityMovementType.MOVE_VTOL_SPRINT))) {
<span class="nc" id="L692">                return true;</span>
            }
            // Controlled sideslip requires check to avoid extra hex of sideslip movement.
<span class="nc bnc" id="L695" title="All 2 branches missed.">            if ((moveStep.getType() == MoveStepType.LATERAL_LEFT</span>
<span class="nc bnc" id="L696" title="All 2 branches missed.">                    || moveStep.getType() == MoveStepType.LATERAL_RIGHT</span>
<span class="nc bnc" id="L697" title="All 2 branches missed.">                    || moveStep.getType() == MoveStepType.LATERAL_LEFT_BACKWARDS</span>
<span class="nc bnc" id="L698" title="All 2 branches missed.">                    || moveStep.getType() == MoveStepType.LATERAL_RIGHT_BACKWARDS)</span>
<span class="nc bnc" id="L699" title="All 6 branches missed.">                    &amp;&amp; (!entity.isUsingManAce()</span>
                    || movementType != EntityMovementType.MOVE_WALK
                    || movementType != EntityMovementType.MOVE_VTOL_WALK)) {
<span class="nc" id="L702">                return true;</span>
            }
        }

        // check leaps
<span class="nc bnc" id="L707" title="All 10 branches missed.">        if ((entity instanceof Mech) &amp;&amp; (delta_alt &lt; -2)</span>
                &amp;&amp; (movementType != EntityMovementType.MOVE_JUMP
                &amp;&amp; (movementType != EntityMovementType.MOVE_VTOL_WALK
                &amp;&amp; (movementType != EntityMovementType.MOVE_VTOL_RUN)))) {
<span class="nc" id="L711">            return true;</span>
        }

<span class="nc" id="L714">        return false;</span>
    }

    /**
     * Can the defending unit be displaced from the source to the destination?
     */
    public static boolean isValidDisplacement(IGame game, int entityId,
                                              Coords src, int direction) {
<span class="nc" id="L722">        return Compute.isValidDisplacement(game, entityId, src,</span>
<span class="nc" id="L723">                src.translated(direction));</span>
    }

    /**
     * Can the defending unit be displaced from the source to the destination?
     */
    public static boolean isValidDisplacement(IGame game, int entityId,
                                              Coords src, Coords dest) {
<span class="nc" id="L731">        final Entity entity = game.getEntity(entityId);</span>
<span class="nc" id="L732">        final IHex srcHex = game.getBoard().getHex(src);</span>
<span class="nc" id="L733">        final IHex destHex = game.getBoard().getHex(dest);</span>
<span class="nc" id="L734">        final ArrayList&lt;Coords&gt; intervening = Coords.intervening(src, dest);</span>
<span class="nc" id="L735">        final int direction = src.direction(dest);</span>

        // arguments valid?
<span class="nc bnc" id="L738" title="All 2 branches missed.">        if (entity == null) {</span>
<span class="nc" id="L739">            throw new IllegalArgumentException(&quot;Entity invalid.&quot;);</span>
        }

        // dropships should never be displaceable
        // this should also take care of the situation of displacing another
        // entity
        // into a grounded droppers hex, because of the stacking violation check
        // below
<span class="nc bnc" id="L747" title="All 2 branches missed.">        if (entity instanceof Dropship) {</span>
<span class="nc" id="L748">            return false;</span>
        }

        // an easy check
<span class="nc bnc" id="L752" title="All 2 branches missed.">        if (!game.getBoard().contains(dest)) {</span>
<span class="nc bnc" id="L753" title="All 2 branches missed.">            if (game.getOptions().booleanOption(OptionsConstants.BASE_PUSH_OFF_BOARD)) {</span>
<span class="nc" id="L754">                return true;</span>
            }
<span class="nc" id="L756">            return false;</span>
        }

        // can't be displaced into prohibited terrain
        // unless we're displacing a tracked or wheeled vee into water
<span class="nc bnc" id="L761" title="All 4 branches missed.">        if (entity.isLocationProhibited(dest)</span>
                &amp;&amp; !((entity instanceof Tank)
<span class="nc bnc" id="L763" title="All 6 branches missed.">                &amp;&amp; destHex.containsTerrain(Terrains.WATER)</span>
                &amp;&amp; ((entity.movementMode == EntityMovementMode.TRACKED)
                || (entity.movementMode == EntityMovementMode.WHEELED)))) {
<span class="nc" id="L766">            return false;</span>
        }

        // can't go up more levels than normally possible
<span class="nc bnc" id="L770" title="All 2 branches missed.">        for (Coords c : intervening) {</span>
            // ignore off-board hexes
<span class="nc bnc" id="L772" title="All 2 branches missed.">            if (!game.getBoard().contains(c)) {</span>
<span class="nc" id="L773">                continue;</span>
            }
<span class="nc" id="L775">            final IHex hex = game.getBoard().getHex(c);</span>
<span class="nc" id="L776">            int change = entity.elevationOccupied(hex)</span>
<span class="nc" id="L777">                    - entity.elevationOccupied(srcHex);</span>
<span class="nc bnc" id="L778" title="All 2 branches missed.">            if (change &gt; entity.getMaxElevationChange()) {</span>
<span class="nc" id="L779">                return false;</span>
            }
<span class="nc" id="L781">        }</span>

        // if there's an entity in the way, can they be displaced in that
        // direction?
<span class="nc" id="L785">        Entity inTheWay = Compute.stackingViolation(game, entityId, dest);</span>
<span class="nc bnc" id="L786" title="All 2 branches missed.">        if (inTheWay != null) {</span>
<span class="nc" id="L787">            return Compute.isValidDisplacement(game, inTheWay.getId(),</span>
<span class="nc" id="L788">                    inTheWay.getPosition(), direction);</span>
        }

        // okay, that's about all the checks
<span class="nc" id="L792">        return true;</span>
    }

    /**
     * Gets a valid displacement, from the hexes around src, as close to the
     * original direction as is possible.
     *
     * @return valid displacement coords, or null if none
     */
    public static Coords getValidDisplacement(IGame game, int entityId,
                                              Coords src, int direction) {
        // check the surrounding hexes, nearest to the original direction first
<span class="nc" id="L804">        int[] offsets = {0, 1, 5, 2, 4, 3};</span>
<span class="nc" id="L805">        int range = 1;</span>
        // check for a central dropship hex and if so, then displace to a two
        // hex radius
<span class="nc bnc" id="L808" title="All 2 branches missed.">        for (Entity en : game.getEntitiesVector(src)) {</span>
<span class="nc bnc" id="L809" title="All 4 branches missed.">            if ((en instanceof Dropship) &amp;&amp; !en.isAirborne()</span>
<span class="nc bnc" id="L810" title="All 2 branches missed.">                    &amp;&amp; en.getPosition().equals(src)) {</span>
<span class="nc" id="L811">                range = 2;</span>
            }
<span class="nc" id="L813">        }</span>
<span class="nc bnc" id="L814" title="All 2 branches missed.">        for (int offset : offsets) {</span>
<span class="nc" id="L815">            Coords dest = src.translated((direction + offset) % 6, range);</span>
<span class="nc bnc" id="L816" title="All 2 branches missed.">            if (Compute.isValidDisplacement(game, entityId, src, dest)) {</span>
<span class="nc" id="L817">                return dest;</span>
            }
            // code here borrowed from Compute.coordsAtRange
<span class="nc bnc" id="L820" title="All 2 branches missed.">            for (int count = 1; count &lt; range; count++) {</span>
<span class="nc" id="L821">                dest = dest.translated((direction + offset + 2) % 6);</span>
<span class="nc bnc" id="L822" title="All 2 branches missed.">                if (Compute.isValidDisplacement(game, entityId, src, dest)) {</span>
<span class="nc" id="L823">                    return dest;</span>
                }
            }
        }
        // have fun being insta-killed!
<span class="nc" id="L828">        return null;</span>
    }

    /**
     * Gets a preferred displacement. Right now this picks the surrounding hex
     * with the same elevation as original hex, if not available it picks the
     * highest elevation that is a valid displacement. This will preferably not
     * displace into friendly units
     *
     * @return valid displacement coords, or null if none
     */
    public static Coords getPreferredDisplacement(IGame game, int entityId,
                                                  Coords src, int direction) {
<span class="nc" id="L841">        final Entity entity = game.getEntity(entityId);</span>
<span class="nc" id="L842">        int highestElev = Integer.MIN_VALUE;</span>
<span class="nc" id="L843">        Coords highest = null;</span>
<span class="nc" id="L844">        int srcElevation =</span>
<span class="nc" id="L845">                entity.elevationOccupied(game.getBoard().getHex(src));</span>

        // check the surrounding hexes, nearest to the original direction first
<span class="nc" id="L848">        int[] offsets = {0, 1, 5, 2, 4, 3};</span>
        // first, try not to displace into friendly units
<span class="nc bnc" id="L850" title="All 2 branches missed.">        for (int offset : offsets) {</span>
<span class="nc" id="L851">            Coords dest = src.translated((direction + offset) % 6);</span>
<span class="nc bnc" id="L852" title="All 2 branches missed.">            if (Compute.isValidDisplacement(game, entityId, src, dest)</span>
<span class="nc bnc" id="L853" title="All 2 branches missed.">                    &amp;&amp; game.getBoard().contains(dest)) {</span>
<span class="nc" id="L854">                Iterator&lt;Entity&gt; entities = game.getFriendlyEntities(dest,</span>
<span class="nc" id="L855">                        game.getEntity(entityId));</span>
<span class="nc bnc" id="L856" title="All 2 branches missed.">                if (entities.hasNext()) {</span>
                    // friendly unit here, try next hex
<span class="nc" id="L858">                    continue;</span>
                }
<span class="nc" id="L860">                IHex hex = game.getBoard().getHex(dest);</span>
<span class="nc" id="L861">                int elevation = entity.elevationOccupied(hex);</span>
<span class="nc bnc" id="L862" title="All 2 branches missed.">                if (elevation &gt; highestElev) {</span>
<span class="nc" id="L863">                    highestElev = elevation;</span>
<span class="nc" id="L864">                    highest = dest;</span>
                }
                // preferably, go to same elevation
<span class="nc bnc" id="L867" title="All 2 branches missed.">                if (elevation == srcElevation) {</span>
<span class="nc" id="L868">                    return dest;</span>
                }
            }
        }
<span class="nc bnc" id="L872" title="All 2 branches missed.">        if (highest != null) {</span>
<span class="nc" id="L873">            return highest;</span>
        }
        // ok, all hexes occupied, now displace preferably to same elevation,
        // else highest
<span class="nc bnc" id="L877" title="All 2 branches missed.">        for (int offset : offsets) {</span>
<span class="nc" id="L878">            Coords dest = src.translated((direction + offset) % 6);</span>
<span class="nc bnc" id="L879" title="All 2 branches missed.">            if (Compute.isValidDisplacement(game, entityId, src, dest)</span>
<span class="nc bnc" id="L880" title="All 2 branches missed.">                    &amp;&amp; game.getBoard().contains(dest)) {</span>
<span class="nc" id="L881">                IHex hex = game.getBoard().getHex(dest);</span>
<span class="nc" id="L882">                int elevation = entity.elevationOccupied(hex);</span>
<span class="nc bnc" id="L883" title="All 2 branches missed.">                if (elevation &gt; highestElev) {</span>
<span class="nc" id="L884">                    highestElev = elevation;</span>
<span class="nc" id="L885">                    highest = dest;</span>
                }
                // preferably, go to same elevation
<span class="nc bnc" id="L888" title="All 2 branches missed.">                if (elevation == entity.getElevation()) {</span>
<span class="nc" id="L889">                    return dest;</span>
                }
            }
        }
<span class="nc" id="L893">        return highest;</span>
    }

    /**
     * Gets a hex to displace a missed charge to. Picks left or right, first
     * preferring higher hexes, then randomly, or returns the base hex if
     * they're impassible.
     */
    public static Coords getMissedChargeDisplacement(IGame game, int entityId,
                                                     Coords src, int direction) {
<span class="nc" id="L903">        Coords first = src.translated((direction + 1) % 6);</span>
<span class="nc" id="L904">        Coords second = src.translated((direction + 5) % 6);</span>
<span class="nc" id="L905">        IHex firstHex = game.getBoard().getHex(first);</span>
<span class="nc" id="L906">        IHex secondHex = game.getBoard().getHex(second);</span>
<span class="nc" id="L907">        Entity entity = game.getEntity(entityId);</span>

<span class="nc bnc" id="L909" title="All 4 branches missed.">        if ((firstHex == null) || (secondHex == null)) {</span>
            // leave it, will be handled
<span class="nc" id="L911">        } else if (entity.elevationOccupied(firstHex) &gt; entity</span>
<span class="nc bnc" id="L912" title="All 2 branches missed.">                .elevationOccupied(secondHex)) {</span>
            // leave it
<span class="nc" id="L914">        } else if (entity.elevationOccupied(firstHex) &lt; entity</span>
<span class="nc bnc" id="L915" title="All 2 branches missed.">                .elevationOccupied(secondHex)) {</span>
            // switch
<span class="nc" id="L917">            Coords temp = first;</span>
<span class="nc" id="L918">            first = second;</span>
<span class="nc" id="L919">            second = temp;</span>
<span class="nc bnc" id="L920" title="All 2 branches missed.">        } else if (Compute.d6() &gt; 3) {</span>
            // switch randomly
<span class="nc" id="L922">            Coords temp = first;</span>
<span class="nc" id="L923">            first = second;</span>
<span class="nc" id="L924">            second = temp;</span>
        }

<span class="nc bnc" id="L927" title="All 2 branches missed.">        if (Compute.isValidDisplacement(game, entityId, src,</span>
<span class="nc" id="L928">                src.direction(first))</span>
<span class="nc bnc" id="L929" title="All 2 branches missed.">                &amp;&amp; game.getBoard().contains(first)) {</span>
<span class="nc" id="L930">            return first;</span>
<span class="nc bnc" id="L931" title="All 2 branches missed.">        } else if (Compute.isValidDisplacement(game, entityId, src,</span>
<span class="nc" id="L932">                src.direction(second))</span>
<span class="nc bnc" id="L933" title="All 2 branches missed.">                &amp;&amp; game.getBoard().contains(second)) {</span>
<span class="nc" id="L934">            return second;</span>
        } else {
<span class="nc" id="L936">            return src;</span>
        }
    }

    /**
     * Finds the best spotter for the attacker. The best spotter is the one with
     * the lowest attack modifiers, of course. LOS modifiers and movement are
     * considered.
     */
    public static Entity findSpotter(IGame game, Entity attacker,
                                     Targetable target) {
<span class="nc" id="L947">        Entity spotter = null;</span>
<span class="nc" id="L948">        int taggedBy = -1;</span>
<span class="nc bnc" id="L949" title="All 2 branches missed.">        if (target instanceof Entity) {</span>
<span class="nc" id="L950">            taggedBy = ((Entity) target).getTaggedBy();</span>
        }
<span class="nc" id="L952">        ToHitData bestMods = new ToHitData(TargetRoll.IMPOSSIBLE, &quot;&quot;);</span>

<span class="nc bnc" id="L954" title="All 2 branches missed.">        for (Entity other : game.getEntitiesVector()) {</span>
<span class="nc bnc" id="L955" title="All 2 branches missed.">            if (((other.isSpotting() &amp;&amp; (other.getSpotTargetId() == target</span>
<span class="nc bnc" id="L956" title="All 4 branches missed.">                    .getTargetId())) || (taggedBy == other.getId()))</span>
<span class="nc bnc" id="L957" title="All 2 branches missed.">                    &amp;&amp; !attacker.isEnemyOf(other)) {</span>
                // what are this guy's mods to the attack?
<span class="nc" id="L959">                LosEffects los = LosEffects.calculateLos(game, other.getId(),</span>
                        target, true);
<span class="nc" id="L961">                ToHitData mods = los.losModifiers(game);</span>
                // If the target isn't spotted, can't target
<span class="nc bnc" id="L963" title="All 2 branches missed.">                if (game.getOptions().booleanOption(OptionsConstants.ADVANCED_DOUBLE_BLIND)</span>
<span class="nc bnc" id="L964" title="All 2 branches missed.">                        &amp;&amp; !Compute.inVisualRange(game, los, other, target)</span>
<span class="nc bnc" id="L965" title="All 2 branches missed.">                        &amp;&amp; !Compute.inSensorRange(game, los, other, target, null)) {</span>
<span class="nc" id="L966">                    mods.addModifier(TargetRoll.IMPOSSIBLE,</span>
                            &quot;outside of visual and sensor range&quot;);
                }
<span class="nc" id="L969">                los.setTargetCover(LosEffects.COVER_NONE);</span>
<span class="nc" id="L970">                mods.append(Compute.getAttackerMovementModifier(game,</span>
<span class="nc" id="L971">                        other.getId()));</span>

                // a spotter suffers a penalty if it's also making an attack this round
                // unless it has a command console or has TAGged the target
<span class="nc bnc" id="L975" title="All 4 branches missed.">                if (other.isAttackingThisTurn() &amp;&amp; !other.getCrew().hasActiveCommandConsole() &amp;&amp;</span>
<span class="nc bnc" id="L976" title="All 4 branches missed.">                        (!isTargetTagged(attacker, target, game) || (taggedBy != -1))) {</span>
<span class="nc" id="L977">                    mods.addModifier(1, &quot;spotter is making an attack this turn&quot;);</span>
                }

                // is this guy a better spotter?
<span class="nc bnc" id="L981" title="All 2 branches missed.">                if ((spotter == null)</span>
<span class="nc bnc" id="L982" title="All 2 branches missed.">                        || (mods.getValue() &lt; bestMods.getValue())) {</span>
<span class="nc" id="L983">                    spotter = other;</span>
<span class="nc" id="L984">                    bestMods = mods;</span>
                }
            }
<span class="nc" id="L987">        }</span>

<span class="nc" id="L989">        return spotter;</span>
    }

    /**
     * Worker function to determine if the target has been tagged.
     *
     * @param target The non-entity target to check
     * @param game   Game object
     * @return Whether or not the given entity or other targetable is tagged.
     */
    public static boolean isTargetTagged(Targetable target, IGame game) {
<span class="nc" id="L1000">        boolean targetTagged = false;</span>

<span class="nc" id="L1002">        Entity te = null;</span>
<span class="nc bnc" id="L1003" title="All 2 branches missed.">        if (target instanceof Entity) {</span>
<span class="nc" id="L1004">            te = (Entity) target;</span>
        }

        // If this is an entity, we can see if it's tagged
<span class="nc bnc" id="L1008" title="All 2 branches missed.">        if (te != null) {</span>
<span class="nc bnc" id="L1009" title="All 2 branches missed.">            targetTagged = te.getTaggedBy() != -1;</span>
        } else { // Non entities will require us to look harder
<span class="nc bnc" id="L1011" title="All 2 branches missed.">            for (TagInfo ti : game.getTagInfo()) {</span>
<span class="nc bnc" id="L1012" title="All 2 branches missed.">                if (target.getTargetId() == ti.target.getTargetId()) {</span>
<span class="nc" id="L1013">                    return true;</span>
                }
<span class="nc" id="L1015">            }</span>
        }

<span class="nc" id="L1018">        return targetTagged;</span>
    }

    /**
     * Worker function to determine if the target has been tagged by the specific attacker.
     *
     * @param attacker The attacker.
     * @param target   The non-entity target to check
     * @param game     Game object
     * @return Whether or not the given entity or other targetable is tagged by the specific attacker.
     */
    public static boolean isTargetTagged(Entity attacker, Targetable target, IGame game) {
<span class="nc" id="L1030">        boolean targetTagged = false;</span>

<span class="nc" id="L1032">        Entity te = null;</span>
<span class="nc bnc" id="L1033" title="All 2 branches missed.">        if (target instanceof Entity) {</span>
<span class="nc" id="L1034">            te = (Entity) target;</span>
        }

        // If this is an entity, we can see if it's tagged
<span class="nc bnc" id="L1038" title="All 2 branches missed.">        if (te != null) {</span>
<span class="nc bnc" id="L1039" title="All 2 branches missed.">            targetTagged = te.getTaggedBy() == attacker.getId();</span>
        } else { // Non entities will require us to look harder
<span class="nc bnc" id="L1041" title="All 2 branches missed.">            for (TagInfo ti : game.getTagInfo()) {</span>
<span class="nc bnc" id="L1042" title="All 2 branches missed.">                if ((target.getTargetId() == ti.target.getTargetId()) &amp;&amp;</span>
<span class="nc bnc" id="L1043" title="All 2 branches missed.">                        (ti.attackerId == attacker.getId())) {</span>
<span class="nc" id="L1044">                    return true;</span>
                }
<span class="nc" id="L1046">            }</span>
        }

<span class="nc" id="L1049">        return targetTagged;</span>
    }


    public static ToHitData getImmobileMod(Targetable target) {
<span class="nc" id="L1054">        return Compute.getImmobileMod(target, Entity.LOC_NONE,</span>
                IAimingModes.AIM_MODE_NONE);
    }

    /**
     * Gets the ToHitData associated with firing at an immobile target. Returns null if target isn't.
     *
     * @param target     The target being considered for firing
     * @param aimingAt   The location of the unit being aimed at
     * @param aimingMode The aiming mode
     * @return The relevant ToHitData
     */
    @Nullable
    public static ToHitData getImmobileMod(Targetable target, int aimingAt,
                                           int aimingMode) {
        // if we are bombing hexes, they are not considered immobile.
<span class="nc bnc" id="L1070" title="All 2 branches missed.">        if (target.getTargetType() == Targetable.TYPE_HEX_BOMB ||</span>
<span class="nc bnc" id="L1071" title="All 2 branches missed.">                target.getTargetType() == Targetable.TYPE_HEX_AERO_BOMB) {</span>
<span class="nc" id="L1072">            return null;</span>
        }

<span class="nc bnc" id="L1075" title="All 2 branches missed.">        if (target.isImmobile()) {</span>
<span class="nc bnc" id="L1076" title="All 6 branches missed.">            if ((target instanceof Mech) &amp;&amp; (aimingAt == Mech.LOC_HEAD)</span>
                    &amp;&amp; (aimingMode == IAimingModes.AIM_MODE_IMMOBILE)) {
<span class="nc" id="L1078">                return new ToHitData(3, &quot;aiming at head&quot;);</span>
            }
<span class="nc" id="L1080">            return new ToHitData(-4, &quot;target immobile&quot;);</span>
        }
<span class="nc" id="L1082">        return null;</span>
    }

    /**
     * Determines the to-hit modifier due to range for an attack with the
     * specified parameters. Includes minimum range, infantry 0-range mods, and
     * target stealth mods. Accounts for friendly C3 units.
     *
     * @return the modifiers
     */
    public static ToHitData getRangeMods(IGame game, Entity ae, int weaponId,
                                         Targetable target) {
<span class="nc" id="L1094">        Mounted weapon = ae.getEquipment(weaponId);</span>
<span class="nc" id="L1095">        WeaponType wtype = (WeaponType) weapon.getType();</span>
<span class="nc" id="L1096">        int[] weaponRanges = wtype.getRanges(weapon);</span>
<span class="nc" id="L1097">        boolean isAttackerInfantry = (ae instanceof Infantry);</span>
<span class="nc" id="L1098">        boolean isAttackerBA = (ae instanceof BattleArmor);</span>
<span class="nc bnc" id="L1099" title="All 4 branches missed.">        boolean isWeaponInfantry = (wtype instanceof InfantryWeapon) &amp;&amp; !wtype.hasFlag(WeaponType.F_TAG);</span>
<span class="nc" id="L1100">        boolean isSwarmOrLegAttack = (wtype instanceof InfantryAttack);</span>
<span class="nc bnc" id="L1101" title="All 2 branches missed.">        boolean isIndirect = ((wtype.getAmmoType() == AmmoType.T_LRM)</span>
<span class="nc bnc" id="L1102" title="All 2 branches missed.">                || (wtype.getAmmoType() == AmmoType.T_LRM_IMP)</span>
<span class="nc bnc" id="L1103" title="All 2 branches missed.">                || (wtype.getAmmoType() == AmmoType.T_MML)</span>
<span class="nc bnc" id="L1104" title="All 2 branches missed.">                || (wtype.getAmmoType() == AmmoType.T_EXLRM)</span>
<span class="nc bnc" id="L1105" title="All 2 branches missed.">                || (wtype.getAmmoType() == AmmoType.T_TBOLT_5)</span>
<span class="nc bnc" id="L1106" title="All 2 branches missed.">                || (wtype.getAmmoType() == AmmoType.T_TBOLT_10)</span>
<span class="nc bnc" id="L1107" title="All 2 branches missed.">                || (wtype.getAmmoType() == AmmoType.T_TBOLT_15)</span>
<span class="nc bnc" id="L1108" title="All 2 branches missed.">                || (wtype.getAmmoType() == AmmoType.T_TBOLT_20)</span>
<span class="nc bnc" id="L1109" title="All 2 branches missed.">                || (wtype.getAmmoType() == AmmoType.T_IATM)</span>
<span class="nc bnc" id="L1110" title="All 2 branches missed.">                || (wtype.getAmmoType() == AmmoType.T_LRM_TORPEDO)</span>
<span class="nc bnc" id="L1111" title="All 4 branches missed.">                || (wtype.getAmmoType() == AmmoType.T_MEK_MORTAR)</span>
                || (wtype instanceof ArtilleryCannonWeapon))
<span class="nc bnc" id="L1113" title="All 2 branches missed.">                &amp;&amp; weapon.curMode().equals(&quot;Indirect&quot;);</span>
<span class="nc" id="L1114">        boolean useExtremeRange = game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_RANGE);</span>
<span class="nc" id="L1115">        boolean useLOSRange = game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_LOS_RANGE);</span>
        //Naval C3 only provides full C3 range benefits to energy weapons and guided missiles
<span class="nc bnc" id="L1117" title="All 2 branches missed.">        boolean nc3EnergyGuided = ((wtype.hasFlag(WeaponType.F_ENERGY))</span>
<span class="nc bnc" id="L1118" title="All 2 branches missed.">                || (wtype.getAtClass() == WeaponType.CLASS_CAPITAL_MISSILE)</span>
<span class="nc bnc" id="L1119" title="All 2 branches missed.">                || (wtype.getAtClass() == WeaponType.CLASS_TELE_MISSILE)</span>
<span class="nc bnc" id="L1120" title="All 2 branches missed.">                || (wtype.getAtClass() == WeaponType.CLASS_AR10)</span>
<span class="nc bnc" id="L1121" title="All 2 branches missed.">                || (wtype.getAtClass() == WeaponType.CLASS_ATM)</span>
<span class="nc bnc" id="L1122" title="All 2 branches missed.">                || (wtype.getAtClass() == WeaponType.CLASS_LRM)</span>
<span class="nc bnc" id="L1123" title="All 2 branches missed.">                || (wtype.getAtClass() == WeaponType.CLASS_SRM)</span>
<span class="nc bnc" id="L1124" title="All 2 branches missed.">                || (wtype.getAtClass() == WeaponType.CLASS_MML)</span>
<span class="nc bnc" id="L1125" title="All 2 branches missed.">                || (wtype.getAtClass() == WeaponType.CLASS_THUNDERBOLT));</span>

<span class="nc bnc" id="L1127" title="All 2 branches missed.">        if (ae.isAirborne()) {</span>
<span class="nc" id="L1128">            useExtremeRange = true;</span>
            // This is a separate SO rule, and isn't implemented yet
<span class="nc" id="L1130">            useLOSRange = false;</span>
        }

<span class="nc" id="L1133">        ToHitData mods = new ToHitData();</span>

<span class="nc" id="L1135">        Entity te = null;</span>
<span class="nc bnc" id="L1136" title="All 2 branches missed.">        if (target instanceof Entity) {</span>
<span class="nc" id="L1137">            te = (Entity) target;</span>
        }

        // We need to adjust the ranges for Centurion Weapon Systems: it's
        //  default range is 6/12/18 but that's only for units that are
        //  susceptible to CWS, for those that aren't the ranges are 1/2/3
<span class="nc bnc" id="L1143" title="All 4 branches missed.">        if (wtype.hasFlag(WeaponType.F_CWS)</span>
<span class="nc bnc" id="L1144" title="All 2 branches missed.">                &amp;&amp; ((te == null) || !te.hasQuirk(&quot;susceptible_cws&quot;))) {</span>
<span class="nc" id="L1145">            weaponRanges[RangeType.RANGE_MINIMUM] = 0;</span>
<span class="nc" id="L1146">            weaponRanges[RangeType.RANGE_SHORT] = 1;</span>
<span class="nc" id="L1147">            weaponRanges[RangeType.RANGE_MEDIUM] = 2;</span>
<span class="nc" id="L1148">            weaponRanges[RangeType.RANGE_LONG] = 3;</span>
<span class="nc" id="L1149">            weaponRanges[RangeType.RANGE_EXTREME] = 4;</span>
        }

        //
        // modifiy the ranges for PPCs when field inhibitors are turned off
        // TODO: See above, it should be coded elsewhere...
        //
<span class="nc bnc" id="L1156" title="All 2 branches missed.">        if (wtype.hasFlag(WeaponType.F_PPC)) {</span>
<span class="nc bnc" id="L1157" title="All 2 branches missed.">            if (game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_PPC_INHIBITORS)) {</span>
<span class="nc bnc" id="L1158" title="All 2 branches missed.">                if ((weapon.curMode() != null)</span>
<span class="nc bnc" id="L1159" title="All 2 branches missed.">                        &amp;&amp; weapon.curMode().equals(&quot;Field Inhibitor OFF&quot;)) {</span>
<span class="nc" id="L1160">                    weaponRanges[RangeType.RANGE_MINIMUM] = 0;</span>
                }
            }
        }

        // Hotloaded weapons
<span class="nc bnc" id="L1166" title="All 2 branches missed.">        if (weapon.isHotLoaded()</span>
<span class="nc bnc" id="L1167" title="All 2 branches missed.">                &amp;&amp; game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_HOTLOAD)) {</span>
<span class="nc" id="L1168">            weaponRanges[RangeType.RANGE_MINIMUM] = 0;</span>
        }

        // is water involved?
<span class="nc" id="L1172">        IHex targHex = game.getBoard().getHex(target.getPosition());</span>
<span class="nc" id="L1173">        int targTop = target.relHeight();</span>
<span class="nc" id="L1174">        int targBottom = target.getElevation();</span>

<span class="nc" id="L1176">        boolean targetInPartialWater = false;</span>
<span class="nc" id="L1177">        boolean targetUnderwater = false;</span>
<span class="nc bnc" id="L1178" title="All 2 branches missed.">        boolean weaponUnderwater = (ae.getLocationStatus(weapon.getLocation()) == ILocationExposureStatus.WET);</span>
<span class="nc bnc" id="L1179" title="All 4 branches missed.">        if ((target.getTargetType() == Targetable.TYPE_ENTITY)</span>
<span class="nc bnc" id="L1180" title="All 4 branches missed.">                &amp;&amp; (targHex != null) &amp;&amp; targHex.containsTerrain(Terrains.WATER)</span>
                &amp;&amp; (targBottom &lt; 0)) {

<span class="nc bnc" id="L1183" title="All 2 branches missed.">            if (targTop &gt;= 0) {</span>
<span class="nc" id="L1184">                targetInPartialWater = true;</span>
            } else {
<span class="nc" id="L1186">                targetUnderwater = true;</span>
            }
        }

        // allow naval units on surface to be attacked from above or below
<span class="nc bnc" id="L1191" title="All 4 branches missed.">        if ((null != te) &amp;&amp; (targBottom == 0)</span>
<span class="nc bnc" id="L1192" title="All 2 branches missed.">                &amp;&amp; (te.getUnitType() == UnitType.NAVAL)) {</span>
<span class="nc" id="L1193">            targetInPartialWater = true;</span>
        }

        // allow naval units to target underwater units,
        // torpedo tubes are mounted underwater
<span class="nc bnc" id="L1198" title="All 2 branches missed.">        if ((targetUnderwater</span>
<span class="nc bnc" id="L1199" title="All 2 branches missed.">                || (wtype.getAmmoType() == AmmoType.T_LRM_TORPEDO) || (wtype</span>
<span class="nc bnc" id="L1200" title="All 2 branches missed.">                .getAmmoType() == AmmoType.T_SRM_TORPEDO))</span>
<span class="nc bnc" id="L1201" title="All 2 branches missed.">                &amp;&amp; (ae.getUnitType() == UnitType.NAVAL)) {</span>
<span class="nc" id="L1202">            weaponUnderwater = true;</span>
<span class="nc" id="L1203">            weaponRanges = wtype.getWRanges();</span>
        }

        // allow ice to be cleared from below
<span class="nc bnc" id="L1207" title="All 4 branches missed.">        if ((targHex != null) &amp;&amp; targHex.containsTerrain(Terrains.WATER)</span>
<span class="nc bnc" id="L1208" title="All 2 branches missed.">                &amp;&amp; (target.getTargetType() == Targetable.TYPE_HEX_CLEAR)) {</span>
<span class="nc" id="L1209">            targetInPartialWater = true;</span>
        }

<span class="nc bnc" id="L1212" title="All 2 branches missed.">        if (weaponUnderwater) {</span>
<span class="nc" id="L1213">            weaponRanges = wtype.getWRanges();</span>
<span class="nc" id="L1214">            boolean MPM = false;</span>
<span class="nc bnc" id="L1215" title="All 2 branches missed.">            if ((wtype.getAmmoType() == AmmoType.T_SRM)</span>
<span class="nc bnc" id="L1216" title="All 2 branches missed.">                    || (wtype.getAmmoType() == AmmoType.T_SRM_IMP)</span>
<span class="nc bnc" id="L1217" title="All 2 branches missed.">                    || (wtype.getAmmoType() == AmmoType.T_MRM)</span>
<span class="nc bnc" id="L1218" title="All 2 branches missed.">                    || (wtype.getAmmoType() == AmmoType.T_LRM)</span>
<span class="nc bnc" id="L1219" title="All 2 branches missed.">                    || (wtype.getAmmoType() == AmmoType.T_LRM_IMP)</span>
<span class="nc bnc" id="L1220" title="All 2 branches missed.">                    || (wtype.getAmmoType() == AmmoType.T_MML)) {</span>
<span class="nc" id="L1221">                AmmoType atype = (AmmoType) weapon.getLinked().getType();</span>
<span class="nc bnc" id="L1222" title="All 2 branches missed.">                if (atype.getMunitionType() == AmmoType.M_TORPEDO) {</span>
<span class="nc" id="L1223">                    weaponRanges = wtype.getRanges(weapon);</span>
<span class="nc bnc" id="L1224" title="All 2 branches missed.">                } else if (atype.getMunitionType() == AmmoType.M_MULTI_PURPOSE) {</span>
<span class="nc" id="L1225">                    weaponRanges = wtype.getRanges(weapon);</span>
<span class="nc" id="L1226">                    MPM = true;</span>
                }
            }

            // HACK on ranges: for those without underwater range,
            // long == medium; iteration in rangeBracket() allows this
<span class="nc bnc" id="L1232" title="All 2 branches missed.">            if (weaponRanges[RangeType.RANGE_SHORT] == 0) {</span>
<span class="nc" id="L1233">                return new ToHitData(TargetRoll.IMPOSSIBLE,</span>
                        &quot;Weapon cannot fire underwater.&quot;);
            }
<span class="nc bnc" id="L1236" title="All 6 branches missed.">            if (!targetUnderwater &amp;&amp; !targetInPartialWater &amp;&amp; !MPM) {</span>
                // target on land or over water
<span class="nc" id="L1238">                return new ToHitData(TargetRoll.IMPOSSIBLE,</span>
                        &quot;Weapon underwater, but not target.&quot;);
            }
            // special case: mechs can only fire upper body weapons at surface
            // naval
<span class="nc bnc" id="L1243" title="All 2 branches missed.">            if ((te != null)</span>
<span class="nc bnc" id="L1244" title="All 4 branches missed.">                    &amp;&amp; (te.getUnitType() == UnitType.NAVAL)</span>
<span class="nc bnc" id="L1245" title="All 2 branches missed.">                    &amp;&amp; (ae instanceof Mech) &amp;&amp; (ae.height() &gt; 0)</span>
<span class="nc bnc" id="L1246" title="All 2 branches missed.">                    &amp;&amp; (ae.getElevation() == -1)) {</span>
<span class="nc" id="L1247">                return new ToHitData(TargetRoll.IMPOSSIBLE,</span>
                        &quot;Partially submerged mech cannot fire leg weapons at surface naval vessels.&quot;);
            }
<span class="nc bnc" id="L1250" title="All 2 branches missed.">        } else if (targetUnderwater) {</span>
<span class="nc" id="L1251">            return new ToHitData(TargetRoll.IMPOSSIBLE,</span>
                    &quot;Target underwater, but not weapon.&quot;);
<span class="nc bnc" id="L1253" title="All 2 branches missed.">        } else if ((wtype.getAmmoType() == AmmoType.T_LRM_TORPEDO)</span>
<span class="nc bnc" id="L1254" title="All 2 branches missed.">                || (wtype.getAmmoType() == AmmoType.T_SRM_TORPEDO)) {</span>
            // Torpedos only fire underwater.
<span class="nc" id="L1256">            return new ToHitData(TargetRoll.IMPOSSIBLE,</span>
                    &quot;Weapon can only fire underwater.&quot;);
        }

        // if Aero then adjust to standard ranges
<span class="nc bnc" id="L1261" title="All 4 branches missed.">        if (ae.isAero() &amp;&amp; (ae.isAirborne()</span>
<span class="nc bnc" id="L1262" title="All 4 branches missed.">                || (ae.usesWeaponBays() &amp;&amp; game.getBoard().onGround()))) {</span>
<span class="nc" id="L1263">            weaponRanges = wtype.getATRanges();</span>
        }
        // And if you're using bearings-only capital missiles, update the extreme range
<span class="nc bnc" id="L1266" title="All 2 branches missed.">        if (weapon.isInBearingsOnlyMode()) {</span>
<span class="nc" id="L1267">            weaponRanges = new int[]{Integer.MIN_VALUE, 12, 24, 40, RangeType.RANGE_BEARINGS_ONLY_OUT};</span>
        }

        // determine base distance &amp; range bracket
<span class="nc" id="L1271">        int distance = Compute.effectiveDistance(game, ae, target, false);</span>
<span class="nc" id="L1272">        int range = RangeType.rangeBracket(distance, weaponRanges,</span>
                useExtremeRange, useLOSRange);

        // Additional checks for LOS range and some weapon types, TO 85
<span class="nc bnc" id="L1276" title="All 2 branches missed.">        if (range == RangeType.RANGE_LOS) {</span>
            // Swarm or leg attacks can't use LoS range
<span class="nc bnc" id="L1278" title="All 2 branches missed.">            if (isSwarmOrLegAttack) {</span>
<span class="nc" id="L1279">                range = RangeType.RANGE_OUT;</span>
            }

            // MGs lack range for LOS Range, but don't have F_DIRECT_FIRE flag
<span class="nc bnc" id="L1283" title="All 2 branches missed.">            if (wtype instanceof MGWeapon) {</span>
<span class="nc" id="L1284">                range = RangeType.RANGE_OUT;</span>
            }

            // AMS lack range for LOS Range, but don't have F_DIRECT_FIRE flag
<span class="nc bnc" id="L1288" title="All 2 branches missed.">            if (wtype.hasFlag(WeaponType.F_AMS)) {</span>
<span class="nc" id="L1289">                range = RangeType.RANGE_OUT;</span>
            }

            // Flamers lack range for LOS Range, but don't have F_DIRECT_FIRE
<span class="nc bnc" id="L1293" title="All 2 branches missed.">            if (wtype.hasFlag(WeaponType.F_FLAMER)) {</span>
<span class="nc" id="L1294">                range = RangeType.RANGE_OUT;</span>
            }

<span class="nc" id="L1297">            int longRange = wtype.getRanges(weapon)[RangeType.RANGE_LONG];</span>
            // No Missiles or Direct Fire Ballistics with range &lt; 13
<span class="nc bnc" id="L1299" title="All 2 branches missed.">            if (wtype.hasFlag(WeaponType.F_MISSILE)</span>
<span class="nc bnc" id="L1300" title="All 2 branches missed.">                    || (wtype.hasFlag(WeaponType.F_DIRECT_FIRE)</span>
<span class="nc bnc" id="L1301" title="All 2 branches missed.">                    &amp;&amp; wtype.hasFlag(WeaponType.F_BALLISTIC))) {</span>
<span class="nc bnc" id="L1302" title="All 2 branches missed.">                if (longRange &lt; 13) {</span>
<span class="nc" id="L1303">                    range = RangeType.RANGE_OUT;</span>
                }
            }
            // No Direct Fire Energy or Pulse with range &lt; 7
<span class="nc bnc" id="L1307" title="All 2 branches missed.">            if (wtype.hasFlag(WeaponType.F_PULSE)</span>
<span class="nc bnc" id="L1308" title="All 2 branches missed.">                    || (wtype.hasFlag(WeaponType.F_ENERGY)</span>
<span class="nc bnc" id="L1309" title="All 2 branches missed.">                    &amp;&amp; wtype.hasFlag(WeaponType.F_DIRECT_FIRE))) {</span>
<span class="nc bnc" id="L1310" title="All 2 branches missed.">                if (longRange &lt; 7) {</span>
<span class="nc" id="L1311">                    range = RangeType.RANGE_OUT;</span>
                }
            }
        }
<span class="nc" id="L1315">        int maxRange = wtype.getMaxRange(weapon);</span>

        // if aero and greater than max range then swith to range_out
<span class="nc bnc" id="L1318" title="All 4 branches missed.">        if ((ae.isAirborne() || (ae.usesWeaponBays() &amp;&amp; game.getBoard()</span>
<span class="nc bnc" id="L1319" title="All 4 branches missed.">                .onGround())) &amp;&amp; (range &gt; maxRange)) {</span>
<span class="nc" id="L1320">            range = RangeType.RANGE_OUT;</span>
        }

        // Swarm/Leg attacks need to  be impossible, not auto-fail, so that the
        // attack can't even be attempted
<span class="nc bnc" id="L1325" title="All 4 branches missed.">        if (isSwarmOrLegAttack &amp;&amp; (distance &gt; 0)) {</span>
<span class="nc" id="L1326">            return new ToHitData(TargetRoll.IMPOSSIBLE,</span>
                    &quot;Swarm/Leg attacks can &quot;
                            + &quot;only target units in the same hex!&quot;);
        }
        // short circuit if at zero range or out of range
<span class="nc bnc" id="L1331" title="All 4 branches missed.">        if ((range == RangeType.RANGE_OUT) &amp;&amp; !isWeaponInfantry) {</span>
<span class="nc" id="L1332">            return new ToHitData(TargetRoll.AUTOMATIC_FAIL,</span>
                    &quot;Target out of range&quot;);
        }

        // Infantry with infantry weapons (rifles, etc, i.e. not field pieces)
        //  and BattleArmor can fire at zero range, among other things
<span class="nc bnc" id="L1338" title="All 10 branches missed.">        if ((distance == 0)</span>
                &amp;&amp; (!isAttackerInfantry ||
                !(isWeaponInfantry || isSwarmOrLegAttack
                        || isAttackerBA))
<span class="nc bnc" id="L1342" title="All 2 branches missed.">                &amp;&amp; !(ae.isAirborne())</span>
<span class="nc bnc" id="L1343" title="All 6 branches missed.">                &amp;&amp; !(ae.isBomber() &amp;&amp; ((IBomber) ae).isVTOLBombing())</span>
<span class="nc bnc" id="L1344" title="All 2 branches missed.">                &amp;&amp; !((ae instanceof Dropship) &amp;&amp; ((Dropship) ae).isSpheroid()</span>
<span class="nc bnc" id="L1345" title="All 6 branches missed.">                &amp;&amp; !ae.isAirborne() &amp;&amp; !ae.isSpaceborne())</span>
<span class="nc" id="L1346">                &amp;&amp; !((ae instanceof Mech) &amp;&amp; (((Mech) ae).getGrappled() == target</span>
<span class="nc bnc" id="L1347" title="All 2 branches missed.">                .getTargetId()))) {</span>
<span class="nc" id="L1348">            return new ToHitData(TargetRoll.AUTOMATIC_FAIL,</span>
                    &quot;Only infantry weapons shoot at zero range&quot;);
        }

        // Account for &quot;dead zones&quot; between Aeros at different altitudes
<span class="nc bnc" id="L1353" title="All 4 branches missed.">        if (!Compute.useSpheroidAtmosphere(game, ae) &amp;&amp; Compute.inDeadZone(game, ae, target)) {</span>
<span class="nc" id="L1354">            return new ToHitData(TargetRoll.IMPOSSIBLE, &quot;Target in dead zone&quot;);</span>
        }

        // find any c3 spotters that could help
<span class="nc" id="L1358">        Entity c3spotter = Compute.findC3Spotter(game, ae, target);</span>
<span class="nc bnc" id="L1359" title="All 2 branches missed.">        if (isIndirect) {</span>
<span class="nc" id="L1360">            c3spotter = ae; // no c3 when using indirect fire</span>
        }
<span class="nc bnc" id="L1362" title="All 2 branches missed.">        if (isIndirect</span>
<span class="nc bnc" id="L1363" title="All 2 branches missed.">                &amp;&amp; game.getOptions().booleanOption(OptionsConstants.BASE_INDIRECT_FIRE)</span>
<span class="nc bnc" id="L1364" title="All 2 branches missed.">                &amp;&amp; !game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_INDIRECT_ALWAYS_POSSIBLE)</span>
<span class="nc bnc" id="L1365" title="All 2 branches missed.">                &amp;&amp; LosEffects.calculateLos(game, ae.getId(), target).canSee()</span>
<span class="nc bnc" id="L1366" title="All 2 branches missed.">                &amp;&amp; (!game.getOptions().booleanOption(OptionsConstants.ADVANCED_DOUBLE_BLIND) || Compute</span>
<span class="nc bnc" id="L1367" title="All 4 branches missed.">                .canSee(game, ae, target))</span>
                &amp;&amp; !(wtype instanceof MekMortarWeapon)) {
<span class="nc" id="L1369">            return new ToHitData(TargetRoll.IMPOSSIBLE,</span>
                    &quot;Indirect fire impossible with direct LOS&quot;);
        }

<span class="nc" id="L1373">        int c3dist = Compute.effectiveDistance(game, c3spotter, target, false);</span>
        // C3 can't benefit from LOS range
<span class="nc" id="L1375">        int c3range = RangeType.rangeBracket(c3dist, weaponRanges,</span>
                useExtremeRange, false);

        /*
         * Tac Ops Extreme Range Rule p. 85 if the weapons normal range is
         * Extreme then C3 uses the next highest range bracket, i.e. medium
         * instead of short.
         */
<span class="nc bnc" id="L1383" title="All 4 branches missed.">        if ((range == RangeType.RANGE_EXTREME) &amp;&amp; (c3range &lt; range)) {</span>
<span class="nc" id="L1384">            c3range++;</span>
        }

        // determine which range we're using
<span class="nc" id="L1388">        int usingRange = Math.min(range, c3range);</span>

        // add range modifier, C3 can't be used with LOS Range
<span class="nc bnc" id="L1391" title="All 8 branches missed.">        if ((usingRange == range) || (range == RangeType.RANGE_LOS) || (ae.hasNavalC3() &amp;&amp; !nc3EnergyGuided)) {</span>
            // Ensure usingRange is set to range, ie with C3
<span class="nc" id="L1393">            usingRange = range;</span>
            // Naval C3 adjustment for ballistic and unguided weapons
<span class="nc bnc" id="L1395" title="All 6 branches missed.">            if ((ae.hasNavalC3() &amp;&amp; !nc3EnergyGuided) &amp;&amp; (c3range &lt; range)) {</span>
<span class="nc bnc" id="L1396" title="All 4 branches missed.">                if (((range == RangeType.RANGE_SHORT) || (range == RangeType.RANGE_MINIMUM))</span>
<span class="nc bnc" id="L1397" title="All 2 branches missed.">                        &amp;&amp; (ae.getShortRangeModifier() != 0)) {</span>
<span class="nc" id="L1398">                    mods.addModifier((ae.getShortRangeModifier() / 2), &quot;NC3 modified short range&quot;);</span>
<span class="nc bnc" id="L1399" title="All 2 branches missed.">                } else if (range == RangeType.RANGE_MEDIUM) {</span>
<span class="nc" id="L1400">                    mods.addModifier((ae.getMediumRangeModifier() / 2), &quot;NC3 modified medium range&quot;);</span>
<span class="nc bnc" id="L1401" title="All 2 branches missed.">                } else if (range == RangeType.RANGE_LONG) {</span>
<span class="nc" id="L1402">                    mods.addModifier((ae.getLongRangeModifier() / 2), &quot;NC3 modified long range&quot;);</span>
<span class="nc bnc" id="L1403" title="All 2 branches missed.">                } else if (range == RangeType.RANGE_EXTREME) {</span>
<span class="nc" id="L1404">                    mods.addModifier((ae.getExtremeRangeModifier() / 2), &quot;NC3 modified Extreme range&quot;);</span>
                }
            } else {
                // no c3 adjustment
<span class="nc bnc" id="L1408" title="All 4 branches missed.">                if (((range == RangeType.RANGE_SHORT) || (range == RangeType.RANGE_MINIMUM))</span>
<span class="nc bnc" id="L1409" title="All 2 branches missed.">                        &amp;&amp; (ae.getShortRangeModifier() != 0)) {</span>
<span class="nc" id="L1410">                    mods.addModifier(ae.getShortRangeModifier(), &quot;short range&quot;);</span>
<span class="nc bnc" id="L1411" title="All 2 branches missed.">                } else if (range == RangeType.RANGE_MEDIUM) {</span>
                    // Right now, the range-mod affecting targeting systems DON'T
                    // affect medium range, so we won't add that here ever.
<span class="nc" id="L1414">                    mods.addModifier(ae.getMediumRangeModifier(), &quot;medium range&quot;);</span>
<span class="nc bnc" id="L1415" title="All 2 branches missed.">                } else if (range == RangeType.RANGE_LONG) {</span>
                    // Protos that loose head sensors can't shoot long range.
<span class="nc bnc" id="L1417" title="All 2 branches missed.">                    if ((ae instanceof Protomech)</span>
                            &amp;&amp; (2 == ((Protomech) ae)
<span class="nc bnc" id="L1419" title="All 2 branches missed.">                            .getCritsHit(Protomech.LOC_HEAD))) {</span>
<span class="nc" id="L1420">                        mods.addModifier(TargetRoll.IMPOSSIBLE,</span>
                                &quot;No long range attacks with destroyed head sensors.&quot;);
                    } else {
<span class="nc" id="L1423">                        mods.addModifier(ae.getLongRangeModifier(), &quot;long range&quot;);</span>
                    }
<span class="nc bnc" id="L1425" title="All 2 branches missed.">                } else if (range == RangeType.RANGE_EXTREME) {</span>
                    // Protos that loose head sensors can't shoot extreme range.
<span class="nc bnc" id="L1427" title="All 2 branches missed.">                    if ((ae instanceof Protomech)</span>
                            &amp;&amp; (2 == ((Protomech) ae)
<span class="nc bnc" id="L1429" title="All 2 branches missed.">                            .getCritsHit(Protomech.LOC_HEAD))) {</span>
<span class="nc" id="L1430">                        mods.addModifier(TargetRoll.IMPOSSIBLE,</span>
                                &quot;No extreme range attacks with destroyed head sensors.&quot;);
                    } else {
<span class="nc" id="L1433">                        mods.addModifier(ae.getExtremeRangeModifier(),</span>
                                &quot;extreme range&quot;);
                    }
<span class="nc bnc" id="L1436" title="All 2 branches missed.">                } else if (range == RangeType.RANGE_LOS) {</span>
                    // Protos that loose head sensors can't shoot LOS range.
<span class="nc bnc" id="L1438" title="All 2 branches missed.">                    if ((ae instanceof Protomech)</span>
                            &amp;&amp; (2 == ((Protomech) ae)
<span class="nc bnc" id="L1440" title="All 2 branches missed.">                            .getCritsHit(Protomech.LOC_HEAD))) {</span>
<span class="nc" id="L1441">                        mods.addModifier(TargetRoll.IMPOSSIBLE,</span>
                                &quot;No LOS range attacks with destroyed head sensors.&quot;);
                    } else {
<span class="nc" id="L1444">                        mods.addModifier(ae.getLOSRangeModifier(),</span>
                                &quot;LOS range&quot;);
                    }
                }
            }
        } else {
            // report c3 adjustment
<span class="nc bnc" id="L1451" title="All 4 branches missed.">            if ((c3range == RangeType.RANGE_SHORT)</span>
                    || (c3range == RangeType.RANGE_MINIMUM)) {
<span class="nc" id="L1453">                mods.addModifier(ae.getShortRangeModifier(),</span>
                        &quot;short range due to C3 spotter&quot;);
<span class="nc bnc" id="L1455" title="All 2 branches missed.">            } else if (c3range == RangeType.RANGE_MEDIUM) {</span>
<span class="nc" id="L1456">                mods.addModifier(ae.getMediumRangeModifier(),</span>
                        &quot;medium range due to C3 spotter&quot;);
<span class="nc bnc" id="L1458" title="All 2 branches missed.">            } else if (c3range == RangeType.RANGE_LONG) {</span>
<span class="nc" id="L1459">                mods.addModifier(ae.getLongRangeModifier(),</span>
                        &quot;long range due to C3 spotter&quot;);
            }
        }

        // add minimum range modifier (only for ground-to-ground attacks)
<span class="nc" id="L1465">        int minRange = weaponRanges[RangeType.RANGE_MINIMUM];</span>
<span class="nc bnc" id="L1466" title="All 4 branches missed.">        if ((minRange &gt; 0) &amp;&amp; (distance &lt;= minRange)</span>
<span class="nc bnc" id="L1467" title="All 2 branches missed.">                &amp;&amp; Compute.isGroundToGround(ae, target)) {</span>
<span class="nc" id="L1468">            int minPenalty = (minRange - distance) + 1;</span>
<span class="nc" id="L1469">            mods.addModifier(minPenalty, &quot;minimum range&quot;);</span>
        }

        // if this is an infantry weapon then we use a whole different
        // calculation
        // to figure out range, so overwrite whatever we have at this point
<span class="nc bnc" id="L1475" title="All 2 branches missed.">        if (isWeaponInfantry) {</span>
<span class="nc" id="L1476">            mods = Compute.getInfantryRangeMods(Math.min(distance, c3dist),</span>
                    (InfantryWeapon) wtype,
<span class="nc bnc" id="L1478" title="All 2 branches missed.">                    (ae instanceof Infantry) ? ((Infantry) ae).getSecondaryWeapon() : null,</span>
                    weaponUnderwater);

<span class="nc" id="L1481">            int rangeModifier = mods.getValue();</span>
<span class="nc bnc" id="L1482" title="All 2 branches missed.">            if (rangeModifier == TargetRoll.AUTOMATIC_FAIL) {</span>
<span class="nc" id="L1483">                usingRange = RangeType.RANGE_OUT;</span>
<span class="nc bnc" id="L1484" title="All 2 branches missed.">            } else if (rangeModifier == 0) {</span>
<span class="nc" id="L1485">                usingRange = RangeType.RANGE_SHORT;</span>
<span class="nc bnc" id="L1486" title="All 2 branches missed.">            } else if (rangeModifier &lt;= 2) {</span>
<span class="nc" id="L1487">                usingRange = RangeType.RANGE_MEDIUM;</span>
<span class="nc bnc" id="L1488" title="All 2 branches missed.">            } else if (rangeModifier &lt;= 4) {</span>
<span class="nc" id="L1489">                usingRange = RangeType.RANGE_LONG;</span>
            } else {
<span class="nc" id="L1491">                usingRange = RangeType.RANGE_EXTREME;</span>
            }
        }

        // add any target stealth modifier
<span class="nc bnc" id="L1496" title="All 2 branches missed.">        if (target instanceof Entity) {</span>
<span class="nc" id="L1497">            TargetRoll tmpTR = ((Entity) target).getStealthModifier(usingRange,</span>
                    ae);
<span class="nc bnc" id="L1499" title="All 4 branches missed.">            if ((tmpTR != null) &amp;&amp; (tmpTR.getValue() != 0)) {</span>
<span class="nc" id="L1500">                mods.append(((Entity) target)</span>
<span class="nc" id="L1501">                        .getStealthModifier(usingRange, ae));</span>
            }
        }

<span class="nc" id="L1505">        return mods;</span>
    }

    /**
     * Calculate the range modifiers for a conventional infantry attack.
     *
     * @param distance   - range to target
     * @param wpn        - the weapon used to calculate range -- secondary if 2/squad, otherwise primary
     * @param secondary  - the secondary weapon, if any. Range zero penalties apply even if primary is used for range
     * @param underwater - underwater range is half, rounded down
     * @return - all modifiers for range
     */
    public static ToHitData getInfantryRangeMods(int distance, InfantryWeapon wpn,
                                                 InfantryWeapon secondary, boolean underwater) {
<span class="nc" id="L1519">        ToHitData mods = new ToHitData();</span>
<span class="nc" id="L1520">        int range = wpn.getInfantryRange();</span>
<span class="nc bnc" id="L1521" title="All 2 branches missed.">        if (underwater) {</span>
<span class="nc" id="L1522">            range /= 2;</span>
        }
<span class="nc" id="L1524">        int mod = 0;</span>

<span class="nc bnc" id="L1526" title="All 9 branches missed.">        switch (range) {</span>
            case 0:
<span class="nc bnc" id="L1528" title="All 2 branches missed.">                if (distance &gt; 0) {</span>
<span class="nc" id="L1529">                    return new ToHitData(TargetRoll.AUTOMATIC_FAIL,</span>
                            &quot;Target out of range&quot;);
<span class="nc bnc" id="L1531" title="All 2 branches missed.">                } else if (distance == 0) {</span>
<span class="nc" id="L1532">                    mod = 0;</span>
                }
                break;
            case 1:
<span class="nc bnc" id="L1536" title="All 2 branches missed.">                if (distance &gt; 3) {</span>
<span class="nc" id="L1537">                    return new ToHitData(TargetRoll.AUTOMATIC_FAIL,</span>
                            &quot;Target out of range&quot;);
<span class="nc bnc" id="L1539" title="All 2 branches missed.">                } else if (distance == 0) {</span>
<span class="nc" id="L1540">                    mod = -2;</span>
<span class="nc bnc" id="L1541" title="All 2 branches missed.">                } else if (distance == 2) {</span>
<span class="nc" id="L1542">                    mod = 2;</span>
<span class="nc bnc" id="L1543" title="All 2 branches missed.">                } else if (distance == 3) {</span>
<span class="nc" id="L1544">                    mod = 4;</span>
                }
                break;
            case 2:
<span class="nc bnc" id="L1548" title="All 2 branches missed.">                if (distance &gt; 6) {</span>
<span class="nc" id="L1549">                    return new ToHitData(TargetRoll.AUTOMATIC_FAIL,</span>
                            &quot;Target out of range&quot;);
<span class="nc bnc" id="L1551" title="All 2 branches missed.">                } else if (distance &gt; 4) {</span>
<span class="nc" id="L1552">                    mod = 4;</span>
<span class="nc bnc" id="L1553" title="All 2 branches missed.">                } else if (distance &gt; 2) {</span>
<span class="nc" id="L1554">                    mod = 2;</span>
<span class="nc bnc" id="L1555" title="All 2 branches missed.">                } else if (distance == 0) {</span>
<span class="nc" id="L1556">                    mod = -2;</span>
                }
                break;
            case 3:
<span class="nc bnc" id="L1560" title="All 2 branches missed.">                if (distance &gt; 9) {</span>
<span class="nc" id="L1561">                    return new ToHitData(TargetRoll.AUTOMATIC_FAIL,</span>
                            &quot;Target out of range&quot;);
<span class="nc bnc" id="L1563" title="All 2 branches missed.">                } else if (distance &gt; 6) {</span>
<span class="nc" id="L1564">                    mod = 4;</span>
<span class="nc bnc" id="L1565" title="All 2 branches missed.">                } else if (distance &gt; 3) {</span>
<span class="nc" id="L1566">                    mod = 2;</span>
<span class="nc bnc" id="L1567" title="All 2 branches missed.">                } else if (distance == 0) {</span>
<span class="nc" id="L1568">                    mod = -2;</span>
                }
                break;
            case 4:
<span class="nc bnc" id="L1572" title="All 2 branches missed.">                if (distance &gt; 12) {</span>
<span class="nc" id="L1573">                    return new ToHitData(TargetRoll.AUTOMATIC_FAIL,</span>
                            &quot;Target out of range&quot;);
<span class="nc bnc" id="L1575" title="All 2 branches missed.">                } else if (distance &gt; 10) {</span>
<span class="nc" id="L1576">                    mod = 4;</span>
<span class="nc bnc" id="L1577" title="All 2 branches missed.">                } else if (distance &gt; 8) {</span>
<span class="nc" id="L1578">                    mod = 3;</span>
<span class="nc bnc" id="L1579" title="All 2 branches missed.">                } else if (distance &gt; 6) {</span>
<span class="nc" id="L1580">                    mod = 2;</span>
<span class="nc bnc" id="L1581" title="All 2 branches missed.">                } else if (distance &gt; 4) {</span>
<span class="nc" id="L1582">                    mod = 1;</span>
<span class="nc bnc" id="L1583" title="All 2 branches missed.">                } else if (distance == 0) {</span>
<span class="nc" id="L1584">                    mod = -2;</span>
                }
                break;
            case 5:
<span class="nc bnc" id="L1588" title="All 2 branches missed.">                if (distance &gt; 15) {</span>
<span class="nc" id="L1589">                    return new ToHitData(TargetRoll.AUTOMATIC_FAIL,</span>
                            &quot;Target out of range&quot;);
<span class="nc bnc" id="L1591" title="All 2 branches missed.">                } else if (distance &gt; 12) {</span>
<span class="nc" id="L1592">                    mod = 4;</span>
<span class="nc bnc" id="L1593" title="All 2 branches missed.">                } else if (distance &gt; 10) {</span>
<span class="nc" id="L1594">                    mod = 3;</span>
<span class="nc bnc" id="L1595" title="All 2 branches missed.">                } else if (distance &gt; 7) {</span>
<span class="nc" id="L1596">                    mod = 2;</span>
<span class="nc bnc" id="L1597" title="All 2 branches missed.">                } else if (distance &gt; 5) {</span>
<span class="nc" id="L1598">                    mod = 1;</span>
<span class="nc bnc" id="L1599" title="All 2 branches missed.">                } else if (distance == 0) {</span>
<span class="nc" id="L1600">                    mod = -1;</span>
                }
                break;
            case 6:
<span class="nc bnc" id="L1604" title="All 2 branches missed.">                if (distance &gt; 18) {</span>
<span class="nc" id="L1605">                    return new ToHitData(TargetRoll.AUTOMATIC_FAIL,</span>
                            &quot;Target out of range&quot;);
<span class="nc bnc" id="L1607" title="All 2 branches missed.">                } else if (distance &gt; 15) {</span>
<span class="nc" id="L1608">                    mod = 5;</span>
<span class="nc bnc" id="L1609" title="All 2 branches missed.">                } else if (distance &gt; 12) {</span>
<span class="nc" id="L1610">                    mod = 4;</span>
<span class="nc bnc" id="L1611" title="All 2 branches missed.">                } else if (distance &gt; 9) {</span>
<span class="nc" id="L1612">                    mod = 2;</span>
<span class="nc bnc" id="L1613" title="All 2 branches missed.">                } else if (distance &gt; 6) {</span>
<span class="nc" id="L1614">                    mod = 1;</span>
<span class="nc bnc" id="L1615" title="All 2 branches missed.">                } else if (distance == 0) {</span>
<span class="nc" id="L1616">                    mod = -1;</span>
                }
                break;
            case 7:
<span class="nc bnc" id="L1620" title="All 2 branches missed.">                if (distance &gt; 21) {</span>
<span class="nc" id="L1621">                    return new ToHitData(TargetRoll.AUTOMATIC_FAIL,</span>
                            &quot;Target out of range&quot;);
<span class="nc bnc" id="L1623" title="All 2 branches missed.">                } else if (distance &gt; 17) {</span>
<span class="nc" id="L1624">                    mod = 6;</span>
<span class="nc bnc" id="L1625" title="All 2 branches missed.">                } else if (distance &gt; 14) {</span>
<span class="nc" id="L1626">                    mod = 4;</span>
<span class="nc bnc" id="L1627" title="All 2 branches missed.">                } else if (distance &gt; 10) {</span>
<span class="nc" id="L1628">                    mod = 2;</span>
<span class="nc bnc" id="L1629" title="All 2 branches missed.">                } else if (distance &gt; 7) {</span>
<span class="nc" id="L1630">                    mod = 1;</span>
<span class="nc bnc" id="L1631" title="All 2 branches missed.">                } else if (distance == 0) {</span>
<span class="nc" id="L1632">                    mod = -1;</span>
                }
                break;
            default:
<span class="nc" id="L1636">                return new ToHitData(TargetRoll.AUTOMATIC_FAIL,</span>
                        &quot;Target out of range&quot;);
        }

        // a bunch of special conditions at range 0
        // penalties due to point blank or encumbering apply for secondary weapon even if
        // primary is used to determine range
<span class="nc bnc" id="L1643" title="All 2 branches missed.">        if (distance == 0) {</span>

<span class="nc bnc" id="L1645" title="All 4 branches missed.">            if (wpn.hasFlag(WeaponType.F_INF_POINT_BLANK)</span>
<span class="nc bnc" id="L1646" title="All 2 branches missed.">                    || (secondary != null &amp;&amp; secondary.hasFlag(WeaponType.F_INF_POINT_BLANK))) {</span>
<span class="nc" id="L1647">                mods.addModifier(1, &quot;point blank weapon&quot;);</span>
            }
<span class="nc bnc" id="L1649" title="All 6 branches missed.">            if (wpn.hasFlag(WeaponType.F_INF_ENCUMBER) || (wpn.getCrew() &gt; 1)</span>
                    || (secondary != null
<span class="nc bnc" id="L1651" title="All 2 branches missed.">                    &amp;&amp; (secondary.hasFlag(WeaponType.F_INF_ENCUMBER)</span>
<span class="nc bnc" id="L1652" title="All 2 branches missed.">                    || secondary.getCrew() &gt; 1))) {</span>
<span class="nc" id="L1653">                mods.addModifier(1, &quot;point blank support weapon&quot;);</span>
            }

<span class="nc bnc" id="L1656" title="All 2 branches missed.">            if (wpn.hasFlag(WeaponType.F_INF_BURST)) {</span>
<span class="nc" id="L1657">                mods.addModifier(-1, &quot;point blank burst fire weapon&quot;);</span>
            }
        }

        // TODO: we need to adjust for stealth modifiers for Chameleon LPS but
        // we don't have range brackets
        // http://bg.battletech.com/forums/index.php/topic,27433.new.html#new

<span class="nc bnc" id="L1665" title="All 2 branches missed.">        if (mod != 0) {</span>
<span class="nc" id="L1666">            mods.addModifier(mod, &quot;infantry range&quot;);</span>
        }

<span class="nc" id="L1669">        return mods;</span>
    }

    /**
     * Finds the effective distance between an attacker and a target. Includes
     * the distance bonus if the attacker and target are in the same building
     * and on different levels. Also takes account of altitude differences
     *
     * @return the effective distance
     */
    public static int effectiveDistance(IGame game, Entity attacker, Targetable target) {
<span class="nc" id="L1680">        return Compute.effectiveDistance(game, attacker, target, false);</span>
    }

    /**
     * Finds the effective distance between an attacker and a target. Includes
     * the distance bonus if the attacker and target are in the same building
     * and on different levels. Also takes account of altitude differences
     *
     * @return the effective distance
     */
    public static int effectiveDistance(IGame game, Entity attacker, Targetable target,
                                        boolean useGroundDistance) {
<span class="nc bnc" id="L1692" title="All 2 branches missed.">        if (Compute.isAirToGround(attacker, target)</span>
<span class="nc bnc" id="L1693" title="All 4 branches missed.">                || (attacker.isBomber() &amp;&amp; target.getTargetType() == Targetable.TYPE_HEX_AERO_BOMB)) {</span>
            // always a distance of zero
<span class="nc" id="L1695">            return 0;</span>
        }

<span class="nc" id="L1698">        Vector&lt;Coords&gt; attackPos = new Vector&lt;&gt;();</span>
<span class="nc" id="L1699">        attackPos.add(attacker.getPosition());</span>
<span class="nc" id="L1700">        Vector&lt;Coords&gt; targetPos = new Vector&lt;&gt;();</span>
<span class="nc" id="L1701">        targetPos.add(target.getPosition());</span>
        // if a grounded dropship is the attacker, then it gets to choose the
        // best secondary position for LoS
<span class="nc bnc" id="L1704" title="All 6 branches missed.">        if ((attacker instanceof Dropship) &amp;&amp; !attacker.isAirborne() &amp;&amp; !attacker.isSpaceborne()) {</span>
<span class="nc" id="L1705">            attackPos = new Vector&lt;&gt;();</span>
<span class="nc bnc" id="L1706" title="All 2 branches missed.">            for (int key : attacker.getSecondaryPositions().keySet()) {</span>
<span class="nc" id="L1707">                attackPos.add(attacker.getSecondaryPositions().get(key));</span>
<span class="nc" id="L1708">            }</span>
        }
<span class="nc bnc" id="L1710" title="All 6 branches missed.">        if ((target instanceof Dropship) &amp;&amp; !target.isAirborne() &amp;&amp; !((Entity) target).isSpaceborne()) {</span>
<span class="nc" id="L1711">            targetPos = new Vector&lt;&gt;();</span>
<span class="nc bnc" id="L1712" title="All 2 branches missed.">            for (final int key : target.getSecondaryPositions().keySet()) {</span>
<span class="nc" id="L1713">                targetPos.add(target.getSecondaryPositions().get(key));</span>
<span class="nc" id="L1714">            }</span>
        }
<span class="nc" id="L1716">        int distance = Integer.MAX_VALUE;</span>
<span class="nc bnc" id="L1717" title="All 2 branches missed.">        for (Coords apos : attackPos) {</span>
<span class="nc bnc" id="L1718" title="All 2 branches missed.">            for (Coords tpos : targetPos) {</span>
<span class="nc bnc" id="L1719" title="All 4 branches missed.">                if ((tpos != null) &amp;&amp; (apos != null)</span>
<span class="nc bnc" id="L1720" title="All 2 branches missed.">                        &amp;&amp; (apos.distance(tpos) &lt; distance)) {</span>
<span class="nc" id="L1721">                    distance = apos.distance(tpos);</span>
                }
<span class="nc" id="L1723">            }</span>
<span class="nc" id="L1724">        }</span>

<span class="nc bnc" id="L1726" title="All 4 branches missed.">        if (Compute.isGroundToAir(attacker, target) &amp;&amp; (target instanceof Entity)) {</span>
            // distance is determined by closest point on flight path
<span class="nc" id="L1728">            distance = attacker.getPosition().distance(getClosestFlightPath(attacker.getId(),</span>
<span class="nc" id="L1729">                    attacker.getPosition(), (Entity) target));</span>

            // if the ground attacker uses weapon bays and we are on a
            // ground map, then we will divide this distance by 16
            // This is totally crazy, but I don't see how else to do it. Use
            // the unofficial
            // &quot;grounded dropships use individual weapons&quot; for sanity.
<span class="nc bnc" id="L1736" title="All 4 branches missed.">            if (attacker.usesWeaponBays() &amp;&amp; game.getBoard().onGround()) {</span>
<span class="nc" id="L1737">                distance = (int) Math.ceil(distance / 16.0);</span>
            }
        }

        // if this is an air-to-air attack on the ground map, then divide
        // distance by 16
<span class="nc bnc" id="L1743" title="All 6 branches missed.">        if (Compute.isAirToAir(attacker, target) &amp;&amp; game.getBoard().onGround() &amp;&amp; !useGroundDistance) {</span>
<span class="nc" id="L1744">            distance = (int) Math.ceil(distance / 16.0);</span>
        }

        // If the attack is completely inside a building, add the difference
        // in elevations between the attacker and target to the range.
        // TODO: should the player be explicitly notified?
<span class="nc bnc" id="L1750" title="All 2 branches missed.">        if (Compute.isInSameBuilding(game, attacker, target)) {</span>
<span class="nc" id="L1751">            int aElev = attacker.getElevation();</span>
<span class="nc" id="L1752">            int tElev = target.getElevation();</span>
<span class="nc" id="L1753">            distance += Math.abs(aElev - tElev);</span>
        }

        // air-to-air attacks add one for altitude differences
<span class="nc bnc" id="L1757" title="All 2 branches missed.">        if (Compute.isAirToAir(attacker, target)) {</span>
<span class="nc" id="L1758">            int aAlt = attacker.getAltitude();</span>
<span class="nc" id="L1759">            int tAlt = target.getAltitude();</span>
<span class="nc bnc" id="L1760" title="All 2 branches missed.">            if (target.isAirborneVTOLorWIGE()) {</span>
<span class="nc" id="L1761">                tAlt++;</span>
            }
<span class="nc" id="L1763">            distance += Math.abs(aAlt - tAlt);</span>
        }

<span class="nc bnc" id="L1766" title="All 2 branches missed.">        if (Compute.isGroundToAir(attacker, target)) {</span>
<span class="nc bnc" id="L1767" title="All 4 branches missed.">            if (attacker.usesWeaponBays() &amp;&amp; game.getBoard().onGround()) {</span>
<span class="nc" id="L1768">                distance += (target.getAltitude());</span>
            } else {
<span class="nc" id="L1770">                distance += (2 * target.getAltitude());</span>
            }
        }

        // Attacking a ground unit while dropping
<span class="nc bnc" id="L1775" title="All 4 branches missed.">        if (attacker.isDropping() &amp;&amp; target.getAltitude() == 0) {</span>
<span class="nc" id="L1776">            distance += (2 * attacker.getAltitude());</span>
        }

<span class="nc" id="L1779">        return distance;</span>
    }

    /**
     * @param aPos the attacker's position
     * @param te   the target entity
     * @return the closest position along &lt;code&gt;te&lt;/codeE&gt;'s flight path to &lt;code&gt;aPos&lt;/code&gt;. In
     * the case of multiple equi-distance positions, the first one is picked unless
     * &lt;code&gt;te&lt;/code&gt;'s playerPickedPassThrough position is non-null.
     */
    public static @Nullable
    Coords getClosestFlightPath(int attackerId, Coords aPos, Entity te) {
<span class="nc" id="L1791">        Coords finalPos = te.getPosition();</span>
<span class="nc bnc" id="L1792" title="All 2 branches missed.">        if (te.getPlayerPickedPassThrough(attackerId) != null) {</span>
<span class="nc" id="L1793">            finalPos = te.getPlayerPickedPassThrough(attackerId);</span>
        }
<span class="nc" id="L1795">        int distance = Integer.MAX_VALUE;</span>
<span class="nc bnc" id="L1796" title="All 2 branches missed.">        if (finalPos != null) {</span>
<span class="nc" id="L1797">            distance = aPos.distance(finalPos);</span>
        }
        // don't return zero distance Coords, but rather the Coords immediately
        // before this
        // This is necessary to determine angle of attack and arc information
        // for direct fly-overs
<span class="nc bnc" id="L1803" title="All 2 branches missed.">        for (Coords c : te.getPassedThrough()) {</span>
<span class="nc bnc" id="L1804" title="All 4 branches missed.">            if (!aPos.equals(c) &amp;&amp; (c != null)</span>
<span class="nc bnc" id="L1805" title="All 4 branches missed.">                    &amp;&amp; ((aPos.distance(c) &lt; distance) || (distance == 0))) {</span>
<span class="nc" id="L1806">                finalPos = c;</span>
<span class="nc" id="L1807">                distance = aPos.distance(c);</span>
            }
<span class="nc" id="L1809">        }</span>
<span class="nc" id="L1810">        return finalPos;</span>
    }

    public static int getClosestFlightPathFacing(int attackerId,
                                                 Coords aPos, Entity te) {

<span class="nc" id="L1816">        Coords finalPos = te.getPosition();</span>
<span class="nc bnc" id="L1817" title="All 2 branches missed.">        if (te.getPlayerPickedPassThrough(attackerId) != null) {</span>
<span class="nc" id="L1818">            finalPos = te.getPlayerPickedPassThrough(attackerId);</span>
        }
<span class="nc" id="L1820">        int distance = Integer.MAX_VALUE;</span>
<span class="nc bnc" id="L1821" title="All 2 branches missed.">        if (finalPos != null) {</span>
<span class="nc" id="L1822">            distance = aPos.distance(finalPos);</span>
        }
<span class="nc" id="L1824">        int finalFacing = te.getFacing();</span>
        // don't return zero distance Coords, but rather the Coords immediately
        // before this
        // This is necessary to determine angle of attack and arc information
        // for direct fly-overs
<span class="nc bnc" id="L1829" title="All 2 branches missed.">        for (int i = 0; i &lt; te.getPassedThrough().size(); i++) {</span>
<span class="nc" id="L1830">            Coords c = te.getPassedThrough().get(i);</span>
<span class="nc bnc" id="L1831" title="All 4 branches missed.">            if (!aPos.equals(c) &amp;&amp; (c != null)</span>
<span class="nc bnc" id="L1832" title="All 4 branches missed.">                    &amp;&amp; ((aPos.distance(c) &lt; distance) || (distance == 0))) {</span>
<span class="nc" id="L1833">                finalFacing = te.getPassedThroughFacing().get(i);</span>
<span class="nc" id="L1834">                finalPos = c;</span>
<span class="nc" id="L1835">                distance = aPos.distance(c);</span>
<span class="nc bnc" id="L1836" title="All 2 branches missed.">            } else if (c.equals(finalPos)) {</span>
<span class="nc" id="L1837">                finalFacing = te.getPassedThroughFacing().get(i);</span>
            }
        }
<span class="nc" id="L1840">        return finalFacing;</span>
    }

    /**
     * WOR: Need this function to find out where my nova stuff doesn't work.
     * Delete it if nova works but remember to alter the /nova debug server
     * command.
     */
    public static Entity exposed_findC3Spotter(IGame game, Entity attacker,
                                               Targetable target) {
<span class="nc" id="L1850">        return findC3Spotter(game, attacker, target);</span>
    }

    /**
     * find a c3, c3i, NC3, or nova spotter that is closer to the target than the
     * attacker.
     *
     * @param game
     * @param attacker
     * @param target
     * @return A closer C3/C3i/Nova spotter, or the attacker if no spotters are
     * found
     */
    private static Entity findC3Spotter(IGame game, Entity attacker,
                                        Targetable target) {
        // no available C3-like system
<span class="nc bnc" id="L1866" title="All 4 branches missed.">        if (!attacker.hasC3() &amp;&amp; !attacker.hasC3i()</span>
<span class="nc bnc" id="L1867" title="All 4 branches missed.">                &amp;&amp; !attacker.hasActiveNovaCEWS() &amp;&amp; !attacker.hasNavalC3()) {</span>
<span class="nc" id="L1868">            return attacker;</span>
        }

<span class="nc" id="L1871">        ArrayList&lt;Entity&gt; network = new ArrayList&lt;Entity&gt;();</span>

        // Compute friends in network
<span class="nc bnc" id="L1874" title="All 2 branches missed.">        for (Entity friend : game.getEntitiesVector()) {</span>

<span class="nc bnc" id="L1876" title="All 2 branches missed.">            if (attacker.equals(friend)</span>
<span class="nc bnc" id="L1877" title="All 2 branches missed.">                    || !attacker.onSameC3NetworkAs(friend, true)</span>
<span class="nc bnc" id="L1878" title="All 2 branches missed.">                    || !friend.isDeployed()</span>
<span class="nc bnc" id="L1879" title="All 2 branches missed.">                    || (friend.getTransportId() != Entity.NONE)) {</span>
<span class="nc" id="L1880">                continue; // useless to us...</span>
            }

            // Must have LoS, Compute.canSee considers sensors and visual range
<span class="nc bnc" id="L1884" title="All 2 branches missed.">            if (!LosEffects.calculateLos(game, friend.getId(), target).canSee()) {</span>
<span class="nc" id="L1885">                continue;</span>
            }

<span class="nc" id="L1888">            int buddyRange = Compute.effectiveDistance(game, friend, target,</span>
                    false);

<span class="nc" id="L1891">            boolean added = false;</span>
            // put everyone in the C3 network into a list and sort it by range.
<span class="nc bnc" id="L1893" title="All 2 branches missed.">            for (int pos = 0; pos &lt; network.size(); pos++) {</span>
<span class="nc bnc" id="L1894" title="All 2 branches missed.">                if (Compute.effectiveDistance(game, network.get(pos), target,</span>
                        false) &gt;= buddyRange) {
<span class="nc" id="L1896">                    network.add(pos, friend);</span>
<span class="nc" id="L1897">                    added = true;</span>
<span class="nc" id="L1898">                    break;</span>
                }
            }

<span class="nc bnc" id="L1902" title="All 2 branches missed.">            if (!added) {</span>
<span class="nc" id="L1903">                network.add(friend);</span>
            }
<span class="nc" id="L1905">        }</span>

        // ensure network connectivity
<span class="nc" id="L1908">        List&lt;ECMInfo&gt; allECMInfo = ComputeECM.computeAllEntitiesECMInfo(game</span>
<span class="nc" id="L1909">                .getEntitiesVector());</span>
<span class="nc" id="L1910">        int position = 0;</span>
<span class="nc bnc" id="L1911" title="All 2 branches missed.">        for (Entity spotter : network) {</span>
<span class="nc bnc" id="L1912" title="All 2 branches missed.">            for (int count = position++; count &lt; network.size(); count++) {</span>
<span class="nc bnc" id="L1913" title="All 2 branches missed.">                if (Compute.canCompleteNodePath(spotter, attacker, network,</span>
                        count, allECMInfo)) {
<span class="nc" id="L1915">                    return spotter;</span>
                }
            }
<span class="nc" id="L1918">        }</span>

<span class="nc" id="L1920">        return attacker;</span>
    }

    /**
     * Looks through the network list to ensure that the given Entity is
     * connected to the network.
     *
     * @param start
     * @param end
     * @param network
     * @param startPosition
     * @return
     */
    private static boolean canCompleteNodePath(Entity start, Entity end,
                                               ArrayList&lt;Entity&gt; network, int startPosition,
                                               List&lt;ECMInfo&gt; allECMInfo) {

<span class="nc" id="L1937">        Entity spotter = network.get(startPosition);</span>

        // ECMInfo for line between spotter's position and start's position
<span class="nc" id="L1940">        ECMInfo spotterStartECM = ComputeECM.getECMEffects(spotter,</span>
<span class="nc" id="L1941">                start.getPosition(), spotter.getPosition(), true, allECMInfo);</span>

        // Check for ECM between spotter and start
<span class="nc bnc" id="L1944" title="All 4 branches missed.">        boolean isC3BDefeated = start.hasBoostedC3()</span>
<span class="nc bnc" id="L1945" title="All 2 branches missed.">                &amp;&amp; (spotterStartECM != null) &amp;&amp; spotterStartECM.isAngelECM();</span>
<span class="nc bnc" id="L1946" title="All 4 branches missed.">        boolean isNovaDefeated = start.hasNovaCEWS()</span>
<span class="nc bnc" id="L1947" title="All 2 branches missed.">                &amp;&amp; (spotterStartECM != null) &amp;&amp; spotterStartECM.isNovaECM();</span>
<span class="nc bnc" id="L1948" title="All 6 branches missed.">        boolean isC3Defeated = !(start.hasBoostedC3() || start.hasNovaCEWS())</span>
<span class="nc bnc" id="L1949" title="All 2 branches missed.">                &amp;&amp; (spotterStartECM != null) &amp;&amp; spotterStartECM.isECM();</span>
<span class="nc bnc" id="L1950" title="All 6 branches missed.">        if (isC3BDefeated || isNovaDefeated || isC3Defeated) {</span>
<span class="nc" id="L1951">            return false;</span>
        }

        // ECMInfo for line between spotter's position and end's position
<span class="nc" id="L1955">        ECMInfo spotterEndECM = ComputeECM.getECMEffects(spotter,</span>
<span class="nc" id="L1956">                spotter.getPosition(), end.getPosition(), true, allECMInfo);</span>
<span class="nc bnc" id="L1957" title="All 4 branches missed.">        isC3BDefeated = start.hasBoostedC3() &amp;&amp; (spotterEndECM != null)</span>
<span class="nc bnc" id="L1958" title="All 2 branches missed.">                &amp;&amp; spotterEndECM.isAngelECM();</span>
<span class="nc bnc" id="L1959" title="All 4 branches missed.">        isNovaDefeated = start.hasNovaCEWS() &amp;&amp; (spotterEndECM != null)</span>
<span class="nc bnc" id="L1960" title="All 2 branches missed.">                &amp;&amp; spotterEndECM.isNovaECM();</span>
<span class="nc bnc" id="L1961" title="All 6 branches missed.">        isC3Defeated = !(start.hasBoostedC3() || start.hasNovaCEWS())</span>
<span class="nc bnc" id="L1962" title="All 2 branches missed.">                &amp;&amp; (spotterEndECM != null) &amp;&amp; spotterEndECM.isECM();</span>
        // If there's no ECM between spotter and end, we're done
<span class="nc bnc" id="L1964" title="All 6 branches missed.">        if (!(isC3BDefeated || isNovaDefeated || isC3Defeated)) {</span>
<span class="nc" id="L1965">            return true;</span>
        }

<span class="nc bnc" id="L1968" title="All 2 branches missed.">        for (++startPosition; startPosition &lt; network.size(); startPosition++) {</span>
<span class="nc bnc" id="L1969" title="All 2 branches missed.">            if (Compute.canCompleteNodePath(spotter, end, network,</span>
                    startPosition, allECMInfo)) {
<span class="nc" id="L1971">                return true;</span>
            }
        }

<span class="nc" id="L1975">        return false;</span>
    }

    /**
     * Gets the modifiers, if any, that the mech receives from being prone.
     *
     * @return any applicable modifiers due to being prone
     */
    public static ToHitData getProneMods(IGame game, Entity attacker,
                                         int weaponId) {
<span class="nc bnc" id="L1985" title="All 2 branches missed.">        if (!attacker.isProne()) {</span>
<span class="nc" id="L1986">            return null; // no modifier</span>
        }
<span class="nc" id="L1988">        ToHitData mods = new ToHitData();</span>
<span class="nc" id="L1989">        Mounted weapon = attacker.getEquipment(weaponId);</span>
<span class="nc bnc" id="L1990" title="All 2 branches missed.">        if (attacker.entityIsQuad()) {</span>
<span class="nc" id="L1991">            int legsDead = ((Mech) attacker).countBadLegs();</span>
<span class="nc bnc" id="L1992" title="All 4 branches missed.">            if (legsDead == 0 &amp;&amp; !((Mech) attacker).hasHipCrit()) {</span>
                // No legs destroyed and no hip crits: no penalty and can fire all weapons
<span class="nc" id="L1994">                return null; // no modifier</span>
<span class="nc bnc" id="L1995" title="All 2 branches missed.">            } else if (legsDead &gt;= 3) {</span>
<span class="nc" id="L1996">                return new ToHitData(TargetRoll.IMPOSSIBLE,</span>
                        &quot;Prone with three or more legs destroyed.&quot;);
            }
            // we have one or two dead legs...

            // Need an intact front leg
<span class="nc bnc" id="L2002" title="All 2 branches missed.">            if (attacker.isLocationBad(Mech.LOC_RARM)</span>
<span class="nc bnc" id="L2003" title="All 2 branches missed.">                    &amp;&amp; attacker.isLocationBad(Mech.LOC_LARM)) {</span>
<span class="nc" id="L2004">                return new ToHitData(TargetRoll.IMPOSSIBLE,</span>
                        &quot;Prone with both front legs destroyed.&quot;);
            }

            // front leg-mounted weapons have addidional trouble
<span class="nc bnc" id="L2009" title="All 4 branches missed.">            if ((weapon.getLocation() == Mech.LOC_RARM) || (weapon.getSecondLocation() == Mech.LOC_RARM)</span>
<span class="nc bnc" id="L2010" title="All 4 branches missed.">                    || (weapon.getLocation() == Mech.LOC_LARM || (weapon.getSecondLocation() == Mech.LOC_LARM))) {</span>
<span class="nc bnc" id="L2011" title="All 2 branches missed.">                int otherArm = (weapon.getLocation() == Mech.LOC_RARM</span>
<span class="nc bnc" id="L2012" title="All 2 branches missed.">                        || weapon.getSecondLocation() == Mech.LOC_RARM) ? Mech.LOC_LARM</span>
<span class="nc" id="L2013">                        : Mech.LOC_RARM;</span>
                // check previous attacks for weapons fire from the other arm
<span class="nc bnc" id="L2015" title="All 2 branches missed.">                if (Compute.isFiringFromArmAlready(game, weaponId, attacker,</span>
                        otherArm)) {
<span class="nc" id="L2017">                    return new ToHitData(TargetRoll.IMPOSSIBLE,</span>
                            &quot;Prone and firing from other front leg already.&quot;);
                }
            }
            // can't fire rear leg weapons
<span class="nc bnc" id="L2022" title="All 2 branches missed.">            if ((weapon.getLocation() == Mech.LOC_LLEG)</span>
<span class="nc bnc" id="L2023" title="All 2 branches missed.">                    || (weapon.getLocation() == Mech.LOC_RLEG)) {</span>
<span class="nc" id="L2024">                return new ToHitData(TargetRoll.IMPOSSIBLE,</span>
                        &quot;Can't fire rear leg-mounted weapons while prone with destroyed legs.&quot;);
            }
<span class="nc bnc" id="L2027" title="All 2 branches missed.">            if (((Mech) attacker).getCockpitType() == Mech.COCKPIT_DUAL</span>
<span class="nc bnc" id="L2028" title="All 2 branches missed.">                    &amp;&amp; attacker.getCrew().hasDedicatedGunner()) {</span>
<span class="nc" id="L2029">                mods.addModifier(1, &quot;attacker prone&quot;);</span>
            } else {
<span class="nc" id="L2031">                mods.addModifier(2, &quot;attacker prone&quot;);</span>
            }
<span class="nc" id="L2033">        } else {</span>
<span class="nc" id="L2034">            int l3ProneFiringArm = Entity.LOC_NONE;</span>

<span class="nc bnc" id="L2036" title="All 2 branches missed.">            if (attacker.isLocationBad(Mech.LOC_RARM)</span>
<span class="nc bnc" id="L2037" title="All 2 branches missed.">                    || attacker.isLocationBad(Mech.LOC_LARM)) {</span>
<span class="nc bnc" id="L2038" title="All 2 branches missed.">                if (game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_PRONE_FIRE)) {</span>
                    // Can fire with only one arm
<span class="nc bnc" id="L2040" title="All 2 branches missed.">                    if (attacker.isLocationBad(Mech.LOC_RARM)</span>
<span class="nc bnc" id="L2041" title="All 2 branches missed.">                            &amp;&amp; attacker.isLocationBad(Mech.LOC_LARM)) {</span>
<span class="nc" id="L2042">                        return new ToHitData(TargetRoll.IMPOSSIBLE,</span>
                                &quot;Prone with both arms destroyed.&quot;);
                    }

<span class="nc bnc" id="L2046" title="All 2 branches missed.">                    l3ProneFiringArm = attacker.isLocationBad(Mech.LOC_RARM) ? Mech.LOC_LARM</span>
<span class="nc" id="L2047">                            : Mech.LOC_RARM;</span>
                } else {
                    // must have an arm intact
<span class="nc" id="L2050">                    return new ToHitData(TargetRoll.IMPOSSIBLE,</span>
                            &quot;Prone with one or both arms destroyed.&quot;);
                }
            }

            // arm-mounted weapons have addidional trouble
<span class="nc bnc" id="L2056" title="All 4 branches missed.">            if ((weapon.getLocation() == Mech.LOC_RARM) || (weapon.getSecondLocation() == Mech.LOC_RARM)</span>
<span class="nc bnc" id="L2057" title="All 4 branches missed.">                    || (weapon.getLocation() == Mech.LOC_LARM) || (weapon.getSecondLocation() == Mech.LOC_LARM)) {</span>
<span class="nc bnc" id="L2058" title="All 2 branches missed.">                if (l3ProneFiringArm == weapon.getLocation()</span>
<span class="nc bnc" id="L2059" title="All 4 branches missed.">                        || (weapon.getSecondLocation() != Entity.NONE &amp;&amp; l3ProneFiringArm == weapon.getSecondLocation())) {</span>
<span class="nc" id="L2060">                    return new ToHitData(TargetRoll.IMPOSSIBLE,</span>
                            &quot;Prone and propping up with this arm.&quot;);
                }

<span class="nc bnc" id="L2064" title="All 2 branches missed.">                int otherArm = (weapon.getLocation() == Mech.LOC_RARM</span>
<span class="nc bnc" id="L2065" title="All 2 branches missed.">                        || weapon.getSecondLocation() == Mech.LOC_RARM) ? Mech.LOC_LARM</span>
<span class="nc" id="L2066">                        : Mech.LOC_RARM;</span>
                // check previous attacks for weapons fire from the other arm
<span class="nc bnc" id="L2068" title="All 2 branches missed.">                if (Compute.isFiringFromArmAlready(game, weaponId, attacker,</span>
                        otherArm)) {
<span class="nc" id="L2070">                    return new ToHitData(TargetRoll.IMPOSSIBLE,</span>
                            &quot;Prone and firing from other arm already.&quot;);
                }
            }
            // can't fire leg weapons
<span class="nc bnc" id="L2075" title="All 2 branches missed.">            if ((weapon.getLocation() == Mech.LOC_LLEG)</span>
<span class="nc bnc" id="L2076" title="All 2 branches missed.">                    || (weapon.getLocation() == Mech.LOC_RLEG)) {</span>
<span class="nc" id="L2077">                return new ToHitData(TargetRoll.IMPOSSIBLE,</span>
                        &quot;Can't fire leg-mounted weapons while prone.&quot;);
            }
<span class="nc bnc" id="L2080" title="All 2 branches missed.">            if (((Mech) attacker).getCockpitType() == Mech.COCKPIT_DUAL</span>
<span class="nc bnc" id="L2081" title="All 2 branches missed.">                    &amp;&amp; attacker.getCrew().hasDedicatedGunner()) {</span>
<span class="nc" id="L2082">                mods.addModifier(1, &quot;attacker prone&quot;);</span>
            } else {
<span class="nc" id="L2084">                mods.addModifier(2, &quot;attacker prone&quot;);</span>
            }

<span class="nc bnc" id="L2087" title="All 2 branches missed.">            if (l3ProneFiringArm != Entity.LOC_NONE) {</span>
<span class="nc" id="L2088">                mods.addModifier(1, &quot;attacker propping on single arm&quot;);</span>
            }
        }
<span class="nc" id="L2091">        return mods;</span>
    }

    /**
     * Checks to see if there is an attack previous to the one with this weapon
     * from the specified arm.
     *
     * @return true if there is a previous attack from this arm
     */
    private static boolean isFiringFromArmAlready(IGame game, int weaponId,
                                                  final Entity attacker, int armLoc) {
<span class="nc" id="L2102">        int torsoLoc = Mech.getInnerLocation(armLoc);</span>
<span class="nc" id="L2103">        for (Enumeration&lt;EntityAction&gt; i = game.getActions(); i</span>
<span class="nc bnc" id="L2104" title="All 2 branches missed.">                .hasMoreElements(); ) {</span>
<span class="nc" id="L2105">            EntityAction ea = i.nextElement();</span>
<span class="nc bnc" id="L2106" title="All 2 branches missed.">            if (!(ea instanceof WeaponAttackAction)) {</span>
<span class="nc" id="L2107">                continue;</span>
            }
<span class="nc" id="L2109">            WeaponAttackAction prevAttack = (WeaponAttackAction) ea;</span>
            // stop when we get to this weaponattack (does this always work?)
<span class="nc bnc" id="L2111" title="All 2 branches missed.">            if ((prevAttack.getEntityId() == attacker.getId())</span>
<span class="nc bnc" id="L2112" title="All 2 branches missed.">                    &amp;&amp; (prevAttack.getWeaponId() == weaponId)) {</span>
<span class="nc" id="L2113">                break;</span>
            }
<span class="nc bnc" id="L2115" title="All 2 branches missed.">            if (((prevAttack.getEntityId() == attacker.getId()) &amp;&amp; (attacker</span>
<span class="nc" id="L2116">                    .getEquipment(prevAttack.getWeaponId())</span>
<span class="nc bnc" id="L2117" title="All 2 branches missed.">                    .getLocation() == armLoc))</span>
<span class="nc bnc" id="L2118" title="All 2 branches missed.">                    || ((prevAttack.getEntityId() == attacker.getId())</span>
<span class="nc" id="L2119">                    &amp;&amp; (attacker.getEquipment(prevAttack.getWeaponId())</span>
<span class="nc bnc" id="L2120" title="All 2 branches missed.">                    .getLocation() == torsoLoc) &amp;&amp; attacker</span>
<span class="nc bnc" id="L2121" title="All 2 branches missed.">                    .getEquipment(prevAttack.getWeaponId()).isSplit())) {</span>
<span class="nc" id="L2122">                return true;</span>
            }
<span class="nc" id="L2124">        }</span>
<span class="nc" id="L2125">        return false;</span>
    }

    /**
     * Adds any damage modifiers from arm critical hits or sensor damage.
     *
     * @return Any applicable damage modifiers
     */
    public static ToHitData getDamageWeaponMods(Entity attacker, Mounted weapon) {
<span class="fc" id="L2134">        ToHitData mods = new ToHitData();</span>
<span class="pc bpc" id="L2135" title="1 of 2 branches missed.">        if (attacker instanceof Protomech) {</span>
            // Head criticals add to target number of all weapons.
<span class="nc" id="L2137">            int hits = ((Protomech) attacker).getCritsHit(Protomech.LOC_HEAD);</span>
<span class="nc bnc" id="L2138" title="All 2 branches missed.">            if (hits &gt; 0) {</span>
<span class="nc" id="L2139">                mods.addModifier(hits, hits + &quot; head critical(s)&quot;);</span>
            }

            // Arm mounted (and main gun) weapons get DRMs from arm crits.
<span class="nc bnc" id="L2143" title="All 3 branches missed.">            switch (weapon.getLocation()) {</span>
                case Protomech.LOC_LARM:
                case Protomech.LOC_RARM:
<span class="nc" id="L2146">                    hits = ((Protomech) attacker).getCritsHit(weapon</span>
<span class="nc" id="L2147">                            .getLocation());</span>
<span class="nc bnc" id="L2148" title="All 2 branches missed.">                    if (hits &gt; 0) {</span>
<span class="nc" id="L2149">                        mods.addModifier(hits, hits + &quot; arm critical(s)&quot;);</span>
                    }
                    break;
                case Protomech.LOC_MAINGUN:
                    // Main gun is affected by crits in *both* arms.
<span class="nc" id="L2154">                    hits = ((Protomech) attacker)</span>
<span class="nc" id="L2155">                            .getCritsHit(Protomech.LOC_LARM);</span>
<span class="nc" id="L2156">                    hits += ((Protomech) attacker)</span>
<span class="nc" id="L2157">                            .getCritsHit(Protomech.LOC_RARM);</span>
<span class="nc bnc" id="L2158" title="All 2 branches missed.">                    if (4 == hits) {</span>
<span class="nc" id="L2159">                        mods.addModifier(TargetRoll.IMPOSSIBLE,</span>
                                &quot;Cannot fire main gun with no arms.&quot;);
<span class="nc bnc" id="L2161" title="All 2 branches missed.">                    } else if (hits &gt; 0) {</span>
<span class="nc" id="L2162">                        mods.addModifier(hits, hits + &quot; arm critical(s)&quot;);</span>
                    }
                    break;
            }

<span class="nc" id="L2167">        } // End attacker-is-Protomech</span>

        // only mechs have arm actuators - for those, we check whether
        // there is arm actuator damage
<span class="fc bfc" id="L2171" title="All 2 branches covered.">        else if (attacker instanceof Mech) {</span>
            // split weapons need to account for arm actuator hits, too
            // see bug 1363690
            // we don't need to specifically check for weapons split between
            // torso and leg, because for those, the location stored in the
            // Mounted is the leg.
<span class="fc" id="L2177">            int location = weapon.getLocation();</span>
<span class="pc bpc" id="L2178" title="1 of 2 branches missed.">            if (weapon.isSplit()) {</span>
<span class="nc bnc" id="L2179" title="All 3 branches missed.">                switch (location) {</span>
                    case Mech.LOC_LT:
<span class="nc" id="L2181">                        location = Mech.LOC_LARM;</span>
<span class="nc" id="L2182">                        break;</span>
                    case Mech.LOC_RT:
<span class="nc" id="L2184">                        location = Mech.LOC_RARM;</span>
<span class="nc" id="L2185">                        break;</span>
                    default:
                }
            }

            // only arms can have damaged arm actuators
<span class="pc bpc" id="L2191" title="2 of 4 branches missed.">            if (location == Mech.LOC_LARM || location == Mech.LOC_RARM) {</span>
<span class="pc bpc" id="L2192" title="1 of 2 branches missed.">                if (attacker.getBadCriticals(CriticalSlot.TYPE_SYSTEM,</span>
                        Mech.ACTUATOR_SHOULDER, location) &gt; 0) {
<span class="nc" id="L2194">                    mods.addModifier(4, &quot;shoulder actuator destroyed&quot;);</span>
                } else {
                    // no shoulder hits, add other arm hits
<span class="fc" id="L2197">                    int actuatorHits = 0;</span>
<span class="pc bpc" id="L2198" title="1 of 2 branches missed.">                    if (attacker.getBadCriticals(CriticalSlot.TYPE_SYSTEM,</span>
                            Mech.ACTUATOR_UPPER_ARM, location) &gt; 0) {
<span class="nc" id="L2200">                        actuatorHits++;</span>
                    }
<span class="pc bpc" id="L2202" title="1 of 2 branches missed.">                    if (attacker.getBadCriticals(CriticalSlot.TYPE_SYSTEM,</span>
                            Mech.ACTUATOR_LOWER_ARM, location) &gt; 0) {
<span class="nc" id="L2204">                        actuatorHits++;</span>
                    }
<span class="pc bpc" id="L2206" title="1 of 2 branches missed.">                    if (actuatorHits &gt; 0) {</span>
<span class="nc" id="L2207">                        mods.addModifier(actuatorHits, actuatorHits</span>
                                + &quot; destroyed arm actuators&quot;);
                    }
                }
            }
        }

        // sensors critical hit to attacker
<span class="fc" id="L2215">        int sensorHits = attacker.getBadCriticals(CriticalSlot.TYPE_SYSTEM,</span>
                Mech.SYSTEM_SENSORS, Mech.LOC_HEAD);
<span class="fc bfc" id="L2217" title="All 2 branches covered.">        if ((attacker instanceof Mech)</span>
<span class="pc bpc" id="L2218" title="1 of 2 branches missed.">                &amp;&amp; (((Mech) attacker).getCockpitType() == Mech.COCKPIT_TORSO_MOUNTED)) {</span>
<span class="nc" id="L2219">            sensorHits += attacker.getBadCriticals(CriticalSlot.TYPE_SYSTEM,</span>
                    Mech.SYSTEM_SENSORS, Mech.LOC_CT);
<span class="nc bnc" id="L2221" title="All 2 branches missed.">            if (sensorHits &gt; 1) {</span>
<span class="nc" id="L2222">                mods.addModifier(4, &quot;attacker sensors badly damaged&quot;);</span>
<span class="nc bnc" id="L2223" title="All 2 branches missed.">            } else if (sensorHits &gt; 0) {</span>
<span class="nc" id="L2224">                mods.addModifier(2, &quot;attacker sensors damaged&quot;);</span>
            }
<span class="fc bfc" id="L2226" title="All 2 branches covered.">        } else if (sensorHits &gt; 0) {</span>
<span class="pc bpc" id="L2227" title="2 of 4 branches missed.">            if (attacker instanceof Mech &amp;&amp; ((Mech) attacker).getCockpitType() == Mech.COCKPIT_DUAL</span>
<span class="nc bnc" id="L2228" title="All 2 branches missed.">                    &amp;&amp; attacker.getCrew().hasDedicatedGunner()) {</span>
<span class="nc" id="L2229">                mods.addModifier(1, &quot;attacker sensors damaged&quot;);</span>
            } else {
<span class="fc" id="L2231">                mods.addModifier(2, &quot;attacker sensors damaged&quot;);</span>
            }
        }

        // if partial sensor/stabilizer/fcs/cic repairs are present the shot will be more difficult
<span class="pc bpc" id="L2236" title="1 of 2 branches missed.">        if (attacker.getPartialRepairs() != null) {</span>
<span class="nc bnc" id="L2237" title="All 2 branches missed.">            if (attacker.getPartialRepairs().booleanOption(&quot;sensors_1_crit&quot;)) {</span>
<span class="nc" id="L2238">                mods.addModifier(1, &quot;sensor damage&quot;);</span>
            }
<span class="nc bnc" id="L2240" title="All 2 branches missed.">            if (attacker.getPartialRepairs().booleanOption(&quot;mech_sensors_2_crit&quot;)) {</span>
<span class="nc" id="L2241">                mods.addModifier(2, &quot;sensor damage&quot;);</span>
            }
<span class="nc bnc" id="L2243" title="All 2 branches missed.">            if (attacker.getPartialRepairs().booleanOption(&quot;veh_stabilizer_crit&quot;)) {</span>
<span class="nc" id="L2244">                mods.addModifier(1, &quot;stabilizer damage&quot;);</span>
            }
<span class="nc bnc" id="L2246" title="All 2 branches missed.">            if (attacker.getPartialRepairs().booleanOption(&quot;aero_cic_fcs_replace&quot;)) {</span>
<span class="nc" id="L2247">                mods.addModifier(1, &quot;misreplaced cic/fcs equipment&quot;);</span>
            }
<span class="nc bnc" id="L2249" title="All 2 branches missed.">            if (attacker.getPartialRepairs().booleanOption(&quot;aero_cic_fcs_crit&quot;)) {</span>
<span class="nc" id="L2250">                mods.addModifier(1, &quot;faulty cic/fcs repairs&quot;);</span>
            }
        }

<span class="fc" id="L2254">        return mods;</span>
    }

    /**
     * Determines if the current target is a secondary target, and if so,
     * returns the appropriate modifier.
     *
     * @return The secondary target modifier.
     * @author Ben
     */
    public static ToHitData getSecondaryTargetMod(IGame game, Entity attacker,
                                                  Targetable target) {

        // large craft do not get secondary target mod
        // http://www.classicbattletech.com/forums/index.php/topic,37661.0.html
<span class="nc bnc" id="L2269" title="All 2 branches missed.">        if (attacker.getCrew().getCrewType().getMaxPrimaryTargets() &lt; 0) {</span>
<span class="nc" id="L2270">            return null;</span>
        }

<span class="nc" id="L2273">        boolean curInFrontArc = Compute</span>
<span class="nc" id="L2274">                .isInArc(attacker.getPosition(), attacker.getSecondaryFacing(),</span>
<span class="nc" id="L2275">                        target, attacker.getForwardArc());</span>
<span class="nc" id="L2276">        boolean curInRearArc = Compute.isInArc(attacker.getPosition(),</span>
<span class="nc" id="L2277">                attacker.getSecondaryFacing(), target, attacker.getRearArc());</span>
<span class="nc bnc" id="L2278" title="All 4 branches missed.">        if (!curInRearArc &amp;&amp; attacker.hasQuirk(OptionsConstants.QUIRK_POS_MULTI_TRAC)) {</span>
<span class="nc" id="L2279">            return null;</span>
        }

<span class="nc" id="L2282">        int primaryTarget = Entity.NONE;</span>
<span class="nc" id="L2283">        boolean primaryInFrontArc = false;</span>
        // Track # of targets, for secondary modifiers w/ multi-crew vehicles
<span class="nc" id="L2285">        Set&lt;Integer&gt; targIds = new HashSet&lt;&gt;();</span>
<span class="nc" id="L2286">        for (Enumeration&lt;EntityAction&gt; i = game.getActions(); i</span>
<span class="nc bnc" id="L2287" title="All 2 branches missed.">                .hasMoreElements(); ) {</span>
<span class="nc" id="L2288">            Object o = i.nextElement();</span>
<span class="nc bnc" id="L2289" title="All 2 branches missed.">            if (!(o instanceof WeaponAttackAction)) {</span>
<span class="nc" id="L2290">                continue;</span>
            }
<span class="nc" id="L2292">            WeaponAttackAction prevAttack = (WeaponAttackAction) o;</span>
<span class="nc bnc" id="L2293" title="All 2 branches missed.">            if (prevAttack.getEntityId() == attacker.getId()) {</span>
                // Don't add id of current target, as it gets counted elsewhere
<span class="nc bnc" id="L2295" title="All 2 branches missed.">                if (prevAttack.getTargetId() != target.getTargetId()) {</span>
<span class="nc" id="L2296">                    targIds.add(prevAttack.getTargetId());</span>
                }
                // first front arc target is our primary.
                // if first target is non-front, and either a later target or
                // the current one is in front, use that instead.
<span class="nc bnc" id="L2301" title="All 2 branches missed.">                if (!game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_NO_FORCED_PRIMARY_TARGETS)) {</span>
<span class="nc" id="L2302">                    Targetable pte = game.getTarget(prevAttack.getTargetType(),</span>
<span class="nc" id="L2303">                            prevAttack.getTargetId());</span>
                    // in double blind play, we might not have the target in our
                    // local copy of the game. In that case, the sprite won't
                    // have the correct to-hit number, but at least we don't crash
<span class="nc bnc" id="L2307" title="All 2 branches missed.">                    if (pte == null) {</span>
<span class="nc" id="L2308">                        continue;</span>
                    }

                    // Determine primary target
<span class="nc bnc" id="L2312" title="All 4 branches missed.">                    if ((primaryTarget == Entity.NONE || !primaryInFrontArc)</span>
<span class="nc bnc" id="L2313" title="All 2 branches missed.">                            &amp;&amp; Compute.isInArc(attacker.getPosition(),</span>
<span class="nc" id="L2314">                            attacker.getSecondaryFacing(), pte,</span>
<span class="nc" id="L2315">                            attacker.getForwardArc())) {</span>
<span class="nc" id="L2316">                        primaryTarget = prevAttack.getTargetId();</span>
<span class="nc" id="L2317">                        primaryInFrontArc = true;</span>
<span class="nc bnc" id="L2318" title="All 4 branches missed.">                    } else if ((primaryTarget == Entity.NONE) &amp;&amp; !curInFrontArc) {</span>
<span class="nc" id="L2319">                        primaryTarget = prevAttack.getTargetId();</span>
                    }
<span class="nc bnc" id="L2321" title="All 2 branches missed.">                } else if (primaryTarget == Entity.NONE) {</span>
<span class="nc" id="L2322">                    primaryTarget = prevAttack.getTargetId();</span>
                }
            }
<span class="nc" id="L2325">        }</span>

        // # of targets, +1 for the passed target
<span class="nc" id="L2328">        int countTargets = 1 + targIds.size();</span>

<span class="nc" id="L2330">        int maxPrimary = 1;</span>
        //Tripods and QuadVees with dedicated gunnery can target up to three units before incurring a penalty, and two for dual cockpit
<span class="nc bnc" id="L2332" title="All 2 branches missed.">        if (attacker.getCrew().hasDedicatedGunner()) {</span>
<span class="nc" id="L2333">            maxPrimary = attacker.getCrew().getCrewType().getMaxPrimaryTargets();</span>
        }
<span class="nc bnc" id="L2335" title="All 4 branches missed.">        if (game.getOptions().booleanOption(&quot;tacops_tank_crews&quot;)</span>
                &amp;&amp; (attacker instanceof Tank)) {

            // If we are a tank, and only have 1 crew then we have some special
            //  restrictions
<span class="nc bnc" id="L2340" title="All 4 branches missed.">            if (countTargets &gt; 1 &amp;&amp; attacker.getCrew().getSize() == 1) {</span>
<span class="nc" id="L2341">                return new ToHitData(TargetRoll.IMPOSSIBLE,</span>
                        &quot;Vehicles with only 1 crewman may not attack &quot;
                                + &quot;secondary targets&quot;);
            }
            // If we are a tank, we can have Crew Size - 1 targets before
            //  incurring a secondary target penalty (or crew size - 2 secondary
            //  targets without penalty)
<span class="nc" id="L2348">            maxPrimary = attacker.getCrew().getSize() - 1;</span>
        }
<span class="nc bnc" id="L2350" title="All 2 branches missed.">        if (countTargets &lt;= maxPrimary) {</span>
<span class="nc" id="L2351">            return null; // no modifier</span>
        }

<span class="nc bnc" id="L2354" title="All 2 branches missed.">        if ((primaryTarget == Entity.NONE)</span>
<span class="nc bnc" id="L2355" title="All 2 branches missed.">                || (primaryTarget == target.getTargetId())) {</span>
            // current target is primary target
<span class="nc" id="L2357">            return null; // no modifier</span>
        }

        // current target is secondary

        // Stealthed Mechs can't be secondary targets (TW, pg. 142)
<span class="nc bnc" id="L2363" title="All 6 branches missed.">        if (((target instanceof Tank) || (target instanceof Mech) || (target instanceof Aero))</span>
<span class="nc bnc" id="L2364" title="All 2 branches missed.">                &amp;&amp; ((Entity) target).isStealthActive()) {</span>
<span class="nc" id="L2365">            return new ToHitData(TargetRoll.IMPOSSIBLE,</span>
                    &quot;Can't target unit with active stealth armor as &quot; +
                            &quot;secondary target&quot;);
        }

<span class="nc" id="L2370">        int mod = 2;</span>
<span class="nc bnc" id="L2371" title="All 4 branches missed.">        if (curInFrontArc || (attacker instanceof BattleArmor)) {</span>
<span class="nc" id="L2372">            mod--;</span>
        }
<span class="nc bnc" id="L2374" title="All 2 branches missed.">        if (attacker.hasAbility(OptionsConstants.GUNNERY_MULTI_TASKER)) {</span>
<span class="nc" id="L2375">            mod--;</span>
        }
<span class="nc" id="L2377">        return new ToHitData(mod, &quot;secondary target modifier&quot;);</span>
    }

    /**
     * Damage that a mech does with a accidental fall from above.
     */

    public static int getAffaDamageFor(Entity entity) {
<span class="nc" id="L2385">        return (int) entity.getWeight() / 10;</span>
    }

    /**
     * Modifier to attacks due to attacker movement
     */
    public static ToHitData getAttackerMovementModifier(IGame game, int entityId) {
<span class="nc" id="L2392">        return Compute.getAttackerMovementModifier(game, entityId,</span>
<span class="nc" id="L2393">                game.getEntity(entityId).moved);</span>
    }

    /**
     * Modifier to attacks due to attacker movement
     */
    public static ToHitData getAttackerMovementModifier(IGame game,
                                                        int entityId, EntityMovementType movement) {
<span class="nc" id="L2401">        final Entity entity = game.getEntity(entityId);</span>
<span class="nc" id="L2402">        ToHitData toHit = new ToHitData();</span>

        // infantry aren't affected by their own movement.
<span class="nc bnc" id="L2405" title="All 2 branches missed.">        if (entity instanceof Infantry) {</span>
<span class="nc" id="L2406">            return toHit;</span>
        }

<span class="nc bnc" id="L2409" title="All 2 branches missed.">        if ((entity.getMovementMode() == EntityMovementMode.BIPED_SWIM)</span>
<span class="nc bnc" id="L2410" title="All 2 branches missed.">                || (entity.getMovementMode() == EntityMovementMode.QUAD_SWIM)) {</span>
<span class="nc" id="L2411">            toHit.addModifier(3, &quot;attacker used UMUs&quot;);</span>
<span class="nc bnc" id="L2412" title="All 4 branches missed.">        } else if (entity instanceof LandAirMech &amp;&amp; movement == EntityMovementType.MOVE_VTOL_WALK) {</span>
<span class="nc" id="L2413">            toHit.addModifier(3, &quot;attacker cruised&quot;);</span>
<span class="nc bnc" id="L2414" title="All 4 branches missed.">        } else if (entity instanceof LandAirMech &amp;&amp; movement == EntityMovementType.MOVE_VTOL_RUN) {</span>
<span class="nc" id="L2415">            toHit.addModifier(4, &quot;attacker flanked&quot;);</span>
<span class="nc bnc" id="L2416" title="All 6 branches missed.">        } else if ((movement == EntityMovementType.MOVE_WALK) || (movement == EntityMovementType.MOVE_VTOL_WALK)</span>
                || (movement == EntityMovementType.MOVE_CAREFUL_STAND)) {
<span class="nc" id="L2418">            toHit.addModifier(1, &quot;attacker walked&quot;);</span>
<span class="nc bnc" id="L2419" title="All 4 branches missed.">        } else if ((movement == EntityMovementType.MOVE_RUN) || (movement == EntityMovementType.MOVE_VTOL_RUN)) {</span>
<span class="nc" id="L2420">            toHit.addModifier(2, &quot;attacker ran&quot;);</span>
<span class="nc bnc" id="L2421" title="All 2 branches missed.">        } else if (movement == EntityMovementType.MOVE_SKID) {</span>
<span class="nc" id="L2422">            toHit.addModifier(3, &quot;attacker ran and skidded&quot;);</span>
<span class="nc bnc" id="L2423" title="All 2 branches missed.">        } else if (movement == EntityMovementType.MOVE_JUMP) {</span>
<span class="nc bnc" id="L2424" title="All 2 branches missed.">            if (entity.hasAbility(OptionsConstants.PILOT_JUMPING_JACK)) {</span>
<span class="nc" id="L2425">                toHit.addModifier(1, &quot;attacker jumped&quot;);</span>
<span class="nc bnc" id="L2426" title="All 2 branches missed.">            } else if (entity.hasAbility(OptionsConstants.PILOT_HOPPING_JACK)) {</span>
<span class="nc" id="L2427">                toHit.addModifier(2, &quot;attacker jumped&quot;);</span>
            } else {
<span class="nc" id="L2429">                toHit.addModifier(3, &quot;attacker jumped&quot;);</span>
            }
<span class="nc bnc" id="L2431" title="All 4 branches missed.">        } else if (movement == EntityMovementType.MOVE_SPRINT</span>
                || movement == EntityMovementType.MOVE_VTOL_SPRINT) {
<span class="nc" id="L2433">            return new ToHitData(TargetRoll.AUTOMATIC_FAIL, &quot;attacker sprinted&quot;);</span>
        }

        //Dual cockpit with both pilot and gunner has lower modifier for attacker movement.
<span class="nc bnc" id="L2437" title="All 4 branches missed.">        if (toHit.getValue() != TargetRoll.AUTOMATIC_FAIL</span>
<span class="nc bnc" id="L2438" title="All 2 branches missed.">                &amp;&amp; entity instanceof Mech &amp;&amp; ((Mech) entity).getCockpitType() == Mech.COCKPIT_DUAL</span>
<span class="nc bnc" id="L2439" title="All 2 branches missed.">                &amp;&amp; entity.getCrew().hasDedicatedGunner()) {</span>
<span class="nc bnc" id="L2440" title="All 2 branches missed.">            for (TargetRollModifier mod : toHit.getModifiers()) {</span>
<span class="nc" id="L2441">                mod.setValue(mod.getValue() / 2);</span>
<span class="nc" id="L2442">            }</span>
        }
<span class="nc" id="L2444">        return toHit;</span>
    }

    /**
     * Modifier to attacks due to spotter movement
     */
    public static ToHitData getSpotterMovementModifier(IGame game, int entityId) {
<span class="nc" id="L2451">        return Compute.getSpotterMovementModifier(game, entityId,</span>
<span class="nc" id="L2452">                game.getEntity(entityId).moved);</span>
    }

    /**
     * Modifier to attacks due to spotter movement
     */
    public static ToHitData getSpotterMovementModifier(IGame game,
                                                       int entityId, EntityMovementType movement) {
<span class="nc" id="L2460">        ToHitData toHit = new ToHitData();</span>

<span class="nc" id="L2462">        Entity e = game.getEntity(entityId);</span>
<span class="nc bnc" id="L2463" title="All 4 branches missed.">        if ((e != null) &amp;&amp; (e instanceof Infantry)) {</span>
<span class="nc" id="L2464">            return toHit;</span>
        }

<span class="nc bnc" id="L2467" title="All 4 branches missed.">        if ((movement == EntityMovementType.MOVE_WALK)</span>
                || (movement == EntityMovementType.MOVE_VTOL_WALK)) {
<span class="nc" id="L2469">            toHit.addModifier(1, &quot;spotter walked&quot;);</span>
<span class="nc bnc" id="L2470" title="All 6 branches missed.">        } else if ((movement == EntityMovementType.MOVE_RUN)</span>
                || (movement == EntityMovementType.MOVE_VTOL_RUN)
                || (movement == EntityMovementType.MOVE_SKID)) {
<span class="nc" id="L2473">            toHit.addModifier(2, &quot;spotter ran&quot;);</span>
<span class="nc bnc" id="L2474" title="All 2 branches missed.">        } else if (movement == EntityMovementType.MOVE_JUMP) {</span>
<span class="nc" id="L2475">            toHit.addModifier(3, &quot;spotter jumped&quot;);</span>
<span class="nc bnc" id="L2476" title="All 4 branches missed.">        } else if (movement == EntityMovementType.MOVE_SPRINT</span>
                || movement == EntityMovementType.MOVE_VTOL_SPRINT) {
<span class="nc" id="L2478">            return new ToHitData(TargetRoll.IMPOSSIBLE, &quot;spotter sprinted&quot;);</span>
        }

<span class="nc" id="L2481">        return toHit;</span>
    }

    /**
     * Modifier to physical attack BTH due to pilot advantages
     */
    public static void modifyPhysicalBTHForAdvantages(final Entity attacker, final Entity target,
                                                      final ToHitData toHit, final IGame game) {
<span class="nc" id="L2489">        Objects.requireNonNull(attacker);</span>

<span class="nc bnc" id="L2491" title="All 4 branches missed.">        if (attacker.hasAbility(OptionsConstants.PILOT_MELEE_SPECIALIST)</span>
                &amp;&amp; (attacker instanceof Mech)) {
<span class="nc" id="L2493">            toHit.addModifier(-1, &quot;melee specialist&quot;);</span>
        }

<span class="nc bnc" id="L2496" title="All 6 branches missed.">        if (attacker.hasAbility(OptionsConstants.PILOT_TM_FROGMAN)</span>
                &amp;&amp; ((attacker instanceof Mech) || (attacker instanceof Protomech))
<span class="nc bnc" id="L2498" title="All 2 branches missed.">                &amp;&amp; (game.getBoard().getHex(attacker.getPosition()).terrainLevel(Terrains.WATER) &gt; 1)) {</span>
<span class="nc" id="L2499">            toHit.addModifier(-1, &quot;Frogman&quot;);</span>
        }

<span class="nc bnc" id="L2502" title="All 2 branches missed.">        if (attacker.hasAbility(OptionsConstants.UNOFF_CLAN_PILOT_TRAINING)) {</span>
<span class="nc" id="L2503">            toHit.addModifier(1, &quot;clan pilot training&quot;);</span>
        }

        // Mek targets that are dodging are harder to hit.
<span class="nc bnc" id="L2507" title="All 2 branches missed.">        if ((target instanceof Mech)</span>
<span class="nc bnc" id="L2508" title="All 4 branches missed.">                &amp;&amp; target.hasAbility(OptionsConstants.PILOT_DODGE_MANEUVER) &amp;&amp; target.dodging) {</span>
<span class="nc" id="L2509">            toHit.addModifier(2, &quot;target is dodging&quot;);</span>
        }
<span class="nc" id="L2511">    }</span>

    /**
     * Modifier to attacks due to target movement
     */
    public static ToHitData getTargetMovementModifier(IGame game, int entityId) {
<span class="nc" id="L2517">        Entity entity = game.getEntity(entityId);</span>

<span class="nc bnc" id="L2519" title="All 2 branches missed.">        if (entity.isAero()) {</span>
<span class="nc" id="L2520">            return new ToHitData();</span>
        }

        //If we're a trailer and being towed, return data for the tractor
<span class="nc bnc" id="L2524" title="All 4 branches missed.">        if (entity.isTrailer() &amp;&amp; entity.getTractor() != Entity.NONE) {</span>
<span class="nc" id="L2525">            return getTargetMovementModifier(game, entity.getTractor());</span>
        }

<span class="nc bnc" id="L2528" title="All 4 branches missed.">        if (game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_TACOPS_STANDING_STILL)</span>
                &amp;&amp; (entity.mpUsed == 0)
<span class="nc bnc" id="L2530" title="All 8 branches missed.">                &amp;&amp; !entity.isImmobile()</span>
                &amp;&amp; !((entity instanceof Infantry) || (entity instanceof VTOL) || (entity instanceof GunEmplacement))) {
<span class="nc" id="L2532">            ToHitData toHit = new ToHitData();</span>
<span class="nc" id="L2533">            toHit.addModifier(-1, &quot;target didn't move&quot;);</span>
<span class="nc" id="L2534">            return toHit;</span>
        }

<span class="nc bnc" id="L2537" title="All 2 branches missed.">        if (entity.isAssaultDropInProgress()) {</span>
<span class="nc" id="L2538">            ToHitData toHit = new ToHitData();</span>
<span class="nc" id="L2539">            toHit.addModifier(3, &quot;target is assault dropping&quot;);</span>
<span class="nc" id="L2540">            return toHit;</span>
        }

<span class="nc" id="L2543">        ToHitData toHit = Compute</span>
<span class="nc" id="L2544">                .getTargetMovementModifier(</span>
                        entity.delta_distance,
<span class="nc bnc" id="L2546" title="All 14 branches missed.">                        (entity.getMovementMode() != EntityMovementMode.WIGE)</span>
                                &amp;&amp; ((entity.moved == EntityMovementType.MOVE_JUMP)
                                || (entity.moved == EntityMovementType.MOVE_VTOL_RUN)
                                || (entity.moved == EntityMovementType.MOVE_VTOL_WALK)
                                || (entity.moved == EntityMovementType.MOVE_VTOL_SPRINT)),

                        (entity.moved == EntityMovementType.MOVE_VTOL_RUN)
                                || (entity.moved == EntityMovementType.MOVE_VTOL_WALK)
<span class="nc bnc" id="L2554" title="All 4 branches missed.">                                || (entity.getMovementMode() == EntityMovementMode.VTOL)</span>
                                || (entity.moved == EntityMovementType.MOVE_VTOL_SPRINT),
                        game);
<span class="nc bnc" id="L2557" title="All 6 branches missed.">        if (entity.moved != EntityMovementType.MOVE_JUMP</span>
                &amp;&amp; entity.delta_distance &gt; 0
<span class="nc bnc" id="L2559" title="All 2 branches missed.">                &amp;&amp; entity instanceof Mech &amp;&amp; ((Mech) entity).getCockpitType() == Mech.COCKPIT_DUAL</span>
<span class="nc bnc" id="L2560" title="All 2 branches missed.">                &amp;&amp; entity.getCrew().hasDedicatedPilot()) {</span>
<span class="nc bnc" id="L2561" title="All 2 branches missed.">            if (toHit.getModifiers().isEmpty()) {</span>
<span class="nc" id="L2562">                toHit.addModifier(1, &quot;target moved 1-2 hexes&quot;);</span>
            } else {
<span class="nc" id="L2564">                toHit.getModifiers().get(0).setValue(toHit.getModifiers().get(0).getValue() + 1);</span>
            }
        }

        // Did the target skid this turn?
<span class="nc bnc" id="L2569" title="All 2 branches missed.">        if (entity.moved == EntityMovementType.MOVE_SKID) {</span>
<span class="nc" id="L2570">            toHit.addModifier(2, &quot;target skidded&quot;);</span>
        }
<span class="nc bnc" id="L2572" title="All 2 branches missed.">        if ((entity.getElevation() &gt; 0)</span>
<span class="nc bnc" id="L2573" title="All 2 branches missed.">                &amp;&amp; (entity.getMovementMode() == EntityMovementMode.WIGE)) {</span>
<span class="nc" id="L2574">            toHit.addModifier(1, &quot;target is airborne&quot;);</span>
        }

        // did the target sprint?
<span class="nc bnc" id="L2578" title="All 4 branches missed.">        if (entity.moved == EntityMovementType.MOVE_SPRINT</span>
                || entity.moved == EntityMovementType.MOVE_VTOL_SPRINT) {
<span class="nc" id="L2580">            toHit.addModifier(-1, &quot;target sprinted&quot;);</span>
        }

<span class="nc" id="L2583">        return toHit;</span>
    }

    /**
     * Target movement modifer for the specified delta_distance
     */
    public static ToHitData getTargetMovementModifier(int distance,
                                                      boolean jumped, boolean isVTOL, IGame game) {
<span class="nc" id="L2591">        ToHitData toHit = new ToHitData();</span>
<span class="nc bnc" id="L2592" title="All 4 branches missed.">        if (distance == 0 &amp;&amp; !jumped) {</span>
<span class="nc" id="L2593">            return toHit;</span>
        }

<span class="nc bnc" id="L2596" title="All 2 branches missed.">        if ((game != null)</span>
<span class="nc bnc" id="L2597" title="All 2 branches missed.">                &amp;&amp; game.getOptions().booleanOption(OptionsConstants.ADVANCED_MAXTECH_MOVEMENT_MODS)) {</span>
<span class="nc bnc" id="L2598" title="All 4 branches missed.">            if ((distance &gt;= 3) &amp;&amp; (distance &lt;= 4)) {</span>
<span class="nc" id="L2599">                toHit.addModifier(1, &quot;target moved 3-4 hexes&quot;);</span>
<span class="nc bnc" id="L2600" title="All 4 branches missed.">            } else if ((distance &gt;= 5) &amp;&amp; (distance &lt;= 6)) {</span>
<span class="nc" id="L2601">                toHit.addModifier(2, &quot;target moved 5-6 hexes&quot;);</span>
<span class="nc bnc" id="L2602" title="All 4 branches missed.">            } else if ((distance &gt;= 7) &amp;&amp; (distance &lt;= 9)) {</span>
<span class="nc" id="L2603">                toHit.addModifier(3, &quot;target moved 7-9 hexes&quot;);</span>
<span class="nc bnc" id="L2604" title="All 4 branches missed.">            } else if ((distance &gt;= 10) &amp;&amp; (distance &lt;= 13)) {</span>
<span class="nc" id="L2605">                toHit.addModifier(4, &quot;target moved 10-13 hexes&quot;);</span>
<span class="nc bnc" id="L2606" title="All 4 branches missed.">            } else if ((distance &gt;= 14) &amp;&amp; (distance &lt;= 18)) {</span>
<span class="nc" id="L2607">                toHit.addModifier(5, &quot;target moved 18-24 hexes&quot;);</span>
<span class="nc bnc" id="L2608" title="All 4 branches missed.">            } else if ((distance &gt;= 19) &amp;&amp; (distance &lt;= 24)) {</span>
<span class="nc" id="L2609">                toHit.addModifier(6, &quot;target moved 18-24 hexes&quot;);</span>
<span class="nc bnc" id="L2610" title="All 2 branches missed.">            } else if (distance &gt;= 25) {</span>
<span class="nc" id="L2611">                toHit.addModifier(7, &quot;target moved 25+ hexes&quot;);</span>
            }
        } else {
<span class="nc bnc" id="L2614" title="All 4 branches missed.">            if ((distance &gt;= 3) &amp;&amp; (distance &lt;= 4)) {</span>
<span class="nc" id="L2615">                toHit.addModifier(1, &quot;target moved 3-4 hexes&quot;);</span>
<span class="nc bnc" id="L2616" title="All 4 branches missed.">            } else if ((distance &gt;= 5) &amp;&amp; (distance &lt;= 6)) {</span>
<span class="nc" id="L2617">                toHit.addModifier(2, &quot;target moved 5-6 hexes&quot;);</span>
<span class="nc bnc" id="L2618" title="All 4 branches missed.">            } else if ((distance &gt;= 7) &amp;&amp; (distance &lt;= 9)) {</span>
<span class="nc" id="L2619">                toHit.addModifier(3, &quot;target moved 7-9 hexes&quot;);</span>
<span class="nc bnc" id="L2620" title="All 4 branches missed.">            } else if ((distance &gt;= 10) &amp;&amp; (distance &lt;= 17)) {</span>
<span class="nc" id="L2621">                toHit.addModifier(4, &quot;target moved 10-17 hexes&quot;);</span>
<span class="nc bnc" id="L2622" title="All 4 branches missed.">            } else if ((distance &gt;= 18) &amp;&amp; (distance &lt;= 24)) {</span>
<span class="nc" id="L2623">                toHit.addModifier(5, &quot;target moved 18-24 hexes&quot;);</span>
<span class="nc bnc" id="L2624" title="All 2 branches missed.">            } else if (distance &gt;= 25) {</span>
<span class="nc" id="L2625">                toHit.addModifier(6, &quot;target moved 25+ hexes&quot;);</span>
            }
        }

<span class="nc bnc" id="L2629" title="All 2 branches missed.">        if (jumped) {</span>
<span class="nc bnc" id="L2630" title="All 4 branches missed.">            if (isVTOL &amp;&amp; (distance &gt; 0)) {</span>
<span class="nc" id="L2631">                toHit.addModifier(1, &quot;target VTOL used MPs&quot;);</span>
            } else {
<span class="nc" id="L2633">                toHit.addModifier(1, &quot;target jumped&quot;);</span>
            }
        }

<span class="nc" id="L2637">        return toHit;</span>
    }

    /**
     * Modifier to attacks due to attacker terrain
     */
    public static ToHitData getAttackerTerrainModifier(IGame game, int entityId) {
<span class="nc" id="L2644">        final Entity attacker = game.getEntity(entityId);</span>
<span class="nc" id="L2645">        final IHex hex = game.getBoard().getHex(attacker.getPosition());</span>

<span class="nc" id="L2647">        ToHitData toHit = new ToHitData();</span>

        // space screens; bonus depends on number (level)
<span class="nc bnc" id="L2650" title="All 4 branches missed.">        if ((hex != null) &amp;&amp; (hex.terrainLevel(Terrains.SCREEN) &gt; 0)) {</span>
<span class="nc" id="L2651">            toHit.addModifier(hex.terrainLevel(Terrains.SCREEN) + 1,</span>
                    &quot;attacker in screen(s)&quot;);
        }

<span class="nc" id="L2655">        return toHit;</span>
    }

    /**
     * Modifier to attacks due to target terrain TODO:um....should VTOLs get
     * modifiers for smoke, etc.
     */
    public static ToHitData getTargetTerrainModifier(IGame game, Targetable t) {
<span class="nc" id="L2663">        return Compute.getTargetTerrainModifier(game, t, 0);</span>
    }

    public static ToHitData getTargetTerrainModifier(IGame game, Targetable t,
                                                     int eistatus) {
<span class="nc" id="L2668">        return Compute.getTargetTerrainModifier(game, t, eistatus, false);</span>
    }

    public static ToHitData getTargetTerrainModifier(IGame game, Targetable t,
                                                     int eistatus, boolean attackerInSameBuilding) {
<span class="nc" id="L2673">        return Compute.getTargetTerrainModifier(game, t, eistatus,</span>
                attackerInSameBuilding, false);
    }

    public static ToHitData getTargetTerrainModifier(IGame game, Targetable t,
                                                     int eistatus, boolean attackerInSameBuilding,
                                                     boolean underwaterWeapon) {
<span class="nc" id="L2680">        ToHitData toHit = new ToHitData();</span>

        // no terrain mods for bombs, artillery strikes
<span class="nc bnc" id="L2683" title="All 2 branches missed.">        if (t.getTargetType() == Targetable.TYPE_HEX_AERO_BOMB ||</span>
<span class="nc bnc" id="L2684" title="All 2 branches missed.">                t.getTargetType() == Targetable.TYPE_HEX_ARTILLERY) {</span>
<span class="nc" id="L2685">            return toHit;</span>
        }

<span class="nc" id="L2688">        Entity entityTarget = null;</span>
<span class="nc" id="L2689">        IHex hex = game.getBoard().getHex(t.getPosition());</span>
<span class="nc bnc" id="L2690" title="All 2 branches missed.">        if (t.getTargetType() == Targetable.TYPE_ENTITY) {</span>
<span class="nc" id="L2691">            entityTarget = (Entity) t;</span>
<span class="nc bnc" id="L2692" title="All 2 branches missed.">            if (hex == null) {</span>
<span class="nc" id="L2693">                entityTarget.setPosition(game.getEntity(entityTarget.getId())</span>
<span class="nc" id="L2694">                        .getPosition());</span>
<span class="nc" id="L2695">                hex = game.getBoard().getHex(</span>
<span class="nc" id="L2696">                        game.getEntity(entityTarget.getId()).getPosition());</span>
            }
        }

        // if the hex doesn't exist, it's unlikely to have terrain modifiers
<span class="nc bnc" id="L2701" title="All 2 branches missed.">        if (hex == null) {</span>
<span class="nc" id="L2702">            return toHit;</span>
        }


<span class="nc bnc" id="L2706" title="All 4 branches missed.">        boolean hasWoods = hex.containsTerrain(Terrains.WOODS) || hex.containsTerrain(Terrains.JUNGLE);</span>
        // Standard mechs (standing) report their height as 1, tanks as 0
        // Standard mechs should not benefit from 1 level high woods

<span class="nc bnc" id="L2710" title="All 2 branches missed.">        boolean isAboveWoods = (entityTarget == null)</span>
<span class="nc bnc" id="L2711" title="All 2 branches missed.">                || (entityTarget.relHeight() + 1 &gt; hex.terrainLevel(Terrains.FOLIAGE_ELEV))</span>
<span class="nc bnc" id="L2712" title="All 4 branches missed.">                || entityTarget.isAirborne()</span>
                || !hasWoods;
<span class="nc bnc" id="L2714" title="All 2 branches missed.">        boolean isAboveSmoke = (entityTarget == null)</span>
<span class="nc bnc" id="L2715" title="All 2 branches missed.">                || (entityTarget.relHeight() + 1 &gt; 2)</span>
<span class="nc bnc" id="L2716" title="All 2 branches missed.">                || !hex.containsTerrain(Terrains.SMOKE);</span>
<span class="nc bnc" id="L2717" title="All 2 branches missed.">        boolean isUnderwater = (entityTarget != null)</span>
<span class="nc bnc" id="L2718" title="All 4 branches missed.">                &amp;&amp; hex.containsTerrain(Terrains.WATER) &amp;&amp; (hex.depth() &gt; 0)</span>
<span class="nc bnc" id="L2719" title="All 2 branches missed.">                &amp;&amp; (entityTarget.getElevation() &lt; hex.surface());</span>

        // if we have in-building combat, it's a +1
<span class="nc bnc" id="L2722" title="All 2 branches missed.">        if (attackerInSameBuilding) {</span>
<span class="nc" id="L2723">            toHit.addModifier(1, &quot;target in a building hex&quot;);</span>
        }

        // Smoke and woods. With L3, the effects STACK.
<span class="nc" id="L2727">        int woodsLevel = hex.terrainLevel(Terrains.WOODS);</span>
<span class="nc" id="L2728">        int jungleLevel = hex.terrainLevel(Terrains.JUNGLE);</span>
<span class="nc" id="L2729">        String woodsText = &quot;woods&quot;;</span>
<span class="nc bnc" id="L2730" title="All 2 branches missed.">        if (woodsLevel &lt; jungleLevel) {</span>
<span class="nc" id="L2731">            woodsLevel = jungleLevel;</span>
<span class="nc" id="L2732">            woodsText = &quot;jungle&quot;;</span>
        }
<span class="nc bnc" id="L2734" title="All 2 branches missed.">        if (woodsLevel == 1) {</span>
<span class="nc" id="L2735">            woodsText = &quot;target in light &quot; + woodsText;</span>
<span class="nc bnc" id="L2736" title="All 2 branches missed.">        } else if (woodsLevel == 2) {</span>
<span class="nc" id="L2737">            woodsText = &quot;target in heavy &quot; + woodsText;</span>
<span class="nc bnc" id="L2738" title="All 2 branches missed.">        } else if (woodsLevel == 3) {</span>
<span class="nc" id="L2739">            woodsText = &quot;target in ultra heavy &quot; + woodsText;</span>
        }

<span class="nc bnc" id="L2742" title="All 4 branches missed.">        if (!game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_WOODS_COVER)</span>
                &amp;&amp; !isAboveWoods
<span class="nc bnc" id="L2744" title="All 2 branches missed.">                &amp;&amp; !((t.getTargetType() == Targetable.TYPE_HEX_CLEAR)</span>
<span class="nc bnc" id="L2745" title="All 2 branches missed.">                || (t.getTargetType() == Targetable.TYPE_HEX_IGNITE)</span>
<span class="nc bnc" id="L2746" title="All 2 branches missed.">                || (t.getTargetType() == Targetable.TYPE_HEX_BOMB)</span>
<span class="nc bnc" id="L2747" title="All 2 branches missed.">                || (t.getTargetType() == Targetable.TYPE_HEX_ARTILLERY)</span>
<span class="nc bnc" id="L2748" title="All 2 branches missed.">                || (t.getTargetType() == Targetable.TYPE_MINEFIELD_DELIVER))) {</span>
<span class="nc bnc" id="L2749" title="All 4 branches missed.">            if ((woodsLevel == 1) &amp;&amp; (eistatus != 2)) {</span>
<span class="nc" id="L2750">                toHit.addModifier(1, woodsText);</span>
<span class="nc bnc" id="L2751" title="All 2 branches missed.">            } else if (woodsLevel &gt; 1) {</span>
<span class="nc bnc" id="L2752" title="All 2 branches missed.">                if (eistatus &gt; 0) {</span>
<span class="nc" id="L2753">                    toHit.addModifier(woodsLevel - 1, woodsText);</span>
                } else {
<span class="nc" id="L2755">                    toHit.addModifier(woodsLevel, woodsText);</span>
                }
            }
        }
<span class="nc bnc" id="L2759" title="All 6 branches missed.">        if (!isAboveSmoke &amp;&amp; !isUnderwater &amp;&amp; !underwaterWeapon) {</span>
<span class="nc bnc" id="L2760" title="All 2 branches missed.">            if ((hex.terrainLevel(Terrains.SMOKE) == SmokeCloud.SMOKE_LIGHT)</span>
<span class="nc bnc" id="L2761" title="All 2 branches missed.">                    || (hex.terrainLevel(Terrains.SMOKE) == SmokeCloud.SMOKE_LI_LIGHT)</span>
<span class="nc bnc" id="L2762" title="All 2 branches missed.">                    || (hex.terrainLevel(Terrains.SMOKE) == SmokeCloud.SMOKE_LI_HEAVY)</span>
<span class="nc bnc" id="L2763" title="All 2 branches missed.">                    || (hex.terrainLevel(Terrains.SMOKE) == SmokeCloud.SMOKE_CHAFF_LIGHT)) {</span>
<span class="nc" id="L2764">                toHit.addModifier(1, &quot;target in light smoke&quot;);</span>
<span class="nc bnc" id="L2765" title="All 2 branches missed.">            } else if (hex.terrainLevel(Terrains.SMOKE) == SmokeCloud.SMOKE_HEAVY) {</span>
<span class="nc bnc" id="L2766" title="All 2 branches missed.">                if (eistatus &gt; 0) {</span>
<span class="nc" id="L2767">                    toHit.addModifier(1, &quot;target in heavy smoke&quot;);</span>
                } else {
<span class="nc" id="L2769">                    toHit.addModifier(2, &quot;target in heavy smoke&quot;);</span>
                }
            }
        }
<span class="nc bnc" id="L2773" title="All 2 branches missed.">        if (hex.terrainLevel(Terrains.GEYSER) == 2) {</span>
<span class="nc bnc" id="L2774" title="All 2 branches missed.">            if (eistatus &gt; 0) {</span>
<span class="nc" id="L2775">                toHit.addModifier(1, &quot;target in erupting geyser&quot;);</span>
            } else {
<span class="nc" id="L2777">                toHit.addModifier(2, &quot;target in erupting geyser&quot;);</span>
            }
        }

<span class="nc bnc" id="L2781" title="All 2 branches missed.">        if (hex.containsTerrain(Terrains.INDUSTRIAL)) {</span>
<span class="nc" id="L2782">            toHit.addModifier(+1, &quot;target in heavy industrial zone&quot;);</span>
        }
        // space screens; bonus depends on number (level)
<span class="nc bnc" id="L2785" title="All 2 branches missed.">        if (hex.terrainLevel(Terrains.SCREEN) &gt; 0) {</span>
<span class="nc" id="L2786">            toHit.addModifier(hex.terrainLevel(Terrains.SCREEN) + 1,</span>
                    &quot;target in screen(s)&quot;);
        }

        // only entities get remaining terrain bonuses
        // TODO: should this be changed for buildings???
<span class="nc bnc" id="L2792" title="All 2 branches missed.">        if (entityTarget == null) {</span>
<span class="nc" id="L2793">            return toHit;</span>
<span class="nc bnc" id="L2794" title="All 2 branches missed.">        } else if (entityTarget.isMakingDfa()) {</span>
            // you don't get terrain modifiers in midair
            // should be abstracted more into a 'not on the ground'
            // flag for vtols and such
<span class="nc" id="L2798">            return toHit;</span>
        }

<span class="nc bnc" id="L2801" title="All 2 branches missed.">        if (entityTarget.isStuck()) {</span>
<span class="nc" id="L2802">            toHit.addModifier(-2, &quot;target stuck in swamp&quot;);</span>
        }
<span class="nc bnc" id="L2804" title="All 2 branches missed.">        if ((entityTarget instanceof Infantry)</span>
<span class="nc bnc" id="L2805" title="All 2 branches missed.">                &amp;&amp; hex.containsTerrain(Terrains.FIELDS)) {</span>
<span class="nc" id="L2806">            toHit.addModifier(+1, &quot;target in planted fields&quot;);</span>
        }
<span class="nc" id="L2808">        return toHit;</span>
    }

    public static ToHitData getStrafingTerrainModifier(IGame game,
                                                       int eistatus, IHex hex) {
<span class="nc" id="L2813">        ToHitData toHit = new ToHitData();</span>
        // Smoke and woods. With L3, the effects STACK.
<span class="nc" id="L2815">        int woodsLevel = hex.terrainLevel(Terrains.WOODS);</span>
<span class="nc" id="L2816">        int jungleLevel = hex.terrainLevel(Terrains.JUNGLE);</span>
<span class="nc" id="L2817">        String woodsText = &quot;woods&quot;;</span>
<span class="nc bnc" id="L2818" title="All 2 branches missed.">        if (woodsLevel &lt; jungleLevel) {</span>
<span class="nc" id="L2819">            woodsLevel = jungleLevel;</span>
<span class="nc" id="L2820">            woodsText = &quot;jungle&quot;;</span>
        }
<span class="nc bnc" id="L2822" title="All 2 branches missed.">        if (woodsLevel == 1) {</span>
<span class="nc" id="L2823">            woodsText = &quot;light &quot; + woodsText;</span>
<span class="nc bnc" id="L2824" title="All 2 branches missed.">        } else if (woodsLevel == 2) {</span>
<span class="nc" id="L2825">            woodsText = &quot;heavy &quot; + woodsText;</span>
<span class="nc bnc" id="L2826" title="All 2 branches missed.">        } else if (woodsLevel == 3) {</span>
<span class="nc" id="L2827">            woodsText = &quot;heavy &quot; + woodsText;</span>
        }

<span class="nc bnc" id="L2830" title="All 2 branches missed.">        if (!game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_WOODS_COVER)) {</span>
<span class="nc bnc" id="L2831" title="All 4 branches missed.">            if ((woodsLevel == 1) &amp;&amp; (eistatus != 2)) {</span>
<span class="nc" id="L2832">                toHit.addModifier(1, woodsText);</span>
<span class="nc bnc" id="L2833" title="All 2 branches missed.">            } else if (woodsLevel &gt; 1) {</span>
<span class="nc bnc" id="L2834" title="All 2 branches missed.">                if (eistatus &gt; 0) {</span>
<span class="nc" id="L2835">                    toHit.addModifier(woodsLevel - 1, woodsText);</span>
                } else {
<span class="nc" id="L2837">                    toHit.addModifier(woodsLevel, woodsText);</span>
                }
            }
        }

<span class="nc bnc" id="L2842" title="All 2 branches missed.">        if ((hex.terrainLevel(Terrains.SMOKE) == SmokeCloud.SMOKE_LIGHT)</span>
<span class="nc bnc" id="L2843" title="All 2 branches missed.">                || (hex.terrainLevel(Terrains.SMOKE) == SmokeCloud.SMOKE_LI_LIGHT)</span>
<span class="nc bnc" id="L2844" title="All 2 branches missed.">                || (hex.terrainLevel(Terrains.SMOKE) == SmokeCloud.SMOKE_LI_HEAVY)</span>
<span class="nc bnc" id="L2845" title="All 2 branches missed.">                || (hex.terrainLevel(Terrains.SMOKE) == SmokeCloud.SMOKE_CHAFF_LIGHT)) {</span>
<span class="nc" id="L2846">            toHit.addModifier(1, &quot;light smoke&quot;);</span>
<span class="nc bnc" id="L2847" title="All 2 branches missed.">        } else if (hex.terrainLevel(Terrains.SMOKE) == SmokeCloud.SMOKE_HEAVY) {</span>
<span class="nc bnc" id="L2848" title="All 2 branches missed.">            if (eistatus &gt; 0) {</span>
<span class="nc" id="L2849">                toHit.addModifier(1, &quot;heavy smoke&quot;);</span>
            } else {
<span class="nc" id="L2851">                toHit.addModifier(2, &quot;heavy smoke&quot;);</span>
            }
        }

<span class="nc bnc" id="L2855" title="All 2 branches missed.">        if (hex.terrainLevel(Terrains.GEYSER) == 2) {</span>
<span class="nc bnc" id="L2856" title="All 2 branches missed.">            if (eistatus &gt; 0) {</span>
<span class="nc" id="L2857">                toHit.addModifier(1, &quot;erupting geyser&quot;);</span>
            } else {
<span class="nc" id="L2859">                toHit.addModifier(2, &quot;erupting geyser&quot;);</span>
            }
        }
<span class="nc" id="L2862">        return toHit;</span>
    }

    /**
     * Calculates the current theoretical damage absorbable(armor+structure, etc) by the given target.
     * Used as a measure of the potential durability of the target under fire.
     */
    public static int getTargetTotalHP(IGame game, Targetable target) {
<span class="nc" id="L2870">        int targetType = target.getTargetType();</span>
<span class="nc" id="L2871">        int targetId = target.getTargetId();</span>
<span class="nc" id="L2872">        Coords position = target.getPosition();</span>

        //First, handle buildings versus entities, since they are handled differently.
<span class="nc bnc" id="L2875" title="All 2 branches missed.">        if (targetType == Targetable.TYPE_BUILDING) {</span>
            //Buildings are a simple sum of their current CF and armor values.
<span class="nc" id="L2877">            Building parentBuilding = game.getBoard().getBuildingAt(position); //the building the targeted hex belongs to. We have to get this and then get values for the specific hex internally to it.</span>
<span class="nc" id="L2878">            int targetCF = parentBuilding.getCurrentCF(position);</span>
<span class="nc" id="L2879">            int targetArmor = parentBuilding.getArmor(position);</span>
<span class="nc" id="L2880">            return targetCF + targetArmor;</span>
<span class="nc bnc" id="L2881" title="All 2 branches missed.">        } else if (targetType == Targetable.TYPE_ENTITY) {</span>
            //I don't *think* we have to handle infantry differently here- I think these methods should return the total number of men remaining as internal structure.
<span class="nc" id="L2883">            Entity targetEntity = game.getEntity(targetId);</span>

<span class="nc bnc" id="L2885" title="All 2 branches missed.">            if (targetEntity instanceof GunEmplacement) { //If this is a gun emplacement, handle it as the building hex it is in.</span>
<span class="nc" id="L2886">                Building parentBuilding = game.getBoard().getBuildingAt(position);</span>
<span class="nc" id="L2887">                int targetCF = parentBuilding.getCurrentCF(position);</span>
<span class="nc" id="L2888">                int targetArmor = parentBuilding.getArmor(position);</span>
<span class="nc" id="L2889">                return targetCF + targetArmor;</span>
            }
<span class="nc" id="L2891">            int targetArmor = targetEntity.getTotalArmor();</span>
<span class="nc" id="L2892">            int targetStructure = targetEntity.getTotalInternal();</span>
<span class="nc" id="L2893">            return targetArmor + targetStructure;</span>
<span class="nc bnc" id="L2894" title="All 2 branches missed.">        } else if (targetType == Targetable.TYPE_HEX_CLEAR) {</span>
            // clearing a hex - the &quot;HP&quot; is the terrain factor of destroyable terrain on this hex
<span class="nc" id="L2896">            IHex mhex = game.getBoard().getHex(position);</span>
<span class="nc" id="L2897">            int terrainTypes[] = mhex.getTerrainTypes();</span>
<span class="nc" id="L2898">            int totalTF = 0;</span>

<span class="nc bnc" id="L2900" title="All 2 branches missed.">            for (int i = 0; i &lt; terrainTypes.length; i++) {</span>
<span class="nc" id="L2901">                int tf = 0;</span>
<span class="nc" id="L2902">                int terType = terrainTypes[i];</span>
<span class="nc bnc" id="L2903" title="All 2 branches missed.">                if (mhex.containsTerrain(terType)) {</span>
<span class="nc" id="L2904">                    tf = mhex.getTerrain(terType).getTerrainFactor();</span>
                }

<span class="nc" id="L2907">                totalTF += tf;</span>
            }

<span class="nc" id="L2910">            return totalTF;</span>
        } else { //something else, e.g. terrain. We probably don't need to handle it for now.
<span class="nc" id="L2912">            return 0;</span>
        }
    }

    /**
     * Returns the weapon attack out of a list that has the highest expected
     * damage
     */
    public static WeaponAttackAction getHighestExpectedDamage(IGame g,
                                                              List&lt;WeaponAttackAction&gt; vAttacks, boolean assumeHit) {
<span class="nc" id="L2922">        float fHighest = -1.0f;</span>
<span class="nc" id="L2923">        WeaponAttackAction waaHighest = null;</span>
<span class="nc bnc" id="L2924" title="All 2 branches missed.">        for (int x = 0, n = vAttacks.size(); x &lt; n; x++) {</span>
<span class="nc" id="L2925">            WeaponAttackAction waa = vAttacks.get(x);</span>
<span class="nc" id="L2926">            float fDanger = Compute.getExpectedDamage(g, waa, assumeHit);</span>
<span class="nc bnc" id="L2927" title="All 2 branches missed.">            if (fDanger &gt; fHighest) {</span>
<span class="nc" id="L2928">                fHighest = fDanger;</span>
<span class="nc" id="L2929">                waaHighest = waa;</span>
            }
        }
<span class="nc" id="L2932">        return waaHighest;</span>
    }

    // store these as constants since the tables will never change
<span class="fc" id="L2936">    private static float[] expectedHitsByRackSize = {0.0f, 1.0f, 1.58f, 2.0f,</span>
            2.63f, 3.17f, 4.0f, 4.49f, 4.98f, 5.47f, 6.31f, 7.23f, 8.14f,
            8.59f, 9.04f, 9.5f, 10.1f, 10.8f, 11.42f, 12.1f, 12.7f};

    /*
     * | No Modifier | +2 (Artemis, Narc) | -2 (HAG, AMS v Art)| -4 (AMS) | |
     * Avg | Avg | Avg | Avg | | Hits Pct | Hits Pct | Hits Pct | Hits Pct | |
     * Avg Per vs | Avg Per vs | Avg Per vs | Avg Per vs | Size| Hits Size Avg |
     * Hits Size Avg | Hits Size Avg | Hits Size Avg |
     * ----+--------------------+
     * --------------------+--------------------+--------------------+ 2 | 1.42
     * 0.708 9.1 | 1.72 0.861 10.3 | 1.17 0.583 10.7 | 1.03 0.514 21.9 | 3 |
     * 2.00 0.667 2.7 | 2.39 0.796 2.0 | 1.61 0.537 2.0 | 1.28 0.426 1.0 | 4 |
     * 2.64 0.660 1.6 | 3.11 0.778 -0.4 | 2.11 0.528 0.2 | 1.67 0.417 -1.2 | 5 |
     * 3.17 0.633 -2.5 | 3.83 0.767 -1.8 | 2.50 0.500 -5.1 | 1.86 0.372 -11.7 |
     * 6 | 4.00 0.667 2.7 | 4.78 0.796 2.0 | 3.22 0.537 2.0 | 2.58 0.431 2.1 | 7
     * | 4.39 0.627 -3.4 | 5.42 0.774 -0.9 | 3.47 0.496 -5.8 | 2.69 0.385 -8.7 |
     * 8 | 5.08 0.635 -2.1 | 6.06 0.757 -3.0 | 4.22 0.528 0.2 | 3.58 0.448 6.2 |
     * 9 | 5.47 0.608 -6.4 | 6.69 0.744 -4.7 | 4.47 0.497 -5.7 | 3.69 0.410 -2.7
     * | 10 | 6.31 0.631 -2.9 | 7.67 0.767 -1.8 | 5.06 0.506 -4.0 | 3.97 0.397
     * -5.8 | 11 | 7.31 0.664 2.3 | 8.67 0.788 0.9 | 6.06 0.551 4.5 | 4.97 0.452
     * 7.2 | 12 | 8.14 0.678 4.5 | 9.64 0.803 2.9 | 6.64 0.553 5.0 | 5.25 0.438
     * 3.7 | 13 | 8.42 0.647 -0.3 | 10.22 0.786 0.7 | 6.72 0.517 -1.8 | 5.25
     * 0.404 -4.2 | 14 | 9.22 0.659 1.5 | 10.92 0.780 -0.1 | 7.64 0.546 3.6 |
     * 6.25 0.446 5.9 | 15 | 9.50 0.633 -2.5 | 11.50 0.767 -1.8 | 7.72 0.515
     * -2.3 | 6.25 0.417 -1.2 | 16 | 10.42 0.651 0.3 | 12.50 0.781 0.1 | 8.44
     * 0.528 0.2 | 6.67 0.417 -1.2 | 17 | 10.69 0.629 -3.1 | 13.08 0.770 -1.4 |
     * 8.53 0.502 -4.8 | 6.67 0.392 -7.0 | 18 | 11.50 0.639 -1.6 | 13.78 0.765
     * -1.9 | 9.44 0.525 -0.4 | 7.67 0.426 1.0 | 19 | 11.78 0.620 -4.5 | 14.36
     * 0.756 -3.2 | 9.53 0.501 -4.8 | 7.67 0.404 -4.3 | 20 | 12.69 0.635 -2.2 |
     * 15.36 0.768 -1.6 | 10.25 0.512 -2.7 | 8.08 0.404 -4.2 | 21 | 13.61 0.648
     * -0.2 | 16.33 0.778 -0.4 | 11.11 0.529 0.4 | 8.94 0.426 1.0 | 22 | 14.44
     * 0.657 1.1 | 17.31 0.787 0.8 | 11.69 0.532 0.9 | 9.22 0.419 -0.6 | 23 |
     * 15.36 0.668 2.9 | 18.31 0.796 2.0 | 12.42 0.540 2.5 | 9.64 0.419 -0.6 |
     * 24 | 16.28 0.678 4.5 | 19.28 0.803 2.9 | 13.28 0.553 5.0 | 10.50 0.438
     * 3.7 | 25 | 16.56 0.662 2.0 | 19.86 0.794 1.8 | 13.36 0.534 1.5 | 10.50
     * 0.420 -0.4 | 26 | 17.36 0.668 2.8 | 20.56 0.791 1.3 | 14.28 0.549 4.2 |
     * 11.50 0.442 4.9 | 27 | 17.64 0.653 0.6 | 21.14 0.783 0.3 | 14.36 0.532
     * 1.0 | 11.50 0.426 1.0 | 28 | 17.92 0.640 -1.4 | 21.72 0.776 -0.6 | 14.44
     * 0.516 -2.1 | 11.50 0.411 -2.6 | 29 | 18.72 0.646 -0.6 | 22.42 0.773 -1.0
     * | 15.36 0.530 0.6 | 12.50 0.431 2.2 | 30 | 19.00 0.633 -2.5 | 23.00 0.767
     * -1.8 | 15.44 0.515 -2.3 | 12.50 0.417 -1.2 | 40 | 25.39 0.635 -2.2 |
     * 30.72 0.768 -1.6 | 20.50 0.512 -2.7 | 16.17 0.404 -4.2 | ----- -----
     * ----- ----- Average: 0.649 0.781 0.527 0.422 1.202 0.811 0.649
     */

    /**
     * Determines the expected damage of a weapon attack, based on to-hit, salvo
     * sizes, etc.
     */
    public static float getExpectedDamage(IGame g, WeaponAttackAction waa,
                                          boolean assumeHit) {
<span class="nc" id="L2988">        return Compute.getExpectedDamage(g, waa, assumeHit, null);</span>
    }

    /**
     * Determines the expected damage of a weapon attack, based on to-hit, salvo
     * sizes, etc.
     */
    public static float getExpectedDamage(IGame g, WeaponAttackAction waa,
                                          boolean assumeHit, List&lt;ECMInfo&gt; allECMInfo) {
<span class="nc" id="L2997">        boolean use_table = false;</span>

<span class="nc" id="L2999">        AmmoType loaded_ammo = new AmmoType();</span>

<span class="nc" id="L3001">        Entity attacker = g.getEntity(waa.getEntityId());</span>
<span class="nc" id="L3002">        Entity target = g.getEntity(waa.getTargetId());</span>

<span class="nc bnc" id="L3004" title="All 2 branches missed.">        int baShootingStrength = attacker instanceof BattleArmor ?</span>
<span class="nc" id="L3005">                ((BattleArmor) attacker).getShootingStrength() : 0;</span>

<span class="nc" id="L3007">        int infShootingStrength = 0;</span>
<span class="nc" id="L3008">        double infDamagePerTrooper = 0;</span>

<span class="nc" id="L3010">        Mounted weapon = attacker.getEquipment(waa.getWeaponId());</span>
        Mounted lnk_guide;

<span class="nc" id="L3013">        ToHitData hitData = waa.toHit(g, allECMInfo);</span>

<span class="nc bnc" id="L3015" title="All 2 branches missed.">        if (attacker.isConventionalInfantry()) {</span>
<span class="nc" id="L3016">            infShootingStrength = ((Infantry) attacker).getShootingStrength();</span>
<span class="nc" id="L3017">            infDamagePerTrooper = ((Infantry) attacker).getDamagePerTrooper();</span>
        }

<span class="nc" id="L3020">        WeaponType wt = (WeaponType) weapon.getType();</span>

<span class="nc" id="L3022">        float fDamage = 0.0f;</span>
<span class="nc" id="L3023">        float fChance = 0.0f;</span>
<span class="nc bnc" id="L3024" title="All 2 branches missed.">        if (assumeHit) {</span>
<span class="nc" id="L3025">            fChance = 1.0f;</span>
        } else {
<span class="nc bnc" id="L3027" title="All 2 branches missed.">            if ((hitData.getValue() == TargetRoll.IMPOSSIBLE)</span>
<span class="nc bnc" id="L3028" title="All 2 branches missed.">                    || (hitData.getValue() == TargetRoll.AUTOMATIC_FAIL)) {</span>
<span class="nc" id="L3029">                return 0.0f;</span>
            }

<span class="nc bnc" id="L3032" title="All 2 branches missed.">            if (hitData.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {</span>
<span class="nc" id="L3033">                fChance = 1.0f;</span>
            } else {
<span class="nc" id="L3035">                fChance = (float) Compute.oddsAbove(hitData.getValue(),</span>
<span class="nc" id="L3036">                        attacker.hasAbility(OptionsConstants.PILOT_APTITUDE_GUNNERY))</span>
                        / 100.0f;
            }
        }

        // Missiles, HAGs, LBX cluster rounds, and ultra/rotary cannons (when
        // spun up)
        // use the missile hits table
<span class="nc bnc" id="L3044" title="All 2 branches missed.">        if (wt.getDamage() == WeaponType.DAMAGE_BY_CLUSTERTABLE) {</span>
<span class="nc" id="L3045">            use_table = true;</span>
        }

        //Unless it's a fighter squadron, which uses a weird group of single weapons and should return mass AV
<span class="nc bnc" id="L3049" title="All 2 branches missed.">        if (attacker.isCapitalFighter()) {</span>
<span class="nc" id="L3050">            use_table = false;</span>
        }

<span class="nc bnc" id="L3053" title="All 2 branches missed.">        if ((wt.getAmmoType() == AmmoType.T_AC_LBX)</span>
<span class="nc bnc" id="L3054" title="All 2 branches missed.">                || (wt.getAmmoType() == AmmoType.T_AC_LBX_THB)</span>
<span class="nc bnc" id="L3055" title="All 2 branches missed.">                || (wt.getAmmoType() == AmmoType.T_AC_LBX_THB)) {</span>
<span class="nc" id="L3056">            loaded_ammo = (AmmoType) weapon.getLinked().getType();</span>
<span class="nc bnc" id="L3057" title="All 2 branches missed.">            if (((loaded_ammo.getAmmoType() == AmmoType.T_AC_LBX) || (loaded_ammo</span>
<span class="nc bnc" id="L3058" title="All 2 branches missed.">                    .getAmmoType() == AmmoType.T_AC_LBX_THB))</span>
<span class="nc bnc" id="L3059" title="All 2 branches missed.">                    &amp;&amp; (loaded_ammo.getMunitionType() == AmmoType.M_CLUSTER)) {</span>
<span class="nc" id="L3060">                use_table = true;</span>
            }
        }

<span class="nc bnc" id="L3064" title="All 2 branches missed.">        if ((wt.getAmmoType() == AmmoType.T_AC_ULTRA)</span>
<span class="nc bnc" id="L3065" title="All 2 branches missed.">                || (wt.getAmmoType() == AmmoType.T_AC_ULTRA_THB)</span>
<span class="nc bnc" id="L3066" title="All 2 branches missed.">                || (wt.getAmmoType() == AmmoType.T_AC_ROTARY)) {</span>
<span class="nc bnc" id="L3067" title="All 2 branches missed.">            if ((weapon.curMode().getName().equals(&quot;Ultra&quot;))</span>
<span class="nc bnc" id="L3068" title="All 2 branches missed.">                    || (weapon.curMode().getName().equals(&quot;2-shot&quot;))</span>
<span class="nc bnc" id="L3069" title="All 2 branches missed.">                    || (weapon.curMode().getName().equals(&quot;3-shot&quot;))</span>
<span class="nc bnc" id="L3070" title="All 2 branches missed.">                    || (weapon.curMode().getName().equals(&quot;4-shot&quot;))</span>
<span class="nc bnc" id="L3071" title="All 2 branches missed.">                    || (weapon.curMode().getName().equals(&quot;5-shot&quot;))</span>
<span class="nc bnc" id="L3072" title="All 2 branches missed.">                    || (weapon.curMode().getName().equals(&quot;6-shot&quot;))) {</span>
<span class="nc" id="L3073">                use_table = true;</span>
            }
        }

        // Kinda cheap, but lets use the missile hits table for Battle armor
        // weapons too

<span class="nc bnc" id="L3080" title="All 2 branches missed.">        if (attacker instanceof BattleArmor) {</span>
<span class="nc bnc" id="L3081" title="All 2 branches missed.">            if ((wt.getInternalName() != Infantry.SWARM_MEK)</span>
<span class="nc bnc" id="L3082" title="All 2 branches missed.">                    &amp;&amp; (wt.getInternalName() != Infantry.LEG_ATTACK)) {</span>
<span class="nc" id="L3083">                use_table = true;</span>
            }
        }

<span class="nc bnc" id="L3087" title="All 2 branches missed.">        if (use_table == true) {</span>
<span class="nc bnc" id="L3088" title="All 2 branches missed.">            if (!(attacker instanceof BattleArmor)) {</span>
<span class="nc bnc" id="L3089" title="All 2 branches missed.">                if (weapon.getLinked() == null) {</span>
<span class="nc" id="L3090">                    return 0.0f;</span>
                }
            }
<span class="nc" id="L3093">            AmmoType at = null;</span>
<span class="nc bnc" id="L3094" title="All 2 branches missed.">            if ((weapon.getLinked() != null)</span>
<span class="nc bnc" id="L3095" title="All 2 branches missed.">                    &amp;&amp; (weapon.getLinked().getType() instanceof AmmoType)) {</span>
<span class="nc" id="L3096">                at = (AmmoType) weapon.getLinked().getType();</span>
<span class="nc" id="L3097">                fDamage = at.getDamagePerShot();</span>
            }

<span class="nc" id="L3100">            float fHits = 0.0f;</span>
<span class="nc bnc" id="L3101" title="All 4 branches missed.">            if ((wt.getRackSize() != 40) &amp;&amp; (wt.getRackSize() != 30)) {</span>
<span class="nc" id="L3102">                fHits = expectedHitsByRackSize[wt.getRackSize()];</span>
            } else {
<span class="nc" id="L3104">                fHits = 2.0f * expectedHitsByRackSize[wt.getRackSize() / 2];</span>
            }
<span class="nc bnc" id="L3106" title="All 2 branches missed.">            if (((wt.getAmmoType() == AmmoType.T_SRM_STREAK)</span>
<span class="nc bnc" id="L3107" title="All 2 branches missed.">                    || (wt.getAmmoType() == AmmoType.T_MRM_STREAK) || (wt</span>
<span class="nc bnc" id="L3108" title="All 2 branches missed.">                    .getAmmoType() == AmmoType.T_LRM_STREAK))</span>
<span class="nc bnc" id="L3109" title="All 2 branches missed.">                    &amp;&amp; !ComputeECM.isAffectedByAngelECM(attacker, attacker</span>
<span class="nc" id="L3110">                            .getPosition(), waa.getTarget(g).getPosition(),</span>
                    allECMInfo)) {
<span class="nc" id="L3112">                fHits = wt.getRackSize();</span>
            }
<span class="nc bnc" id="L3114" title="All 2 branches missed.">            if ((wt.getAmmoType() == AmmoType.T_AC_ULTRA)</span>
<span class="nc bnc" id="L3115" title="All 2 branches missed.">                    || (wt.getAmmoType() == AmmoType.T_AC_ULTRA_THB)</span>
<span class="nc bnc" id="L3116" title="All 2 branches missed.">                    || (wt.getAmmoType() == AmmoType.T_AC_ROTARY)) {</span>
<span class="nc bnc" id="L3117" title="All 2 branches missed.">                if ((weapon.curMode().getName().equals(&quot;Ultra&quot;))</span>
<span class="nc bnc" id="L3118" title="All 2 branches missed.">                        || (weapon.curMode().getName().equals(&quot;2-shot&quot;))) {</span>
<span class="nc" id="L3119">                    fHits = expectedHitsByRackSize[2];</span>
                }
<span class="nc bnc" id="L3121" title="All 2 branches missed.">                if (weapon.curMode().getName().equals(&quot;3-shot&quot;)) {</span>
<span class="nc" id="L3122">                    fHits = expectedHitsByRackSize[3];</span>
                }
<span class="nc bnc" id="L3124" title="All 2 branches missed.">                if (weapon.curMode().getName().equals(&quot;4-shot&quot;)) {</span>
<span class="nc" id="L3125">                    fHits = expectedHitsByRackSize[4];</span>
                }
<span class="nc bnc" id="L3127" title="All 2 branches missed.">                if (weapon.curMode().getName().equals(&quot;5-shot&quot;)) {</span>
<span class="nc" id="L3128">                    fHits = expectedHitsByRackSize[5];</span>
                }
<span class="nc bnc" id="L3130" title="All 2 branches missed.">                if (weapon.curMode().getName().equals(&quot;6-shot&quot;)) {</span>
<span class="nc" id="L3131">                    fHits = expectedHitsByRackSize[6];</span>
                }
            }

            // Most Battle Armor units have a weapon per trooper, plus their
            // weapons do odd things when mounting multiples
<span class="nc bnc" id="L3137" title="All 2 branches missed.">            if (attacker instanceof BattleArmor) {</span>
                // The number of troopers hitting
<span class="nc" id="L3139">                fHits = expectedHitsByRackSize[baShootingStrength];</span>
<span class="nc bnc" id="L3140" title="All 2 branches missed.">                if (wt.getDamage() == WeaponType.DAMAGE_BY_CLUSTERTABLE) {</span>
<span class="nc" id="L3141">                    fHits *= expectedHitsByRackSize[wt.getRackSize()];</span>
                }
<span class="nc bnc" id="L3143" title="All 2 branches missed.">                if (wt.getDamage() != WeaponType.DAMAGE_BY_CLUSTERTABLE) {</span>
<span class="nc bnc" id="L3144" title="All 2 branches missed.">                    if (wt.getDamage() != WeaponType.DAMAGE_VARIABLE) {</span>
<span class="nc" id="L3145">                        fDamage = wt.getDamage();</span>
                    } else {
<span class="nc" id="L3147">                        fDamage = wt.getRackSize();</span>
                    }
                }
<span class="nc bnc" id="L3150" title="All 2 branches missed.">                if (wt.hasFlag(WeaponType.F_MISSILE_HITS)) {</span>
<span class="nc" id="L3151">                    fHits *= expectedHitsByRackSize[wt.getRackSize()];</span>
                }
            }

            // If there is no ECM coverage to the target, guidance systems are
            // good for another 1.20x damage on missile weapons
<span class="nc bnc" id="L3157" title="All 2 branches missed.">            if ((!ComputeECM.isAffectedByECM(attacker, attacker.getPosition(), g</span>
<span class="nc" id="L3158">                    .getEntity(waa.getTargetId()).getPosition(), allECMInfo))</span>
<span class="nc bnc" id="L3159" title="All 2 branches missed.">                    &amp;&amp; (wt.getDamage() == WeaponType.DAMAGE_BY_CLUSTERTABLE)</span>
<span class="nc bnc" id="L3160" title="All 2 branches missed.">                    &amp;&amp; (wt.hasFlag(WeaponType.F_MISSILE))) {</span>
                // Check for linked artemis guidance system
<span class="nc bnc" id="L3162" title="All 2 branches missed.">                if ((wt.getAmmoType() == AmmoType.T_LRM)</span>
<span class="nc bnc" id="L3163" title="All 2 branches missed.">                        || (wt.getAmmoType() == AmmoType.T_LRM_IMP)</span>
<span class="nc bnc" id="L3164" title="All 2 branches missed.">                        || (wt.getAmmoType() == AmmoType.T_MML)</span>
<span class="nc bnc" id="L3165" title="All 2 branches missed.">                        || (wt.getAmmoType() == AmmoType.T_SRM)</span>
<span class="nc bnc" id="L3166" title="All 2 branches missed.">                        || (wt.getAmmoType() == AmmoType.T_SRM_IMP)) {</span>
<span class="nc" id="L3167">                    lnk_guide = weapon.getLinkedBy();</span>
<span class="nc bnc" id="L3168" title="All 6 branches missed.">                    if ((lnk_guide != null) &amp;&amp; (lnk_guide.getType() instanceof MiscType) &amp;&amp; !lnk_guide.isDestroyed()</span>
<span class="nc bnc" id="L3169" title="All 4 branches missed.">                            &amp;&amp; !lnk_guide.isMissing() &amp;&amp; !lnk_guide.isBreached()</span>
<span class="nc bnc" id="L3170" title="All 2 branches missed.">                            &amp;&amp; lnk_guide.getType().hasFlag(MiscType.F_ARTEMIS)) {</span>

                        // Don't use artemis if this is indirect fire
                        // -&gt; Hook for Artemis V Level 3 Clan tech here; use
                        // 1.30f multiplier when implemented
<span class="nc bnc" id="L3175" title="All 4 branches missed.">                        if (((weapon.curMode() == null) || !weapon.curMode().equals(&quot;Indirect&quot;))</span>
<span class="nc bnc" id="L3176" title="All 2 branches missed.">                                &amp;&amp; (at.getMunitionType() == AmmoType.M_ARTEMIS_CAPABLE)) {</span>
<span class="nc" id="L3177">                            fHits *= 1.2f;</span>
                        }
<span class="nc bnc" id="L3179" title="All 4 branches missed.">                        if (((weapon.curMode() == null) || !weapon.curMode().equals(&quot;Indirect&quot;))</span>
<span class="nc bnc" id="L3180" title="All 2 branches missed.">                                &amp;&amp; (at.getMunitionType() == AmmoType.M_ARTEMIS_V_CAPABLE)) {</span>
<span class="nc" id="L3181">                            fHits *= 1.3f;</span>
                        }
                    }
                }

                // Check for ATMs, which have built in Artemis
<span class="nc bnc" id="L3187" title="All 2 branches missed.">                if (wt.getAmmoType() == AmmoType.T_ATM) {</span>
<span class="nc" id="L3188">                    fHits *= 1.2f;</span>
                }

                // Check for target with attached Narc or iNarc homing pod from
                // friendly unit
<span class="nc bnc" id="L3193" title="All 2 branches missed.">                if (target.isNarcedBy(attacker.getOwner().getTeam())</span>
<span class="nc bnc" id="L3194" title="All 2 branches missed.">                        || target.isINarcedBy(attacker.getOwner().getTeam())) {</span>
<span class="nc bnc" id="L3195" title="All 2 branches missed.">                    if (((at.getAmmoType() == AmmoType.T_LRM)</span>
<span class="nc bnc" id="L3196" title="All 2 branches missed.">                            || (at.getAmmoType() == AmmoType.T_LRM_IMP)</span>
<span class="nc bnc" id="L3197" title="All 2 branches missed.">                            || (at.getAmmoType() == AmmoType.T_MML)</span>
<span class="nc bnc" id="L3198" title="All 2 branches missed.">                            || (at.getAmmoType() == AmmoType.T_SRM)</span>
<span class="nc bnc" id="L3199" title="All 2 branches missed.">                            || (at.getAmmoType() == AmmoType.T_SRM_IMP))</span>
<span class="nc bnc" id="L3200" title="All 2 branches missed.">                            &amp;&amp; (at.getMunitionType() == AmmoType.M_NARC_CAPABLE)) {</span>
<span class="nc" id="L3201">                        fHits *= 1.2f;</span>
                    }
                }
            }

<span class="nc bnc" id="L3206" title="All 2 branches missed.">            if (wt.getAmmoType() == AmmoType.T_MRM) {</span>
<span class="nc" id="L3207">                lnk_guide = weapon.getLinkedBy();</span>
<span class="nc bnc" id="L3208" title="All 2 branches missed.">                if ((lnk_guide != null)</span>
<span class="nc bnc" id="L3209" title="All 2 branches missed.">                        &amp;&amp; (lnk_guide.getType() instanceof MiscType)</span>
<span class="nc bnc" id="L3210" title="All 4 branches missed.">                        &amp;&amp; !lnk_guide.isDestroyed() &amp;&amp; !lnk_guide.isMissing()</span>
<span class="nc bnc" id="L3211" title="All 2 branches missed.">                        &amp;&amp; !lnk_guide.isBreached()</span>
<span class="nc bnc" id="L3212" title="All 2 branches missed.">                        &amp;&amp; lnk_guide.getType().hasFlag(MiscType.F_APOLLO)) {</span>
<span class="nc" id="L3213">                    fHits *= .9f;</span>
                }
            }

            // adjust for previous AMS
<span class="nc bnc" id="L3218" title="All 2 branches missed.">            if ((wt.getDamage() == WeaponType.DAMAGE_BY_CLUSTERTABLE)</span>
<span class="nc bnc" id="L3219" title="All 2 branches missed.">                    &amp;&amp; wt.hasFlag(WeaponType.F_MISSILE)) {</span>
<span class="nc" id="L3220">                ArrayList&lt;Mounted&gt; vCounters = waa.getCounterEquipment();</span>
<span class="nc bnc" id="L3221" title="All 2 branches missed.">                if (vCounters != null) {</span>
<span class="nc bnc" id="L3222" title="All 2 branches missed.">                    for (int x = 0; x &lt; vCounters.size(); x++) {</span>
<span class="nc" id="L3223">                        EquipmentType type = vCounters.get(x).getType();</span>
<span class="nc bnc" id="L3224" title="All 2 branches missed.">                        if ((type instanceof WeaponType)</span>
<span class="nc bnc" id="L3225" title="All 2 branches missed.">                                &amp;&amp; type.hasFlag(WeaponType.F_AMS)) {</span>
<span class="nc" id="L3226">                            fHits *= 0.6;</span>
                        }
                    }
                }
            }

            // * HAGs modify their cluster hits for range.
<span class="nc bnc" id="L3233" title="All 2 branches missed.">            if (wt instanceof HAGWeapon) {</span>
<span class="nc" id="L3234">                int distance = attacker.getPosition().distance(</span>
<span class="nc" id="L3235">                        target.getPosition());</span>
<span class="nc bnc" id="L3236" title="All 2 branches missed.">                if (distance &lt;= wt.getShortRange()) {</span>
<span class="nc" id="L3237">                    fHits *= 1.2;</span>
<span class="nc bnc" id="L3238" title="All 2 branches missed.">                } else if (distance &gt; wt.getMediumRange()) {</span>
<span class="nc" id="L3239">                    fHits *= 0.8;</span>
                }
            }

<span class="nc" id="L3243">            fDamage *= fHits;</span>

<span class="nc bnc" id="L3245" title="All 2 branches missed.">            if ((wt.getAmmoType() == AmmoType.T_AC_ULTRA)</span>
<span class="nc bnc" id="L3246" title="All 2 branches missed.">                    || (wt.getAmmoType() == AmmoType.T_AC_ULTRA_THB)</span>
<span class="nc bnc" id="L3247" title="All 2 branches missed.">                    || (wt.getAmmoType() == AmmoType.T_AC_ROTARY)) {</span>
<span class="nc" id="L3248">                fDamage = fHits * wt.getDamage();</span>
            }

<span class="nc" id="L3251">        } else {</span>
            // Direct fire weapons (and LBX slug rounds) just do a single shot
            // so they don't use the missile hits table. Weapon bays also deal
            // damage in a single block
<span class="nc bnc" id="L3255" title="All 2 branches missed.">            if ((attacker.getPosition() != null)</span>
<span class="nc bnc" id="L3256" title="All 2 branches missed.">                    &amp;&amp; (target.getPosition() != null)) {</span>
                // Damage may vary by range for some weapons, so let's see how far
                // away we actually are and then set the damage accordingly.
<span class="nc" id="L3259">                int rangeToTarget = attacker.getPosition().distance(target.getPosition());</span>

                //Convert AV to fDamage for bay weapons, fighters, etc
<span class="nc bnc" id="L3262" title="All 2 branches missed.">                if (attacker.usesWeaponBays()) {</span>
<span class="nc" id="L3263">                    double av = 0;</span>
<span class="nc" id="L3264">                    double threat = 1;</span>
<span class="nc bnc" id="L3265" title="All 2 branches missed.">                    for (int wId : weapon.getBayWeapons()) {</span>
<span class="nc" id="L3266">                        Mounted bayW = attacker.getEquipment(wId);</span>
<span class="nc" id="L3267">                        WeaponType bayWType = ((WeaponType) bayW.getType());</span>
                        //Capital weapons have a different range scale
<span class="nc bnc" id="L3269" title="All 2 branches missed.">                        if (wt.isCapital()) {</span>
                            // Capital missiles get higher priority than standard missiles:
                            // damage plus a bonus for the critical hit threat they represent
<span class="nc" id="L3272">                            threat = 12;</span>
<span class="nc bnc" id="L3273" title="All 2 branches missed.">                            if (rangeToTarget &gt; 50) {</span>
<span class="nc" id="L3274">                                av = 0;</span>
<span class="nc bnc" id="L3275" title="All 2 branches missed.">                            } else if (rangeToTarget &gt; 40) {</span>
<span class="nc" id="L3276">                                av += bayWType.getExtAV();</span>
<span class="nc bnc" id="L3277" title="All 2 branches missed.">                            } else if (rangeToTarget &gt; 25) {</span>
<span class="nc" id="L3278">                                av += bayWType.getLongAV();</span>
<span class="nc bnc" id="L3279" title="All 2 branches missed.">                            } else if (rangeToTarget &gt; 12) {</span>
<span class="nc" id="L3280">                                av += bayWType.getMedAV();</span>
                            } else {
<span class="nc" id="L3282">                                av += bayWType.getShortAV();</span>
                            }
                        } else {
<span class="nc bnc" id="L3285" title="All 2 branches missed.">                            if (rangeToTarget &gt; 25) {</span>
<span class="nc" id="L3286">                                av = 0;</span>
<span class="nc bnc" id="L3287" title="All 2 branches missed.">                            } else if (rangeToTarget &gt; 20) {</span>
<span class="nc" id="L3288">                                av += bayWType.getExtAV();</span>
<span class="nc bnc" id="L3289" title="All 2 branches missed.">                            } else if (rangeToTarget &gt; 12) {</span>
<span class="nc" id="L3290">                                av += bayWType.getLongAV();</span>
<span class="nc bnc" id="L3291" title="All 2 branches missed.">                            } else if (rangeToTarget &gt; 6) {</span>
<span class="nc" id="L3292">                                av += bayWType.getMedAV();</span>
                            } else {
<span class="nc" id="L3294">                                av += bayWType.getShortAV();</span>
                            }
                        }
<span class="nc" id="L3297">                        fDamage = (float) (av * threat);</span>
<span class="nc" id="L3298">                    }</span>
<span class="nc bnc" id="L3299" title="All 2 branches missed.">                } else if (attacker.isCapitalFighter()) {</span>
<span class="nc" id="L3300">                    double av = 0;</span>
<span class="nc" id="L3301">                    double threat = 1;</span>
                    //Capital weapons have a different range scale
<span class="nc bnc" id="L3303" title="All 2 branches missed.">                    if (wt.isCapital()) {</span>
                        // Capital missiles should have higher priority than standard missiles
<span class="nc" id="L3305">                        threat = 12;</span>
<span class="nc bnc" id="L3306" title="All 2 branches missed.">                        if (rangeToTarget &gt; 50) {</span>
<span class="nc" id="L3307">                            av = 0;</span>
<span class="nc bnc" id="L3308" title="All 2 branches missed.">                        } else if (rangeToTarget &gt; 40) {</span>
<span class="nc" id="L3309">                            av += (wt.getExtAV() * weapon.getNWeapons());</span>
<span class="nc bnc" id="L3310" title="All 2 branches missed.">                        } else if (rangeToTarget &gt; 25) {</span>
<span class="nc" id="L3311">                            av += (wt.getLongAV() * weapon.getNWeapons());</span>
<span class="nc bnc" id="L3312" title="All 2 branches missed.">                        } else if (rangeToTarget &gt; 12) {</span>
<span class="nc" id="L3313">                            av += (wt.getMedAV() * weapon.getNWeapons());</span>
                        } else {
<span class="nc" id="L3315">                            av += (wt.getShortAV() * weapon.getNWeapons());</span>
                        }
                    } else {
<span class="nc bnc" id="L3318" title="All 2 branches missed.">                        if (rangeToTarget &gt; 25) {</span>
<span class="nc" id="L3319">                            av = 0;</span>
<span class="nc bnc" id="L3320" title="All 2 branches missed.">                        } else if (rangeToTarget &gt; 20) {</span>
<span class="nc" id="L3321">                            av += (wt.getExtAV() * weapon.getNWeapons());</span>
<span class="nc bnc" id="L3322" title="All 2 branches missed.">                        } else if (rangeToTarget &gt; 12) {</span>
<span class="nc" id="L3323">                            av += (wt.getLongAV() * weapon.getNWeapons());</span>
<span class="nc bnc" id="L3324" title="All 2 branches missed.">                        } else if (rangeToTarget &gt; 6) {</span>
<span class="nc" id="L3325">                            av += (wt.getMedAV() * weapon.getNWeapons());</span>
                        } else {
<span class="nc" id="L3327">                            av += (wt.getShortAV() * weapon.getNWeapons());</span>
                        }
                    }
<span class="nc" id="L3330">                    fDamage = (float) (av * threat);</span>

<span class="nc bnc" id="L3332" title="All 2 branches missed.">                } else if ((wt.getAmmoType() == AmmoType.T_ARROW_IV)</span>
<span class="nc bnc" id="L3333" title="All 2 branches missed.">                        || wt.getAmmoType() == BombType.B_HOMING) {</span>
                    //This is for arrow IV AMS threat processing
<span class="nc" id="L3335">                    fDamage = (float) wt.getRackSize();</span>
                } else {
<span class="nc" id="L3337">                    fDamage = wt.getDamage(rangeToTarget);</span>
                }
            }

            // Infantry follow some special rules, but do fixed amounts of damage
            // Anti-mek attacks are weapon-like in nature, so include them here as well
<span class="nc bnc" id="L3343" title="All 2 branches missed.">            if (attacker instanceof Infantry) {</span>
<span class="nc bnc" id="L3344" title="All 2 branches missed.">                if (wt.getInternalName() == Infantry.LEG_ATTACK) {</span>
<span class="nc" id="L3345">                    fDamage = 20.0f; // Actually 5, but the chance of crits</span>
                    // deserves a boost
                    // leg attacks are mutually exclusive with swarm attacks,
                } else {
<span class="nc bnc" id="L3349" title="All 4 branches missed.">                    boolean targetIsSwarmable = (target instanceof Mech) || (target instanceof Tank);</span>

<span class="nc bnc" id="L3351" title="All 2 branches missed.">                    if (attacker.isConventionalInfantry()) {</span>
<span class="nc bnc" id="L3352" title="All 2 branches missed.">                        if (wt.getInternalName() == Infantry.SWARM_MEK) {</span>
                            // If the target is a Mek that is not swarmed, this is a
                            // good thing
<span class="nc bnc" id="L3355" title="All 4 branches missed.">                            if ((target.getSwarmAttackerId() == Entity.NONE) &amp;&amp; targetIsSwarmable) {</span>
<span class="nc" id="L3356">                                fDamage = 1.5f</span>
                                        * (float) infDamagePerTrooper
                                        * infShootingStrength;
                            }
                            // Otherwise, call it 0 damage
                            else {
<span class="nc" id="L3362">                                fDamage = 0.0f;</span>
                            }
                        } else {
                            // conventional weapons; field guns should be handled
                            // under the standard weapons section
<span class="nc" id="L3367">                            fDamage = 0.6f</span>
                                    * (float) infDamagePerTrooper
                                    * infShootingStrength;
                        }
                    } else {
                        // Battle armor units conducting swarm attack
<span class="nc bnc" id="L3373" title="All 2 branches missed.">                        if (wt.getInternalName() == Infantry.SWARM_MEK) {</span>
                            // If the target is a Mek that is not swarmed, this is a
                            // good thing
<span class="nc bnc" id="L3376" title="All 4 branches missed.">                            if ((target.getSwarmAttackerId() == Entity.NONE) &amp;&amp; targetIsSwarmable) {</span>
                                // Overestimated, but the chance at crits and head
                                // shots deserves a boost
<span class="nc" id="L3379">                                fDamage = 10.0f * baShootingStrength;</span>
                            }
                            // Otherwise, call it 0 damage
                            else {
<span class="nc" id="L3383">                                fDamage = 0.0f;</span>
                            }
                        }
                    }
                }
            }

        }

        // Need to adjust damage if the target is infantry.
<span class="nc bnc" id="L3393" title="All 2 branches missed.">        if (g.getEntity(waa.getTargetId()).isConventionalInfantry()) {</span>
<span class="nc" id="L3394">            fDamage = directBlowInfantryDamage(fDamage, 0,</span>
<span class="nc" id="L3395">                    wt.getInfantryDamageClass(), ((Infantry) (g.getEntity(waa</span>
<span class="nc" id="L3396">                            .getTargetId()))).isMechanized(), false);</span>
        }

<span class="nc" id="L3399">        fDamage *= fChance;</span>

        // Conventional infantry take double damage in the open
<span class="nc bnc" id="L3402" title="All 2 branches missed.">        if (g.getEntity(waa.getTargetId()).isConventionalInfantry()) {</span>
<span class="nc" id="L3403">            IHex e_hex = g.getBoard().getHex(</span>
<span class="nc" id="L3404">                    g.getEntity(waa.getTargetId()).getPosition().getX(),</span>
<span class="nc" id="L3405">                    g.getEntity(waa.getTargetId()).getPosition().getY());</span>
<span class="nc bnc" id="L3406" title="All 2 branches missed.">            if (!e_hex.containsTerrain(Terrains.WOODS)</span>
<span class="nc bnc" id="L3407" title="All 2 branches missed.">                    &amp;&amp; !e_hex.containsTerrain(Terrains.JUNGLE)</span>
<span class="nc bnc" id="L3408" title="All 2 branches missed.">                    &amp;&amp; !e_hex.containsTerrain(Terrains.BUILDING)) {</span>
<span class="nc" id="L3409">                fDamage *= 2.0f;</span>
            }

            // Cap damage to prevent run-away values
<span class="nc bnc" id="L3413" title="All 2 branches missed.">            if (infShootingStrength &gt; 0) {</span>
<span class="nc" id="L3414">                fDamage = Math.min(infShootingStrength, fDamage);</span>
            }
        }
<span class="nc" id="L3417">        return fDamage;</span>
    }

    /**
     * If the unit is carrying multiple types of ammo for the specified weapon,
     * cycle through them and choose the type best suited to engage the
     * specified target
     * Value returned is expected damage
     * Note that some ammo types, such as infernos, do no damage or have special
     * properties and so the damage is an estimation of effectiveness
     */

    public static double getAmmoAdjDamage(IGame cgame, WeaponAttackAction atk) {
<span class="nc" id="L3430">        boolean no_bin = true;</span>
<span class="nc" id="L3431">        boolean multi_bin = false;</span>

        double ammo_multiple, ex_damage, max_damage;

        Entity shooter, target;

        Mounted fabin, best_bin;
<span class="nc" id="L3438">        AmmoType abin_type = new AmmoType();</span>
<span class="nc" id="L3439">        AmmoType fabin_type = new AmmoType();</span>
<span class="nc" id="L3440">        WeaponType wtype = new WeaponType();</span>
<span class="nc" id="L3441">        WeaponType target_weapon = new WeaponType();</span>

        // Get shooter entity, target entity, and weapon being fired
<span class="nc" id="L3444">        target = cgame.getEntity(atk.getTargetId());</span>
<span class="nc" id="L3445">        shooter = atk.getEntity(cgame);</span>
<span class="nc" id="L3446">        wtype = (WeaponType) shooter.getEquipment(atk.getWeaponId()).getType();</span>

<span class="nc" id="L3448">        max_damage = 0.0;</span>

        // If the weapon doesn't require ammo, just get the estimated damage
<span class="nc bnc" id="L3451" title="All 2 branches missed.">        if (wtype.hasFlag(WeaponType.F_ENERGY)</span>
<span class="nc bnc" id="L3452" title="All 2 branches missed.">                || wtype.hasFlag(WeaponType.F_ONESHOT)</span>
<span class="nc bnc" id="L3453" title="All 2 branches missed.">                || wtype.hasFlag(WeaponType.F_INFANTRY)</span>
<span class="nc bnc" id="L3454" title="All 2 branches missed.">                || (wtype.getAmmoType() == AmmoType.T_NA)) {</span>
<span class="nc" id="L3455">            return Compute.getExpectedDamage(cgame, atk, false);</span>
        }

        // Get a list of ammo bins and the first valid bin
<span class="nc" id="L3459">        fabin = null;</span>
<span class="nc" id="L3460">        best_bin = null;</span>

<span class="nc bnc" id="L3462" title="All 2 branches missed.">        for (Mounted abin : shooter.getAmmo()) {</span>
<span class="nc bnc" id="L3463" title="All 2 branches missed.">            if (shooter.loadWeapon(shooter.getEquipment(atk.getWeaponId()),</span>
                    abin)) {
<span class="nc bnc" id="L3465" title="All 2 branches missed.">                if (abin.getUsableShotsLeft() &gt; 0) {</span>
<span class="nc" id="L3466">                    abin_type = (AmmoType) abin.getType();</span>
<span class="nc bnc" id="L3467" title="All 2 branches missed.">                    if (!AmmoType.canDeliverMinefield(abin_type)) {</span>
<span class="nc" id="L3468">                        fabin = abin;</span>
<span class="nc" id="L3469">                        fabin_type = (AmmoType) fabin.getType();</span>
<span class="nc" id="L3470">                        break;</span>
                    }
                }
            }
<span class="nc" id="L3474">        }</span>

        // To save processing time, lets see if we have more than one type of
        // bin
        // Thunder-type ammos and empty bins are excluded from the list
<span class="nc bnc" id="L3479" title="All 2 branches missed.">        for (Mounted abin : shooter.getAmmo()) {</span>
<span class="nc bnc" id="L3480" title="All 2 branches missed.">            if (shooter.loadWeapon(shooter.getEquipment(atk.getWeaponId()),</span>
                    abin)) {
<span class="nc bnc" id="L3482" title="All 2 branches missed.">                if (abin.getUsableShotsLeft() &gt; 0) {</span>
<span class="nc" id="L3483">                    abin_type = (AmmoType) abin.getType();</span>
<span class="nc bnc" id="L3484" title="All 2 branches missed.">                    if (!AmmoType.canDeliverMinefield(abin_type)) {</span>
<span class="nc" id="L3485">                        no_bin = false;</span>
<span class="nc" id="L3486">                        if (abin_type.getMunitionType() != fabin_type</span>
<span class="nc bnc" id="L3487" title="All 2 branches missed.">                                .getMunitionType()) {</span>
<span class="nc" id="L3488">                            multi_bin = true;</span>
<span class="nc" id="L3489">                            break;</span>
                        }
                    }
                }
            }
<span class="nc" id="L3494">        }</span>

        // If no_bin is true, then either all bins are empty or contain
        // Thunder-type rounds and
        // we can safely say that the expected damage is 0.0
        // If no_bin is false, then we have at least one good bin
<span class="nc bnc" id="L3500" title="All 2 branches missed.">        if (no_bin) {</span>
<span class="nc" id="L3501">            return 0.0;</span>
        }
        // If multi_bin is true, then multiple ammo types are present and an
        // appropriate type must be selected
        // If multi_bin is false, then all bin types are the same; skip down
        // to getting the expected damage
<span class="nc bnc" id="L3507" title="All 2 branches missed.">        if (!multi_bin) {</span>
<span class="nc" id="L3508">            return Compute.getExpectedDamage(cgame, atk, false);</span>
        }
<span class="nc bnc" id="L3510" title="All 2 branches missed.">        if (multi_bin) {</span>

            // Set default max damage as 0, and the best bin as the first
            // bin
<span class="nc" id="L3514">            max_damage = 0.0;</span>
<span class="nc" id="L3515">            best_bin = fabin;</span>

            // For each valid ammo bin
<span class="nc bnc" id="L3518" title="All 2 branches missed.">            for (Mounted abin : shooter.getAmmo()) {</span>
<span class="nc bnc" id="L3519" title="All 2 branches missed.">                if (shooter.loadWeapon(shooter.getEquipment(atk.getWeaponId()), abin)) {</span>
<span class="nc bnc" id="L3520" title="All 2 branches missed.">                    if (abin.getUsableShotsLeft() &gt; 0) {</span>
<span class="nc" id="L3521">                        abin_type = (AmmoType) abin.getType();</span>
<span class="nc bnc" id="L3522" title="All 2 branches missed.">                        if (!AmmoType.canDeliverMinefield(abin_type)) {</span>

                            // Load weapon with specified bin
<span class="nc" id="L3525">                            shooter.loadWeapon(shooter.getEquipment(atk.getWeaponId()), abin);</span>
<span class="nc" id="L3526">                            atk.setAmmoId(shooter.getEquipmentNum(abin));</span>

                            // Get expected damage
<span class="nc" id="L3529">                            ex_damage = Compute.getExpectedDamage(cgame, atk, false);</span>

                            // Calculate any modifiers due to ammo type
<span class="nc" id="L3532">                            ammo_multiple = 1.0;</span>

                            // Frag missiles, flechette AC rounds do double
                            // damage against conventional infantry
                            // and 0 damage against everything else
                            // Any further anti-personnel specialized rounds
                            // should be tested for here
<span class="nc bnc" id="L3539" title="All 2 branches missed.">                            if (((((abin_type.getAmmoType() == AmmoType.T_LRM)</span>
<span class="nc bnc" id="L3540" title="All 2 branches missed.">                                    || (abin_type.getAmmoType() == AmmoType.T_LRM_IMP)</span>
<span class="nc bnc" id="L3541" title="All 2 branches missed.">                                    || (abin_type.getAmmoType() == AmmoType.T_MML)</span>
<span class="nc bnc" id="L3542" title="All 2 branches missed.">                                    || (abin_type.getAmmoType() == AmmoType.T_SRM)</span>
<span class="nc bnc" id="L3543" title="All 2 branches missed.">                                    || (abin_type.getAmmoType() == AmmoType.T_SRM_IMP)))</span>
<span class="nc bnc" id="L3544" title="All 2 branches missed.">                                    &amp;&amp; (abin_type.getMunitionType() == AmmoType.M_FRAGMENTATION))</span>
<span class="nc bnc" id="L3545" title="All 2 branches missed.">                                    || (((abin_type.getAmmoType() == AmmoType.T_AC)</span>
<span class="nc bnc" id="L3546" title="All 2 branches missed.">                                    || (abin_type.getAmmoType() == AmmoType.T_LAC)</span>
<span class="nc bnc" id="L3547" title="All 2 branches missed.">                                    || (abin_type.getAmmoType() == AmmoType.T_AC_IMP)</span>
<span class="nc bnc" id="L3548" title="All 2 branches missed.">                                    || (abin_type.getAmmoType() == AmmoType.T_PAC))</span>
<span class="nc bnc" id="L3549" title="All 2 branches missed.">                                    &amp;&amp; (abin_type.getMunitionType() == AmmoType.M_FLECHETTE))) {</span>
<span class="nc bnc" id="L3550" title="All 2 branches missed.">                                ammo_multiple = target.isConventionalInfantry() ? 2.0 : 0.0;</span>
                            }

                            // LBX cluster rounds work better against units
                            // with little armor, vehicles, and Meks in
                            // partial cover
                            // Other ammo that deliver lots of small
                            // submunitions should be tested for here too
<span class="nc bnc" id="L3558" title="All 2 branches missed.">                            if (((abin_type.getAmmoType() == AmmoType.T_AC_LBX)</span>
<span class="nc bnc" id="L3559" title="All 2 branches missed.">                                    || (abin_type.getAmmoType() == AmmoType.T_AC_LBX_THB)</span>
<span class="nc bnc" id="L3560" title="All 2 branches missed.">                                    || (abin_type.getAmmoType() == AmmoType.T_SBGAUSS))</span>
<span class="nc bnc" id="L3561" title="All 2 branches missed.">                                    &amp;&amp; (abin_type.getMunitionType() == AmmoType.M_CLUSTER)) {</span>
<span class="nc bnc" id="L3562" title="All 2 branches missed.">                                if (target.getArmorRemainingPercent() &lt;= 0.25) {</span>
<span class="nc" id="L3563">                                    ammo_multiple = 1.0 + (wtype.getRackSize() / 10.0);</span>
                                }
<span class="nc bnc" id="L3565" title="All 2 branches missed.">                                if (target instanceof Tank) {</span>
<span class="nc" id="L3566">                                    ammo_multiple += 1.0;</span>
                                }
                            }

                            // AP autocannon rounds work much better against
                            // Meks and vehicles than infantry,
                            // give a damage boost in proportion to calibre
                            // to reflect scaled crit chance
                            // Other armor-penetrating ammo types should be
                            // tested here, such as Tandem-charge SRMs
<span class="nc bnc" id="L3576" title="All 2 branches missed.">                            if (((abin_type.getAmmoType() == AmmoType.T_AC)</span>
<span class="nc bnc" id="L3577" title="All 2 branches missed.">                                    || (abin_type.getAmmoType() == AmmoType.T_LAC)</span>
<span class="nc bnc" id="L3578" title="All 2 branches missed.">                                    || (abin_type.getAmmoType() == AmmoType.T_AC_IMP)</span>
<span class="nc bnc" id="L3579" title="All 2 branches missed.">                                    || (abin_type.getAmmoType() == AmmoType.T_PAC))</span>
<span class="nc bnc" id="L3580" title="All 2 branches missed.">                                    &amp;&amp; (abin_type.getMunitionType() == AmmoType.M_ARMOR_PIERCING)) {</span>
<span class="nc bnc" id="L3581" title="All 4 branches missed.">                                if ((target instanceof Mech)</span>
                                        || (target instanceof Tank)) {
<span class="nc" id="L3583">                                    ammo_multiple = 1.0 + (wtype.getRackSize() / 10);</span>
                                }
<span class="nc bnc" id="L3585" title="All 2 branches missed.">                                if (target instanceof Infantry) {</span>
<span class="nc" id="L3586">                                    ammo_multiple = 0.6;</span>
                                }
                            }

                            // Inferno SRMs work better against overheating
                            // Meks that are not/almost not on fire,
                            // and against vehicles and protos if allowed by
                            // game option
<span class="nc bnc" id="L3594" title="All 2 branches missed.">                            if (((abin_type.getAmmoType() == AmmoType.T_SRM)</span>
<span class="nc bnc" id="L3595" title="All 2 branches missed.">                                    || (abin_type.getAmmoType() == AmmoType.T_SRM_IMP)</span>
<span class="nc bnc" id="L3596" title="All 2 branches missed.">                                    || (abin_type.getAmmoType() == AmmoType.T_MML))</span>
<span class="nc bnc" id="L3597" title="All 2 branches missed.">                                    &amp;&amp; (abin_type.getMunitionType() == AmmoType.M_INFERNO)) {</span>
<span class="nc" id="L3598">                                ammo_multiple = 0.5;</span>
<span class="nc bnc" id="L3599" title="All 2 branches missed.">                                if (target instanceof Mech) {</span>
<span class="nc bnc" id="L3600" title="All 4 branches missed.">                                    if ((target.infernos.getTurnsLeftToBurn() &lt; 4)</span>
                                            &amp;&amp; (target.heat &gt;= 5)) {
<span class="nc" id="L3602">                                        ammo_multiple = 1.1;</span>
                                    }
                                }
<span class="nc bnc" id="L3605" title="All 2 branches missed.">                                if ((target instanceof Tank)</span>
<span class="nc" id="L3606">                                        &amp;&amp; !(cgame.getOptions()</span>
<span class="nc bnc" id="L3607" title="All 2 branches missed.">                                        .booleanOption(OptionsConstants.ADVCOMBAT_VEHICLES_SAFE_FROM_INFERNOS))) {</span>
<span class="nc" id="L3608">                                    ammo_multiple = 1.1;</span>
                                }
<span class="nc bnc" id="L3610" title="All 2 branches missed.">                                if ((target instanceof Protomech)</span>
<span class="nc" id="L3611">                                        &amp;&amp; !(cgame.getOptions()</span>
<span class="nc bnc" id="L3612" title="All 2 branches missed.">                                        .booleanOption(OptionsConstants.ADVCOMBAT_PROTOS_SAFE_FROM_INFERNOS))) {</span>
<span class="nc" id="L3613">                                    ammo_multiple = 1.1;</span>
                                }
                            }

                            // Narc beacon doesn't really do damage but if
                            // the target is not infantry and doesn't have
                            // one, give 'em one by making it an attractive
                            // option
<span class="nc bnc" id="L3621" title="All 2 branches missed.">                            if ((wtype.getAmmoType() == AmmoType.T_NARC)</span>
<span class="nc bnc" id="L3622" title="All 2 branches missed.">                                    &amp;&amp; (abin_type.getMunitionType() == AmmoType.M_STANDARD)) {</span>
<span class="nc bnc" id="L3623" title="All 4 branches missed.">                                if (!(target.isNarcedBy(shooter.getOwner().getTeam()))</span>
                                        &amp;&amp; !(target instanceof Infantry)) {
<span class="nc" id="L3625">                                    ex_damage = 5.0;</span>
                                } else {
<span class="nc" id="L3627">                                    ex_damage = 0.5;</span>
                                }
                            }

                            // iNarc beacon doesn't really do damage, but if
                            // the target is not infantry and doesn't have
                            // one, give 'em one by making it an attractive
                            // option
<span class="nc bnc" id="L3635" title="All 2 branches missed.">                            if (wtype.getAmmoType() == AmmoType.T_INARC) {</span>
<span class="nc bnc" id="L3636" title="All 4 branches missed.">                                if ((abin_type.getMunitionType() == AmmoType.M_STANDARD)</span>
                                        &amp;&amp; !(target instanceof Infantry)) {
<span class="nc bnc" id="L3638" title="All 2 branches missed.">                                    if (!(target.isINarcedBy(shooter.getOwner().getTeam()))) {</span>
<span class="nc" id="L3639">                                        ex_damage = 7.0;</span>
                                    } else {
<span class="nc" id="L3641">                                        ex_damage = 1.0;</span>
                                    }
                                }

                                // iNarc ECM doesn't really do damage, but
                                // if the target has a C3 link or missile
                                // launchers
                                // make it a priority
                                // Checking for actual ammo types carried
                                // would be nice, but can't be sure of exact
                                // loads
                                // when &quot;true&quot; double blind is implemented
<span class="nc bnc" id="L3653" title="All 2 branches missed.">                                if ((abin_type.getAmmoType() == AmmoType.T_INARC)</span>
<span class="nc bnc" id="L3654" title="All 4 branches missed.">                                        &amp;&amp; (abin_type.getMunitionType() == AmmoType.M_ECM)</span>
                                        &amp;&amp; !(target instanceof Infantry)) {
<span class="nc bnc" id="L3656" title="All 2 branches missed.">                                    if (!target.isINarcedWith(AmmoType.M_ECM)) {</span>
<span class="nc bnc" id="L3657" title="All 2 branches missed.">                                        if (!(target.getC3MasterId() == Entity.NONE)</span>
<span class="nc bnc" id="L3658" title="All 2 branches missed.">                                                || target.hasC3M()</span>
<span class="nc bnc" id="L3659" title="All 2 branches missed.">                                                || target.hasC3MM()</span>
<span class="nc bnc" id="L3660" title="All 2 branches missed.">                                                || target.hasC3i()) {</span>
<span class="nc" id="L3661">                                            ex_damage = 8.0;</span>
                                        } else {
<span class="nc" id="L3663">                                            ex_damage = 0.5;</span>
                                        }
<span class="nc bnc" id="L3665" title="All 2 branches missed.">                                        for (Mounted weapon : shooter.getWeaponList()) {</span>
<span class="nc" id="L3666">                                            target_weapon = (WeaponType) weapon.getType();</span>
<span class="nc bnc" id="L3667" title="All 2 branches missed.">                                            if ((target_weapon.getAmmoType() == AmmoType.T_LRM)</span>
<span class="nc bnc" id="L3668" title="All 2 branches missed.">                                                    || (target_weapon.getAmmoType() == AmmoType.T_LRM_IMP)</span>
<span class="nc bnc" id="L3669" title="All 2 branches missed.">                                                    || (target_weapon.getAmmoType() == AmmoType.T_MML)</span>
<span class="nc bnc" id="L3670" title="All 2 branches missed.">                                                    || (target_weapon.getAmmoType() == AmmoType.T_SRM)</span>
<span class="nc bnc" id="L3671" title="All 2 branches missed.">                                                    || (target_weapon.getAmmoType() == AmmoType.T_SRM_IMP)) {</span>
<span class="nc" id="L3672">                                                ex_damage = ex_damage + (target_weapon.getRackSize() / 2);</span>
                                            }
<span class="nc" id="L3674">                                        }</span>
                                    }
                                }

                                // iNarc Nemesis doesn't really do damage,
                                // but if the target is not infantry and
                                // doesn't have
                                // one give it a try; make fast units a
                                // priority because they are usually out
                                // front
<span class="nc bnc" id="L3684" title="All 2 branches missed.">                                if ((abin_type.getAmmoType() == AmmoType.T_INARC)</span>
<span class="nc bnc" id="L3685" title="All 4 branches missed.">                                        &amp;&amp; (abin_type.getMunitionType() == AmmoType.M_NEMESIS)</span>
                                        &amp;&amp; !(target instanceof Infantry)) {
<span class="nc bnc" id="L3687" title="All 2 branches missed.">                                    if (!target.isINarcedWith(AmmoType.M_NEMESIS)) {</span>
<span class="nc" id="L3688">                                        ex_damage = (double) (target.getWalkMP() + target.getJumpMP()) / 2;</span>
                                    } else {
<span class="nc" id="L3690">                                        ex_damage = 0.5;</span>
                                    }
                                }
                            }

                            // If the adjusted damage is highest, store the
                            // damage and bin
<span class="nc bnc" id="L3697" title="All 2 branches missed.">                            if ((ex_damage * ammo_multiple) &gt; max_damage) {</span>
<span class="nc" id="L3698">                                max_damage = ex_damage * ammo_multiple;</span>
<span class="nc" id="L3699">                                best_bin = abin;</span>
                            }
                        }
                    }
                }
<span class="nc" id="L3704">            }</span>

            // Now that the best bin has been found, reload the weapon with
            // it
<span class="nc" id="L3708">            shooter.loadWeapon(shooter.getEquipment(atk.getWeaponId()),</span>
                    best_bin);
<span class="nc" id="L3710">            atk.setAmmoId(shooter.getEquipmentNum(best_bin));</span>
        }
<span class="nc" id="L3712">        return max_damage;</span>
    }

    /**
     * If this is an ultra or rotary cannon, lets see about 'spinning it up' for
     * extra damage
     *
     * @return the &lt;code&gt;int&lt;/code&gt; ID of weapon mode
     */
    public static int spinUpCannon(IGame cgame, WeaponAttackAction atk) {
<span class="nc" id="L3722">        return spinUpCannon(cgame, atk, Compute.d6(2) - 1);</span>
    }

    /**
     * If this is an ultra or rotary cannon, lets see about 'spinning it up' for
     * extra damage
     *
     * @return the &lt;code&gt;int&lt;/code&gt; ID of weapon mode
     */

    public static int spinUpCannon(IGame cgame, WeaponAttackAction atk, int spinupThreshold) {

<span class="fc" id="L3734">        int threshold = 12;</span>
        int final_spin;
        Entity shooter;
        Mounted weapon;
<span class="fc" id="L3738">        WeaponType wtype = new WeaponType();</span>

        // Double check this is an Ultra or Rotary cannon
        // or a standard AC with the TacOps rapid fire rule turned on
<span class="fc" id="L3742">        shooter = atk.getEntity(cgame);</span>
<span class="fc" id="L3743">        weapon = shooter.getEquipment(atk.getWeaponId());</span>
<span class="fc" id="L3744">        wtype = (WeaponType) shooter.getEquipment(atk.getWeaponId()).getType();</span>

<span class="pc bpc" id="L3746" title="3 of 4 branches missed.">        boolean rapidAC = (wtype.getAmmoType() == AmmoType.T_AC) &amp;&amp; cgame.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_RAPID_AC);</span>

<span class="pc bpc" id="L3748" title="1 of 2 branches missed.">        if (!((wtype.getAmmoType() == AmmoType.T_AC_ULTRA)</span>
<span class="pc bpc" id="L3749" title="1 of 2 branches missed.">                || (wtype.getAmmoType() == AmmoType.T_AC_ULTRA_THB)</span>
<span class="pc bpc" id="L3750" title="2 of 4 branches missed.">                || (wtype.getAmmoType() == AmmoType.T_AC_ROTARY)</span>
                || rapidAC)) {
<span class="fc" id="L3752">            return 0;</span>
        }

        // Get the to-hit number
<span class="nc" id="L3756">        threshold = atk.toHit(cgame).getValue();</span>

        // Set the weapon to single shot mode
<span class="nc bnc" id="L3759" title="All 2 branches missed.">        weapon.setMode(rapidAC ? &quot;&quot; : Weapon.MODE_AC_SINGLE);</span>
<span class="nc" id="L3760">        final_spin = 0;</span>

        // If weapon can't hit target, exit the function with the weapon on
        // single shot
<span class="nc bnc" id="L3764" title="All 4 branches missed.">        if ((threshold == TargetRoll.IMPOSSIBLE)</span>
                || (threshold == TargetRoll.AUTOMATIC_FAIL)) {
<span class="nc" id="L3766">            return final_spin;</span>
        }

        // If random roll is &gt;= to-hit + 1, then set double-spin
<span class="nc bnc" id="L3770" title="All 2 branches missed.">        if (spinupThreshold &gt;= threshold) {</span>
<span class="nc" id="L3771">            final_spin = 1;</span>
<span class="nc bnc" id="L3772" title="All 2 branches missed.">            if ((wtype.getAmmoType() == AmmoType.T_AC_ULTRA)</span>
<span class="nc bnc" id="L3773" title="All 2 branches missed.">                    || (wtype.getAmmoType() == AmmoType.T_AC_ULTRA_THB)) {</span>
<span class="nc" id="L3774">                weapon.setMode(Weapon.MODE_UAC_ULTRA);</span>
<span class="nc bnc" id="L3775" title="All 2 branches missed.">            } else if (wtype.getAmmoType() == AmmoType.T_AC_ROTARY) {</span>
<span class="nc" id="L3776">                weapon.setMode(Weapon.MODE_RAC_TWO_SHOT);</span>
<span class="nc bnc" id="L3777" title="All 2 branches missed.">            } else if (rapidAC) {</span>
<span class="nc" id="L3778">                weapon.setMode(Weapon.MODE_AC_RAPID);</span>
            }
        }

        // If this is a Rotary cannon
<span class="nc bnc" id="L3783" title="All 2 branches missed.">        if (wtype.getAmmoType() == AmmoType.T_AC_ROTARY) {</span>

            // If random roll is &gt;= to-hit + 2 then set to quad-spin
<span class="nc bnc" id="L3786" title="All 2 branches missed.">            if (spinupThreshold &gt;= (threshold + 1)) {</span>
<span class="nc" id="L3787">                final_spin = 2;</span>
<span class="nc" id="L3788">                weapon.setMode(Weapon.MODE_RAC_FOUR_SHOT);</span>
            }

            // If random roll is &gt;= to-hit + 3 then set to six-spin
<span class="nc bnc" id="L3792" title="All 2 branches missed.">            if (spinupThreshold &gt;= (threshold + 2)) {</span>
<span class="nc" id="L3793">                final_spin = 3;</span>
<span class="nc" id="L3794">                weapon.setMode(Weapon.MODE_RAC_SIX_SHOT);</span>
            }
        }
<span class="nc" id="L3797">        return final_spin;</span>
    }

    /**
     * Checks to see if a target is in arc of the specified weapon, on the
     * specified entity
     */
    public static boolean isInArc(IGame game, int attackerId, int weaponId,
                                  Targetable t) {
<span class="nc" id="L3806">        Entity ae = game.getEntity(attackerId);</span>
<span class="nc bnc" id="L3807" title="All 2 branches missed.">        if ((ae instanceof Mech)</span>
<span class="nc bnc" id="L3808" title="All 2 branches missed.">                &amp;&amp; (((Mech) ae).getGrappled() == t.getTargetId())) {</span>
<span class="nc" id="L3809">            return true;</span>
        }
<span class="nc bnc" id="L3811" title="All 2 branches missed.">        int facing = ae.isSecondaryArcWeapon(weaponId) ? ae</span>
<span class="nc" id="L3812">                .getSecondaryFacing() : ae.getFacing();</span>
<span class="nc bnc" id="L3813" title="All 2 branches missed.">        if ((ae instanceof Tank)</span>
<span class="nc" id="L3814">                &amp;&amp; (ae.getEquipment(weaponId).getLocation() == ((Tank) ae)</span>
<span class="nc bnc" id="L3815" title="All 2 branches missed.">                .getLocTurret2())) {</span>
<span class="nc" id="L3816">            facing = ((Tank) ae).getDualTurretFacing();</span>
        }
<span class="nc bnc" id="L3818" title="All 2 branches missed.">        if (ae.getEquipment(weaponId).isMechTurretMounted()) {</span>
<span class="nc" id="L3819">            facing = ae.getSecondaryFacing()</span>
<span class="nc" id="L3820">                    + (ae.getEquipment(weaponId).getFacing() % 6);</span>
        }
<span class="nc" id="L3822">        Coords aPos = ae.getPosition();</span>
<span class="nc" id="L3823">        Vector&lt;Coords&gt; tPosV = new Vector&lt;Coords&gt;();</span>
<span class="nc" id="L3824">        Coords tPos = t.getPosition();</span>
        // aeros in the same hex in space may still be able to fire at one
        // another. First I need to translate
        // their positions to see who was further back
<span class="nc bnc" id="L3828" title="All 2 branches missed.">        if (game.getBoard().inSpace()</span>
<span class="nc bnc" id="L3829" title="All 2 branches missed.">                &amp;&amp; ae.getPosition().equals(t.getPosition())</span>
<span class="nc bnc" id="L3830" title="All 4 branches missed.">                &amp;&amp; ae.isAero() &amp;&amp; t.isAero()) {</span>
<span class="nc" id="L3831">            int moveSort = shouldMoveBackHex(ae, (Entity) t);</span>
<span class="nc bnc" id="L3832" title="All 2 branches missed.">            if (moveSort &lt; 0) {</span>
<span class="nc" id="L3833">                aPos = ae.getPriorPosition();</span>
            }
<span class="nc bnc" id="L3835" title="All 2 branches missed.">            if (moveSort &gt; 0) {</span>
<span class="nc" id="L3836">                tPos = ((Entity) t).getPriorPosition();</span>
            }
        }

        // if using advanced AA options, then ground-to-air fire determines arc
        // by closest position
<span class="nc bnc" id="L3842" title="All 4 branches missed.">        if (isGroundToAir(ae, t) &amp;&amp; (t instanceof Entity)) {</span>
<span class="nc" id="L3843">            tPos = getClosestFlightPath(ae.getId(), ae.getPosition(),</span>
                    (Entity) t);
        }

        // AMS defending against Ground to Air fire needs to calculate arc based on the closest flight path
        // Technically it's an AirToGround attack since the AMS is on the aircraft
<span class="nc bnc" id="L3849" title="All 4 branches missed.">        if (isAirToGround(ae, t) &amp;&amp; (t instanceof Entity)</span>
<span class="nc bnc" id="L3850" title="All 2 branches missed.">                &amp;&amp; (ae.getEquipment(weaponId).getType().hasFlag(WeaponType.F_AMS)</span>
<span class="nc bnc" id="L3851" title="All 2 branches missed.">                || ae.getEquipment(weaponId).getType().hasFlag(WeaponType.F_AMSBAY))) {</span>
<span class="nc" id="L3852">            Entity te = (Entity) t;</span>
<span class="nc" id="L3853">            aPos = getClosestFlightPath(te.getId(), te.getPosition(),</span>
                    ae);
        }

<span class="nc" id="L3857">        tPosV.add(tPos);</span>
        // check for secondary positions
<span class="nc bnc" id="L3859" title="All 2 branches missed.">        if ((t instanceof Entity)</span>
<span class="nc bnc" id="L3860" title="All 2 branches missed.">                &amp;&amp; (null != ((Entity) t).getSecondaryPositions())) {</span>
<span class="nc bnc" id="L3861" title="All 2 branches missed.">            for (int key : ((Entity) t).getSecondaryPositions().keySet()) {</span>
<span class="nc" id="L3862">                tPosV.add(((Entity) t).getSecondaryPositions().get(key));</span>
<span class="nc" id="L3863">            }</span>
        }
<span class="nc" id="L3865">        return Compute.isInArc(aPos, facing, tPosV, ae.getWeaponArc(weaponId));</span>
    }

    /**
     * Returns true if the line between source Coords and target goes through
     * the hex in front of the attacker
     */
    public static boolean isThroughFrontHex(IGame game, Coords src, Entity t) {
<span class="nc" id="L3873">        Coords dest = t.getPosition();</span>
<span class="nc" id="L3874">        int fa = dest.degree(src) - (t.getFacing() * 60);</span>
<span class="nc bnc" id="L3875" title="All 2 branches missed.">        if (fa &lt; 0) {</span>
<span class="nc" id="L3876">            fa += 360;</span>
        }
<span class="nc bnc" id="L3878" title="All 4 branches missed.">        return (fa &gt; 330) || (fa &lt; 30);</span>
    }

    /**
     * Converts the facing of a vehicular grenade launcher to the corresponding firing arc.
     *
     * @param facing The VGL facing returned by {@link Mounted#getFacing()}
     * @return The firing arc
     */
    public static int firingArcFromVGLFacing(int facing) {
<span class="nc" id="L3888">        return VGL_FIRING_ARCS[facing % 6];</span>
    }

    public static boolean isInArc(Coords src, int facing, Targetable target,
                                  int arc) {

<span class="nc" id="L3894">        Vector&lt;Coords&gt; tPosV = new Vector&lt;Coords&gt;();</span>
<span class="nc" id="L3895">        tPosV.add(target.getPosition());</span>
        // check for secondary positions
<span class="nc bnc" id="L3897" title="All 2 branches missed.">        if ((target instanceof Entity)</span>
<span class="nc bnc" id="L3898" title="All 2 branches missed.">                &amp;&amp; (null != ((Entity) target).getSecondaryPositions())) {</span>
<span class="nc bnc" id="L3899" title="All 2 branches missed.">            for (int key : ((Entity) target).getSecondaryPositions().keySet()) {</span>
<span class="nc" id="L3900">                tPosV.add(((Entity) target).getSecondaryPositions().get(key));</span>
<span class="nc" id="L3901">            }</span>
        }

<span class="nc" id="L3904">        return isInArc(src, facing, tPosV, arc);</span>
    }

    public static boolean isInArc(Coords src, int facing, Coords dest, int arc) {
<span class="nc" id="L3908">        Vector&lt;Coords&gt; destV = new Vector&lt;Coords&gt;();</span>
<span class="nc" id="L3909">        destV.add(dest);</span>
<span class="nc" id="L3910">        return isInArc(src, facing, destV, arc);</span>
    }

    /**
     * Returns true if the target is in the specified arc. Note: This has to
     * take vectors of coordinates to account for potential secondary positions
     *
     * @param src    the attack coordinates
     * @param facing the appropriate attacker sfacing
     * @param destV  A vector of target coordinates
     * @param arc    the arc
     */
    public static boolean isInArc(Coords src, int facing, Vector&lt;Coords&gt; destV,
                                  int arc) {
<span class="nc bnc" id="L3924" title="All 4 branches missed.">        if ((src == null) || (destV == null)) {</span>
<span class="nc" id="L3925">            return true;</span>
        }

        // Jay: I have to adjust this to take in vectors of coordinates to
        // account for secondary positions of the
        // target - I am fairly certain that secondary positions of the attacker
        // shouldn't matter because you don't get
        // to move the angle based on the secondary positions

        // if any of the destination coords are in the right place, then return
        // true
<span class="nc bnc" id="L3936" title="All 2 branches missed.">        for (Coords dest : destV) {</span>
            // calculate firing angle
<span class="nc" id="L3938">            int fa = src.degree(dest) - (facing * 60);</span>
<span class="nc bnc" id="L3939" title="All 2 branches missed.">            if (fa &lt; 0) {</span>
<span class="nc" id="L3940">                fa += 360;</span>
            }
            // is it in the specifed arc?
<span class="nc bnc" id="L3943" title="All 49 branches missed.">            switch (arc) {</span>
                case ARC_FORWARD:
<span class="nc bnc" id="L3945" title="All 4 branches missed.">                    if ((fa &gt;= 300) || (fa &lt;= 60)) {</span>
<span class="nc" id="L3946">                        return true;</span>
                    }
                    break;
                case Compute.ARC_RIGHTARM:
<span class="nc bnc" id="L3950" title="All 4 branches missed.">                    if ((fa &gt;= 300) || (fa &lt;= 120)) {</span>
<span class="nc" id="L3951">                        return true;</span>
                    }
                    break;
                case Compute.ARC_LEFTARM:
<span class="nc bnc" id="L3955" title="All 4 branches missed.">                    if ((fa &gt;= 240) || (fa &lt;= 60)) {</span>
<span class="nc" id="L3956">                        return true;</span>
                    }
                    break;
                case ARC_REAR:
<span class="nc bnc" id="L3960" title="All 4 branches missed.">                    if ((fa &gt; 120) &amp;&amp; (fa &lt; 240)) {</span>
<span class="nc" id="L3961">                        return true;</span>
                    }
                    break;
                case ARC_RIGHTSIDE:
<span class="nc bnc" id="L3965" title="All 4 branches missed.">                    if ((fa &gt; 60) &amp;&amp; (fa &lt;= 120)) {</span>
<span class="nc" id="L3966">                        return true;</span>
                    }
                    break;
                case ARC_LEFTSIDE:
<span class="nc bnc" id="L3970" title="All 4 branches missed.">                    if ((fa &lt; 300) &amp;&amp; (fa &gt;= 240)) {</span>
<span class="nc" id="L3971">                        return true;</span>
                    }
                    break;
                case ARC_MAINGUN:
<span class="nc bnc" id="L3975" title="All 4 branches missed.">                    if ((fa &gt;= 240) || (fa &lt;= 120)) {</span>
<span class="nc" id="L3976">                        return true;</span>
                    }
                    break;
                case ARC_360:
<span class="nc" id="L3980">                    return true;</span>
                case ARC_NORTH:
<span class="nc bnc" id="L3982" title="All 4 branches missed.">                    if ((fa &gt;= 270) || (fa &lt;= 30)) {</span>
<span class="nc" id="L3983">                        return true;</span>
                    }
                    break;
                case ARC_EAST:
<span class="nc bnc" id="L3987" title="All 4 branches missed.">                    if ((fa &gt;= 30) &amp;&amp; (fa &lt;= 150)) {</span>
<span class="nc" id="L3988">                        return true;</span>
                    }
                    break;
                case ARC_WEST:
<span class="nc bnc" id="L3992" title="All 4 branches missed.">                    if ((fa &gt;= 150) &amp;&amp; (fa &lt;= 270)) {</span>
<span class="nc" id="L3993">                        return true;</span>
                    }
                    break;
                case ARC_NOSE:
<span class="nc bnc" id="L3997" title="All 4 branches missed.">                    if ((fa &gt; 300) || (fa &lt; 60)) {</span>
<span class="nc" id="L3998">                        return true;</span>
                    }
                    break;
                case ARC_NOSE_WPL:
<span class="nc bnc" id="L4002" title="All 4 branches missed.">                    if ((fa &gt; 240) || (fa &lt; 120)) {</span>
<span class="nc" id="L4003">                        return true;</span>
                    }
                    break;
                case ARC_LWING:
<span class="nc bnc" id="L4007" title="All 4 branches missed.">                    if ((fa &gt; 300) || (fa &lt;= 0)) {</span>
<span class="nc" id="L4008">                        return true;</span>
                    }
                    break;
                case ARC_LWING_WPL:
<span class="nc bnc" id="L4012" title="All 4 branches missed.">                    if ((fa &gt; 240) || (fa &lt; 60)) {</span>
<span class="nc" id="L4013">                        return true;</span>
                    }
                    break;
                case ARC_RWING:
<span class="nc bnc" id="L4017" title="All 4 branches missed.">                    if ((fa &gt;= 0) &amp;&amp; (fa &lt; 60)) {</span>
<span class="nc" id="L4018">                        return true;</span>
                    }
                    break;
                case ARC_RWING_WPL:
<span class="nc bnc" id="L4022" title="All 4 branches missed.">                    if ((fa &gt; 300) || (fa &lt; 120)) {</span>
<span class="nc" id="L4023">                        return true;</span>
                    }
                    break;
                case ARC_LWINGA:
<span class="nc bnc" id="L4027" title="All 4 branches missed.">                    if ((fa &gt;= 180) &amp;&amp; (fa &lt; 240)) {</span>
<span class="nc" id="L4028">                        return true;</span>
                    }
                    break;
                case ARC_LWINGA_WPL:
<span class="nc bnc" id="L4032" title="All 4 branches missed.">                    if ((fa &gt; 120) &amp;&amp; (fa &lt; 300)) {</span>
<span class="nc" id="L4033">                        return true;</span>
                    }
                    break;
                case ARC_RWINGA:
<span class="nc bnc" id="L4037" title="All 4 branches missed.">                    if ((fa &gt; 120) &amp;&amp; (fa &lt;= 180)) {</span>
<span class="nc" id="L4038">                        return true;</span>
                    }
                    break;
                case ARC_RWINGA_WPL:
<span class="nc bnc" id="L4042" title="All 4 branches missed.">                    if ((fa &gt; 60) &amp;&amp; (fa &lt; 240)) {</span>
<span class="nc" id="L4043">                        return true;</span>
                    }
                    break;
                case ARC_AFT:
<span class="nc bnc" id="L4047" title="All 4 branches missed.">                    if ((fa &gt; 120) &amp;&amp; (fa &lt; 240)) {</span>
<span class="nc" id="L4048">                        return true;</span>
                    }
                    break;
                case ARC_AFT_WPL:
<span class="nc bnc" id="L4052" title="All 4 branches missed.">                    if ((fa &gt; 60) &amp;&amp; (fa &lt; 300)) {</span>
<span class="nc" id="L4053">                        return true;</span>
                    }
                    break;
                case ARC_LEFTSIDE_SPHERE:
<span class="nc bnc" id="L4057" title="All 4 branches missed.">                    if ((fa &gt; 240) || (fa &lt; 0)) {</span>
<span class="nc" id="L4058">                        return true;</span>
                    }
                    break;
                case ARC_LEFTSIDE_SPHERE_WPL:
<span class="nc bnc" id="L4062" title="All 4 branches missed.">                    if ((fa &gt; 180) || (fa &lt; 60)) {</span>
<span class="nc" id="L4063">                        return true;</span>
                    }
                    break;
                case ARC_RIGHTSIDE_SPHERE:
<span class="nc bnc" id="L4067" title="All 4 branches missed.">                    if ((fa &gt; 0) &amp;&amp; (fa &lt; 120)) {</span>
<span class="nc" id="L4068">                        return true;</span>
                    }
                    break;
                case ARC_RIGHTSIDE_SPHERE_WPL:
<span class="nc bnc" id="L4072" title="All 4 branches missed.">                    if ((fa &gt; 300) || (fa &lt; 180)) {</span>
<span class="nc" id="L4073">                        return true;</span>
                    }
                    break;
                case ARC_LEFTSIDEA_SPHERE:
<span class="nc bnc" id="L4077" title="All 4 branches missed.">                    if ((fa &gt; 180) &amp;&amp; (fa &lt; 300)) {</span>
<span class="nc" id="L4078">                        return true;</span>
                    }
                    break;
                case ARC_LEFTSIDEA_SPHERE_WPL:
<span class="nc bnc" id="L4082" title="All 4 branches missed.">                    if ((fa &gt; 120) &amp;&amp; (fa &lt; 360)) {</span>
<span class="nc" id="L4083">                        return true;</span>
                    }
                    break;
                case ARC_RIGHTSIDEA_SPHERE:
<span class="nc bnc" id="L4087" title="All 4 branches missed.">                    if ((fa &gt; 60) &amp;&amp; (fa &lt; 180)) {</span>
<span class="nc" id="L4088">                        return true;</span>
                    }
                    break;
                case ARC_RIGHTSIDEA_SPHERE_WPL:
<span class="nc bnc" id="L4092" title="All 4 branches missed.">                    if ((fa &gt; 0) &amp;&amp; (fa &lt; 240)) {</span>
<span class="nc" id="L4093">                        return true;</span>
                    }
                    break;
                case ARC_LEFT_BROADSIDE:
<span class="nc bnc" id="L4097" title="All 4 branches missed.">                    if ((fa &gt;= 240) &amp;&amp; (fa &lt;= 300)) {</span>
<span class="nc" id="L4098">                        return true;</span>
                    }
                    break;
                case ARC_LEFT_BROADSIDE_WPL:
<span class="nc bnc" id="L4102" title="All 4 branches missed.">                    if ((fa &gt; 180) &amp;&amp; (fa &lt;= 360)) {</span>
<span class="nc" id="L4103">                        return true;</span>
                    }
                    break;
                case ARC_RIGHT_BROADSIDE:
<span class="nc bnc" id="L4107" title="All 4 branches missed.">                    if ((fa &gt;= 60) &amp;&amp; (fa &lt;= 120)) {</span>
<span class="nc" id="L4108">                        return true;</span>
                    }
                    break;
                case ARC_RIGHT_BROADSIDE_WPL:
<span class="nc bnc" id="L4112" title="All 4 branches missed.">                    if ((fa &gt; 0) &amp;&amp; (fa &lt; 180)) {</span>
<span class="nc" id="L4113">                        return true;</span>
                    }
                    break;
                case ARC_LEFT_SPHERE_GROUND:
<span class="nc bnc" id="L4117" title="All 4 branches missed.">                    if ((fa &gt;= 180) &amp;&amp; (fa &lt; 360)) {</span>
<span class="nc" id="L4118">                        return true;</span>
                    }
                    break;
                case ARC_RIGHT_SPHERE_GROUND:
<span class="nc bnc" id="L4122" title="All 4 branches missed.">                    if ((fa &gt;= 0) &amp;&amp; (fa &lt; 180)) {</span>
<span class="nc" id="L4123">                        return true;</span>
                    }
                    break;
                case ARC_TURRET:
<span class="nc bnc" id="L4127" title="All 4 branches missed.">                    if ((fa &gt;= 330) || (fa &lt;= 30)) {</span>
<span class="nc" id="L4128">                        return true;</span>
                    }
                    break;
                case ARC_SPONSON_TURRET_LEFT:
                case ARC_PINTLE_TURRET_LEFT:
<span class="nc bnc" id="L4133" title="All 4 branches missed.">                    if ((fa &gt;= 180) || (fa == 0)) {</span>
<span class="nc" id="L4134">                        return true;</span>
                    }
                    break;
                case ARC_SPONSON_TURRET_RIGHT:
                case ARC_PINTLE_TURRET_RIGHT:
<span class="nc bnc" id="L4139" title="All 4 branches missed.">                    if ((fa &gt;= 0) &amp;&amp; (fa &lt;= 180)) {</span>
<span class="nc" id="L4140">                        return true;</span>
                    }
                    break;
                case ARC_PINTLE_TURRET_FRONT:
<span class="nc bnc" id="L4144" title="All 4 branches missed.">                    if ((fa &gt;= 270) || (fa &lt;= 90)) {</span>
<span class="nc" id="L4145">                        return true;</span>
                    }
                    break;
                case ARC_PINTLE_TURRET_REAR:
<span class="nc bnc" id="L4149" title="All 4 branches missed.">                    if ((fa &gt;= 90) &amp;&amp; (fa &lt;= 270)) {</span>
<span class="nc" id="L4150">                        return true;</span>
                    }
                    break;
                case ARC_VGL_FRONT:
<span class="nc bnc" id="L4154" title="All 4 branches missed.">                    return (fa &gt;= 270) || (fa &lt;= 90);</span>
                case ARC_VGL_RF:
<span class="nc bnc" id="L4156" title="All 4 branches missed.">                    return (fa &gt;= 330) || (fa &lt;= 150);</span>
                case ARC_VGL_RR:
<span class="nc bnc" id="L4158" title="All 4 branches missed.">                    return (fa &gt;= 30) &amp;&amp; (fa &lt;= 210);</span>
                case ARC_VGL_REAR:
<span class="nc bnc" id="L4160" title="All 4 branches missed.">                    return (fa &gt;= 90) &amp;&amp; (fa &lt;= 270);</span>
                case ARC_VGL_LR:
<span class="nc bnc" id="L4162" title="All 4 branches missed.">                    return (fa &gt;= 150) &amp;&amp; (fa &lt;= 330);</span>
                case ARC_VGL_LF:
<span class="nc bnc" id="L4164" title="All 4 branches missed.">                    return (fa &gt;= 210) || (fa &lt;= 30);</span>
            }
<span class="nc" id="L4166">        }</span>
        // if we got here then no matches
<span class="nc" id="L4168">        return false;</span>
    }

    /**
     * checks to see whether the target is within visual range of the entity,
     * but not necessarily LoS
     */
    public static boolean inVisualRange(IGame game, Entity ae, Targetable target) {
<span class="nc" id="L4176">        return inVisualRange(game, null, ae, target);</span>
    }

    /**
     * Determine whether the attacking entity is within visual range of the
     * target.  This requires line of sight effects to determine if there are
     * certain intervening obstructions, like smoke, that can reduce visual
     * range.  Since repeated LoSEffects computations can be expensive, it is
     * possible to pass in the LosEffects, since they are commonly already
     * computed when this method is called.
     *
     * @param game
     * @param los
     * @param ae
     * @param target
     * @return
     */
    public static boolean inVisualRange(IGame game, LosEffects los, Entity ae,
                                        Targetable target) {
        //Use firing solution if Advanced Sensors is on
<span class="nc bnc" id="L4196" title="All 2 branches missed.">        if (game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_STRATOPS_ADVANCED_SENSORS)</span>
<span class="nc bnc" id="L4197" title="All 2 branches missed.">                &amp;&amp; target.getTargetType() == Targetable.TYPE_ENTITY</span>
<span class="nc bnc" id="L4198" title="All 2 branches missed.">                &amp;&amp; game.getBoard().inSpace()) {</span>
<span class="nc" id="L4199">            Entity te = (Entity) target;</span>
<span class="nc" id="L4200">            return hasAnyFiringSolution(game, te.getId());</span>
        }
<span class="nc" id="L4202">        boolean teIlluminated = false;</span>
<span class="nc bnc" id="L4203" title="All 2 branches missed.">        if (target.getTargetType() == Targetable.TYPE_ENTITY) {</span>
<span class="nc" id="L4204">            Entity te = (Entity) target;</span>
<span class="nc" id="L4205">            teIlluminated = te.isIlluminated();</span>
<span class="nc bnc" id="L4206" title="All 2 branches missed.">            if (te.isOffBoard()) {</span>
<span class="nc" id="L4207">                return false;</span>
            }
        }

        // Target may be in an illuminated hex
<span class="nc bnc" id="L4212" title="All 2 branches missed.">        if (!teIlluminated) {</span>
<span class="nc" id="L4213">            int lightLvl = game.isPositionIlluminated(target.getPosition());</span>
<span class="nc bnc" id="L4214" title="All 2 branches missed.">            teIlluminated = lightLvl != Game.ILLUMINATED_NONE;</span>
        }

        // if either does not have a position then return false
<span class="nc bnc" id="L4218" title="All 4 branches missed.">        if ((ae.getPosition() == null) || (target.getPosition() == null)) {</span>
<span class="nc" id="L4219">            return false;</span>
        }

        // check visual range based on planetary conditions
<span class="nc bnc" id="L4223" title="All 2 branches missed.">        if (los == null) {</span>
<span class="nc" id="L4224">            los = LosEffects.calculateLos(game, ae.getId(), target);</span>
        }
<span class="nc" id="L4226">        int visualRange = getVisualRange(game, ae, los, teIlluminated);</span>

        //Check for factors that only apply to an entity target
<span class="nc" id="L4229">        Coords targetPos = target.getPosition();</span>
<span class="nc bnc" id="L4230" title="All 2 branches missed.">        if (target.getTargetType() == Targetable.TYPE_ENTITY) {</span>
<span class="nc" id="L4231">            Entity te = (Entity) target;</span>

            // check for camo and null sig on the target
<span class="nc bnc" id="L4234" title="All 2 branches missed.">            if (te.isVoidSigActive()) {</span>
<span class="nc" id="L4235">                visualRange = visualRange / 4;</span>
<span class="nc bnc" id="L4236" title="All 2 branches missed.">            } else if (te.hasWorkingMisc(MiscType.F_VISUAL_CAMO, -1)) {</span>
<span class="nc" id="L4237">                visualRange = visualRange / 2;</span>
<span class="nc bnc" id="L4238" title="All 2 branches missed.">            } else if (te.isChameleonShieldActive()) {</span>
<span class="nc" id="L4239">                visualRange = visualRange / 2;</span>
<span class="nc bnc" id="L4240" title="All 4 branches missed.">            } else if (te.isConventionalInfantry() &amp;&amp; ((Infantry) te).hasSneakCamo()) {</span>
<span class="nc" id="L4241">                visualRange = visualRange / 2;</span>
            }

            // Ground targets pick the closest path to Aeros (TW pg 107)
<span class="nc bnc" id="L4245" title="All 4 branches missed.">            if ((te.isAero()) &amp;&amp; isGroundToAir(ae, target)) {</span>
<span class="nc" id="L4246">                targetPos = Compute.getClosestFlightPath(ae.getId(),</span>
<span class="nc" id="L4247">                        ae.getPosition(), te);</span>
            }
            //Airborne aeros can only see ground targets they overfly, and only at Alt &lt;=8
<span class="nc bnc" id="L4250" title="All 2 branches missed.">            if (isAirToGround(ae, target)) {</span>
<span class="nc bnc" id="L4251" title="All 2 branches missed.">                if (ae.getAltitude() &gt; 8) {</span>
<span class="nc" id="L4252">                    return false;</span>
                }
<span class="nc bnc" id="L4254" title="All 2 branches missed.">                if (ae.passedOver(target)) {</span>
<span class="nc" id="L4255">                    return true;</span>
                } else {
<span class="nc" id="L4257">                    return false;</span>
                }
            }
        }

<span class="nc" id="L4262">        visualRange = Math.max(visualRange, 1);</span>
        int distance;
        // Ground distance
<span class="nc" id="L4265">        distance = ae.getPosition().distance(targetPos);</span>
        //Need to track difference in altitude, not just add altitude to the range
<span class="nc" id="L4267">        distance += Math.abs(2 * target.getAltitude() - 2 * ae.getAltitude());</span>
<span class="nc bnc" id="L4268" title="All 2 branches missed.">        return distance &lt;= visualRange;</span>

    }

    //Space Combat Detection stuff

    /**
     * Checks to see if an entity has already been detected by anyone
     * Used for sensor return icons on board
     *
     * @param game     - the current game
     * @param targetId - the ID# of the target entity we're looking for
     */
    public static boolean isAnySensorContact(IGame game, int targetId) {
<span class="nc bnc" id="L4282" title="All 2 branches missed.">        for (Entity detector : game.getEntitiesVector()) {</span>
<span class="nc bnc" id="L4283" title="All 4 branches missed.">            if (detector.hasSensorContactFor(targetId) &amp;&amp; game.getEntity(targetId) != null) {</span>
<span class="nc" id="L4284">                game.getEntity(targetId).addBeenDetectedBy(detector.getOwner());</span>
<span class="nc" id="L4285">                return true;</span>
            }
<span class="nc" id="L4287">        }</span>
<span class="nc" id="L4288">        return false;</span>
    }

    /**
     * Checks to see if target entity has already appeared on @detector's sensors
     * Used with Naval C3 to determine if @detector can fire weapons at @target
     *
     * @param detector - the entity making a sensor scan
     * @param targetId - the entity id of the scan target
     */
    public static boolean hasSensorContact(Entity detector, int targetId) {
<span class="nc" id="L4299">        return detector.hasSensorContactFor(targetId);</span>
    }

    /**
     * Checks to see if an entity is in anyone's firing solutions list
     * Used for visibility
     *
     * @param game     - the current game
     * @param targetId - the ID # of the target we're firing at
     */
    public static boolean hasAnyFiringSolution(IGame game, int targetId) {
<span class="nc bnc" id="L4310" title="All 2 branches missed.">        for (Entity detector : game.getEntitiesVector()) {</span>
<span class="nc bnc" id="L4311" title="All 4 branches missed.">            if (detector.hasFiringSolutionFor(targetId) &amp;&amp; game.getEntity(targetId) != null) {</span>
<span class="nc" id="L4312">                game.getEntity(targetId).addBeenSeenBy(detector.getOwner());</span>
<span class="nc" id="L4313">                return true;</span>
            }
<span class="nc" id="L4315">        }</span>
<span class="nc" id="L4316">        return false;</span>
    }

    /**
     * Calculates the ECM effects in play between a detector and target pair
     *
     * @param game   - the current game
     * @param ae     - the entity making a sensor scan
     * @param target - the entity we're trying to spot
     * @return
     */
    private static int calcSpaceECM(IGame game, Entity ae,
                                    Targetable target) {
<span class="nc" id="L4329">        int mod = 0;</span>
<span class="nc" id="L4330">        int ecm = ComputeECM.getLargeCraftECM(ae, ae.getPosition(), target.getPosition());</span>
<span class="nc bnc" id="L4331" title="All 2 branches missed.">        if (!ae.isLargeCraft()) {</span>
<span class="nc" id="L4332">            ecm += ComputeECM.getSmallCraftECM(ae, ae.getPosition(), target.getPosition());</span>
        }
<span class="nc" id="L4334">        ecm = Math.min(4, ecm);</span>
<span class="nc" id="L4335">        int eccm = 0;</span>
<span class="nc bnc" id="L4336" title="All 2 branches missed.">        if (ae.isLargeCraft()) {</span>
<span class="nc" id="L4337">            eccm = ((Aero) ae).getECCMBonus();</span>
        }
<span class="nc bnc" id="L4339" title="All 2 branches missed.">        if (ecm &gt; 0) {</span>
<span class="nc" id="L4340">            mod += ecm;</span>
<span class="nc bnc" id="L4341" title="All 2 branches missed.">            if (eccm &gt; 0) {</span>
<span class="nc" id="L4342">                mod -= (Math.min(ecm, eccm));</span>
            }
        }
<span class="nc" id="L4345">        return mod;</span>
    }

    /**
     * Calculates the Sensor Shadow effect in play between a detector and target pair
     *
     * @param game   - the current game
     * @param ae     - the entity making a sensor scan
     * @param target - the entity we're trying to spot
     * @return
     */
    private static int calcSensorShadow(IGame game, Entity ae,
                                        Targetable target) {
<span class="nc" id="L4358">        int mod = 0;</span>
<span class="nc bnc" id="L4359" title="All 2 branches missed.">        if (target.getTargetType() != Targetable.TYPE_ENTITY) {</span>
<span class="nc" id="L4360">            return 0;</span>
        }
<span class="nc" id="L4362">        Entity te = (Entity) target;</span>
<span class="nc bnc" id="L4363" title="All 2 branches missed.">        for (Entity en : Compute.getAdjacentEntitiesAlongAttack(ae.getPosition(), target.getPosition(), game)) {</span>
<span class="nc bnc" id="L4364" title="All 8 branches missed.">            if (!en.isEnemyOf(te) &amp;&amp; en.isLargeCraft() &amp;&amp; !en.equals((Entity) te) &amp;&amp; ((en.getWeight() - te.getWeight()) &gt;= -100000.0)) {</span>
<span class="nc" id="L4365">                mod++;</span>
<span class="nc" id="L4366">                break;</span>
            }
<span class="nc" id="L4368">        }</span>
<span class="nc bnc" id="L4369" title="All 2 branches missed.">        for (Entity en : game.getEntitiesVector(target.getPosition())) {</span>
<span class="nc bnc" id="L4370" title="All 8 branches missed.">            if (!en.isEnemyOf(te) &amp;&amp; en.isLargeCraft() &amp;&amp; !en.equals((Entity) ae) &amp;&amp; !en.equals((Entity) te)</span>
<span class="nc bnc" id="L4371" title="All 2 branches missed.">                    &amp;&amp; ((en.getWeight() - te.getWeight()) &gt;= -100000.0)) {</span>
<span class="nc" id="L4372">                mod++;</span>
<span class="nc" id="L4373">                break;</span>
            }
<span class="nc" id="L4375">        }</span>
<span class="nc" id="L4376">        return mod;</span>
    }

    /**
     * Updates an entity's firingSolutions, removing any objects that no longer meet criteria for being
     * tracked as targets. Also, if the detecting entity no longer meets criteria for having firing solutions,
     * empty the list. We wouldn't want a dead ship to be providing NC3 data, now would we...
     */
    public static void updateFiringSolutions(IGame game, Entity detector) {
<span class="nc" id="L4385">        List&lt;Integer&gt; toRemove = new ArrayList&lt;Integer&gt;();</span>
        //Flush the detecting unit's firing solutions if any of these conditions applies
<span class="nc bnc" id="L4387" title="All 2 branches missed.">        if (detector.isDestroyed()</span>
<span class="nc bnc" id="L4388" title="All 2 branches missed.">                || detector.isDoomed()</span>
<span class="nc bnc" id="L4389" title="All 2 branches missed.">                || detector.getTransportId() != Entity.NONE</span>
<span class="nc bnc" id="L4390" title="All 2 branches missed.">                || detector.isPartOfFighterSquadron()</span>
<span class="nc bnc" id="L4391" title="All 2 branches missed.">                || detector.isOffBoard()</span>
<span class="nc bnc" id="L4392" title="All 2 branches missed.">                || detector.getPosition() == null) {</span>
<span class="nc" id="L4393">            detector.clearFiringSolutions();</span>
<span class="nc" id="L4394">            return;</span>
        }
<span class="nc bnc" id="L4396" title="All 2 branches missed.">        for (int id : detector.getFiringSolutions()) {</span>
<span class="nc" id="L4397">            Entity target = game.getEntity(id);</span>
            //The target should be removed if it's off the board for any of these reasons
<span class="nc bnc" id="L4399" title="All 2 branches missed.">            if (target == null</span>
<span class="nc bnc" id="L4400" title="All 2 branches missed.">                    || target.getPosition() == null</span>
<span class="nc bnc" id="L4401" title="All 2 branches missed.">                    || target.isDestroyed()</span>
<span class="nc bnc" id="L4402" title="All 2 branches missed.">                    || target.isDoomed()</span>
<span class="nc bnc" id="L4403" title="All 2 branches missed.">                    || target.getTransportId() != Entity.NONE</span>
<span class="nc bnc" id="L4404" title="All 2 branches missed.">                    || target.isPartOfFighterSquadron()</span>
<span class="nc bnc" id="L4405" title="All 2 branches missed.">                    || target.isOffBoard()) {</span>
<span class="nc" id="L4406">                toRemove.add(id);</span>
<span class="nc" id="L4407">                continue;</span>
            }
<span class="nc" id="L4409">            Coords targetPos = target.getPosition();</span>
<span class="nc" id="L4410">            int distance = detector.getPosition().distance(targetPos);</span>
            //Per SO p119, optical firing solutions are lost if the target moves beyond 1/10 max range
<span class="nc bnc" id="L4412" title="All 4 branches missed.">            if (detector.getActiveSensor().getType() == Sensor.TYPE_AERO_THERMAL</span>
                    &amp;&amp; distance &gt; Sensor.ASF_OPTICAL_FIRING_SOLUTION_RANGE) {
<span class="nc" id="L4414">                toRemove.add(id);</span>
<span class="nc bnc" id="L4415" title="All 4 branches missed.">            } else if (detector.getActiveSensor().getType() == Sensor.TYPE_SPACECRAFT_THERMAL</span>
                    &amp;&amp; distance &gt; Sensor.LC_OPTICAL_FIRING_SOLUTION_RANGE) {
<span class="nc" id="L4417">                toRemove.add(id);</span>
                //For ASF sensors, make sure we're using the space range of 555...
<span class="nc bnc" id="L4419" title="All 4 branches missed.">            } else if (detector.getActiveSensor().getType() == Sensor.TYPE_AERO_SENSOR</span>
                    &amp;&amp; distance &gt; Sensor.ASF_RADAR_MAX_RANGE) {
<span class="nc" id="L4421">                toRemove.add(id);</span>
            } else {
                //Radar firing solutions are only lost if the target moves out of range
<span class="nc bnc" id="L4424" title="All 2 branches missed.">                if (distance &gt; detector.getActiveSensor().getRangeByBracket()) {</span>
<span class="nc" id="L4425">                    toRemove.add(id);</span>
                }
            }
<span class="nc" id="L4428">        }</span>
<span class="nc" id="L4429">        detector.removeFiringSolution(toRemove);</span>
<span class="nc" id="L4430">    }</span>

    /**
     * Updates an entity's sensorContacts, removing any objects that no longer meet criteria for being
     * tracked. Also, if the detecting entity no longer meets criteria for having sensor contacts,
     * empty the list. We wouldn't want a dead ship to be providing sensor data, now would we...
     */
    public static void updateSensorContacts(IGame game, Entity detector) {
<span class="nc" id="L4438">        List&lt;Integer&gt; toRemove = new ArrayList&lt;Integer&gt;();</span>
        //Flush the detecting unit's sensor contacts if any of these conditions applies
<span class="nc bnc" id="L4440" title="All 2 branches missed.">        if (detector.getPosition() == null</span>
<span class="nc bnc" id="L4441" title="All 2 branches missed.">                || detector.isDestroyed()</span>
<span class="nc bnc" id="L4442" title="All 2 branches missed.">                || detector.isDoomed()</span>
<span class="nc bnc" id="L4443" title="All 2 branches missed.">                || detector.getTransportId() != Entity.NONE</span>
<span class="nc bnc" id="L4444" title="All 2 branches missed.">                || detector.isPartOfFighterSquadron()</span>
<span class="nc bnc" id="L4445" title="All 2 branches missed.">                || detector.isOffBoard()) {</span>
<span class="nc" id="L4446">            detector.clearSensorContacts();</span>
<span class="nc" id="L4447">            return;</span>
        }
<span class="nc bnc" id="L4449" title="All 2 branches missed.">        for (int id : detector.getSensorContacts()) {</span>
<span class="nc" id="L4450">            Entity target = game.getEntity(id);</span>
            //The target should be removed if it's off the board for any of these reasons
<span class="nc bnc" id="L4452" title="All 2 branches missed.">            if (target == null</span>
<span class="nc bnc" id="L4453" title="All 2 branches missed.">                    || target.getPosition() == null</span>
<span class="nc bnc" id="L4454" title="All 2 branches missed.">                    || target.isDestroyed()</span>
<span class="nc bnc" id="L4455" title="All 2 branches missed.">                    || target.isDoomed()</span>
<span class="nc bnc" id="L4456" title="All 2 branches missed.">                    || target.getTransportId() != Entity.NONE</span>
<span class="nc bnc" id="L4457" title="All 2 branches missed.">                    || target.isPartOfFighterSquadron()</span>
<span class="nc bnc" id="L4458" title="All 2 branches missed.">                    || target.isOffBoard()) {</span>
<span class="nc" id="L4459">                toRemove.add(id);</span>
<span class="nc" id="L4460">                continue;</span>
            }
            //And now calculate whether or not the target has moved out of range. Per SO p117-119,
            //sensor contacts remain tracked on the plotting board until this occurs.
<span class="nc" id="L4464">            Coords targetPos = target.getPosition();</span>
<span class="nc" id="L4465">            int distance = detector.getPosition().distance(targetPos);</span>
<span class="nc bnc" id="L4466" title="All 2 branches missed.">            if (distance &gt; detector.getActiveSensor().getRangeByBracket()) {</span>
<span class="nc" id="L4467">                toRemove.add(id);</span>
            }
<span class="nc" id="L4469">        }</span>
<span class="nc" id="L4470">        detector.removeSensorContact(toRemove);</span>
<span class="nc" id="L4471">    }</span>


    /**
     * If the game is in space, &quot;visual range&quot; represents a firing solution as defined in SO starting on p117
     * Also, in most cases each target must be detected with sensors before it can be seen, so we need to make
     * sensor rolls for detection. This should only be used if Tacops sensor rules are in use.
     * This requires line of sight effects to determine if there are
     * certain intervening obstructions, like sensor shadows, asteroids and that sort of thing, that can reduce visual
     * range.  Since repeated LoSEffects computations can be expensive, it is
     * possible to pass in the LosEffects, since they are commonly already
     * computed when this method is called.
     *
     * @param game   - the current game
     * @param ae     - the entity making a sensor scan
     * @param target - the entity we're trying to spot
     * @return
     */

    public static boolean calcFiringSolution(IGame game, Entity ae,
                                             Targetable target) {
<span class="nc bnc" id="L4492" title="All 2 branches missed.">        if (target.getTargetType() == Targetable.TYPE_ENTITY) {</span>
<span class="nc" id="L4493">            Entity te = (Entity) target;</span>
<span class="nc bnc" id="L4494" title="All 2 branches missed.">            if (te.isOffBoard()) {</span>
<span class="nc" id="L4495">                return false;</span>
            }
        }

        //NPE check. Fighter squadrons don't start with sensors, but pick them up from the component fighters each round
<span class="nc bnc" id="L4500" title="All 2 branches missed.">        if (ae.getActiveSensor() == null) {</span>
<span class="nc" id="L4501">            return false;</span>
        }

        //ESM sensor can't produce a firing solution
<span class="nc bnc" id="L4505" title="All 2 branches missed.">        if (ae.getActiveSensor().getType() == Sensor.TYPE_SPACECRAFT_ESM) {</span>
<span class="nc" id="L4506">            return false;</span>
        }
<span class="nc" id="L4508">        Coords targetPos = target.getPosition();</span>
<span class="nc" id="L4509">        int distance = ae.getPosition().distance(targetPos);</span>
<span class="nc" id="L4510">        int roll = Compute.d6(2);</span>
<span class="nc" id="L4511">        int tn = ae.getCrew().getPiloting();</span>
<span class="nc" id="L4512">        int autoVisualRange = 1;</span>
<span class="nc" id="L4513">        int outOfVisualRange = (ae.getActiveSensor().getRangeByBracket());</span>
<span class="nc" id="L4514">        int rangeIncrement = (int) Math.ceil(outOfVisualRange / 10.0);</span>

        //A bit of a hack here. &quot;Aero Sensors&quot; return the ground range, because Sensor doesn't know about Game or Entity
        //to do otherwise. We need to use the space range instead.
<span class="nc bnc" id="L4518" title="All 2 branches missed.">        if (ae.getActiveSensor().getType() == Sensor.TYPE_AERO_SENSOR) {</span>
<span class="nc" id="L4519">            outOfVisualRange = Sensor.ASF_RADAR_MAX_RANGE;</span>
<span class="nc" id="L4520">            rangeIncrement = Sensor.ASF_RADAR_AUTOSPOT_RANGE;</span>
        }

<span class="nc bnc" id="L4523" title="All 2 branches missed.">        if (distance &gt; outOfVisualRange) {</span>
<span class="nc" id="L4524">            return false;</span>
        }

<span class="nc bnc" id="L4527" title="All 2 branches missed.">        if (ae instanceof Aero) {</span>
<span class="nc" id="L4528">            Aero aero = (Aero) ae;</span>
            //Account for sensor damage
<span class="nc bnc" id="L4530" title="All 2 branches missed.">            if (aero.isAeroSensorDestroyed()) {</span>
<span class="nc" id="L4531">                return false;</span>
            } else {
<span class="nc" id="L4533">                tn += aero.getSensorHits();</span>
            }
        }

        //Targets at 1/10 max range are automatically detected
<span class="nc bnc" id="L4538" title="All 2 branches missed.">        if (ae.getActiveSensor().getType() == Sensor.TYPE_AERO_SENSOR) {</span>
<span class="nc" id="L4539">            autoVisualRange = Sensor.ASF_RADAR_AUTOSPOT_RANGE;</span>
<span class="nc bnc" id="L4540" title="All 2 branches missed.">        } else if (ae.getActiveSensor().getType() == Sensor.TYPE_SPACECRAFT_RADAR) {</span>
<span class="nc" id="L4541">            autoVisualRange = Sensor.LC_RADAR_AUTOSPOT_RANGE;</span>
<span class="nc bnc" id="L4542" title="All 2 branches missed.">        } else if (ae.getActiveSensor().getType() == Sensor.TYPE_AERO_THERMAL) {</span>
<span class="nc" id="L4543">            autoVisualRange = Sensor.ASF_OPTICAL_FIRING_SOLUTION_RANGE;</span>
<span class="nc bnc" id="L4544" title="All 2 branches missed.">        } else if (ae.getActiveSensor().getType() == Sensor.TYPE_SPACECRAFT_THERMAL) {</span>
<span class="nc" id="L4545">            autoVisualRange = Sensor.LC_OPTICAL_FIRING_SOLUTION_RANGE;</span>
        }

<span class="nc bnc" id="L4548" title="All 2 branches missed.">        if (distance &lt;= autoVisualRange) {</span>
<span class="nc" id="L4549">            return true;</span>
        }

        //Apply Sensor Geek SPA, if present
<span class="nc bnc" id="L4553" title="All 2 branches missed.">        if (ae.hasAbility(OptionsConstants.UNOFF_SENSOR_GEEK)) {</span>
<span class="nc" id="L4554">            tn -= 2;</span>
        }

        //Otherwise, we add +1 to the tn for detection for each increment of the autovisualrange between attacker and target
<span class="nc" id="L4558">        tn += (distance / rangeIncrement);</span>

        // Apply ECM/ECCM effects
<span class="nc bnc" id="L4561" title="All 2 branches missed.">        if (game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_STRATOPS_ECM)) {</span>
<span class="nc" id="L4562">            tn += calcSpaceECM(game, ae, target);</span>
        }

        // Apply large craft sensor shadows
<span class="nc bnc" id="L4566" title="All 2 branches missed.">        if (game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_STRATOPS_SENSOR_SHADOW)) {</span>
<span class="nc" id="L4567">            tn += calcSensorShadow(game, ae, target);</span>
        }

        //Apply modifiers for attacker's equipment
        //-2 for a working Large NCSS
<span class="nc bnc" id="L4572" title="All 2 branches missed.">        if (ae.hasWorkingMisc(MiscType.F_LARGE_COMM_SCANNER_SUITE)) {</span>
<span class="nc" id="L4573">            tn -= 2;</span>
        }
        //-1 for a working Small NCSS
<span class="nc bnc" id="L4576" title="All 2 branches missed.">        if (ae.hasWorkingMisc(MiscType.F_SMALL_COMM_SCANNER_SUITE)) {</span>
<span class="nc" id="L4577">            tn -= 1;</span>
        }
        //-2 for any type of BAP or EW Equipment. ECM is already accounted for, so don't let the BAP check do that
<span class="nc bnc" id="L4580" title="All 2 branches missed.">        if (ae.hasWorkingMisc(MiscType.F_EW_EQUIPMENT)</span>
<span class="nc bnc" id="L4581" title="All 2 branches missed.">                || ae.hasBAP(false)) {</span>
<span class="nc" id="L4582">            tn -= 2;</span>
        }

        //Now, determine if we've detected the target this round
<span class="nc bnc" id="L4586" title="All 2 branches missed.">        return roll &gt;= tn;</span>
    }

    /**
     * Determines whether we have an &quot;object&quot; detection as defined in SO's Advanced Sensors rules starting on p117
     *
     * @param game   - the current game
     * @param ae     - the entity making a sensor scan
     * @param target - the entity we're trying to spot
     * @return
     */

    public static boolean calcSensorContact(IGame game, Entity ae,
                                            Targetable target) {

        //NPE check. Fighter squadrons don't start with sensors, but pick them up from the component fighters each round
<span class="nc bnc" id="L4602" title="All 2 branches missed.">        if (ae.getActiveSensor() == null) {</span>
<span class="nc" id="L4603">            return false;</span>
        }
<span class="nc" id="L4605">        Coords targetPos = target.getPosition();</span>
<span class="nc" id="L4606">        int distance = ae.getPosition().distance(targetPos);</span>
<span class="nc" id="L4607">        int roll = Compute.d6(2);</span>
<span class="nc" id="L4608">        int tn = ae.getCrew().getPiloting();</span>
<span class="nc" id="L4609">        int maxSensorRange = ae.getActiveSensor().getRangeByBracket();</span>
<span class="nc" id="L4610">        int rangeIncrement = (int) Math.ceil(maxSensorRange / 10.0);</span>

        //A bit of a hack here. &quot;Aero Sensors&quot; return the ground range, because Sensor doesn't know about Game or Entity
        //to do otherwise. We need to use the space range instead.
<span class="nc bnc" id="L4614" title="All 2 branches missed.">        if (ae.getActiveSensor().getType() == Sensor.TYPE_AERO_SENSOR) {</span>
<span class="nc" id="L4615">            maxSensorRange = Sensor.ASF_RADAR_MAX_RANGE;</span>
<span class="nc" id="L4616">            rangeIncrement = Sensor.ASF_RADAR_AUTOSPOT_RANGE;</span>
        }

<span class="nc bnc" id="L4619" title="All 2 branches missed.">        if (ae instanceof Aero) {</span>
<span class="nc" id="L4620">            Aero aero = (Aero) ae;</span>
            //Account for sensor damage
<span class="nc bnc" id="L4622" title="All 2 branches missed.">            if (aero.isAeroSensorDestroyed()) {</span>
<span class="nc" id="L4623">                return false;</span>
            } else {
<span class="nc" id="L4625">                tn += aero.getSensorHits();</span>
            }
        }

        //Apply modifiers for attacker's equipment
        //-2 for a working Large NCSS.  Triple the detection range.
<span class="nc bnc" id="L4631" title="All 2 branches missed.">        if (ae.hasWorkingMisc(MiscType.F_LARGE_COMM_SCANNER_SUITE)) {</span>
<span class="nc" id="L4632">            maxSensorRange *= 3;</span>
<span class="nc" id="L4633">            tn -= 2;</span>
        }
        //-1 for a working Small NCSS. Double the detection range.
<span class="nc bnc" id="L4636" title="All 2 branches missed.">        if (ae.hasWorkingMisc(MiscType.F_SMALL_COMM_SCANNER_SUITE)) {</span>
<span class="nc" id="L4637">            maxSensorRange *= 2;</span>
<span class="nc" id="L4638">            tn -= 1;</span>
        }
        //-2 for any type of BAP or EW Equipment. ECM is already accounted for, so don't let the BAP check do that
<span class="nc bnc" id="L4641" title="All 2 branches missed.">        if (ae.hasWorkingMisc(MiscType.F_EW_EQUIPMENT)</span>
<span class="nc bnc" id="L4642" title="All 2 branches missed.">                || ae.hasBAP(false)) {</span>
<span class="nc" id="L4643">            tn -= 2;</span>
        }

        //Military ESM automatically detects anyone using active sensors, which includes all telemissiles
<span class="nc bnc" id="L4647" title="All 4 branches missed.">        if (ae.getActiveSensor().getType() == Sensor.TYPE_SPACECRAFT_ESM &amp;&amp; target.getTargetType() == Targetable.TYPE_ENTITY) {</span>
<span class="nc" id="L4648">            Entity te = (Entity) target;</span>
<span class="nc bnc" id="L4649" title="All 2 branches missed.">            if (te.getActiveSensor().getType() == Sensor.TYPE_AERO_SENSOR</span>
<span class="nc bnc" id="L4650" title="All 4 branches missed.">                    || te.getActiveSensor().getType() == Sensor.TYPE_SPACECRAFT_RADAR</span>
                    || te instanceof TeleMissile) {
<span class="nc" id="L4652">                return true;</span>
            }
<span class="nc" id="L4654">            return false;</span>
        }

        //Can't detect anything beyond this distance
<span class="nc bnc" id="L4658" title="All 2 branches missed.">        if (distance &gt; maxSensorRange) {</span>
<span class="nc" id="L4659">            return false;</span>
        }

        //Apply Sensor Geek SPA, if present
<span class="nc bnc" id="L4663" title="All 2 branches missed.">        if (ae.hasAbility(OptionsConstants.UNOFF_SENSOR_GEEK)) {</span>
<span class="nc" id="L4664">            tn -= 2;</span>
        }

        //Otherwise, we add +1 to the tn for each 1/10 of the max sensor range (rounded up) between attacker and target
<span class="nc" id="L4668">        tn += (distance / rangeIncrement);</span>

        // Apply ECM/ECCM effects
<span class="nc bnc" id="L4671" title="All 2 branches missed.">        if (game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_STRATOPS_ECM)) {</span>
<span class="nc" id="L4672">            tn += calcSpaceECM(game, ae, target);</span>
        }

        // Apply large craft sensor shadows
<span class="nc bnc" id="L4676" title="All 2 branches missed.">        if (game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_STRATOPS_SENSOR_SHADOW)) {</span>
<span class="nc" id="L4677">            tn += calcSensorShadow(game, ae, target);</span>
        }

        //Now, determine if we've detected the target this round
<span class="nc bnc" id="L4681" title="All 2 branches missed.">        return roll &gt;= tn;</span>
    }

    public static int getVisualRange(IGame game, Entity ae, LosEffects los,
                                     boolean teIlluminated) {
<span class="nc" id="L4686">        int visualRange = game.getPlanetaryConditions().getVisualRange(ae,</span>
                teIlluminated);
<span class="nc" id="L4688">        visualRange -= los.getLightSmoke();</span>
<span class="nc" id="L4689">        visualRange -= 2 * los.getHeavySmoke();</span>
<span class="nc" id="L4690">        visualRange = Math.max(1, visualRange);</span>
<span class="nc" id="L4691">        return visualRange;</span>
    }

    /**
     * Checks to see whether the target is within sensor range (but not
     * necessarily LoS or visual range)
     *
     * @param allECMInfo A collection of ECMInfo for all entities, this value
     *                   can be null and it will be computed when it's
     *                   needed, however passing in the pre-computed
     *                   collection is much faster
     */
    public static boolean inSensorRange(IGame game, Entity ae,
                                        Targetable target, List&lt;ECMInfo&gt; allECMInfo) {
<span class="nc" id="L4705">        return inSensorRange(game, null, ae, target, allECMInfo);</span>
    }

    public static boolean inSensorRange(IGame game, LosEffects los, Entity ae,
                                        Targetable target, List&lt;ECMInfo&gt; allECMInfo) {
        // This is not applicable to objects on the same team.
<span class="nc bnc" id="L4711" title="All 2 branches missed.">        if (!target.isEnemyOf(ae)) {</span>
<span class="nc" id="L4712">            return false;</span>
        }

        //For Space games with this option, return something different
<span class="nc bnc" id="L4716" title="All 2 branches missed.">        if (game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_STRATOPS_ADVANCED_SENSORS)</span>
<span class="nc bnc" id="L4717" title="All 2 branches missed.">                &amp;&amp; target.getTargetType() == Targetable.TYPE_ENTITY</span>
<span class="nc bnc" id="L4718" title="All 2 branches missed.">                &amp;&amp; game.getBoard().inSpace()) {</span>
<span class="nc" id="L4719">            Entity te = (Entity) target;</span>
<span class="nc" id="L4720">            return hasSensorContact(ae, te.getId());</span>
        }

<span class="nc bnc" id="L4723" title="All 2 branches missed.">        if (!game.getOptions().booleanOption(OptionsConstants.ADVANCED_TACOPS_SENSORS)) {</span>
<span class="nc" id="L4724">            return false;</span>
        }

        // if either does not have a position then return false
<span class="nc bnc" id="L4728" title="All 4 branches missed.">        if ((ae.getPosition() == null) || (target.getPosition() == null)) {</span>
<span class="nc" id="L4729">            return false;</span>
        }

        // If we have no sensors then return false
<span class="nc bnc" id="L4733" title="All 2 branches missed.">        if (ae.getActiveSensor() == null) {</span>
<span class="nc" id="L4734">            return false;</span>
        }

<span class="nc" id="L4737">        int bracket = Compute.getSensorRangeBracket(ae, target, allECMInfo);</span>
<span class="nc" id="L4738">        int range = Compute.getSensorRangeByBracket(game, ae, target, los);</span>

<span class="nc" id="L4740">        int maxSensorRange = bracket * range;</span>
<span class="nc" id="L4741">        int minSensorRange = Math.max((bracket - 1) * range, 0);</span>
<span class="nc bnc" id="L4742" title="All 2 branches missed.">        if (game.getOptions().booleanOption(OptionsConstants.ADVANCED_INCLUSIVE_SENSOR_RANGE)) {</span>
<span class="nc" id="L4743">            minSensorRange = 0;</span>
        }

<span class="nc" id="L4746">        int distance = ae.getPosition().distance(target.getPosition());</span>

        //Aeros have to check visibility to ground targets for the closest point of approach along their flight path
        //Because the rules state &quot;within X hexes of the flight path&quot; we're using ground distance so altitude doesn't screw us up
<span class="nc bnc" id="L4750" title="All 4 branches missed.">        if (isAirToGround(ae, target) &amp;&amp; (target instanceof Entity)) {</span>
<span class="nc" id="L4751">            Entity te = (Entity) target;</span>
<span class="nc" id="L4752">            distance = te.getPosition().distance(</span>
<span class="nc" id="L4753">                    getClosestFlightPath(te.getId(),</span>
<span class="nc" id="L4754">                            te.getPosition(), (Entity) ae));</span>
<span class="nc bnc" id="L4755" title="All 4 branches missed.">            return (distance &gt; minSensorRange) &amp;&amp; (distance &lt;= maxSensorRange);</span>
        }
        //This didn't work right for Aeros. Should account for the difference in altitude, not just add the target's altitude to distance
<span class="nc" id="L4758">        distance += Math.abs(2 * target.getAltitude() - 2 * ae.getAltitude());</span>

        // if this is an air-to-air scan on the ground map, then divide distance by 16 to match weapon ranges
        // I purposely left this calculation out of visual spotting, so we should do some testing with this and
        // see if it's errata-worthy. The idea is that you'll boost sensor range to help find an enemy aero on the map
        // but still won't be able to see it and shoot at it beyond normal visual conditions.
<span class="nc bnc" id="L4764" title="All 4 branches missed.">        if (isAirToAir(ae, target) &amp;&amp; game.getBoard().onGround()) {</span>
<span class="nc" id="L4765">            distance = (int) Math.ceil(distance / 16.0);</span>
        }
<span class="nc bnc" id="L4767" title="All 4 branches missed.">        return (distance &gt; minSensorRange) &amp;&amp; (distance &lt;= maxSensorRange);</span>
    }

    /**
     * Checks to see if the target is visible to the unit, always considering
     * sensors.
     */
    public static boolean canSee(IGame game, Entity ae, Targetable target) {
<span class="nc" id="L4775">        return canSee(game, ae, target, true, null, null);</span>
    }

    /**
     * Checks to see if the target is visible to the unit, if the sensor flag
     * is true then sensors are checked as well.
     */
    public static boolean canSee(IGame game, Entity ae, Targetable target,
                                 boolean useSensors, LosEffects los, List&lt;ECMInfo&gt; allECMInfo) {

<span class="nc bnc" id="L4785" title="All 2 branches missed.">        if (!ae.getCrew().isActive()) {</span>
<span class="nc" id="L4786">            return false;</span>
        }
<span class="nc bnc" id="L4788" title="All 2 branches missed.">        if (target.isOffBoard()) {</span>
<span class="nc" id="L4789">            return false;</span>
        }

<span class="nc bnc" id="L4792" title="All 2 branches missed.">        if (los == null) {</span>
<span class="nc" id="L4793">            los = LosEffects.calculateLos(game, ae.getId(), target);</span>
        }
<span class="nc bnc" id="L4795" title="All 2 branches missed.">        boolean isVisible = los.canSee()</span>
<span class="nc bnc" id="L4796" title="All 2 branches missed.">                &amp;&amp; Compute.inVisualRange(game, los, ae, target);</span>
<span class="nc bnc" id="L4797" title="All 2 branches missed.">        if (useSensors) {</span>
<span class="nc bnc" id="L4798" title="All 2 branches missed.">            isVisible = isVisible</span>
<span class="nc bnc" id="L4799" title="All 2 branches missed.">                    || Compute.inSensorRange(game, los, ae, target, allECMInfo);</span>
        }
<span class="nc" id="L4801">        return isVisible;</span>
    }

    /**
     * gets the sensor range bracket when detecting a particular type of target.
     * target may be null here, which gives you the bracket without target
     * entity modifiers
     *
     * @param allECMInfo A collection of ECMInfo for all entities, this value
     *                   can be null and it will be computed when it's
     *                   needed, however passing in the pre-computed
     *                   collection is much faster
     */
    public static int getSensorRangeBracket(Entity ae, Targetable target,
                                            List&lt;ECMInfo&gt; allECMInfo) {

<span class="nc" id="L4817">        Sensor sensor = ae.getActiveSensor();</span>
<span class="nc bnc" id="L4818" title="All 2 branches missed.">        if (null == sensor) {</span>
<span class="nc" id="L4819">            return 0;</span>
        }
        // only works for entities
<span class="nc" id="L4822">        Entity te = null;</span>
<span class="nc bnc" id="L4823" title="All 2 branches missed.">        if (null != target) {</span>
<span class="nc bnc" id="L4824" title="All 2 branches missed.">            if (target.getTargetType() != Targetable.TYPE_ENTITY) {</span>
<span class="nc" id="L4825">                return 0;</span>
            }
<span class="nc" id="L4827">            te = (Entity) target;</span>
        }

        // if this sensor is an active probe and it is critted, then no can see
<span class="nc bnc" id="L4831" title="All 4 branches missed.">        if (sensor.isBAP() &amp;&amp; !ae.hasBAP(false)) {</span>
<span class="nc" id="L4832">            return 0;</span>
        }

        //In space, sensors don't have brackets, so we should always return the range for bracket 1.
<span class="nc bnc" id="L4836" title="All 2 branches missed.">        if (ae.isSpaceborne()) {</span>
<span class="nc" id="L4837">            return Compute.getSensorBracket(7);</span>
        }

<span class="nc" id="L4840">        int check = ae.getSensorCheck();</span>
<span class="nc bnc" id="L4841" title="All 4 branches missed.">        if ((null != ae.getCrew()) &amp;&amp; ae.hasAbility(OptionsConstants.UNOFF_SENSOR_GEEK)) {</span>
<span class="nc" id="L4842">            check -= 2;</span>
        }
<span class="nc bnc" id="L4844" title="All 2 branches missed.">        if (null != te) {</span>
<span class="nc" id="L4845">            check += sensor.getModsForStealth(te);</span>
            // Metal Content...
<span class="nc bnc" id="L4847" title="All 2 branches missed.">            if (ae.getGame().getOptions().booleanOption(OptionsConstants.ADVANCED_METAL_CONTENT)) {</span>
<span class="nc" id="L4848">                check += sensor.getModForMetalContent(ae, te);</span>
            }
        }
        // ECM bubbles
<span class="nc" id="L4852">        check += sensor.getModForECM(ae, allECMInfo);</span>

<span class="nc" id="L4854">        return Compute.getSensorBracket(check);</span>
    }

    /**
     * returns the brackets for sensor checks
     */
    public static int getSensorBracket(int check) {
        // get the range bracket (0 - none; 1 - short; 2 - medium; 3 - long)
<span class="nc" id="L4862">        int bracket = 0;</span>
<span class="nc bnc" id="L4863" title="All 4 branches missed.">        if ((check == 7) || (check == 8)) {</span>
<span class="nc" id="L4864">            bracket = 1;</span>
        }
<span class="nc bnc" id="L4866" title="All 4 branches missed.">        if ((check == 5) || (check == 6)) {</span>
<span class="nc" id="L4867">            bracket = 2;</span>
        }
<span class="nc bnc" id="L4869" title="All 2 branches missed.">        if (check &lt; 5) {</span>
<span class="nc" id="L4870">            bracket = 3;</span>
        }
<span class="nc" id="L4872">        return bracket;</span>
    }

    /**
     * gets the size of the sensor range bracket when detecting a particular
     * type of target. target may be null here, which gives you the range
     * without target entity modifiers
     */
    public static int getSensorRangeByBracket(IGame game, Entity ae,
                                              Targetable target, LosEffects los) {
<span class="nc bnc" id="L4882" title="All 2 branches missed.">        if (los == null) {</span>
<span class="nc" id="L4883">            los = LosEffects.calculateLos(game, ae.getId(), target);</span>
        }
<span class="nc" id="L4885">        Sensor sensor = ae.getActiveSensor();</span>
<span class="nc bnc" id="L4886" title="All 2 branches missed.">        if (null == sensor) {</span>
<span class="nc" id="L4887">            return 0;</span>
        }
        // only works for entities
<span class="nc" id="L4890">        Entity te = null;</span>
<span class="nc bnc" id="L4891" title="All 2 branches missed.">        if (null != target) {</span>
<span class="nc bnc" id="L4892" title="All 2 branches missed.">            if (target.getTargetType() != Targetable.TYPE_ENTITY) {</span>
<span class="nc" id="L4893">                return 0;</span>
            }
<span class="nc" id="L4895">            te = (Entity) target;</span>
        }

        // if this sensor is an active probe and it is critted, then no can see
<span class="nc bnc" id="L4899" title="All 4 branches missed.">        if (sensor.isBAP() &amp;&amp; !ae.hasBAP(false)) {</span>
<span class="nc" id="L4900">            return 0;</span>
        }

        // if we are crossing water then only magscan will work unless we are a
        // naval vessel
<span class="nc bnc" id="L4905" title="All 4 branches missed.">        if ((null != te) &amp;&amp; los.isBlockedByWater()</span>
<span class="nc bnc" id="L4906" title="All 2 branches missed.">                &amp;&amp; (sensor.getType() != Sensor.TYPE_MEK_MAGSCAN)</span>
<span class="nc bnc" id="L4907" title="All 2 branches missed.">                &amp;&amp; (sensor.getType() != Sensor.TYPE_VEE_MAGSCAN)</span>
<span class="nc bnc" id="L4908" title="All 2 branches missed.">                &amp;&amp; (ae.getMovementMode() != EntityMovementMode.HYDROFOIL)</span>
<span class="nc bnc" id="L4909" title="All 2 branches missed.">                &amp;&amp; (ae.getMovementMode() != EntityMovementMode.NAVAL)) {</span>
<span class="nc" id="L4910">            return 0;</span>
        }

        // now get the range
<span class="nc" id="L4914">        int range = sensor.getRangeByBracket();</span>

        // adjust the range based on LOS and planetary conditions
<span class="nc" id="L4917">        range = sensor.adjustRange(range, game, los);</span>

        //If we're an airborne aero, sensor range is limited to within a few hexes of the flightline against ground targets
        //TO Dec 2017 Errata p17
<span class="nc bnc" id="L4921" title="All 6 branches missed.">        if (te != null &amp;&amp; ae.isAirborne() &amp;&amp; !te.isAirborne()) {</span>
            //Can't see anything if above Alt 8.
<span class="nc bnc" id="L4923" title="All 2 branches missed.">            if (ae.getAltitude() &gt; 8) {</span>
<span class="nc" id="L4924">                range = 0;</span>
<span class="nc bnc" id="L4925" title="All 2 branches missed.">            } else if (sensor.isBAP()) {</span>
                //Add 1 to range for active probe of any type
<span class="nc" id="L4927">                range = 2;</span>
            } else {
                //Basic sensor range listed in errata
<span class="nc" id="L4930">                range = 1;</span>
            }
<span class="nc" id="L4932">            return range;</span>
        }

        // now adjust for anything about the target entity (size, heat, etc)
<span class="nc bnc" id="L4936" title="All 2 branches missed.">        if (null != te) {</span>
<span class="nc" id="L4937">            range = sensor.entityAdjustments(range, te, game);</span>
        }

<span class="nc bnc" id="L4940" title="All 2 branches missed.">        if (range &lt; 0) {</span>
<span class="nc" id="L4941">            range = 0;</span>
        }

<span class="nc" id="L4944">        return range;</span>

    }

    public static int targetSideTable(Coords inPosition, Targetable target) {
<span class="nc" id="L4949">        return target.sideTable(inPosition);</span>
    }

    public static int targetSideTable(Entity attacker, Targetable target) {
<span class="nc" id="L4953">        return Compute</span>
<span class="nc" id="L4954">                .targetSideTable(attacker, target, CalledShot.CALLED_NONE);</span>
    }

    public static int targetSideTable(Entity attacker, Targetable target,
                                      int called) {
<span class="nc" id="L4959">        Coords attackPos = attacker.getPosition();</span>

<span class="nc" id="L4961">        Entity te = null;</span>
<span class="nc bnc" id="L4962" title="All 2 branches missed.">        if (target instanceof Entity) {</span>
<span class="nc" id="L4963">            te = (Entity) target;</span>
        }

<span class="nc" id="L4966">        boolean usePrior = false;</span>
        // aeros in the same hex need to adjust position to get side
        // table
<span class="nc bnc" id="L4969" title="All 2 branches missed.">        if (isAirToAir(attacker, target)</span>
<span class="nc bnc" id="L4970" title="All 2 branches missed.">                &amp;&amp; attackPos.equals(target.getPosition())</span>
<span class="nc bnc" id="L4971" title="All 4 branches missed.">                &amp;&amp; attacker.isAero() &amp;&amp; target.isAero()) {</span>
<span class="nc" id="L4972">            int moveSort = shouldMoveBackHex(attacker, (Entity) target);</span>
<span class="nc bnc" id="L4973" title="All 2 branches missed.">            if (moveSort &lt; 0) {</span>
<span class="nc" id="L4974">                attackPos = attacker.getPriorPosition();</span>
            }
<span class="nc bnc" id="L4976" title="All 2 branches missed.">            usePrior = moveSort &gt; 0;</span>
        }

        // if this is a air to ground attack, then attacker position is given by
        // the direction from which they entered the target hex
<span class="nc bnc" id="L4981" title="All 2 branches missed.">        if (isAirToGround(attacker, target)) {</span>
<span class="nc" id="L4982">            attackPos = attacker.passedThroughPrevious(target.getPosition());</span>
        }

<span class="nc bnc" id="L4985" title="All 4 branches missed.">        if (isGroundToAir(attacker, target) &amp;&amp; (null != te)) {</span>
<span class="nc" id="L4986">            int facing = Compute.getClosestFlightPathFacing(attacker.getId(),</span>
                    attackPos, te);
<span class="nc" id="L4988">            Coords pos = Compute.getClosestFlightPath(attacker.getId(),</span>
                    attackPos, te);
<span class="nc" id="L4990">            return te.sideTable(attackPos, usePrior, facing, pos);</span>
        }

<span class="nc bnc" id="L4993" title="All 4 branches missed.">        if ((null != te) &amp;&amp; (called == CalledShot.CALLED_LEFT)) {</span>
<span class="nc" id="L4994">            return te.sideTable(attackPos, usePrior, (te.getFacing() + 5) % 6);</span>
<span class="nc bnc" id="L4995" title="All 4 branches missed.">        } else if ((null != te) &amp;&amp; (called == CalledShot.CALLED_RIGHT)) {</span>
<span class="nc" id="L4996">            return te.sideTable(attackPos, usePrior, (te.getFacing() + 1) % 6);</span>
        }

<span class="nc" id="L4999">        return target.sideTable(attackPos, usePrior);</span>
    }


    /**
     * Compares the initiative of two aerospace units in the same hex to determine attack angle.
     * The attack angle is computed as if the unit with the higher initiative were in its previous hex.
     *
     * @param e1 The first &lt;code&gt;Entity&lt;/code&gt; to compare
     * @param e2 The second &lt;code&gt;Entity&lt;/code&gt; to compare
     * @return &lt; 0 if the first unit has a higher initiative, &gt; 0 if the second is higher,
     * or 0 if one of the units is not an aerospace unit, does not have a valid position,
     * or the two units are not in the same hex.
     */
    public static int shouldMoveBackHex(Entity e1, Entity e2) {
<span class="nc bnc" id="L5014" title="All 4 branches missed.">        if (null == e1.getPosition() || null == e2.getPosition()</span>
<span class="nc bnc" id="L5015" title="All 2 branches missed.">                || !e1.getPosition().equals(e2.getPosition())</span>
<span class="nc bnc" id="L5016" title="All 4 branches missed.">                || !e1.isAero() || !e2.isAero()) {</span>
<span class="nc" id="L5017">            return 0;</span>
        }

<span class="nc" id="L5020">        int retVal = e1.getUnitType() - e2.getUnitType();</span>
<span class="nc bnc" id="L5021" title="All 2 branches missed.">        if (retVal == 0) {</span>
<span class="nc" id="L5022">            retVal = ((IAero) e2).getCurrentVelocity() -</span>
<span class="nc" id="L5023">                    ((IAero) e1).getCurrentVelocity();</span>
        }
        // if all criteria are the same, select randomly
<span class="nc bnc" id="L5026" title="All 2 branches missed.">        if (retVal == 0) {</span>
<span class="nc bnc" id="L5027" title="All 2 branches missed.">            retVal = d6() &lt; 4 ? -1 : 1;</span>
        }
<span class="nc" id="L5029">        return retVal;</span>
    }

    /**
     * Maintain backwards compatability.
     *
     * @param missiles - the &lt;code&gt;int&lt;/code&gt; number of missiles in the pack.
     */
    public static int missilesHit(int missiles) {
<span class="nc" id="L5038">        return Compute.missilesHit(missiles, 0);</span>
    }

    /**
     * Maintain backwards compatability.
     *
     * @param missiles
     * @param nMod
     * @return
     */
    public static int missilesHit(int missiles, int nMod) {
<span class="nc" id="L5049">        return Compute.missilesHit(missiles, nMod, false);</span>
    }

    /**
     * Maintain backwards compatability.
     *
     * @param missiles
     * @param nMod
     * @param hotloaded
     * @return
     */
    public static int missilesHit(int missiles, int nMod, boolean hotloaded) {
<span class="nc" id="L5061">        return Compute.missilesHit(missiles, nMod, hotloaded, false, false);</span>
    }

    /**
     * Roll the number of missiles (or whatever) on the missile hit table, with
     * the specified mod to the roll.
     *
     * @param missiles    - the &lt;code&gt;int&lt;/code&gt; number of missiles in the pack.
     * @param nMod        - the &lt;code&gt;int&lt;/code&gt; modifier to the roll for number of
     *                    missiles that hit.
     * @param hotloaded   - roll 3d6 take worst 2
     * @param streak      - force a roll of 11 on the cluster table
     * @param advancedAMS - the roll can now go below 2, indicating no damage
     */
    public static int missilesHit(int missiles, int nMod, boolean hotloaded,
                                  boolean streak, boolean advancedAMS) {
<span class="nc" id="L5077">        int nRoll = Compute.d6(2);</span>

<span class="nc bnc" id="L5079" title="All 2 branches missed.">        if (hotloaded) {</span>
<span class="nc" id="L5080">            int roll1 = Compute.d6();</span>
<span class="nc" id="L5081">            int roll2 = Compute.d6();</span>
<span class="nc" id="L5082">            int roll3 = Compute.d6();</span>
<span class="nc" id="L5083">            int lowRoll1 = 0;</span>
<span class="nc" id="L5084">            int lowRoll2 = 0;</span>

<span class="nc bnc" id="L5086" title="All 4 branches missed.">            if ((roll1 &lt;= roll2) &amp;&amp; (roll1 &lt;= roll3)) {</span>
<span class="nc" id="L5087">                lowRoll1 = roll1;</span>
<span class="nc" id="L5088">                lowRoll2 = Math.min(roll2, roll3);</span>
<span class="nc bnc" id="L5089" title="All 4 branches missed.">            } else if ((roll2 &lt;= roll1) &amp;&amp; (roll2 &lt;= roll3)) {</span>
<span class="nc" id="L5090">                lowRoll1 = roll2;</span>
<span class="nc" id="L5091">                lowRoll2 = Math.min(roll1, roll3);</span>
<span class="nc bnc" id="L5092" title="All 4 branches missed.">            } else if ((roll3 &lt;= roll1) &amp;&amp; (roll3 &lt;= roll2)) {</span>
<span class="nc" id="L5093">                lowRoll1 = roll3;</span>
<span class="nc" id="L5094">                lowRoll2 = Math.min(roll2, roll1);</span>
            }
<span class="nc" id="L5096">            nRoll = lowRoll1 + lowRoll2;</span>
        }
<span class="nc bnc" id="L5098" title="All 2 branches missed.">        if (streak) {</span>
<span class="nc" id="L5099">            nRoll = 11;</span>
        }
<span class="nc" id="L5101">        nRoll += nMod;</span>
<span class="nc bnc" id="L5102" title="All 2 branches missed.">        if (!advancedAMS) {</span>
<span class="nc" id="L5103">            nRoll = Math.min(Math.max(nRoll, 2), 12);</span>
        } else {
<span class="nc" id="L5105">            nRoll = Math.min(nRoll, 12);</span>
        }
<span class="nc bnc" id="L5107" title="All 2 branches missed.">        if (nRoll &lt; 2) {</span>
<span class="nc" id="L5108">            return 0;</span>
        }

<span class="nc bnc" id="L5111" title="All 2 branches missed.">        for (int[] element : clusterHitsTable) {</span>
<span class="nc bnc" id="L5112" title="All 2 branches missed.">            if (element[0] == missiles) {</span>
<span class="nc" id="L5113">                return element[nRoll - 1];</span>
            }
        }
        // BA missiles may have larger number of missiles than max entry on the
        // table
        // if so, take largest, subtract value and try again
<span class="nc bnc" id="L5119" title="All 2 branches missed.">        for (int i = clusterHitsTable.length - 1; i &gt;= 0; i--) {</span>
<span class="nc bnc" id="L5120" title="All 2 branches missed.">            if (missiles &gt; clusterHitsTable[i][0]) {</span>
<span class="nc" id="L5121">                return clusterHitsTable[i][nRoll - 1]</span>
<span class="nc" id="L5122">                        + Compute.missilesHit(</span>
                        missiles - clusterHitsTable[i][0], nMod,
                        hotloaded, streak, advancedAMS);
            }
        }
<span class="nc" id="L5127">        throw new RuntimeException(</span>
                &quot;Could not find number of missiles in hit table&quot;);
    }

    public static int calculateClusterHitTableAmount(int roll, int rackSize) {
<span class="nc bnc" id="L5132" title="All 2 branches missed.">        for (int[] element : clusterHitsTable) {</span>
<span class="nc bnc" id="L5133" title="All 2 branches missed.">            if (element[0] == rackSize) {</span>
<span class="nc" id="L5134">                return element[roll - 1];</span>
            }
        }

<span class="nc" id="L5138">        return 0;</span>
    }

    /**
     * Returns the consciousness roll number
     *
     * @param hit - the &lt;code&gt;int&lt;/code&gt; number of the crew hit currently being
     *            rolled.
     * @return The &lt;code&gt;int&lt;/code&gt; number that must be rolled on 2d6 for the
     * crew to stay conscious.
     */
    public static int getConsciousnessNumber(int hit) {
<span class="nc bnc" id="L5150" title="All 7 branches missed.">        switch (hit) {</span>
            case 0:
<span class="nc" id="L5152">                return 2;</span>
            case 1:
<span class="nc" id="L5154">                return 3;</span>
            case 2:
<span class="nc" id="L5156">                return 5;</span>
            case 3:
<span class="nc" id="L5158">                return 7;</span>
            case 4:
<span class="nc" id="L5160">                return 10;</span>
            case 5:
<span class="nc" id="L5162">                return 11;</span>
            default:
<span class="nc" id="L5164">                return Integer.MAX_VALUE;</span>
        }
    }

    /**
     * Check for ferrous metal content in terrain on path from a to b return the
     * total content.
     */
    public static int getMetalInPath(Entity ae, Coords a, Coords b) {
        // If we're in space, or anything is null... get out.
<span class="nc bnc" id="L5174" title="All 6 branches missed.">        if ((ae == null) || (a == null) || (b == null)) {</span>
<span class="nc" id="L5175">            return 0;</span>
        }
<span class="nc" id="L5177">        IBoard board = ae.getGame().getBoard();</span>
<span class="nc bnc" id="L5178" title="All 2 branches missed.">        if (board.inSpace()) {</span>
<span class="nc" id="L5179">            return 0;</span>
        }

<span class="nc bnc" id="L5182" title="All 4 branches missed.">        if (!board.contains(a) || !board.contains(b)) {</span>
<span class="nc" id="L5183">            return 0;</span>
        }

        // get intervening Coords.
<span class="nc" id="L5187">        ArrayList&lt;Coords&gt; coords = Coords.intervening(a, b);</span>
        // loop through all intervening coords, check each if they are ECM
        // affected
<span class="nc" id="L5190">        int metalContent = 0;</span>
<span class="nc bnc" id="L5191" title="All 2 branches missed.">        for (Coords c : coords) {</span>
<span class="nc" id="L5192">            IHex hex = board.getHex(c);</span>
<span class="nc bnc" id="L5193" title="All 4 branches missed.">            if (hex != null &amp;&amp; hex.containsTerrain(Terrains.METAL_CONTENT)) {</span>
<span class="nc" id="L5194">                metalContent += hex.terrainLevel(Terrains.METAL_CONTENT);</span>
            }
<span class="nc" id="L5196">        }</span>
<span class="nc" id="L5197">        return metalContent;</span>
    }

    /**
     * Check for ECM bubbles in Ghost Target mode along the path from a to b and
     * return the highest target roll. -1 if no Ghost Targets
     */
    public static int getGhostTargetNumber(Entity ae, Coords a, Coords b) {
<span class="nc bnc" id="L5205" title="All 2 branches missed.">        if (ae.getGame().getBoard().inSpace()) {</span>
            // ghost targets don't work in space
<span class="nc" id="L5207">            return 0;</span>
        }
<span class="nc bnc" id="L5209" title="All 4 branches missed.">        if ((a == null) || (b == null)) {</span>
<span class="nc" id="L5210">            return 0;</span>
        }

        // Only grab enemies with active ECM
        // need to create two hashtables for ghost targeting, one with mods
        // and one with booleans indicating that this ghost target was
        // intersected
        // the keys will be the entity id
<span class="nc" id="L5218">        Hashtable&lt;Integer, Boolean&gt; hEnemyGTCrossed = new Hashtable&lt;Integer, Boolean&gt;();</span>
<span class="nc" id="L5219">        Hashtable&lt;Integer, Integer&gt; hEnemyGTMods = new Hashtable&lt;Integer, Integer&gt;();</span>
<span class="nc" id="L5220">        Vector&lt;Coords&gt; vEnemyECCMCoords = new Vector&lt;Coords&gt;(16);</span>
<span class="nc" id="L5221">        Vector&lt;Integer&gt; vEnemyECCMRanges = new Vector&lt;Integer&gt;(16);</span>
<span class="nc" id="L5222">        Vector&lt;Double&gt; vEnemyECCMStrengths = new Vector&lt;Double&gt;(16);</span>
<span class="nc" id="L5223">        Vector&lt;Coords&gt; vEnemyGTCoords = new Vector&lt;Coords&gt;(16);</span>
<span class="nc" id="L5224">        Vector&lt;Integer&gt; vEnemyGTRanges = new Vector&lt;Integer&gt;(16);</span>
<span class="nc" id="L5225">        Vector&lt;Integer&gt; vEnemyGTId = new Vector&lt;Integer&gt;(16);</span>
<span class="nc" id="L5226">        Vector&lt;Coords&gt; vFriendlyECMCoords = new Vector&lt;Coords&gt;(16);</span>
<span class="nc" id="L5227">        Vector&lt;Integer&gt; vFriendlyECMRanges = new Vector&lt;Integer&gt;(16);</span>
<span class="nc" id="L5228">        Vector&lt;Double&gt; vFriendlyECMStrengths = new Vector&lt;Double&gt;(16);</span>
<span class="nc bnc" id="L5229" title="All 2 branches missed.">        for (Entity ent : ae.getGame().getEntitiesVector()) {</span>
<span class="nc" id="L5230">            Coords entPos = ent.getPosition();</span>
<span class="nc bnc" id="L5231" title="All 6 branches missed.">            if (ent.isEnemyOf(ae) &amp;&amp; ent.hasGhostTargets(true)</span>
                    &amp;&amp; (entPos != null)) {
<span class="nc" id="L5233">                vEnemyGTCoords.addElement(entPos);</span>
<span class="nc" id="L5234">                vEnemyGTRanges.addElement(ent.getECMRange());</span>
<span class="nc" id="L5235">                vEnemyGTId.addElement(ent.getId());</span>
<span class="nc" id="L5236">                hEnemyGTCrossed.put(ent.getId(), false);</span>
<span class="nc" id="L5237">                hEnemyGTMods.put(ent.getId(), ent.getGhostTargetRollMoS());</span>
            }
<span class="nc bnc" id="L5239" title="All 6 branches missed.">            if (ent.isEnemyOf(ae) &amp;&amp; ent.hasActiveECCM() &amp;&amp; (entPos != null)) {</span>
<span class="nc" id="L5240">                vEnemyECCMCoords.addElement(entPos);</span>
<span class="nc" id="L5241">                vEnemyECCMRanges.addElement(ent.getECMRange());</span>
<span class="nc" id="L5242">                vEnemyECCMStrengths.add(ent.getECCMStrength());</span>
            }
<span class="nc bnc" id="L5244" title="All 6 branches missed.">            if (!ent.isEnemyOf(ae) &amp;&amp; ent.hasActiveECM() &amp;&amp; (entPos != null)) {</span>
<span class="nc" id="L5245">                vFriendlyECMCoords.addElement(entPos);</span>
<span class="nc" id="L5246">                vFriendlyECMRanges.addElement(ent.getECMRange());</span>
<span class="nc" id="L5247">                vFriendlyECMStrengths.add(ent.getECMStrength());</span>
            }

            // Check the ECM effects of the entity's passengers.
<span class="nc bnc" id="L5251" title="All 2 branches missed.">            for (Entity other : ent.getLoadedUnits()) {</span>
<span class="nc bnc" id="L5252" title="All 6 branches missed.">                if (other.isEnemyOf(ae) &amp;&amp; other.hasGhostTargets(true)</span>
                        &amp;&amp; (entPos != null)) {
<span class="nc" id="L5254">                    vEnemyGTCoords.addElement(entPos);</span>
<span class="nc" id="L5255">                    vEnemyGTRanges.addElement(other.getECMRange());</span>
<span class="nc" id="L5256">                    vEnemyGTId.addElement(ent.getId());</span>
<span class="nc" id="L5257">                    hEnemyGTCrossed.put(ent.getId(), false);</span>
<span class="nc" id="L5258">                    hEnemyGTMods.put(ent.getId(), ent.getGhostTargetRollMoS());</span>
                }
<span class="nc bnc" id="L5260" title="All 6 branches missed.">                if (other.isEnemyOf(ae) &amp;&amp; other.hasActiveECCM()</span>
                        &amp;&amp; (entPos != null)) {
<span class="nc" id="L5262">                    vEnemyECCMCoords.addElement(entPos);</span>
<span class="nc" id="L5263">                    vEnemyECCMRanges</span>
<span class="nc" id="L5264">                            .addElement(other.getECMRange());</span>
<span class="nc" id="L5265">                    vEnemyECCMStrengths.add(ent.getECCMStrength());</span>
                }
<span class="nc bnc" id="L5267" title="All 6 branches missed.">                if (!other.isEnemyOf(ae) &amp;&amp; ent.hasActiveECM()</span>
                        &amp;&amp; (entPos != null)) {
<span class="nc" id="L5269">                    vFriendlyECMCoords.addElement(entPos);</span>
<span class="nc" id="L5270">                    vFriendlyECMRanges</span>
<span class="nc" id="L5271">                            .addElement(ent.getECMRange());</span>
<span class="nc" id="L5272">                    vFriendlyECMStrengths.add(ent.getECMStrength());</span>
                }
<span class="nc" id="L5274">            }</span>
<span class="nc" id="L5275">        }</span>

        // none? get out of here
<span class="nc bnc" id="L5278" title="All 2 branches missed.">        if (vEnemyGTCoords.size() == 0) {</span>
<span class="nc" id="L5279">            return -1;</span>
        }

        // get intervening Coords.
<span class="nc" id="L5283">        ArrayList&lt;Coords&gt; coords = Coords.intervening(a, b);</span>
        // loop through all intervening coords, if they are not ecm'ed by
        // friendlys then add any Ghost Targets
        // to the hashlist
        // According to the rules clarification below ECM cancels Ghost Targets
        // http://www.classicbattletech.com/forums/index.php/topic,66035.new.html#new
<span class="nc bnc" id="L5289" title="All 2 branches missed.">        for (Coords c : coords) {</span>
            // &gt;0: in friendly ECM
            // &lt;=0: not in friendly ECM
<span class="nc" id="L5292">            int ecmStatus = 0;</span>
            // first, add 1 for each friendly ECM that affects us
<span class="nc" id="L5294">            Enumeration&lt;Integer&gt; ranges = vFriendlyECMRanges.elements();</span>
<span class="nc" id="L5295">            Enumeration&lt;Double&gt; strengths = vFriendlyECMStrengths.elements();</span>
<span class="nc bnc" id="L5296" title="All 2 branches missed.">            for (Coords friendlyECMCoords : vFriendlyECMCoords) {</span>
<span class="nc" id="L5297">                int range = ranges.nextElement().intValue();</span>
<span class="nc" id="L5298">                int nDist = c.distance(friendlyECMCoords);</span>
<span class="nc" id="L5299">                double strength = strengths.nextElement().doubleValue();</span>
<span class="nc bnc" id="L5300" title="All 2 branches missed.">                if (nDist &lt;= range) {</span>
<span class="nc" id="L5301">                    ecmStatus += strength;</span>
                }
<span class="nc" id="L5303">            }</span>
            // now, subtract one for each enemy ECCM
<span class="nc" id="L5305">            ranges = vEnemyECCMRanges.elements();</span>
<span class="nc" id="L5306">            strengths = vEnemyECCMStrengths.elements();</span>
<span class="nc bnc" id="L5307" title="All 2 branches missed.">            for (Coords enemyECCMCoords : vEnemyECCMCoords) {</span>
<span class="nc" id="L5308">                int range = ranges.nextElement().intValue();</span>
<span class="nc" id="L5309">                int nDist = c.distance(enemyECCMCoords);</span>
<span class="nc" id="L5310">                double strength = strengths.nextElement().doubleValue();</span>
<span class="nc bnc" id="L5311" title="All 2 branches missed.">                if (nDist &lt;= range) {</span>
<span class="nc" id="L5312">                    ecmStatus -= strength;</span>
                }
<span class="nc" id="L5314">            }</span>

<span class="nc bnc" id="L5316" title="All 2 branches missed.">            if (ecmStatus &lt; 1) {</span>
                // find any new Ghost Targets that we have crossed
<span class="nc" id="L5318">                ranges = vEnemyGTRanges.elements();</span>
<span class="nc" id="L5319">                Enumeration&lt;Integer&gt; ids = vEnemyGTId.elements();</span>
<span class="nc bnc" id="L5320" title="All 2 branches missed.">                for (Coords enemyGTCoords : vEnemyGTCoords) {</span>
<span class="nc" id="L5321">                    int range = ranges.nextElement().intValue();</span>
<span class="nc" id="L5322">                    int id = ids.nextElement().intValue();</span>
<span class="nc" id="L5323">                    int nDist = c.distance(enemyGTCoords);</span>
<span class="nc bnc" id="L5324" title="All 4 branches missed.">                    if ((nDist &lt;= range) &amp;&amp; !hEnemyGTCrossed.get(id)) {</span>
<span class="nc" id="L5325">                        hEnemyGTCrossed.put(id, true);</span>
                    }
<span class="nc" id="L5327">                }</span>
            }
<span class="nc" id="L5329">        }</span>

        // ok so now we have a hashtable that tells us which Ghost Targets have
        // been crossed
        // lets loop through that and identify the highest bonus and count the
        // total number crossed
<span class="nc" id="L5335">        int totalGT = -1;</span>
<span class="nc" id="L5336">        int highestMod = -1;</span>
<span class="nc" id="L5337">        Enumeration&lt;Integer&gt; ids = hEnemyGTCrossed.keys();</span>
<span class="nc bnc" id="L5338" title="All 2 branches missed.">        while (ids.hasMoreElements()) {</span>
<span class="nc" id="L5339">            int id = ids.nextElement();</span>
<span class="nc bnc" id="L5340" title="All 2 branches missed.">            if (hEnemyGTCrossed.get(id)) {</span>
<span class="nc" id="L5341">                totalGT++;</span>
<span class="nc bnc" id="L5342" title="All 2 branches missed.">                if (hEnemyGTMods.get(id) &gt; highestMod) {</span>
<span class="nc" id="L5343">                    highestMod = hEnemyGTMods.get(id);</span>
                }
            }
<span class="nc" id="L5346">        }</span>

        // according to the following rules clarification, this should be maxed
        // out at +4
        // http://www.classicbattletech.com/forums/index.php?topic=66036.0
<span class="nc" id="L5351">        return Math.min(4, highestMod + totalGT);</span>
    }

    /**
     * Get the base to-hit number of a space bomb attack by the given attacker
     * upon the given defender
     *
     * @param attacker - the &lt;code&gt;Entity&lt;/code&gt; conducting the leg attack.
     * @param defender - the &lt;code&gt;Entity&lt;/code&gt; being attacked.
     * @return The base &lt;code&gt;ToHitData&lt;/code&gt; of the attack.
     */
    public static ToHitData getSpaceBombBaseToHit(Entity attacker,
                                                  Entity defender, IGame game) {
<span class="nc" id="L5364">        int base = TargetRoll.IMPOSSIBLE;</span>
<span class="nc" id="L5365">        StringBuffer reason = new StringBuffer();</span>

<span class="nc bnc" id="L5367" title="All 2 branches missed.">        if (!attacker.isAero()) {</span>
<span class="nc" id="L5368">            return new ToHitData(base, &quot;attacker is not an Aero&quot;);</span>
        }

<span class="nc" id="L5371">        IAero a = (IAero) attacker;</span>

        // the fighters nose must be aligned with its direction of travel
<span class="nc" id="L5374">        boolean rightFacing = false;</span>
        // using normal movement, I think this means that the last move can't be
        // a turn
<span class="nc bnc" id="L5377" title="All 2 branches missed.">        if (!game.useVectorMove()) {</span>
<span class="nc" id="L5378">            rightFacing = true;</span>
        }
        // for advanced movement, it must be aligned with largest vector
<span class="nc bnc" id="L5381" title="All 2 branches missed.">        if (game.useVectorMove()) {</span>
<span class="nc bnc" id="L5382" title="All 2 branches missed.">            for (int h : attacker.getHeading()) {</span>
<span class="nc bnc" id="L5383" title="All 2 branches missed.">                if (h == attacker.facing) {</span>
<span class="nc" id="L5384">                    rightFacing = true;</span>
<span class="nc" id="L5385">                    break;</span>
                }
<span class="nc" id="L5387">            }</span>
        }

<span class="nc" id="L5390">        boolean canTarget = false;</span>
<span class="nc" id="L5391">        Coords attackCoords = null;</span>
<span class="nc bnc" id="L5392" title="All 2 branches missed.">        for (Coords c : attacker.getPassedThrough()) {</span>
<span class="nc bnc" id="L5393" title="All 2 branches missed.">            for (Entity target : game.getEntitiesVector(c)) {</span>
<span class="nc bnc" id="L5394" title="All 2 branches missed.">                if (target.getId() == defender.getId()) {</span>
<span class="nc" id="L5395">                    canTarget = true;</span>
                }
<span class="nc" id="L5397">            }</span>
<span class="nc bnc" id="L5398" title="All 2 branches missed.">            if (canTarget) {</span>
<span class="nc" id="L5399">                break;</span>
            }
<span class="nc" id="L5401">            attackCoords = c;</span>
<span class="nc" id="L5402">        }</span>
<span class="nc bnc" id="L5403" title="All 2 branches missed.">        if (null == attackCoords) {</span>
<span class="nc" id="L5404">            attackCoords = attacker.getPosition();</span>
        }

        // must be in control
<span class="nc bnc" id="L5408" title="All 2 branches missed.">        if (a.isOutControlTotal()) {</span>
<span class="nc" id="L5409">            reason.append(&quot;the attacker is out of control&quot;);</span>
<span class="nc bnc" id="L5410" title="All 2 branches missed.">        } else if (attacker.getBombs(AmmoType.F_SPACE_BOMB).size() &lt; 1) {</span>
<span class="nc" id="L5411">            reason.append(&quot;the attacker has no useable bombs&quot;);</span>
<span class="nc bnc" id="L5412" title="All 2 branches missed.">        } else if (!rightFacing) {</span>
<span class="nc" id="L5413">            reason.append(&quot;the attacker is not facing the direction of travel&quot;);</span>
        }
        // attacker and defender must both be in space hex
<span class="nc" id="L5416">        else if (!game.getBoard().getHex(attacker.getPosition())</span>
<span class="nc bnc" id="L5417" title="All 2 branches missed.">                .containsTerrain(Terrains.SPACE)) {</span>
<span class="nc" id="L5418">            reason.append(&quot;attacker not in space hex&quot;);</span>
<span class="nc" id="L5419">        } else if (!game.getBoard().getHex(defender.getPosition())</span>
<span class="nc bnc" id="L5420" title="All 2 branches missed.">                .containsTerrain(Terrains.SPACE)) {</span>
<span class="nc" id="L5421">            reason.append(&quot;defender not in space hex&quot;);</span>
<span class="nc bnc" id="L5422" title="All 2 branches missed.">        } else if (!canTarget) {</span>
<span class="nc" id="L5423">            reason.append(&quot;defender is not in hex passed through by attacker this turn&quot;);</span>
        }
        // the defender must weight 10000+ tons
<span class="nc bnc" id="L5426" title="All 2 branches missed.">        else if (defender.weight &lt; 10000) {</span>
<span class="nc" id="L5427">            reason.append(&quot;the defender weighs less than 10,000 tons&quot;);</span>
        }

        // ok if we are still alive then lets calculate the tohit
        else {
<span class="nc" id="L5432">            base = attacker.getCrew().getGunnery();</span>
<span class="nc" id="L5433">            reason.append(&quot;base&quot;);</span>
        }

<span class="nc" id="L5436">        ToHitData toHit = new ToHitData(base, reason.toString(),</span>
<span class="nc" id="L5437">                ToHitData.HIT_NORMAL, defender.sideTable(attackCoords));</span>

<span class="nc" id="L5439">        toHit.addModifier(+4, &quot;space bomb attack&quot;);</span>
<span class="nc bnc" id="L5440" title="All 2 branches missed.">        if (attacker.mpUsed &gt; 0) {</span>
<span class="nc" id="L5441">            toHit.addModifier(attacker.mpUsed, &quot;attacker thrust&quot;);</span>
        }
<span class="nc bnc" id="L5443" title="All 2 branches missed.">        if (defender.mpUsed &gt; 0) {</span>
<span class="nc" id="L5444">            toHit.addModifier(defender.mpUsed, &quot;defender thrust&quot;);</span>
        }
<span class="nc bnc" id="L5446" title="All 4 branches missed.">        if ((defender instanceof SpaceStation) || (defender.getWalkMP() == 0)) {</span>
<span class="nc" id="L5447">            toHit.addModifier(-4, &quot;immobile&quot;);</span>
        }
<span class="nc bnc" id="L5449" title="All 2 branches missed.">        if (defender.weight &lt; 100000) {</span>
<span class="nc" id="L5450">            int penalty = (int) Math.ceil((100000 - defender.weight) / 10000);</span>
<span class="nc" id="L5451">            toHit.addModifier(penalty, &quot;defender weight&quot;);</span>
        }

<span class="nc" id="L5454">        return toHit;</span>
    }

    /**
     * This assembles attack roll modifiers for infantry swarm and leg attacks.
     */
    private static ToHitData getAntiMechMods(ToHitData data, Infantry attacker,
                                             Entity defender) {
<span class="nc bnc" id="L5462" title="All 2 branches missed.">        if (attacker == null) {</span>
<span class="nc" id="L5463">            data.addModifier(TargetRoll.IMPOSSIBLE, &quot;Unknown attacker&quot;);</span>
<span class="nc" id="L5464">            return data;</span>
        }
<span class="nc bnc" id="L5466" title="All 2 branches missed.">        if (defender == null) {</span>
<span class="nc" id="L5467">            data.addModifier(TargetRoll.IMPOSSIBLE, &quot;Unknown defender&quot;);</span>
<span class="nc" id="L5468">            return data;</span>
        }

<span class="nc bnc" id="L5471" title="All 2 branches missed.">        if (attacker instanceof BattleArmor) {</span>
            // Battle Armor units can't do an AM Attack if they're burdened.
<span class="nc bnc" id="L5473" title="All 2 branches missed.">            if (((BattleArmor) attacker).isBurdened()) {</span>
<span class="nc" id="L5474">                data.addModifier(TargetRoll.IMPOSSIBLE,</span>
                        &quot;Launcher not jettisoned.&quot;);
<span class="nc" id="L5476">                return data;</span>
            }
            // BA units that jumped using mechanical jump boosters can't attack
<span class="nc bnc" id="L5479" title="All 2 branches missed.">            if (attacker.hasWorkingMisc(MiscType.F_MECHANICAL_JUMP_BOOSTER)</span>
                    // we used a mechanical jump booster for jumping only if we
                    // don't have normal JJs, or if we are underwater-capable
                    // because we underwatercapable BAs can only jump via
                    // mechanical jump boosters
                    // otherwise, normal JJs give the same MP and do not have
                    // this restriction
<span class="nc bnc" id="L5486" title="All 2 branches missed.">                    &amp;&amp; ((attacker.getOriginalJumpMP() == 0) || (attacker</span>
<span class="nc bnc" id="L5487" title="All 4 branches missed.">                    .getMovementMode() == EntityMovementMode.INF_UMU))</span>
                    &amp;&amp; (attacker.moved == EntityMovementType.MOVE_JUMP)) {
<span class="nc" id="L5489">                data.addModifier(</span>
                        TargetRoll.IMPOSSIBLE,
                        &quot;can't jump using mechanical jump booster and anti-mech attack in the same turn&quot;);
<span class="nc" id="L5492">                return data;</span>
            }
        } else {
            // Infantry can't have encumbering armor
<span class="nc bnc" id="L5496" title="All 2 branches missed.">            if (attacker.isArmorEncumbering()) {</span>
<span class="nc" id="L5497">                data.addModifier(TargetRoll.IMPOSSIBLE,</span>
                        &quot;can't engage in anti-mek attacks with encumbering armor.&quot;);
<span class="nc" id="L5499">                return data;</span>
            }
        }

        // Can't target a transported entity.
<span class="nc bnc" id="L5504" title="All 2 branches missed.">        if (Entity.NONE != defender.getTransportId()) {</span>
<span class="nc" id="L5505">            data.addModifier(TargetRoll.IMPOSSIBLE, &quot;Target is a passenger.&quot;);</span>
<span class="nc" id="L5506">            return data;</span>
        }

<span class="nc bnc" id="L5509" title="All 2 branches missed.">        if (defender.isMakingDfa()) {</span>
<span class="nc" id="L5510">            data.addModifier(TargetRoll.IMPOSSIBLE, &quot;Target is making a DFA.&quot;);</span>
<span class="nc" id="L5511">            return data;</span>
        }

        // Already conducting a swarm attack.
<span class="nc bnc" id="L5515" title="All 2 branches missed.">        if (Entity.NONE != attacker.getSwarmTargetId()) {</span>
<span class="nc" id="L5516">            data.addModifier(TargetRoll.IMPOSSIBLE,</span>
                    &quot;Attacker is currently swarming.&quot;);
<span class="nc" id="L5518">            return data;</span>
        }

<span class="nc bnc" id="L5521" title="All 2 branches missed.">        if (defender.isAirborneVTOLorWIGE()) {</span>
<span class="nc" id="L5522">            data.addModifier(TargetRoll.IMPOSSIBLE, &quot;Cannot target airborne unit.&quot;);</span>
<span class="nc" id="L5523">            return data;</span>
        }

<span class="nc bnc" id="L5526" title="All 4 branches missed.">        if ((defender instanceof Mech) &amp;&amp; ((Mech) defender).isIndustrial()) {</span>
<span class="nc" id="L5527">            data.addModifier(-1, &quot;targeting industrial mech&quot;);</span>
        }

        // protected/exposed actuator quirk may adjust target roll
<span class="nc bnc" id="L5531" title="All 2 branches missed.">        if (defender.hasQuirk(OptionsConstants.QUIRK_POS_PRO_ACTUATOR)) {</span>
<span class="nc" id="L5532">            data.addModifier(+1, &quot;protected actuators&quot;);</span>
        }
<span class="nc bnc" id="L5534" title="All 2 branches missed.">        if (defender.hasQuirk(OptionsConstants.QUIRK_NEG_EXP_ACTUATOR)) {</span>
<span class="nc" id="L5535">            data.addModifier(-1, &quot;exposed actuators&quot;);</span>
        }

        // MD Infantry with grappler/magnets get bonus
<span class="nc bnc" id="L5539" title="All 2 branches missed.">        if (attacker.hasAbility(OptionsConstants.MD_PL_ENHANCED)) {</span>
<span class="nc" id="L5540">            data.addModifier(-2, &quot;MD Grapple/Magnet&quot;);</span>
        }

        // swarm/leg attacks take target movement mods into account
<span class="nc" id="L5544">        data.append(getTargetMovementModifier(attacker.getGame(), defender.getTargetId()));</span>

<span class="nc" id="L5546">        return data;</span>
    }

    /**
     * Get the base to-hit number of a Leg Attack by the given attacker upon the
     * given defender
     *
     * @param attacker - the &lt;code&gt;Entity&lt;/code&gt; conducting the leg attack.
     * @param defender - the &lt;code&gt;Entity&lt;/code&gt; being attacked.
     * @return The base &lt;code&gt;ToHitData&lt;/code&gt; of the attack.
     */
    public static ToHitData getLegAttackBaseToHit(Entity attacker,
                                                  Entity defender, IGame game) {
<span class="nc" id="L5559">        String reason = &quot;Non Infantry not allowed to do AM attacks.&quot;;</span>
<span class="nc" id="L5560">        ToHitData toReturn = null;</span>
<span class="nc" id="L5561">        boolean alreadyPerformingOther = false;</span>
<span class="nc" id="L5562">        for (Enumeration&lt;EntityAction&gt; actions = game.getActions(); actions</span>
<span class="nc bnc" id="L5563" title="All 2 branches missed.">                .hasMoreElements(); ) {</span>
<span class="nc" id="L5564">            EntityAction ea = actions.nextElement();</span>
<span class="nc bnc" id="L5565" title="All 2 branches missed.">            if (ea instanceof WeaponAttackAction) {</span>
<span class="nc" id="L5566">                WeaponAttackAction waa = (WeaponAttackAction) ea;</span>
<span class="nc" id="L5567">                Entity waaAE = waa.getEntity(game);</span>
<span class="nc bnc" id="L5568" title="All 4 branches missed.">                if ((waaAE != null) &amp;&amp; waaAE.equals(attacker)) {</span>
                    // impossible if already doing a swarm attack
<span class="nc" id="L5570">                    if (waa.getEntity(game).getEquipment(waa.getWeaponId())</span>
<span class="nc" id="L5571">                            .getType().getInternalName()</span>
<span class="nc bnc" id="L5572" title="All 2 branches missed.">                            .equals(Infantry.SWARM_MEK)) {</span>
<span class="nc" id="L5573">                        alreadyPerformingOther = true;</span>

                    }
                }
            }
<span class="nc" id="L5578">        }</span>

<span class="nc bnc" id="L5580" title="All 2 branches missed.">        if (alreadyPerformingOther) {</span>
<span class="nc" id="L5581">            reason = &quot;already performing a swarm attack&quot;;</span>
        }
        // Can only attack a Mek's legs.
<span class="nc bnc" id="L5584" title="All 2 branches missed.">        else if (!(defender instanceof Mech)) {</span>
<span class="nc" id="L5585">            reason = &quot;Defender is not a Mech.&quot;;</span>
        }

        // Can't attack if flying
<span class="nc bnc" id="L5589" title="All 2 branches missed.">        else if (attacker.getElevation() &gt; defender.getElevation()) {</span>
<span class="nc" id="L5590">            reason = &quot;Cannot do leg attack while flying.&quot;;</span>
        }

        // Handle BattleArmor attackers.
<span class="nc bnc" id="L5594" title="All 2 branches missed.">        else if (attacker instanceof BattleArmor) {</span>
<span class="nc" id="L5595">            BattleArmor inf = (BattleArmor) attacker;</span>
<span class="nc" id="L5596">            toReturn = new ToHitData(inf.getCrew().getPiloting(),</span>
                    &quot;anti-mech skill&quot;, ToHitData.HIT_KICK, ToHitData.SIDE_FRONT);
<span class="nc" id="L5598">            int men = inf.getShootingStrength();</span>
<span class="nc" id="L5599">            int modifier = TargetRoll.IMPOSSIBLE;</span>
<span class="nc bnc" id="L5600" title="All 2 branches missed.">            if (men &gt;= 4) {</span>
<span class="nc" id="L5601">                modifier = 0;</span>
<span class="nc bnc" id="L5602" title="All 2 branches missed.">            } else if (men &gt;= 3) {</span>
<span class="nc" id="L5603">                modifier = 2;</span>
<span class="nc bnc" id="L5604" title="All 2 branches missed.">            } else if (men &gt;= 2) {</span>
<span class="nc" id="L5605">                modifier = 5;</span>
<span class="nc bnc" id="L5606" title="All 2 branches missed.">            } else if (men &gt;= 1) {</span>
<span class="nc" id="L5607">                modifier = 7;</span>
            }
<span class="nc" id="L5609">            toReturn.addModifier(modifier, men + &quot; trooper(s) active&quot;);</span>
<span class="nc bnc" id="L5610" title="All 2 branches missed.">        } else if (attacker instanceof Infantry) {</span>
            // Non-BattleArmor infantry need many more men.
<span class="nc" id="L5612">            Infantry inf = (Infantry) attacker;</span>
<span class="nc" id="L5613">            toReturn = new ToHitData(inf.getCrew().getPiloting(),</span>
                    &quot;anti-mech skill&quot;, ToHitData.HIT_KICK, ToHitData.SIDE_FRONT);
<span class="nc" id="L5615">            int men = inf.getShootingStrength();</span>
<span class="nc" id="L5616">            int modifier = TargetRoll.IMPOSSIBLE;</span>
<span class="nc bnc" id="L5617" title="All 2 branches missed.">            if (men &gt;= 22) {</span>
<span class="nc" id="L5618">                modifier = 0;</span>
<span class="nc bnc" id="L5619" title="All 2 branches missed.">            } else if (men &gt;= 16) {</span>
<span class="nc" id="L5620">                modifier = 2;</span>
<span class="nc bnc" id="L5621" title="All 2 branches missed.">            } else if (men &gt;= 10) {</span>
<span class="nc" id="L5622">                modifier = 5;</span>
<span class="nc bnc" id="L5623" title="All 2 branches missed.">            } else if (men &gt;= 5) {</span>
<span class="nc" id="L5624">                modifier = 7;</span>
            }
<span class="nc" id="L5626">            toReturn.addModifier(modifier, men + &quot; trooper(s) active&quot;);</span>
        }

<span class="nc bnc" id="L5629" title="All 4 branches missed.">        if (defender instanceof Mech &amp;&amp; ((Mech) defender).hasTracks()) {</span>
<span class="nc" id="L5630">            toReturn.addModifier(-2, &quot;has tracks&quot;);</span>
        }

        // If the swarm is impossible, ToHitData wasn't created
<span class="nc bnc" id="L5634" title="All 2 branches missed.">        if (toReturn == null) {</span>
<span class="nc" id="L5635">            toReturn = new ToHitData(TargetRoll.IMPOSSIBLE, reason.toString(),</span>
                    ToHitData.HIT_KICK, ToHitData.SIDE_FRONT);
        }
<span class="nc bnc" id="L5638" title="All 2 branches missed.">        if (toReturn.getValue() == TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5639">            return toReturn;</span>
        }
<span class="nc" id="L5641">        toReturn = Compute.getAntiMechMods(toReturn, (Infantry) attacker,</span>
                defender);
<span class="nc" id="L5643">        return toReturn;</span>
    }

    /**
     * Get the base to-hit number of a Swarm Mek by the given attacker upon the
     * given defender.
     *
     * @param attacker - the &lt;code&gt;Entity&lt;/code&gt; swarming.
     * @param defender - the &lt;code&gt;Entity&lt;/code&gt; being swarmed.
     * @return The base &lt;code&gt;ToHitData&lt;/code&gt; of the mek.
     */
    public static ToHitData getSwarmMekBaseToHit(Entity attacker,
                                                 Entity defender, IGame game) {
<span class="nc" id="L5656">        ToHitData toReturn = null;</span>
<span class="nc" id="L5657">        String reason = &quot;Non Infantry not allowed to do AM attacks.&quot;;</span>

<span class="nc" id="L5659">        boolean alreadyPerformingOther = false;</span>
<span class="nc" id="L5660">        for (Enumeration&lt;EntityAction&gt; actions = game.getActions(); actions</span>
<span class="nc bnc" id="L5661" title="All 2 branches missed.">                .hasMoreElements(); ) {</span>
<span class="nc" id="L5662">            EntityAction ea = actions.nextElement();</span>
<span class="nc bnc" id="L5663" title="All 2 branches missed.">            if (ea instanceof WeaponAttackAction) {</span>
<span class="nc" id="L5664">                WeaponAttackAction waa = (WeaponAttackAction) ea;</span>
<span class="nc" id="L5665">                Entity waaAE = waa.getEntity(game);</span>
<span class="nc bnc" id="L5666" title="All 4 branches missed.">                if ((waaAE != null) &amp;&amp; waaAE.equals(attacker)) {</span>
                    // impossible if already doing a swarm attack
<span class="nc" id="L5668">                    if (waa.getEntity(game).getEquipment(waa.getWeaponId())</span>
<span class="nc" id="L5669">                            .getType().getInternalName()</span>
<span class="nc bnc" id="L5670" title="All 2 branches missed.">                            .equals(Infantry.LEG_ATTACK)) {</span>
<span class="nc" id="L5671">                        alreadyPerformingOther = true;</span>

                    }
                }
            }
<span class="nc" id="L5676">        }</span>
<span class="nc bnc" id="L5677" title="All 2 branches missed.">        if (alreadyPerformingOther) {</span>
<span class="nc" id="L5678">            reason = &quot;attacker is already performing a leg attack&quot;;</span>
        }
        // Can only swarm a Mek.
<span class="nc bnc" id="L5681" title="All 4 branches missed.">        else if (!(defender instanceof Mech) &amp;&amp; !(defender instanceof Tank)) {</span>
<span class="nc" id="L5682">            reason = &quot;Defender is not a Mech or vehicle.&quot;;</span>
        }
        // Can't swarm a friendly Mek. See
        // http://www.classicbattletech.com/w3t/showflat
        // .php?Cat=&amp;Board=ask&amp;Number=632321&amp;page=0&amp;view=collapsed&amp;sb=5&amp;o=0&amp;fpart=
<span class="nc bnc" id="L5687" title="All 2 branches missed.">        else if (!attacker.isEnemyOf(defender)</span>
<span class="nc" id="L5688">                &amp;&amp; !attacker.getGame().getOptions()</span>
<span class="nc bnc" id="L5689" title="All 2 branches missed.">                .booleanOption(OptionsConstants.BASE_FRIENDLY_FIRE)) {</span>
<span class="nc" id="L5690">            reason = &quot;Can only swarm an enemy.&quot;;</span>
        }
        // target is already swarmed
<span class="nc bnc" id="L5693" title="All 2 branches missed.">        else if (defender.getSwarmAttackerId() != Entity.NONE) {</span>
<span class="nc" id="L5694">            reason = &quot;Only one swarm allowed at a time.&quot;;</span>
        }
        // Handle BattleArmor attackers.
<span class="nc bnc" id="L5697" title="All 2 branches missed.">        else if (attacker instanceof BattleArmor) {</span>
<span class="nc" id="L5698">            BattleArmor inf = (BattleArmor) attacker;</span>
<span class="nc" id="L5699">            toReturn = new ToHitData(inf.getCrew().getPiloting(), &quot;anti-mech skill&quot;);</span>
<span class="nc" id="L5700">            int men = inf.getShootingStrength();</span>
<span class="nc" id="L5701">            int modifier = TargetRoll.IMPOSSIBLE;</span>
<span class="nc bnc" id="L5702" title="All 2 branches missed.">            if (men &gt;= 4) {</span>
<span class="nc" id="L5703">                modifier = 2;</span>
<span class="nc bnc" id="L5704" title="All 2 branches missed.">            } else if (men &gt;= 1) {</span>
<span class="nc" id="L5705">                modifier = 5;</span>
            }
<span class="nc" id="L5707">            toReturn.addModifier(modifier, men + &quot; trooper(s) active&quot;);</span>
<span class="nc" id="L5708">        }</span>
        // Non-BattleArmor infantry need many more men.
<span class="nc bnc" id="L5710" title="All 2 branches missed.">        else if (attacker instanceof Infantry) {</span>
<span class="nc" id="L5711">            Infantry inf = (Infantry) attacker;</span>
<span class="nc" id="L5712">            toReturn = new ToHitData(inf.getCrew().getPiloting(), &quot;anti-mech skill&quot;);</span>
<span class="nc" id="L5713">            int men = inf.getShootingStrength();</span>
<span class="nc" id="L5714">            int modifier = TargetRoll.IMPOSSIBLE;</span>
<span class="nc bnc" id="L5715" title="All 2 branches missed.">            if (men &gt;= 22) {</span>
<span class="nc" id="L5716">                modifier = 2;</span>
<span class="nc bnc" id="L5717" title="All 2 branches missed.">            } else if (men &gt;= 16) {</span>
<span class="nc" id="L5718">                modifier = 5;</span>
            }
<span class="nc" id="L5720">            toReturn.addModifier(modifier, men + &quot; trooper(s) active&quot;);</span>
        }
        // If the swarm is impossible, ToHitData wasn't created
<span class="nc bnc" id="L5723" title="All 2 branches missed.">        if (toReturn == null) {</span>
<span class="nc" id="L5724">            toReturn = new ToHitData(TargetRoll.IMPOSSIBLE, reason.toString());</span>
        }
<span class="nc bnc" id="L5726" title="All 2 branches missed.">        if (toReturn.getValue() == TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5727">            return toReturn;</span>
        }
<span class="nc" id="L5729">        toReturn = Compute.getAntiMechMods(toReturn, (Infantry) attacker,</span>
                defender);

        // If the attacker has assault claws, give a -1 modifier.
        // We can stop looking when we find our first match.
<span class="nc bnc" id="L5734" title="All 2 branches missed.">        for (Mounted mount : attacker.getMisc()) {</span>
<span class="nc" id="L5735">            EquipmentType equip = mount.getType();</span>
<span class="nc bnc" id="L5736" title="All 2 branches missed.">            if (equip.hasFlag(MiscType.F_MAGNET_CLAW)) {</span>
<span class="nc" id="L5737">                toReturn.addModifier(-1, &quot;attacker has magnetic claws&quot;);</span>
<span class="nc" id="L5738">                break;</span>
            }
<span class="nc" id="L5740">        }</span>
<span class="nc" id="L5741">        return toReturn;</span>
    }

    public static boolean canPhysicalTarget(IGame game, int entityId,
                                            Targetable target) {

<span class="nc" id="L5747">        if (PunchAttackAction.toHit(game, entityId, target,</span>
<span class="nc bnc" id="L5748" title="All 2 branches missed.">                PunchAttackAction.LEFT, false).getValue() != TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5749">            return true;</span>
        }

<span class="nc" id="L5752">        if (PunchAttackAction.toHit(game, entityId, target,</span>
<span class="nc bnc" id="L5753" title="All 2 branches missed.">                PunchAttackAction.RIGHT, false).getValue() != TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5754">            return true;</span>
        }

<span class="nc" id="L5757">        if (KickAttackAction.toHit(game, entityId, target,</span>
<span class="nc bnc" id="L5758" title="All 2 branches missed.">                KickAttackAction.LEFT).getValue() != TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5759">            return true;</span>
        }

<span class="nc" id="L5762">        if (KickAttackAction.toHit(game, entityId, target,</span>
<span class="nc bnc" id="L5763" title="All 2 branches missed.">                KickAttackAction.RIGHT).getValue() != TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5764">            return true;</span>
        }

<span class="nc bnc" id="L5767" title="All 2 branches missed.">        if ((game.getEntity(entityId) instanceof QuadMech)</span>
<span class="nc" id="L5768">                &amp;&amp; ((KickAttackAction.toHit(game, entityId, target,</span>
<span class="nc bnc" id="L5769" title="All 2 branches missed.">                KickAttackAction.LEFTMULE).getValue() != TargetRoll.IMPOSSIBLE) ||</span>
                (KickAttackAction
<span class="nc" id="L5771">                        .toHit(game, entityId, target,</span>
<span class="nc bnc" id="L5772" title="All 2 branches missed.">                                KickAttackAction.RIGHTMULE).getValue() != TargetRoll.IMPOSSIBLE))) {</span>
<span class="nc" id="L5773">            return true;</span>
        }

<span class="nc" id="L5776">        if (BrushOffAttackAction.toHit(game, entityId, target,</span>
<span class="nc bnc" id="L5777" title="All 2 branches missed.">                BrushOffAttackAction.LEFT).getValue() != TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5778">            return true;</span>
        }

<span class="nc" id="L5781">        if (BrushOffAttackAction.toHit(game, entityId, target,</span>
<span class="nc bnc" id="L5782" title="All 2 branches missed.">                BrushOffAttackAction.RIGHT).getValue() != TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5783">            return true;</span>
        }

<span class="nc bnc" id="L5786" title="All 2 branches missed.">        if (new ThrashAttackAction(entityId, target).toHit(game).getValue() != TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5787">            return true;</span>
        }

<span class="nc" id="L5790">        if (ProtomechPhysicalAttackAction.toHit(game, entityId, target)</span>
<span class="nc bnc" id="L5791" title="All 2 branches missed.">                .getValue() != TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5792">            return true;</span>
        }

<span class="nc bnc" id="L5795" title="All 2 branches missed.">        if (PushAttackAction.toHit(game, entityId, target).getValue() != TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5796">            return true;</span>
        }

<span class="nc bnc" id="L5799" title="All 2 branches missed.">        if (LayExplosivesAttackAction.toHit(game, entityId, target).getValue() != TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5800">            return true;</span>
        }

<span class="nc bnc" id="L5803" title="All 2 branches missed.">        if (TripAttackAction.toHit(game, entityId, target).getValue() != TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5804">            return true;</span>
        }

<span class="nc bnc" id="L5807" title="All 2 branches missed.">        if (GrappleAttackAction.toHit(game, entityId, target).getValue() != TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5808">            return true;</span>
        }

<span class="nc bnc" id="L5811" title="All 2 branches missed.">        if (BreakGrappleAttackAction.toHit(game, entityId, target).getValue() != TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5812">            return true;</span>
        }

<span class="nc bnc" id="L5815" title="All 2 branches missed.">        for (Mounted club : game.getEntity(entityId).getClubs()) {</span>
<span class="nc bnc" id="L5816" title="All 2 branches missed.">            if (null != club) {</span>
<span class="nc" id="L5817">                if (ClubAttackAction.toHit(game, entityId, target, club,</span>
<span class="nc bnc" id="L5818" title="All 2 branches missed.">                        ToHitData.HIT_NORMAL, false).getValue() != TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5819">                    return true;</span>
                }
            }
<span class="nc" id="L5822">        }</span>

<span class="nc" id="L5824">        if (JumpJetAttackAction.toHit(game, entityId, target,</span>
<span class="nc bnc" id="L5825" title="All 2 branches missed.">                JumpJetAttackAction.BOTH).getValue() != TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5826">            return true;</span>
        }
<span class="nc" id="L5828">        if (JumpJetAttackAction.toHit(game, entityId, target,</span>
<span class="nc bnc" id="L5829" title="All 2 branches missed.">                JumpJetAttackAction.LEFT).getValue() != TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5830">            return true;</span>
        }
<span class="nc" id="L5832">        if (JumpJetAttackAction.toHit(game, entityId, target,</span>
<span class="nc bnc" id="L5833" title="All 2 branches missed.">                JumpJetAttackAction.RIGHT).getValue() != TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5834">            return true;</span>
        }

<span class="nc bnc" id="L5837" title="All 2 branches missed.">        if (BAVibroClawAttackAction.toHit(game, entityId, target).getValue() != TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5838">            return true;</span>
        }

<span class="nc" id="L5841">        return false;</span>
    }

    /**
     * Can movement between the two coordinates be on pavement (which includes
     * roads and bridges)? If so it will override prohibited terrain, it may
     * change movement costs, and it may lead to skids.
     *
     * @param game     - the &lt;code&gt;IGame&lt;/code&gt; object.
     * @param src      - the &lt;code&gt;Coords&lt;/code&gt; being left.
     * @param dest     - the &lt;code&gt;Coords&lt;/code&gt; being entered.
     * @param moveStep
     * @return &lt;code&gt;true&lt;/code&gt; if movement between &lt;code&gt;src&lt;/code&gt; and
     * &lt;code&gt;dest&lt;/code&gt; can be on pavement; &lt;code&gt;false&lt;/code&gt;
     * otherwise.
     */
    public static boolean canMoveOnPavement(IGame game, Coords src,
                                            Coords dest, MoveStep moveStep) {
<span class="nc" id="L5859">        final IHex srcHex = game.getBoard().getHex(src);</span>
<span class="nc" id="L5860">        final IHex destHex = game.getBoard().getHex(dest);</span>
<span class="nc" id="L5861">        final int src2destDir = src.direction(dest);</span>
<span class="nc" id="L5862">        final int dest2srcDir = (src2destDir + 3) % 6;</span>
<span class="nc" id="L5863">        boolean result = false;</span>

        // Jumping shouldn't be considered to be moving on pavement
<span class="nc bnc" id="L5866" title="All 2 branches missed.">        if (moveStep.isJumping()) {</span>
<span class="nc" id="L5867">            return false;</span>
        }

        // We may be moving in the same hex.
<span class="nc bnc" id="L5871" title="All 2 branches missed.">        if (src.equals(dest)</span>
<span class="nc bnc" id="L5872" title="All 2 branches missed.">                &amp;&amp; (srcHex.containsTerrain(Terrains.PAVEMENT)</span>
<span class="nc bnc" id="L5873" title="All 2 branches missed.">                || srcHex.containsTerrain(Terrains.ROAD) || srcHex</span>
<span class="nc bnc" id="L5874" title="All 2 branches missed.">                .containsTerrain(Terrains.BRIDGE))) {</span>
<span class="nc" id="L5875">            result = true;</span>
        }
        // If the source is a pavement hex, then see if the destination
        // hex is also a pavement hex or has a road or bridge that exits
        // into the source hex and the entity is climbing onto the bridge.
<span class="nc bnc" id="L5880" title="All 2 branches missed.">        else if (srcHex.containsTerrain(Terrains.PAVEMENT)</span>
<span class="nc bnc" id="L5881" title="All 2 branches missed.">                &amp;&amp; (destHex.containsTerrain(Terrains.PAVEMENT)</span>
<span class="nc bnc" id="L5882" title="All 2 branches missed.">                || destHex.containsTerrainExit(Terrains.ROAD,</span>
<span class="nc bnc" id="L5883" title="All 2 branches missed.">                dest2srcDir) || (destHex.containsTerrainExit(</span>
<span class="nc bnc" id="L5884" title="All 2 branches missed.">                Terrains.BRIDGE, dest2srcDir) &amp;&amp; moveStep.climbMode()))) {</span>
<span class="nc" id="L5885">            result = true;</span>
        }
        // See if the source hex has a road or bridge (and the entity is on the
        // bridge) that exits into the destination hex, and the dest hex has
        // pavement or a corresponding exit to the src hex
<span class="nc bnc" id="L5890" title="All 2 branches missed.">        else if ((srcHex.containsTerrainExit(Terrains.ROAD, src2destDir) || (srcHex</span>
<span class="nc bnc" id="L5891" title="All 2 branches missed.">                .containsTerrainExit(Terrains.BRIDGE, src2destDir) &amp;&amp; (moveStep.getElevation() == srcHex</span>
<span class="nc bnc" id="L5892" title="All 2 branches missed.">                .terrainLevel(Terrains.BRIDGE_ELEV))))</span>
<span class="nc bnc" id="L5893" title="All 2 branches missed.">                &amp;&amp; (destHex.containsTerrainExit(Terrains.ROAD, dest2srcDir)</span>
<span class="nc bnc" id="L5894" title="All 2 branches missed.">                || (destHex.containsTerrainExit(Terrains.BRIDGE,</span>
<span class="nc bnc" id="L5895" title="All 2 branches missed.">                dest2srcDir) &amp;&amp; moveStep.climbMode()) || destHex</span>
<span class="nc bnc" id="L5896" title="All 2 branches missed.">                .containsTerrain(Terrains.PAVEMENT))) {</span>
<span class="nc" id="L5897">            result = true;</span>
        }

<span class="nc" id="L5900">        return result;</span>
    }

    /**
     * Determines whether the attacker and the target are in the same building.
     *
     * @return true if the target can and does occupy the same building, false
     * otherwise.
     */
    public static boolean isInSameBuilding(IGame game, Entity attacker,
                                           Targetable target) {
<span class="nc bnc" id="L5911" title="All 2 branches missed.">        if (!(target instanceof Entity)) {</span>
<span class="nc" id="L5912">            return false;</span>
        }
<span class="nc" id="L5914">        Entity targetEntity = (Entity) target;</span>
<span class="nc bnc" id="L5915" title="All 2 branches missed.">        if (!Compute.isInBuilding(game, attacker)</span>
<span class="nc bnc" id="L5916" title="All 2 branches missed.">                || !Compute.isInBuilding(game, targetEntity)) {</span>
<span class="nc" id="L5917">            return false;</span>
        }

<span class="nc" id="L5920">        Building attkBldg = game.getBoard().getBuildingAt(</span>
<span class="nc" id="L5921">                attacker.getPosition());</span>
<span class="nc" id="L5922">        Building targBldg = game.getBoard().getBuildingAt(target.getPosition());</span>

<span class="nc" id="L5924">        return attkBldg.equals(targBldg);</span>
    }

    /**
     * Determine if the given unit is inside of a building at the given
     * coordinates.
     *
     * @param game   - the &lt;code&gt;IGame&lt;/code&gt; object. This value may be
     *               &lt;code&gt;null&lt;/code&gt;.
     * @param entity - the &lt;code&gt;Entity&lt;/code&gt; to be checked. This value may be
     *               &lt;code&gt;null&lt;/code&gt;.
     * @return &lt;code&gt;true&lt;/code&gt; if the entity is inside of the building at
     * those coordinates. &lt;code&gt;false&lt;/code&gt; if there is no building at
     * those coordinates or if the entity is on the roof or in the air
     * above the building, or if any input argument is &lt;code&gt;null&lt;/code&gt;
     * .
     */
    public static boolean isInBuilding(IGame game, Entity entity) {

        // No game, no building.
<span class="pc bpc" id="L5944" title="1 of 2 branches missed.">        if (game == null) {</span>
<span class="nc" id="L5945">            return false;</span>
        }

        // Null entities can't be in a building.
<span class="pc bpc" id="L5949" title="1 of 2 branches missed.">        if (entity == null) {</span>
<span class="nc" id="L5950">            return false;</span>
        }

        // Call the version of the function that requires coordinates.
<span class="fc" id="L5954">        return Compute.isInBuilding(game, entity, entity.getPosition());</span>
    }

    /**
     * Determine if the given unit is inside of a building at the given
     * coordinates.
     *
     * @param game   - the &lt;code&gt;IGame&lt;/code&gt; object. This value may be
     *               &lt;code&gt;null&lt;/code&gt;.
     * @param entity - the &lt;code&gt;Entity&lt;/code&gt; to be checked. This value may be
     *               &lt;code&gt;null&lt;/code&gt;.
     * @param coords - the &lt;code&gt;Coords&lt;/code&gt; of the building hex. This value may
     *               be &lt;code&gt;null&lt;/code&gt;.
     * @return &lt;code&gt;true&lt;/code&gt; if the entity is inside of the building at
     * those coordinates. &lt;code&gt;false&lt;/code&gt; if there is no building at
     * those coordinates or if the entity is on the roof or in the air
     * above the building, or if any input argument is &lt;code&gt;null&lt;/code&gt;
     * .
     */
    public static boolean isInBuilding(IGame game, Entity entity, Coords coords) {

        // No game, no building.
<span class="pc bpc" id="L5976" title="1 of 2 branches missed.">        if (game == null) {</span>
<span class="nc" id="L5977">            return false;</span>
        }

        // Null entities can't be in a building.
<span class="pc bpc" id="L5981" title="1 of 2 branches missed.">        if (entity == null) {</span>
<span class="nc" id="L5982">            return false;</span>
        }

        // Null coordinates can't have buildings.
<span class="fc bfc" id="L5986" title="All 2 branches covered.">        if (coords == null) {</span>
<span class="fc" id="L5987">            return false;</span>
        }

        // Get the Hex at those coordinates.

<span class="fc" id="L5992">        return Compute.isInBuilding(game, entity.getElevation(), coords);</span>
    }

    public static boolean isInBuilding(IGame game, int entityElev, Coords coords) {

        // Get the Hex at those coordinates.
<span class="fc" id="L5998">        final IHex curHex = game.getBoard().getHex(coords);</span>

<span class="pc bpc" id="L6000" title="1 of 2 branches missed.">        if (curHex == null) {</span>
            // probably off board artillery or reinforcement
<span class="nc" id="L6002">            return false;</span>
        }

        // The entity can't be inside of a building that isn't there.
<span class="fc bfc" id="L6006" title="All 2 branches covered.">        if (!curHex.containsTerrain(Terrains.BLDG_ELEV)) {</span>
<span class="fc" id="L6007">            return false;</span>
        }

        // The entity can't be inside of a building that isn't there.
<span class="pc bpc" id="L6011" title="1 of 2 branches missed.">        if (!curHex.containsTerrain(Terrains.BUILDING)) {</span>
<span class="nc" id="L6012">            return false;</span>
        }

        // Get the elevations occupied by the building.
<span class="fc" id="L6016">        int bldgHeight = curHex.terrainLevel(Terrains.BLDG_ELEV);</span>
<span class="fc" id="L6017">        int basement = 0;</span>
<span class="pc bpc" id="L6018" title="1 of 2 branches missed.">        if (curHex.containsTerrain(Terrains.BLDG_BASEMENT_TYPE)) {</span>
<span class="nc" id="L6019">            basement = BasementType.getType(</span>
<span class="nc" id="L6020">                    curHex.terrainLevel(Terrains.BLDG_BASEMENT_TYPE))</span>
<span class="nc" id="L6021">                    .getDepth();</span>
        }

        // Return true if the entity is in the range of building elevations.
<span class="pc bpc" id="L6025" title="2 of 4 branches missed.">        if ((entityElev &gt;= (-basement)) &amp;&amp; (entityElev &lt; (bldgHeight))) {</span>
<span class="fc" id="L6026">            return true;</span>
        }

        // Entity is not *inside* of the building.
<span class="nc" id="L6030">        return false;</span>
    }

    /**
     * Scatter from hex according to dive bombing rules (based on MoF),
     * TW pg 246.  The scatter can happen in any direction.
     *
     * @param coords The &lt;code&gt;Coords&lt;/code&gt; to scatter from
     * @param moF    The margin of failure, which deterimines scatter distance
     * @return the &lt;code&gt;Coords&lt;/code&gt; scattered to and distance (moF)
     */
    public static Coords scatterDiveBombs(Coords coords, int moF) {
<span class="nc" id="L6042">        return Compute.scatter(coords, moF);</span>
    }

    /**
     * Scatter from hex according to altitude bombing rules (based on MoF),
     * TW pg 246.  The scatter only happens in the &quot;front&quot; three facings.
     *
     * @param coords The &lt;code&gt;Coords&lt;/code&gt; to scatter from
     * @param facing
     * @return the &lt;code&gt;Coords&lt;/code&gt; scattered to and distance (moF)
     */
    public static Coords scatterAltitudeBombs(Coords coords, int facing) {
<span class="nc" id="L6054">        int dir = 0;</span>
<span class="nc" id="L6055">        int scatterDirection = Compute.d6(1);</span>
<span class="nc bnc" id="L6056" title="All 4 branches missed.">        switch (scatterDirection) {</span>
            case 1:
            case 2:
<span class="nc" id="L6059">                dir = (facing - 1) % 6;</span>
<span class="nc" id="L6060">                break;</span>
            case 3:
            case 4:
<span class="nc" id="L6063">                dir = facing;</span>
<span class="nc" id="L6064">                break;</span>
            case 5:
            case 6:
<span class="nc" id="L6067">                dir = (facing + 1) % 6;</span>
                break;
        }
<span class="nc" id="L6070">        int dist = Compute.d6(1);</span>
<span class="nc" id="L6071">        return coords.translated(dir, dist);</span>
    }

    /**
     * scatter from hex according to direct fire artillery rules (based on MoF)
     *
     * @param coords The &lt;code&gt;Coords&lt;/code&gt; to scatter from
     * @param moF    The margin of failure, which deterimines scatter distance
     * @return the &lt;code&gt;Coords&lt;/code&gt; scattered to
     */
    public static Coords scatterDirectArty(Coords coords, int moF) {
<span class="nc" id="L6082">        return Compute.scatter(coords, moF);</span>
    }

    /**
     * scatter from a hex according, roll d6 to choose scatter direction
     *
     * @param coords The &lt;code&gt;Coords&lt;/code&gt; to scatter from
     * @param margin the &lt;code&gt;int&lt;/code&gt; margin of failure, scatter distance will
     *               be the margin of failure
     * @return the &lt;code&gt;Coords&lt;/code&gt; scattered to
     */
    public static Coords scatter(Coords coords, int margin) {
<span class="nc" id="L6094">        int scatterDirection = Compute.d6(1) - 1;</span>
<span class="nc" id="L6095">        return coords.translated(scatterDirection, margin);</span>
    }

    /**
     * scatter from hex according to atmospheric drop rules d6 for direction,
     * 1d6 per point of MOF
     *
     * @param coords The &lt;code&gt;Coords&lt;/code&gt; to scatter from
     * @param margin the &lt;code&gt;int&lt;/code&gt; margin of failure
     * @return the &lt;code&gt;Coords&lt;/code&gt; scattered to
     */
    public static Coords scatterAssaultDrop(Coords coords, int margin) {
<span class="nc" id="L6107">        int scatterDirection = Compute.d6(1) - 1;</span>
<span class="nc" id="L6108">        int distance = Compute.d6(margin);</span>
<span class="nc" id="L6109">        return coords.translated(scatterDirection, distance);</span>
    }

    /**
     * Gets a new target for a flight of swarm missiles that was just shot at an
     * entity and has missiles left
     *
     * @param game
     * @param aeId     The attacking &lt;code&gt;Entity&lt;/code&gt;
     * @param coords
     * @param weaponId The &lt;code&gt;int&lt;/code&gt; ID of the launcher used to fire this
     *                 volley
     * @return the new target &lt;code&gt;Entity&lt;/code&gt;. May return null if no new
     * target available
     */
    public static Entity getSwarmMissileTarget(IGame game, int aeId,
                                               Coords coords, int weaponId) {
<span class="nc" id="L6126">        Entity tempEntity = null;</span>
        // first, check the hex of the original target
<span class="nc" id="L6128">        Iterator&lt;Entity&gt; entities = game.getEntities(coords);</span>
<span class="nc" id="L6129">        Vector&lt;Entity&gt; possibleTargets = new Vector&lt;Entity&gt;();</span>
<span class="nc bnc" id="L6130" title="All 2 branches missed.">        while (entities.hasNext()) {</span>
<span class="nc" id="L6131">            tempEntity = entities.next();</span>
<span class="nc bnc" id="L6132" title="All 2 branches missed.">            if (!tempEntity.getTargetedBySwarm(aeId, weaponId)) {</span>
                // we found a target
<span class="nc" id="L6134">                possibleTargets.add(tempEntity);</span>
            }
        }
        // if there is at least one target, get a random one of them
<span class="nc bnc" id="L6138" title="All 2 branches missed.">        if (!possibleTargets.isEmpty()) {</span>
<span class="nc" id="L6139">            return possibleTargets</span>
<span class="nc" id="L6140">                    .get(Compute.randomInt(possibleTargets.size()));</span>
        }
        // loop through adjacent hexes
<span class="nc bnc" id="L6143" title="All 2 branches missed.">        for (int dir = 0; dir &lt;= 5; dir++) {</span>
<span class="nc" id="L6144">            Coords tempcoords = coords.translated(dir);</span>
<span class="nc bnc" id="L6145" title="All 2 branches missed.">            if (!game.getBoard().contains(tempcoords)) {</span>
<span class="nc" id="L6146">                continue;</span>
            }
<span class="nc bnc" id="L6148" title="All 2 branches missed.">            if (coords.equals(tempcoords)) {</span>
<span class="nc" id="L6149">                continue;</span>
            }
<span class="nc" id="L6151">            entities = game.getEntities(tempcoords);</span>
<span class="nc bnc" id="L6152" title="All 2 branches missed.">            if (entities.hasNext()) {</span>
<span class="nc" id="L6153">                tempEntity = entities.next();</span>
<span class="nc bnc" id="L6154" title="All 2 branches missed.">                if (!tempEntity.getTargetedBySwarm(aeId, weaponId)) {</span>
                    // we found a target
<span class="nc" id="L6156">                    possibleTargets.add(tempEntity);</span>
                }
            }
        }
        // if there is at least one target, get a random one of them
<span class="nc bnc" id="L6161" title="All 2 branches missed.">        if (!possibleTargets.isEmpty()) {</span>
<span class="nc" id="L6162">            return possibleTargets</span>
<span class="nc" id="L6163">                    .get(Compute.randomInt(possibleTargets.size()));</span>
        }
<span class="nc" id="L6165">        return null;</span>
    }

    /**
     * Gets a new target hex for a flight of smoke missiles fired at a hex, if
     * there are remaining missiles.
     */

    /**
     * * STUFF FOR VECTOR MOVEMENT CALCULATIONS **
     */
    public static Coords getFinalPosition(Coords curpos, int[] v) {

<span class="nc bnc" id="L6178" title="All 4 branches missed.">        if ((v == null) || (v.length != 6)) {</span>
<span class="nc" id="L6179">            return curpos;</span>
        }

        // step through each vector and move the direction indicated
<span class="nc" id="L6183">        int thrust = 0;</span>
<span class="nc" id="L6184">        Coords endpos = curpos;</span>
<span class="nc bnc" id="L6185" title="All 2 branches missed.">        for (int dir = 0; dir &lt; 6; dir++) {</span>
<span class="nc" id="L6186">            thrust = v[dir];</span>
<span class="nc bnc" id="L6187" title="All 2 branches missed.">            while (thrust &gt; 0) {</span>
<span class="nc" id="L6188">                endpos = endpos.translated(dir);</span>
<span class="nc" id="L6189">                thrust--;</span>
            }
        }

<span class="nc" id="L6193">        return endpos;</span>
    }

    /**
     * method to change a set of active vectors for a one-point thrust
     * expenditure in the giving facing
     *
     * @param v
     * @param facing
     * @return
     */
    public static int[] changeVectors(int[] v, int facing) {

<span class="nc bnc" id="L6206" title="All 4 branches missed.">        if ((v == null) || (v.length != 6)) {</span>
<span class="nc" id="L6207">            return v;</span>
        }

        // first look at opposing vectors
<span class="nc" id="L6211">        int oppv = facing + 3;</span>
<span class="nc bnc" id="L6212" title="All 2 branches missed.">        if (oppv &gt; 5) {</span>
<span class="nc" id="L6213">            oppv -= 6;</span>
        }
        // is this vector active
<span class="nc bnc" id="L6216" title="All 2 branches missed.">        if (v[oppv] &gt; 0) {</span>
            // then decrement it by one and return
<span class="nc" id="L6218">            v[oppv]--;</span>
<span class="nc" id="L6219">            return v;</span>
        }

        // now check oblique vectors
<span class="nc" id="L6223">        int oblv1 = facing + 2;</span>
<span class="nc bnc" id="L6224" title="All 2 branches missed.">        if (oblv1 &gt; 5) {</span>
<span class="nc" id="L6225">            oblv1 -= 6;</span>
        }
<span class="nc" id="L6227">        int oblv2 = facing - 2;</span>
<span class="nc bnc" id="L6228" title="All 2 branches missed.">        if (oblv2 &lt; 0) {</span>
<span class="nc" id="L6229">            oblv2 += 6;</span>
        }

        // check both of these and if either is active
        // deal with it and then return
<span class="nc bnc" id="L6234" title="All 4 branches missed.">        if ((v[oblv1] &gt; 0) || (v[oblv2] &gt; 0)) {</span>

<span class="nc" id="L6236">            int newface = facing + 1;</span>
<span class="nc bnc" id="L6237" title="All 2 branches missed.">            if (newface &gt; 5) {</span>
<span class="nc" id="L6238">                newface = 0;</span>
            }
<span class="nc bnc" id="L6240" title="All 2 branches missed.">            if (v[oblv1] &gt; 0) {</span>
<span class="nc" id="L6241">                v[oblv1]--;</span>
<span class="nc" id="L6242">                v[newface]++;</span>
            }

<span class="nc" id="L6245">            newface = facing - 1;</span>
<span class="nc bnc" id="L6246" title="All 2 branches missed.">            if (newface &lt; 0) {</span>
<span class="nc" id="L6247">                newface = 5;</span>
            }
<span class="nc bnc" id="L6249" title="All 2 branches missed.">            if (v[oblv2] &gt; 0) {</span>
<span class="nc" id="L6250">                v[oblv2]--;</span>
<span class="nc" id="L6251">                v[newface]++;</span>
            }
<span class="nc" id="L6253">            return v;</span>
        }

        // if nothing was found, then just increase velocity in this vector
<span class="nc" id="L6257">        v[facing]++;</span>
<span class="nc" id="L6258">        return v;</span>
    }

    /**
     * compare two vectors and determine if they are the same
     *
     * @param v1
     * @param v2
     * @return
     */
    public static boolean sameVectors(int[] v1, int[] v2) {

<span class="nc bnc" id="L6270" title="All 2 branches missed.">        for (int i = 0; i &lt; 6; i++) {</span>
<span class="nc bnc" id="L6271" title="All 2 branches missed.">            if (v1[i] != v2[i]) {</span>
<span class="nc" id="L6272">                return false;</span>
            }
        }

<span class="nc" id="L6276">        return true;</span>
    }

    /**
     * Get the net velocity of two aeros for ramming attacks
     */
    public static int getNetVelocity(Coords src, Entity te, int avel, int tvel) {
<span class="nc" id="L6283">        int angle = te.sideTableRam(src);</span>

<span class="nc bnc" id="L6285" title="All 5 branches missed.">        switch (angle) {</span>
            case Aero.RAM_TOWARD_DIR:
<span class="nc" id="L6287">                return Math.max(avel + tvel, 1);</span>
            case Aero.RAM_TOWARD_OBL:
<span class="nc" id="L6289">                return Math.max(avel + (tvel / 2), 1);</span>
            case Aero.RAM_AWAY_OBL:
<span class="nc" id="L6291">                return Math.max(avel - (tvel / 2), 1);</span>
            case Aero.RAM_AWAY_DIR:
<span class="nc" id="L6293">                return Math.max(avel - tvel, 1);</span>
        }
<span class="nc" id="L6295">        return 0;</span>
    }

    /**
     * Returns how much damage a weapon will do against against a BattleArmor
     * target if the BattleArmor vs BattleArmor rules on TO pg 109 are in
     * effect.
     *
     * @param damage     Original weapon damage
     * @param damageType The damage type for BA vs BA damage
     * @param target     The target, used for ensuring the target BA isn't
     *                   fire resistant
     * @return
     */
    public static int directBlowBADamage(double damage, int damageType,
                                         BattleArmor target) {
<span class="nc bnc" id="L6311" title="All 4 branches missed.">        switch (damageType) {</span>
            case WeaponType.WEAPON_BURST_1D6:
<span class="nc" id="L6313">                damage = Compute.d6();</span>
<span class="nc" id="L6314">                break;</span>
            case WeaponType.WEAPON_BURST_3D6:
<span class="nc" id="L6316">                damage = Compute.d6(3);</span>
<span class="nc" id="L6317">                break;</span>
            case WeaponType.WEAPON_PLASMA:
                // If the target is fire-resistant BA, damage is normal
<span class="nc bnc" id="L6320" title="All 2 branches missed.">                if (!target.isFireResistant()) {</span>
<span class="nc" id="L6321">                    damage = 1 + Compute.d6(1);</span>
                }
                break;
        }
<span class="nc" id="L6325">        damage = Math.ceil(damage);</span>
<span class="nc" id="L6326">        return (int) damage;</span>
    }

    /**
     * Used to get a human-readable string that represents the passed damage
     * type.
     *
     * @param damageType
     * @return
     */
    public static String getDamageTypeString(int damageType) {
<span class="nc bnc" id="L6337" title="All 5 branches missed.">        switch (damageType) {</span>
            case WeaponType.WEAPON_DIRECT_FIRE:
<span class="nc" id="L6339">                return Messages.getString(&quot;WeaponType.DirectFire&quot;);</span>
            case WeaponType.WEAPON_CLUSTER_BALLISTIC:
<span class="nc" id="L6341">                return Messages.getString(&quot;WeaponType.BallisticCluster&quot;);</span>
            case WeaponType.WEAPON_PULSE:
<span class="nc" id="L6343">                return Messages.getString(&quot;WeaponType.Pulse&quot;);</span>
            case WeaponType.WEAPON_CLUSTER_MISSILE:
            case WeaponType.WEAPON_CLUSTER_MISSILE_1D6:
            case WeaponType.WEAPON_CLUSTER_MISSILE_2D6:
            case WeaponType.WEAPON_CLUSTER_MISSILE_3D6:
<span class="nc" id="L6348">                return Messages.getString(&quot;WeaponType.Missile&quot;);</span>
            case WeaponType.WEAPON_BURST_HALFD6:
            case WeaponType.WEAPON_BURST_1D6:
            case WeaponType.WEAPON_BURST_2D6:
            case WeaponType.WEAPON_BURST_3D6:
            case WeaponType.WEAPON_BURST_4D6:
            case WeaponType.WEAPON_BURST_5D6:
            case WeaponType.WEAPON_BURST_6D6:
            case WeaponType.WEAPON_BURST_7D6:
            default:
<span class="nc" id="L6358">                return Messages.getString(&quot;WeaponType.Burst&quot;);</span>
        }
    }

    public static int directBlowInfantryDamage(double damage, int mos,
                                               int damageType, boolean isNonInfantryAgainstMechanized,
                                               boolean isAttackThruBuilding) {
<span class="nc" id="L6365">        return directBlowInfantryDamage(damage, mos, damageType,</span>
                isNonInfantryAgainstMechanized, isAttackThruBuilding,
                Entity.NONE, null);
    }

    /**
     * Method replicates the Non-Conventional Damage against Infantry damage
     * table as well as shifting for direct blows. also adjust for non-infantry
     * damaging mechanized infantry
     *
     * @param damage
     * @param mos
     * @param damageType
     * @return
     */
    public static int directBlowInfantryDamage(double damage, int mos,
                                               int damageType, boolean isNonInfantryAgainstMechanized,
                                               boolean isAttackThruBuilding, int attackerId, Vector&lt;Report&gt; vReport) {

<span class="nc" id="L6384">        int origDamageType = damageType;</span>
<span class="nc" id="L6385">        damageType += mos;</span>
<span class="nc" id="L6386">        double origDamage = damage;</span>
<span class="nc bnc" id="L6387" title="All 16 branches missed.">        switch (damageType) {</span>
            case WeaponType.WEAPON_DIRECT_FIRE:
<span class="nc" id="L6389">                damage /= 10;</span>
<span class="nc" id="L6390">                break;</span>
            case WeaponType.WEAPON_CLUSTER_BALLISTIC:
<span class="nc" id="L6392">                damage /= 10;</span>
<span class="nc" id="L6393">                damage++;</span>
<span class="nc" id="L6394">                break;</span>
            case WeaponType.WEAPON_PULSE:
<span class="nc" id="L6396">                damage /= 10;</span>
<span class="nc" id="L6397">                damage += 2;</span>
<span class="nc" id="L6398">                break;</span>
            case WeaponType.WEAPON_CLUSTER_MISSILE:
<span class="nc" id="L6400">                damage /= 5;</span>
<span class="nc" id="L6401">                break;</span>
            case WeaponType.WEAPON_CLUSTER_MISSILE_1D6:
<span class="nc" id="L6403">                damage /= 5;</span>
<span class="nc" id="L6404">                damage += Compute.d6();</span>
<span class="nc" id="L6405">                break;</span>
            case WeaponType.WEAPON_CLUSTER_MISSILE_2D6:
<span class="nc" id="L6407">                damage /= 5;</span>
<span class="nc" id="L6408">                damage += Compute.d6(2);</span>
<span class="nc" id="L6409">                break;</span>
            case WeaponType.WEAPON_CLUSTER_MISSILE_3D6:
<span class="nc" id="L6411">                damage /= 5;</span>
<span class="nc" id="L6412">                damage += Compute.d6(3);</span>
<span class="nc" id="L6413">                break;</span>
            case WeaponType.WEAPON_BURST_HALFD6:
<span class="nc" id="L6415">                damage = Compute.d6() / 2.0;</span>
<span class="nc bnc" id="L6416" title="All 2 branches missed.">                if (isAttackThruBuilding) {</span>
<span class="nc" id="L6417">                    damage *= 0.5;</span>
                }
                break;
            case WeaponType.WEAPON_BURST_1D6:
<span class="nc" id="L6421">                damage = Compute.d6();</span>
<span class="nc bnc" id="L6422" title="All 2 branches missed.">                if (isAttackThruBuilding) {</span>
<span class="nc" id="L6423">                    damage *= 0.5;</span>
                }
                break;
            case WeaponType.WEAPON_BURST_2D6:
<span class="nc" id="L6427">                damage = Compute.d6(2);</span>
<span class="nc bnc" id="L6428" title="All 2 branches missed.">                if (isAttackThruBuilding) {</span>
<span class="nc" id="L6429">                    damage *= 0.5;</span>
                }
                break;
            case WeaponType.WEAPON_BURST_3D6:
<span class="nc" id="L6433">                damage = Compute.d6(3);</span>
<span class="nc bnc" id="L6434" title="All 2 branches missed.">                if (isAttackThruBuilding) {</span>
<span class="nc" id="L6435">                    damage *= 0.5;</span>
                }
                break;
            case WeaponType.WEAPON_BURST_4D6:
<span class="nc" id="L6439">                damage = Compute.d6(4);</span>
<span class="nc bnc" id="L6440" title="All 2 branches missed.">                if (isAttackThruBuilding) {</span>
<span class="nc" id="L6441">                    damage *= 0.5;</span>
                }
                break;
            case WeaponType.WEAPON_BURST_5D6:
<span class="nc" id="L6445">                damage = Compute.d6(5);</span>
<span class="nc bnc" id="L6446" title="All 2 branches missed.">                if (isAttackThruBuilding) {</span>
<span class="nc" id="L6447">                    damage *= 0.5;</span>
                }
                break;
            case WeaponType.WEAPON_BURST_6D6:
<span class="nc" id="L6451">                damage = Compute.d6(6);</span>
<span class="nc bnc" id="L6452" title="All 2 branches missed.">                if (isAttackThruBuilding) {</span>
<span class="nc" id="L6453">                    damage *= 0.5;</span>
                }
                break;
            case WeaponType.WEAPON_BURST_7D6:
<span class="nc" id="L6457">                damage = Compute.d6(7);</span>
<span class="nc bnc" id="L6458" title="All 2 branches missed.">                if (isAttackThruBuilding) {</span>
<span class="nc" id="L6459">                    damage *= 0.5;</span>
                }
                break;
        }
<span class="nc" id="L6463">        damage = Math.ceil(damage);</span>

        // according to the following ruling, the half damage that mechanized
        // inf get against burst fire should trump the double damage they get
        // from non-infantry rather than cancel it out
        // http://bg.battletech.com/forums/index.php/topic,23928.0.html
<span class="nc bnc" id="L6469" title="All 2 branches missed.">        if (isNonInfantryAgainstMechanized) {</span>
<span class="nc bnc" id="L6470" title="All 2 branches missed.">            if (damageType &lt; WeaponType.WEAPON_BURST_HALFD6) {</span>
<span class="nc" id="L6471">                damage *= 2;</span>
            } else {
<span class="nc" id="L6473">                damage /= 2;</span>
            }
        }

<span class="nc bnc" id="L6477" title="All 2 branches missed.">        if (vReport != null) {</span>
<span class="nc" id="L6478">            Report r = new Report();</span>
<span class="nc" id="L6479">            r.subject = attackerId;</span>
<span class="nc" id="L6480">            r.indent(2);</span>

<span class="nc" id="L6482">            r.add(getDamageTypeString(origDamageType));</span>
<span class="nc bnc" id="L6483" title="All 2 branches missed.">            if (origDamageType != damageType) {</span>
<span class="nc bnc" id="L6484" title="All 2 branches missed.">                if (isAttackThruBuilding) {</span>
<span class="nc" id="L6485">                    r.messageId = 9973;</span>
                } else {
<span class="nc" id="L6487">                    r.messageId = 9972;</span>
                }
<span class="nc" id="L6489">                r.add(getDamageTypeString(damageType));</span>
<span class="nc bnc" id="L6490" title="All 2 branches missed.">            } else if (isAttackThruBuilding) {</span>
<span class="nc" id="L6491">                r.messageId = 9971;</span>
            } else {
<span class="nc" id="L6493">                r.messageId = 9970;</span>
            }

<span class="nc" id="L6496">            r.add((int) origDamage);</span>
<span class="nc" id="L6497">            r.add((int) damage);</span>
<span class="nc" id="L6498">            vReport.addElement(r);</span>
        }
<span class="nc" id="L6500">        return (int) damage;</span>
    }


    /**
     * Method computes how much damage a dial down weapon has done
     *
     * @param weapon
     * @param wtype
     * @returnnew damage
     */
    public static int dialDownDamage(Mounted weapon, WeaponType wtype) {
<span class="nc" id="L6512">        return Compute.dialDownDamage(weapon, wtype, 1);</span>
    }

    /**
     * Method computes how much damage a dial down weapon has done
     *
     * @param weapon
     * @param wtype
     * @param range
     * @return new damage
     */
    public static int dialDownDamage(Mounted weapon, WeaponType wtype, int range) {
<span class="nc" id="L6524">        int toReturn = wtype.getDamage(range);</span>

<span class="nc bnc" id="L6526" title="All 2 branches missed.">        if (!wtype.hasModes()) {</span>
<span class="nc" id="L6527">            return toReturn;</span>
        }

<span class="nc" id="L6530">        String damage = weapon.curMode().getName();</span>

        // Vehicle flamers have damage and heat modes so lets make sure this is
        // an actual dial down Damage.
<span class="nc bnc" id="L6534" title="All 2 branches missed.">        if ((damage.trim().toLowerCase().indexOf(&quot;damage&quot;) == 0)</span>
<span class="nc bnc" id="L6535" title="All 2 branches missed.">                &amp;&amp; (damage.trim().length() &gt; 6)) {</span>
<span class="nc" id="L6536">            toReturn = Integer.parseInt(damage.substring(6).trim());</span>
        }

<span class="nc" id="L6539">        return Math.min(wtype.getDamage(range), toReturn);</span>

    }

    /**
     * Method computes how much heat a dial down weapon generates
     *
     * @param weapon
     * @param wtype
     * @return Heat, minimum of 1;
     */
    public static int dialDownHeat(Mounted weapon, WeaponType wtype) {
<span class="nc" id="L6551">        return Compute.dialDownHeat(weapon, wtype, 1);</span>
    }

    /**
     * Method computes how much heat a dial down weapon generates
     *
     * @param weapon
     * @param wtype
     * @param range
     * @return Heat, minimum of 1;
     */
    public static int dialDownHeat(Mounted weapon, WeaponType wtype, int range) {
<span class="nc" id="L6563">        int toReturn = wtype.getHeat();</span>

<span class="nc bnc" id="L6565" title="All 2 branches missed.">        if (!wtype.hasModes()) {</span>
<span class="nc" id="L6566">            return toReturn;</span>
        }

<span class="nc" id="L6569">        int damage = wtype.getDamage(range);</span>
<span class="nc" id="L6570">        int newDamage = Compute.dialDownDamage(weapon, wtype, range);</span>

<span class="nc" id="L6572">        toReturn = Math.max(1,</span>
<span class="nc" id="L6573">                wtype.getHeat() - Math.max(0, damage - newDamage));</span>
<span class="nc" id="L6574">        return toReturn;</span>

    }

    /**
     * @param aPos - attacking entity
     * @param tPos - targeted entity
     * @return a vector of all the entities that are adjacent to the targeted
     * entity and would fall along the angle of attack
     */
    public static ArrayList&lt;Entity&gt; getAdjacentEntitiesAlongAttack(Coords aPos,
                                                                   Coords tPos, IGame game) {
<span class="nc" id="L6586">        ArrayList&lt;Entity&gt; entities = new ArrayList&lt;Entity&gt;();</span>
<span class="nc" id="L6587">        ArrayList&lt;Coords&gt; coords = Coords.intervening(aPos, tPos);</span>
        // loop through all intervening coords
<span class="nc bnc" id="L6589" title="All 2 branches missed.">        for (Coords c : coords) {</span>
            // must be adjacent to the target
<span class="nc bnc" id="L6591" title="All 4 branches missed.">            if ((c.distance(tPos) &gt; 1) || c.equals(tPos)) {</span>
<span class="nc" id="L6592">                continue;</span>
            }
            // now lets add all the entities here
<span class="nc bnc" id="L6595" title="All 2 branches missed.">            for (Entity en : game.getEntitiesVector(c)) {</span>
<span class="nc" id="L6596">                entities.add(en);</span>
<span class="nc" id="L6597">            }</span>
<span class="nc" id="L6598">        }</span>
<span class="nc" id="L6599">        return entities;</span>
    }

    public static boolean isInUrbanEnvironment(IGame game, Coords unitPOS) {
<span class="nc" id="L6603">        IHex unitHex = game.getBoard().getHex(unitPOS);</span>

<span class="nc bnc" id="L6605" title="All 2 branches missed.">        if (unitHex.containsTerrain(Terrains.PAVEMENT)</span>
<span class="nc bnc" id="L6606" title="All 2 branches missed.">                || unitHex.containsTerrain(Terrains.BUILDING)</span>
<span class="nc bnc" id="L6607" title="All 2 branches missed.">                || unitHex.containsTerrain(Terrains.RUBBLE)) {</span>
<span class="nc" id="L6608">            return true;</span>
        }

        // loop through adjacent hexes
<span class="nc bnc" id="L6612" title="All 2 branches missed.">        for (int dir = 0; dir &lt;= 5; dir++) {</span>
<span class="nc" id="L6613">            Coords adjCoords = unitPOS.translated(dir);</span>
<span class="nc" id="L6614">            IHex adjHex = game.getBoard().getHex(adjCoords);</span>

<span class="nc bnc" id="L6616" title="All 2 branches missed.">            if (!game.getBoard().contains(adjCoords)) {</span>
<span class="nc" id="L6617">                continue;</span>
            }
<span class="nc bnc" id="L6619" title="All 2 branches missed.">            if (unitPOS.equals(adjCoords)) {</span>
<span class="nc" id="L6620">                continue;</span>
            }

            // hex pavement or building?
<span class="nc bnc" id="L6624" title="All 2 branches missed.">            if (adjHex.containsTerrain(Terrains.PAVEMENT)</span>
<span class="nc bnc" id="L6625" title="All 2 branches missed.">                    || adjHex.containsTerrain(Terrains.BUILDING)</span>
<span class="nc bnc" id="L6626" title="All 2 branches missed.">                    || adjHex.containsTerrain(Terrains.RUBBLE)) {</span>
<span class="nc" id="L6627">                return true;</span>
            }
        }
<span class="nc" id="L6630">        return false;</span>
    }

    public static boolean isAirToGround(Entity attacker, Targetable target) {
<span class="pc bpc" id="L6634" title="2 of 4 branches missed.">        if ((attacker == null) || (target == null)) {</span>
<span class="nc" id="L6635">            return false;</span>
        }

        //Artillery attacks need to return differently, since none of the usual air to ground modifiers apply to them
<span class="pc bpc" id="L6639" title="1 of 2 branches missed.">        if (target.getTargetType() == Targetable.TYPE_HEX_ARTILLERY) {</span>
<span class="nc" id="L6640">            return false;</span>
        }

<span class="pc bpc" id="L6643" title="1 of 2 branches missed.">        if (attacker.isSpaceborne()) {</span>
<span class="nc" id="L6644">            return false;</span>
        }
        // According to errata, VTOL and WiGes are considered ground targets
<span class="pc bpc" id="L6647" title="5 of 6 branches missed.">        return attacker.isAirborne() &amp;&amp; !target.isAirborne() &amp;&amp; attacker.isAero();</span>

    }

    public static boolean isAirToAir(Entity attacker, Targetable target) {
<span class="nc bnc" id="L6652" title="All 4 branches missed.">        if ((attacker == null) || (target == null)) {</span>
<span class="nc" id="L6653">            return false;</span>
        }
        // According to errata, VTOL and WiGes are considered ground targets
<span class="nc bnc" id="L6656" title="All 4 branches missed.">        return attacker.isAirborne() &amp;&amp; target.isAirborne();</span>
    }

    public static boolean isGroundToAir(Entity attacker, Targetable target) {
<span class="pc bpc" id="L6660" title="2 of 4 branches missed.">        if ((attacker == null) || (target == null)) {</span>
<span class="nc" id="L6661">            return false;</span>
        }
<span class="pc bpc" id="L6663" title="2 of 4 branches missed.">        return !attacker.isAirborne() &amp;&amp; target.isAirborne();</span>
    }

    public static boolean isGroundToGround(Entity attacker, Targetable target) {
<span class="nc bnc" id="L6667" title="All 4 branches missed.">        if ((attacker == null) || (target == null)) {</span>
<span class="nc" id="L6668">            return false;</span>
        }
<span class="nc bnc" id="L6670" title="All 4 branches missed.">        return !attacker.isAirborne() &amp;&amp; !target.isAirborne();</span>
    }

    /**
     * This is a homebrew function partially drawn from pg. 40-1 of AT2R that
     * allows units that flee the field for any reason to return after a certain
     * number of rounds It can potentially be expanded to include other
     * conditions
     *
     * @param en
     * @return number of rounds until return (-1 if never)
     */
    public static int roundsUntilReturn(IGame game, Entity en) {

<span class="nc bnc" id="L6684" title="All 2 branches missed.">        if (!en.isAero()) {</span>
<span class="nc" id="L6685">            return -1;</span>
        }

<span class="nc bnc" id="L6688" title="All 2 branches missed.">        if (!game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_RETURN_FLYOVER)) {</span>
<span class="nc" id="L6689">            return -1;</span>
        }

<span class="nc" id="L6692">        IAero a = (IAero) en;</span>

        // the table in AT2R is backwards, it should take longer to return if
        // your velocity is higher
<span class="nc" id="L6696">        int turns = 1 + (int) Math.ceil(a.getCurrentVelocity() / 4.0);</span>

        // OOC units should take longer, how about two extra turns?
<span class="nc bnc" id="L6699" title="All 2 branches missed.">        if (a.isOutControlTotal()) {</span>
<span class="nc" id="L6700">            turns += 2;</span>
        }
<span class="nc" id="L6702">        return turns;</span>
    }

    public static boolean inDeadZone(IGame game, Entity ae, Targetable target) {
<span class="nc bnc" id="L6706" title="All 2 branches missed.">        if (ae.isSpaceborne()) {</span>
<span class="nc" id="L6707">            return false;</span>
        }
        // Account for &quot;dead zones&quot; between Aeros at different altitudes
<span class="nc bnc" id="L6710" title="All 2 branches missed.">        if (Compute.isAirToAir(ae, target)) {</span>
<span class="nc" id="L6711">            int distance = Compute.effectiveDistance(game, ae, target,</span>
<span class="nc" id="L6712">                    target.isAirborneVTOLorWIGE());</span>
<span class="nc" id="L6713">            int aAlt = ae.getAltitude();</span>
<span class="nc" id="L6714">            int tAlt = target.getAltitude();</span>
<span class="nc bnc" id="L6715" title="All 2 branches missed.">            if (target.isAirborneVTOLorWIGE()) {</span>
<span class="nc" id="L6716">                tAlt++;</span>
            }
<span class="nc" id="L6718">            int altDiff = Math.abs(aAlt - tAlt);</span>
<span class="nc bnc" id="L6719" title="All 2 branches missed.">            if (altDiff &gt;= (distance - altDiff)) {</span>
<span class="nc" id="L6720">                return true;</span>
            }
        }
<span class="nc" id="L6723">        return false;</span>
    }

    public static ArrayList&lt;Coords&gt; getAcceptableUnloadPositions(
            List&lt;Coords&gt; ring, Entity unit, IGame game, int elev) {

<span class="nc" id="L6729">        ArrayList&lt;Coords&gt; acceptable = new ArrayList&lt;Coords&gt;();</span>

<span class="nc bnc" id="L6731" title="All 2 branches missed.">        for (Coords pos : ring) {</span>
<span class="nc" id="L6732">            IHex hex = game.getBoard().getHex(pos);</span>
<span class="nc bnc" id="L6733" title="All 2 branches missed.">            if (null == hex) {</span>
<span class="nc" id="L6734">                continue;</span>
            }
            // no stacking violations, no prohibited terrain, and within 2
            // elevations

<span class="nc bnc" id="L6739" title="All 2 branches missed.">            if (!unit.isLocationProhibited(pos)</span>
<span class="nc bnc" id="L6740" title="All 2 branches missed.">                    &amp;&amp; (null == stackingViolation(game, unit.getId(), pos))</span>
<span class="nc bnc" id="L6741" title="All 2 branches missed.">                    &amp;&amp; (Math.abs(hex.getLevel() - elev) &lt; 3)) {</span>
<span class="nc" id="L6742">                acceptable.add(pos);</span>
            }
<span class="nc" id="L6744">        }</span>
<span class="nc" id="L6745">        return acceptable;</span>
    }

    /**
     * Builds a list of all adjacent units that can load the given Entity.
     *
     * @param en   The entity to load
     * @param pos  The coordinates of the hex to load from
     * @param elev The absolute elevation of the unit at the point of loading (surface
     *             of the hex + elevation over the surface)
     * @param game The game object
     * @return All adjacent units that can mount the Entity
     */
    public static List&lt;Entity&gt; getMountableUnits(Entity en, Coords pos, int elev, IGame game) {
<span class="nc" id="L6759">        List&lt;Entity&gt; mountable = new ArrayList&lt;&gt;();</span>
        // Expanded to include trains

        // the rules don't say that the unit must be facing loader
        // so lets take the ring
<span class="nc bnc" id="L6764" title="All 2 branches missed.">        for (Coords c : pos.allAdjacent()) {</span>
<span class="nc" id="L6765">            IHex hex = game.getBoard().getHex(c);</span>
<span class="nc bnc" id="L6766" title="All 2 branches missed.">            if (null == hex) {</span>
<span class="nc" id="L6767">                continue;</span>
            }
<span class="nc bnc" id="L6769" title="All 2 branches missed.">            for (Entity other : game.getEntitiesVector(c)) {</span>
                // Is the other unit friendly and not the current entity?
<span class="nc bnc" id="L6771" title="All 2 branches missed.">                if ((en.getOwner().equals(other.getOwner()) || (en.getOwner()</span>
<span class="nc bnc" id="L6772" title="All 2 branches missed.">                        .getTeam() == other.getOwner().getTeam()))</span>
<span class="nc bnc" id="L6773" title="All 4 branches missed.">                        &amp;&amp; !en.equals(other)</span>
<span class="nc bnc" id="L6774" title="All 4 branches missed.">                        &amp;&amp; ((other instanceof SmallCraft) || other.getTowing() != Entity.NONE || other.getTowedBy() != Entity.NONE)</span>
<span class="nc bnc" id="L6775" title="All 2 branches missed.">                        &amp;&amp; other.canLoad(en)</span>
<span class="nc bnc" id="L6776" title="All 2 branches missed.">                        &amp;&amp; !other.isAirborne()</span>
<span class="nc bnc" id="L6777" title="All 2 branches missed.">                        &amp;&amp; (Math.abs((hex.surface() + other.getElevation())</span>
<span class="nc bnc" id="L6778" title="All 2 branches missed.">                        - elev) &lt; 3) &amp;&amp; !mountable.contains(other)) {</span>
<span class="nc" id="L6779">                    mountable.add(other);</span>
                }
<span class="nc" id="L6781">            }</span>
<span class="nc" id="L6782">        }</span>

<span class="nc" id="L6784">        return mountable;</span>

    }

    public static boolean allowAimedShotWith(Mounted weapon, int aimingMode) {
<span class="nc" id="L6789">        WeaponType wtype = (WeaponType) weapon.getType();</span>
<span class="nc" id="L6790">        boolean isWeaponInfantry = wtype.hasFlag(WeaponType.F_INFANTRY);</span>
<span class="nc bnc" id="L6791" title="All 4 branches missed.">        boolean usesAmmo = (wtype.getAmmoType() != AmmoType.T_NA)</span>
                &amp;&amp; !isWeaponInfantry;
<span class="nc bnc" id="L6793" title="All 2 branches missed.">        Mounted ammo = usesAmmo ? weapon.getLinked() : null;</span>
<span class="nc bnc" id="L6794" title="All 2 branches missed.">        AmmoType atype = ammo == null ? null : (AmmoType) ammo.getType();</span>

        // Leg and swarm attacks can't be aimed.
<span class="nc bnc" id="L6797" title="All 2 branches missed.">        if (wtype.getInternalName().equals(Infantry.LEG_ATTACK)</span>
<span class="nc bnc" id="L6798" title="All 2 branches missed.">                || wtype.getInternalName().equals(Infantry.SWARM_MEK)) {</span>
<span class="nc" id="L6799">            return false;</span>
        }
<span class="nc bnc" id="L6801" title="All 4 branches missed.">        switch (aimingMode) {</span>
            case (IAimingModes.AIM_MODE_NONE):
<span class="nc" id="L6803">                return false;</span>
            case (IAimingModes.AIM_MODE_IMMOBILE):
<span class="nc bnc" id="L6805" title="All 2 branches missed.">                if (weapon.getCurrentShots() &gt; 1) {</span>
<span class="nc" id="L6806">                    return false;</span>
                }
<span class="nc bnc" id="L6808" title="All 2 branches missed.">                if (atype == null) {</span>
<span class="nc" id="L6809">                    break;</span>
                }
<span class="nc bnc" id="L6811" title="All 2 branches missed.">                switch (atype.getAmmoType()) {</span>
                    case AmmoType.T_SRM_STREAK:
                    case AmmoType.T_LRM_STREAK:
                    case AmmoType.T_LRM:
                    case AmmoType.T_LRM_IMP:
                    case AmmoType.T_LRM_TORPEDO:
                    case AmmoType.T_SRM:
                    case AmmoType.T_SRM_IMP:
                    case AmmoType.T_SRM_TORPEDO:
                    case AmmoType.T_MRM:
                    case AmmoType.T_NARC:
                    case AmmoType.T_INARC:
                    case AmmoType.T_AMS:
                    case AmmoType.T_ARROW_IV:
                    case AmmoType.T_LONG_TOM:
                    case AmmoType.T_SNIPER:
                    case AmmoType.T_THUMPER:
                    case AmmoType.T_SRM_ADVANCED:
                    case AmmoType.T_LRM_TORPEDO_COMBO:
                    case AmmoType.T_ATM:
                    case AmmoType.T_IATM:
                    case AmmoType.T_MML:
                    case AmmoType.T_EXLRM:
                    case AmmoType.T_NLRM:
                    case AmmoType.T_TBOLT_5:
                    case AmmoType.T_TBOLT_10:
                    case AmmoType.T_TBOLT_15:
                    case AmmoType.T_TBOLT_20:
                    case AmmoType.T_PXLRM:
                    case AmmoType.T_HSRM:
                    case AmmoType.T_MRM_STREAK:
                    case AmmoType.T_HAG:
                    case AmmoType.T_ROCKET_LAUNCHER:
<span class="nc" id="L6844">                        return false;</span>
                }
<span class="nc bnc" id="L6846" title="All 2 branches missed.">                if (((atype.getAmmoType() == AmmoType.T_AC_LBX_THB)</span>
<span class="nc bnc" id="L6847" title="All 2 branches missed.">                        || (atype.getAmmoType() == AmmoType.T_AC_LBX)</span>
<span class="nc bnc" id="L6848" title="All 2 branches missed.">                        || (atype.getAmmoType() == AmmoType.T_SBGAUSS))</span>
<span class="nc bnc" id="L6849" title="All 2 branches missed.">                        &amp;&amp; (atype.getMunitionType() == AmmoType.M_CLUSTER)) {</span>
<span class="nc" id="L6850">                    return false;</span>
                }
                // Flak Ammo can't make aimed shots
<span class="nc bnc" id="L6853" title="All 2 branches missed.">                if (((atype.getAmmoType() == AmmoType.T_AC)</span>
<span class="nc bnc" id="L6854" title="All 2 branches missed.">                        || (atype.getAmmoType() == AmmoType.T_AC_ULTRA)</span>
<span class="nc bnc" id="L6855" title="All 2 branches missed.">                        || (atype.getAmmoType() == AmmoType.T_AC_ULTRA_THB))</span>
<span class="nc bnc" id="L6856" title="All 2 branches missed.">                        &amp;&amp; (atype.getMunitionType() == AmmoType.M_FLAK)) {</span>
<span class="nc" id="L6857">                    return false;</span>
                }

                break;
            case (IAimingModes.AIM_MODE_TARG_COMP):
<span class="nc bnc" id="L6862" title="All 2 branches missed.">                if (!wtype.hasFlag(WeaponType.F_DIRECT_FIRE)</span>
<span class="nc bnc" id="L6863" title="All 4 branches missed.">                        || wtype.hasFlag(WeaponType.F_PULSE)</span>
                        || (wtype instanceof HAGWeapon)) {
<span class="nc" id="L6865">                    return false;</span>
                }
<span class="nc bnc" id="L6867" title="All 2 branches missed.">                if (weapon.getCurrentShots() &gt; 1) {</span>
<span class="nc" id="L6868">                    return false;</span>
                }

<span class="nc bnc" id="L6871" title="All 2 branches missed.">                if ((atype != null)</span>
<span class="nc bnc" id="L6872" title="All 2 branches missed.">                        &amp;&amp; ((atype.getAmmoType() == AmmoType.T_AC_LBX_THB)</span>
<span class="nc bnc" id="L6873" title="All 2 branches missed.">                        || (atype.getAmmoType() == AmmoType.T_AC_LBX)</span>
<span class="nc bnc" id="L6874" title="All 2 branches missed.">                        || (atype.getAmmoType() == AmmoType.T_SBGAUSS))</span>
<span class="nc bnc" id="L6875" title="All 2 branches missed.">                        &amp;&amp; (atype.getMunitionType() == AmmoType.M_CLUSTER)) {</span>
<span class="nc" id="L6876">                    return false;</span>
                }

                // Flak Ammo can't make aimed shots
<span class="nc bnc" id="L6880" title="All 2 branches missed.">                if ((atype != null)</span>
<span class="nc bnc" id="L6881" title="All 2 branches missed.">                        &amp;&amp; ((atype.getAmmoType() == AmmoType.T_AC)</span>
<span class="nc bnc" id="L6882" title="All 2 branches missed.">                        || (atype.getAmmoType() == AmmoType.T_AC_ULTRA)</span>
<span class="nc bnc" id="L6883" title="All 2 branches missed.">                        || (atype.getAmmoType() == AmmoType.T_AC_ULTRA_THB))</span>
<span class="nc bnc" id="L6884" title="All 2 branches missed.">                        &amp;&amp; (atype.getMunitionType() == AmmoType.M_FLAK)) {</span>
<span class="nc" id="L6885">                    return false;</span>
                }
                break;
        }
<span class="nc" id="L6889">        return true;</span>
    }

    // Taken from MekHQ, assumptions are whatever Taharqa made for there - Dylan
    public static int getTotalGunnerNeeds(Entity entity) {
<span class="pc bpc" id="L6894" title="2 of 4 branches missed.">        if (entity instanceof SmallCraft || entity instanceof Jumpship) {</span>
<span class="fc" id="L6895">            int nStandardW = 0;</span>
<span class="fc" id="L6896">            int nCapitalW = 0;</span>
<span class="pc bpc" id="L6897" title="1 of 2 branches missed.">            for (Mounted m : entity.getTotalWeaponList()) {</span>
<span class="nc" id="L6898">                EquipmentType type = m.getType();</span>
<span class="nc bnc" id="L6899" title="All 2 branches missed.">                if (type instanceof BayWeapon) {</span>
<span class="nc" id="L6900">                    continue;</span>
                }
<span class="nc bnc" id="L6902" title="All 2 branches missed.">                if (type instanceof WeaponType) {</span>
<span class="nc bnc" id="L6903" title="All 2 branches missed.">                    if (((WeaponType) type).isCapital()) {</span>
<span class="nc" id="L6904">                        nCapitalW++;</span>
                    } else {
<span class="nc" id="L6906">                        nStandardW++;</span>
                    }
                }
<span class="nc" id="L6909">            }</span>
<span class="fc" id="L6910">            return nCapitalW + (int) Math.ceil(nStandardW / 6.0);</span>
<span class="nc bnc" id="L6911" title="All 2 branches missed.">        } else if (entity.isSupportVehicle()) {</span>
<span class="nc" id="L6912">            return getSupportVehicleGunnerNeeds(entity);</span>
<span class="nc bnc" id="L6913" title="All 2 branches missed.">        } else if (entity instanceof Tank) {</span>
<span class="nc" id="L6914">            return (getFullCrewSize(entity) - 1);</span>
<span class="nc bnc" id="L6915" title="All 2 branches missed.">        } else if (entity instanceof Infantry) {</span>
<span class="nc" id="L6916">            return getFullCrewSize(entity);</span>
<span class="nc bnc" id="L6917" title="All 2 branches missed.">        } else if (entity.getCrew().getCrewType().getGunnerPos() &gt; 0) {</span>
            //Tripod, QuadVee, or dual cockpit
<span class="nc" id="L6919">            return 1;</span>
        }
<span class="nc" id="L6921">        return 0;</span>
    }

    // Taken from MekHQ, assumptions are whatever Taharqa made for there - Dylan
    public static int getAeroCrewNeeds(Entity entity) {
<span class="pc bpc" id="L6926" title="1 of 2 branches missed.">        if (entity instanceof Dropship) {</span>
<span class="nc bnc" id="L6927" title="All 2 branches missed.">            if (((Dropship) entity).isMilitary()) {</span>
<span class="nc" id="L6928">                return 4 + (int) Math.ceil(entity.getWeight() / 5000.0);</span>
            } else {
<span class="nc" id="L6930">                return 3 + (int) Math.ceil(entity.getWeight() / 5000.0);</span>
            }
<span class="pc bpc" id="L6932" title="1 of 2 branches missed.">        } else if (entity instanceof SmallCraft) {</span>
<span class="nc" id="L6933">            return getTotalDriverNeeds(entity);</span>
<span class="pc bpc" id="L6934" title="2 of 4 branches missed.">        } else if (entity instanceof Warship || entity instanceof SpaceStation) {</span>
<span class="nc" id="L6935">            return 45 + (int) Math.ceil(entity.getWeight() / 5000.0);</span>
<span class="pc bpc" id="L6936" title="1 of 2 branches missed.">        } else if (entity instanceof Jumpship) {</span>
<span class="fc" id="L6937">            return 6 + (int) Math.ceil(entity.getWeight() / 20000.0);</span>
        }
<span class="nc" id="L6939">        return 0;</span>
    }

    /**
     * Calculates the base crew requirements for support vehicles.
     *
     * @param entity The support vehicle
     * @return The minimum base crew
     */
    public static int getSVBaseCrewNeeds(Entity entity) {
<span class="nc bnc" id="L6949" title="All 4 branches missed.">        if (entity.isTrailer() &amp;&amp; (entity.getEngine().getEngineType() == Engine.NONE)) {</span>
<span class="nc" id="L6950">            return 0;</span>
        }
<span class="nc bnc" id="L6952" title="All 2 branches missed.">        final boolean naval = entity.getMovementMode().equals(EntityMovementMode.NAVAL)</span>
<span class="nc bnc" id="L6953" title="All 2 branches missed.">                || entity.getMovementMode().equals(EntityMovementMode.HYDROFOIL)</span>
<span class="nc bnc" id="L6954" title="All 2 branches missed.">                || entity.getMovementMode().equals(EntityMovementMode.SUBMARINE);</span>
        int crew;
<span class="nc bnc" id="L6956" title="All 2 branches missed.">        if (entity.getWeightClass() == EntityWeightClass.WEIGHT_SMALL_SUPPORT) {</span>
<span class="nc" id="L6957">            crew = 1;</span>
<span class="nc bnc" id="L6958" title="All 2 branches missed.">        } else if (entity.getWeightClass() == EntityWeightClass.WEIGHT_MEDIUM_SUPPORT) {</span>
<span class="nc bnc" id="L6959" title="All 4 branches missed.">            if (naval || entity.getMovementMode().equals(EntityMovementMode.AIRSHIP)) {</span>
<span class="nc" id="L6960">                crew = 4;</span>
            } else {
<span class="nc" id="L6962">                crew = 2;</span>
            }
        } else {
<span class="nc" id="L6965">            crew = 3;</span>
<span class="nc bnc" id="L6966" title="All 2 branches missed.">            if (naval) {</span>
<span class="nc" id="L6967">                crew += (int) Math.ceil(entity.getWeight() / 5000);</span>
<span class="nc bnc" id="L6968" title="All 2 branches missed.">            } else if (entity.getMovementMode().equals(EntityMovementMode.AIRSHIP)) {</span>
<span class="nc" id="L6969">                crew += (int) Math.ceil(entity.getWeight() / 500);</span>
            }
        }
<span class="nc" id="L6972">        return crew;</span>
    }

    /**
     * Calculates number of gunners required for a support vehicle. See TM, 131.
     *
     * @param entity The support vehicle
     * @return The number of gunners required.
     */
    public static int getSupportVehicleGunnerNeeds(Entity entity) {
<span class="nc" id="L6982">        final boolean advFireCon = entity.hasMisc(MiscType.F_ADVANCED_FIRECONTROL);</span>
<span class="nc bnc" id="L6983" title="All 4 branches missed.">        final boolean basicFireCon = !advFireCon &amp;&amp; entity.hasMisc(MiscType.F_BASIC_FIRECONTROL);</span>
<span class="nc bnc" id="L6984" title="All 2 branches missed.">        if (entity.getWeightClass() == EntityWeightClass.WEIGHT_SMALL_SUPPORT) {</span>
<span class="nc bnc" id="L6985" title="All 4 branches missed.">            if (!advFireCon &amp;&amp; !basicFireCon) {</span>
                // No fire control requires one gunner per weapon.
<span class="nc" id="L6987">                return entity.getWeaponList().size();</span>
            } else {
                // Otherwise we require one gunner per facing, with turrets and pintle mounts counting
                // as separate facings
<span class="nc" id="L6991">                Set&lt;Integer&gt; facings = new HashSet&lt;&gt;();</span>
<span class="nc" id="L6992">                int pintles = 0;</span>
<span class="nc bnc" id="L6993" title="All 2 branches missed.">                for (Mounted m : entity.getWeaponList()) {</span>
<span class="nc bnc" id="L6994" title="All 2 branches missed.">                    if (m.isPintleTurretMounted()) {</span>
<span class="nc" id="L6995">                        pintles++;</span>
                    } else {
<span class="nc" id="L6997">                        facings.add(m.getLocation());</span>
                    }
<span class="nc" id="L6999">                }</span>
<span class="nc bnc" id="L7000" title="All 2 branches missed.">                if (advFireCon) {</span>
                    // Advanced fire control lets the driver count as a gunner, so one fewer dedicated gunners is needed.
<span class="nc" id="L7002">                    return Math.max(0, pintles + facings.size() - 1);</span>
                } else {
<span class="nc" id="L7004">                    return pintles + facings.size();</span>
                }
            }
        } else {
            // Medium and large support vehicle gunner requirements are based on weapon tonnage
<span class="nc bnc" id="L7009" title="All 2 branches missed.">            double tonnage = entity.getWeaponList().stream().filter(m -&gt; !m.getType().hasFlag(WeaponType.F_AMS))</span>
<span class="nc" id="L7010">                    .mapToDouble(m -&gt; m.getTonnage()).sum();</span>
<span class="nc bnc" id="L7011" title="All 2 branches missed.">            if (advFireCon) {</span>
<span class="nc bnc" id="L7012" title="All 2 branches missed.">                if (entity.getStructuralTechRating() == ITechnology.RATING_F) {</span>
<span class="nc" id="L7013">                    return (int) Math.ceil(tonnage / 6.0);</span>
<span class="nc bnc" id="L7014" title="All 2 branches missed.">                } else if (entity.getStructuralTechRating() == ITechnology.RATING_E) {</span>
<span class="nc" id="L7015">                    return (int) Math.ceil(tonnage / 5.0);</span>
                }
<span class="nc" id="L7017">                return (int) Math.ceil(tonnage / 4.0);</span>
<span class="nc bnc" id="L7018" title="All 2 branches missed.">            } else if (basicFireCon) {</span>
<span class="nc" id="L7019">                return (int) Math.ceil(tonnage / 3.0);</span>
            } else {
<span class="nc" id="L7021">                return (int) Math.ceil(tonnage / 2.0);</span>
            }
        }
    }

    /**
     * Calculates addiontal crew required by support vehicles and advanced aerospace vessels
     * for certain misc equipment.
     *
     * @param entity The unit
     * @return The number of additional crew required
     */
    public static int getAdditionalNonGunner(Entity entity) {
<span class="nc" id="L7034">        int crew = 0;</span>
<span class="nc bnc" id="L7035" title="All 2 branches missed.">        for (Mounted m : entity.getMisc()) {</span>
<span class="nc bnc" id="L7036" title="All 2 branches missed.">            if (m.getType().hasFlag(MiscType.F_COMMUNICATIONS)) {</span>
<span class="nc" id="L7037">                crew += (int) m.getTonnage();</span>
<span class="nc bnc" id="L7038" title="All 2 branches missed.">            } else if (m.getType().hasFlag(MiscType.F_FIELD_KITCHEN)) {</span>
<span class="nc" id="L7039">                crew += 3;</span>
<span class="nc bnc" id="L7040" title="All 2 branches missed.">            } else if (m.getType().hasFlag(MiscType.F_MOBILE_FIELD_BASE)) {</span>
<span class="nc" id="L7041">                crew += 5;</span>
<span class="nc bnc" id="L7042" title="All 2 branches missed.">            } else if (m.getType().hasFlag(MiscType.F_MASH)) {</span>
<span class="nc" id="L7043">                crew += 5 * (int) m.getSize();</span>
            }
<span class="nc" id="L7045">        }</span>
<span class="nc" id="L7046">        return crew;</span>
    }

    // Taken from MekHQ, assumptions are whatever Taharqa made for there - Dylan
    public static int getFullCrewSize(Entity entity) {
<span class="pc bpc" id="L7051" title="1 of 2 branches missed.">        if (entity.isSupportVehicle()) {</span>
<span class="nc" id="L7052">            int crew = getSVBaseCrewNeeds(entity) + getSupportVehicleGunnerNeeds(entity)</span>
<span class="nc" id="L7053">                    + getAdditionalNonGunner(entity);</span>
<span class="nc bnc" id="L7054" title="All 2 branches missed.">            if (crew &lt; 4) {</span>
<span class="nc" id="L7055">                return crew;</span>
            }
<span class="nc" id="L7057">            return crew + (int) Math.ceil(crew / 6.0);</span>
<span class="pc bpc" id="L7058" title="1 of 2 branches missed.">        } else if (entity instanceof Tank) {</span>
<span class="nc" id="L7059">            return (int) Math.ceil(entity.getWeight() / 15.0) + ((Tank) entity).getExtraCrewSeats();</span>
<span class="pc bpc" id="L7060" title="1 of 2 branches missed.">        } else if (entity instanceof BattleArmor) {</span>
<span class="nc" id="L7061">            int ntroopers = 0;</span>
<span class="nc bnc" id="L7062" title="All 2 branches missed.">            for (int trooper = 1; trooper &lt; entity.locations(); trooper++) {</span>
                //less than zero means the suit is destroyed
<span class="nc bnc" id="L7064" title="All 2 branches missed.">                if (entity.getInternal(trooper) &gt;= 0) {</span>
                    //Also, if any modular equipment is missing, then we will consider this
                    //unit to be inoperable and will not allow it to load soldiers. This is because
                    //we have no mechanism in MM to handle BA where some suits have the equipment
                    //and others do not
<span class="nc" id="L7069">                    boolean useSuit = true;</span>
<span class="nc bnc" id="L7070" title="All 2 branches missed.">                    for (Mounted m : entity.getEquipment()) {</span>
<span class="nc bnc" id="L7071" title="All 2 branches missed.">                        if (m.isMissingForTrooper(trooper)) {</span>
<span class="nc" id="L7072">                            useSuit = false;</span>
<span class="nc" id="L7073">                            break;</span>
                        }
<span class="nc" id="L7075">                    }</span>
<span class="nc bnc" id="L7076" title="All 2 branches missed.">                    if (useSuit) {</span>
<span class="nc" id="L7077">                        ntroopers++;</span>
                    }
                }
            }
<span class="nc" id="L7081">            return ntroopers;</span>
<span class="pc bpc" id="L7082" title="1 of 2 branches missed.">        } else if (entity instanceof Infantry) {</span>
<span class="nc" id="L7083">            return ((Infantry) entity).getSquadN() * ((Infantry) entity).getSquadSize();</span>
<span class="pc bpc" id="L7084" title="1 of 4 branches missed.">        } else if (entity instanceof Jumpship || entity instanceof SmallCraft) {</span>
<span class="fc" id="L7085">            return getAeroCrewNeeds(entity) + getTotalGunnerNeeds(entity);</span>
        } else {
<span class="fc" id="L7087">            return 1;</span>
        }
    }

    // Taken from MekHQ, assumptions are whatever Taharqa made for there - Dylan
    public static int getTotalDriverNeeds(Entity entity) {
        //Fix for MHQ Bug #3. Space stations have as much need for pilots as jumpships do.
<span class="nc bnc" id="L7094" title="All 2 branches missed.">        if (entity instanceof SpaceStation) {</span>
<span class="nc" id="L7095">            return 2;</span>
        }
<span class="nc bnc" id="L7097" title="All 4 branches missed.">        if (entity instanceof SmallCraft || entity instanceof Jumpship) {</span>
            //its not at all clear how many pilots dropships and jumpships
            //should have, but the old BattleSpace book suggests they should
            //be able to get by with 2. For warships, lets go with 2 per shift
            // so 6.
<span class="nc bnc" id="L7102" title="All 2 branches missed.">            if (entity instanceof Warship) {</span>
<span class="nc" id="L7103">                return 6;</span>
            }
<span class="nc bnc" id="L7105" title="All 2 branches missed.">            if (entity instanceof SmallCraft) {</span>
<span class="nc" id="L7106">                return 3;</span>
            }
<span class="nc" id="L7108">            return 2;</span>
        }
<span class="nc bnc" id="L7110" title="All 2 branches missed.">        if (entity.getCrew().getCrewType() == CrewType.COMMAND_CONSOLE) {</span>
<span class="nc" id="L7111">            return 2;</span>
        }
<span class="nc bnc" id="L7113" title="All 8 branches missed.">        if (entity instanceof Mech || entity instanceof Tank || entity instanceof Aero || entity instanceof Protomech) {</span>
            //only one driver please
<span class="nc" id="L7115">            return 1;</span>
<span class="nc bnc" id="L7116" title="All 2 branches missed.">        } else if (entity instanceof Infantry) {</span>
<span class="nc" id="L7117">            return getFullCrewSize(entity);</span>
        }
<span class="nc" id="L7119">        return 0;</span>
    }

    /**
     * Should we treat this entity, in its current state, as if it is a spheroid unit
     * flying in atmosphere?
     */
    public static boolean useSpheroidAtmosphere(IGame game, Entity en) {
<span class="pc bpc" id="L7127" title="1 of 2 branches missed.">        if (!en.isAero()) {</span>
<span class="nc" id="L7128">            return false;</span>
        }
        // are we in space?
<span class="pc bpc" id="L7131" title="1 of 2 branches missed.">        if (game.getBoard().inSpace()) {</span>
<span class="nc" id="L7132">            return false;</span>
        }
        // aerodyne's will operate like spheroids in vacuum
<span class="pc bpc" id="L7135" title="1 of 2 branches missed.">        if (!((IAero) en).isSpheroid()</span>
<span class="pc bpc" id="L7136" title="1 of 2 branches missed.">                &amp;&amp; !game.getPlanetaryConditions().isVacuum()) {</span>
<span class="fc" id="L7137">            return false;</span>
        }
        // are we in atmosphere?
<span class="nc" id="L7140">        return en.isAirborne();</span>
    }

} // End public class Compute
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.4.201905082037</span></div></body></html>