<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BoardView1.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">megamek</a> &gt; <a href="index.source.html" class="el_package">megamek.client.ui.swing.boardview</a> &gt; <span class="el_source">BoardView1.java</span></div><h1>BoardView1.java</h1><pre class="source lang-java linenums">/*
 * MegaMek -
 * Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 Ben Mazur (bmazur@sev.org)
 * Copyright (C) 2018-2021 - The MegaMek Team. All Rights Reserved.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation; either version 2 of the License, or (at your option) any later
 * version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 */
package megamek.client.ui.swing.boardview;

import megamek.MegaMek;
import megamek.client.TimerSingleton;
import megamek.client.bot.princess.BotGeometry.ConvexBoardArea;
import megamek.client.bot.princess.PathEnumerator;
import megamek.client.bot.princess.Princess;
import megamek.client.event.BoardViewEvent;
import megamek.client.event.BoardViewListener;
import megamek.client.event.MechDisplayEvent;
import megamek.client.ui.IBoardView;
import megamek.client.ui.IDisplayable;
import megamek.client.ui.Messages;
import megamek.client.ui.SharedUtility;
import megamek.client.ui.swing.ChatterBox2;
import megamek.client.ui.swing.ClientGUI;
import megamek.client.ui.swing.GUIPreferences;
import megamek.client.ui.swing.MovementDisplay;
import megamek.client.ui.swing.tileset.HexTileset;
import megamek.client.ui.swing.tileset.TilesetManager;
import megamek.client.ui.swing.util.CommandAction;
import megamek.client.ui.swing.util.ImageCache;
import megamek.client.ui.swing.util.KeyCommandBind;
import megamek.client.ui.swing.util.MegaMekController;
import megamek.client.ui.swing.widget.MegamekBorder;
import megamek.client.ui.swing.widget.SkinSpecification;
import megamek.client.ui.swing.widget.SkinXMLHandler;
import megamek.common.*;
import megamek.common.Building.BasementType;
import megamek.common.IGame.Phase;
import megamek.common.MovePath.MoveStepType;
import megamek.common.actions.*;
import megamek.common.event.*;
import megamek.common.logging.LogLevel;
import megamek.common.options.GameOptions;
import megamek.common.options.OptionsConstants;
import megamek.common.pathfinder.BoardClusterTracker;
import megamek.common.pathfinder.BoardClusterTracker.BoardCluster;
import megamek.common.preference.IClientPreferences;
import megamek.common.preference.IPreferenceChangeListener;
import megamek.common.preference.PreferenceChangeEvent;
import megamek.common.preference.PreferenceManager;
import megamek.common.util.FiringSolution;
import megamek.common.util.ImageUtil;
import megamek.common.util.fileUtils.MegaMekFile;

import javax.imageio.ImageIO;
import javax.swing.*;
import javax.swing.plaf.metal.DefaultMetalTheme;
import javax.swing.plaf.metal.MetalTheme;
import java.awt.*;
import java.awt.event.*;
import java.awt.font.GlyphVector;
import java.awt.geom.AffineTransform;
import java.awt.geom.Path2D;
import java.awt.geom.Point2D;
import java.awt.image.*;
import java.io.File;
import java.util.List;
import java.util.Queue;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Displays the board; lets the user scroll around and select points on it.
 */
public class BoardView1 extends JPanel implements IBoardView, Scrollable,
        BoardListener, MouseListener, IPreferenceChangeListener {

    // the dimensions of megamek's hex images
    public static final int HEX_W = HexTileset.HEX_W;
    public static final int HEX_H = HexTileset.HEX_H;
<span class="fc" id="L88">    public static final int HEX_DIAG = (int) Math.round(Math.sqrt(HEX_W * HEX_W + HEX_H * HEX_H));</span>
<span class="fc" id="L89">    public static final int[] allDirections = {0, 1, 2, 3, 4, 5};</span>
    static final int HEX_ELEV = 12;
    // the index of zoom factor 1.00f
    static final int BASE_ZOOM_INDEX = 7;
    // line width of the c3 network lines
    static final int C3_LINE_WIDTH = 1;
    // line width of the fly over lines
    static final int FLY_OVER_LINE_WIDTH = 3;
    private static final long serialVersionUID = -5582195884759007416L;
    private static final int BOARD_HEX_CLICK = 1;
    private static final int BOARD_HEX_DOUBLECLICK = 2;
    private static final int BOARD_HEX_DRAG = 3;
    private static final int BOARD_HEX_POPUP = 4;
    private static final int HEX_WC = HEX_W - (HEX_W / 4);
<span class="fc" id="L103">    private static final float[] ZOOM_FACTORS = {0.30f, 0.41f, 0.50f, 0.60f,</span>
            0.68f, 0.79f, 0.90f, 1.00f, 1.09f, 1.17f, 1.3f};
<span class="fc" id="L105">    private static final int[] ZOOM_SCALE_TYPES = {</span>
            ImageUtil.IMAGE_SCALE_AVG_FILTER, ImageUtil.IMAGE_SCALE_AVG_FILTER,
            ImageUtil.IMAGE_SCALE_BICUBIC, ImageUtil.IMAGE_SCALE_BICUBIC,
            ImageUtil.IMAGE_SCALE_BICUBIC, ImageUtil.IMAGE_SCALE_BICUBIC,
            ImageUtil.IMAGE_SCALE_BICUBIC, ImageUtil.IMAGE_SCALE_BICUBIC,
            ImageUtil.IMAGE_SCALE_BICUBIC, ImageUtil.IMAGE_SCALE_BICUBIC,
            ImageUtil.IMAGE_SCALE_BICUBIC};
    // FIXME : Fonts shouldn't ever be handled like this for accessibility reasons
    private static final String SansSerif = &quot;SansSerif&quot;;
<span class="fc" id="L114">    private static final Font FONT_7 = new Font(SansSerif, Font.PLAIN, 7);</span>
<span class="fc" id="L115">    private static final Font FONT_8 = new Font(SansSerif, Font.PLAIN, 8);</span>
<span class="fc" id="L116">    private static final Font FONT_9 = new Font(SansSerif, Font.PLAIN, 9);</span>
<span class="fc" id="L117">    private static final Font FONT_10 = new Font(SansSerif, Font.PLAIN, 10);</span>
<span class="fc" id="L118">    private static final Font FONT_12 = new Font(SansSerif, Font.PLAIN, 12);</span>
<span class="fc" id="L119">    private static final String[] rangeTexts = {&quot;min&quot;, &quot;S&quot;, &quot;M&quot;, &quot;L&quot;, &quot;E&quot;};</span>
<span class="fc" id="L120">    private static final Kernel kernel = new Kernel(5, 5,</span>
            new float[]{
                    1f / 25f, 1f / 25f, 1f / 25f, 1f / 25f, 1f / 25f,
                    1f / 25f, 1f / 25f, 1f / 25f, 1f / 25f, 1f / 25f,
                    1f / 25f, 1f / 25f, 1f / 25f, 1f / 25f, 1f / 25f,
                    1f / 25f, 1f / 25f, 1f / 25f, 1f / 25f, 1f / 25f,
                    1f / 25f, 1f / 25f, 1f / 25f, 1f / 25f, 1f / 25f});
<span class="fc" id="L127">    private static final BufferedImageOp blurOp = new ConvolveOp(kernel);</span>
    private static final int FRAMES = 24;
    /**
     * Speed of soft centering of the board, less is faster
     */
    private static final int SOFT_CENTER_SPEED = 8;
    // polygons for a few things
    static Polygon hexPoly;

    static {
        // hex polygon
<span class="fc" id="L138">        hexPoly = new Polygon();</span>
<span class="fc" id="L139">        hexPoly.addPoint(21, 0);</span>
<span class="fc" id="L140">        hexPoly.addPoint(62, 0);</span>
<span class="fc" id="L141">        hexPoly.addPoint(83, 35);</span>
<span class="fc" id="L142">        hexPoly.addPoint(83, 36);</span>
<span class="fc" id="L143">        hexPoly.addPoint(62, 71);</span>
<span class="fc" id="L144">        hexPoly.addPoint(21, 71);</span>
<span class="fc" id="L145">        hexPoly.addPoint(0, 36);</span>
<span class="fc" id="L146">        hexPoly.addPoint(0, 35);</span>
<span class="fc" id="L147">    }</span>

    public final IGame game;
<span class="fc" id="L150">    protected final RedrawWorker redrawWorker = new RedrawWorker();</span>
<span class="fc" id="L151">    private final Font font_note = FONT_10;</span>
<span class="fc" id="L152">    private final ArrayList&lt;FlareSprite&gt; flareSprites = new ArrayList&lt;&gt;();</span>
    // sprites for the three selection cursors
    private final CursorSprite cursorSprite;
    private final CursorSprite highlightSprite;
    private final CursorSprite selectedSprite;
    private final CursorSprite firstLOSSprite;
    private final CursorSprite secondLOSSprite;
<span class="fc" id="L159">    private final ArrayList&lt;Coords&gt; strafingCoords = new ArrayList&lt;&gt;(5);</span>
<span class="fc" id="L160">    private final ArrayList&lt;FiringSolutionSprite&gt; firingSprites = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L161">    private final ArrayList&lt;MovementEnvelopeSprite&gt; moveEnvSprites = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L162">    private final ArrayList&lt;MovementModifierEnvelopeSprite&gt; moveModEnvSprites = new ArrayList&lt;&gt;();</span>
    // vector of sprites for all movement paths (using vectored movement)
<span class="fc" id="L164">    private final ArrayList&lt;MovementSprite&gt; movementSprites = new ArrayList&lt;&gt;();</span>
    // vector of sprites for C3 network lines
<span class="fc" id="L166">    private final ArrayList&lt;C3Sprite&gt; c3Sprites = new ArrayList&lt;&gt;();</span>
    // list of sprites for declared VTOL/airmech bombing/strafing targets
<span class="fc" id="L168">    private final ArrayList&lt;VTOLAttackSprite&gt; vtolAttackSprites = new ArrayList&lt;&gt;();</span>
    // vector of sprites for aero flyover lines
<span class="fc" id="L170">    private final ArrayList&lt;FlyOverSprite&gt; flyOverSprites = new ArrayList&lt;&gt;();</span>
    // List of sprites for the weapon field of fire
<span class="fc" id="L172">    private final ArrayList&lt;HexSprite&gt; fieldofFireSprites = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L173">    private final ImageCache&lt;Integer, BufferedImage&gt; shadowImageCache = new ImageCache&lt;&gt;();</span>
<span class="fc" id="L174">    private final Set&lt;Integer&gt; animatedImages = new HashSet&lt;&gt;();</span>
    // Move units step by step
<span class="fc" id="L176">    private final ArrayList&lt;MovingUnit&gt; movingUnits = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L177">    private final ArrayList&lt;GhostEntitySprite&gt; ghostEntitySprites = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L178">    private final Font fpsFont = new Font(SansSerif, 0, 20); //$NON-NLS-1$</span>
<span class="fc" id="L179">    private final String FILENAME_FLARE_IMAGE = &quot;flare.png&quot;;</span>
<span class="fc" id="L180">    private final String FILENAME_RADAR_BLIP_IMAGE = &quot;radarBlip.png&quot;;</span>
    private final Image flareImage;
    private final Image radarBlipImage;
    /**
     * The final position of a soft centering relative to board size (x, y=0...1).
     */
<span class="fc" id="L186">    private final Point2D softCenterTarget = new Point2D.Double();</span>
    /**
     * Stores the correct tooltip dismiss delay so it can be restored when exiting the boardview
     */
<span class="fc" id="L190">    private final int dismissDelay = ToolTipManager.sharedInstance().getDismissDelay();</span>
    // Initial zoom index
<span class="fc" id="L192">    public int zoomIndex = BASE_ZOOM_INDEX;</span>
<span class="fc" id="L193">    public int[][] fieldofFireRanges = {new int[5], new int[5]};</span>
    public int fieldofFireWpArc;
    public Entity fieldofFireUnit;
    public int fieldofFireWpLoc;
    // int because it acts as an array index
<span class="fc" id="L198">    public int fieldofFireWpUnderwater = 0;</span>
    /**
     * Keeps track of whether all deployment zones should
     * be shown in the Arty Auto Hit Designation phase
     */
<span class="fc" id="L203">    public boolean showAllDeployment = false;</span>
<span class="fc" id="L204">    protected transient ArrayList&lt;BoardViewListener&gt; boardListeners = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L205">    int DROPSHDW_DIST = 20;</span>
    Dimension hex_size;
    ClientGUI clientgui;
    // sprite for current movement
<span class="fc" id="L209">    ArrayList&lt;StepSprite&gt; pathSprites = new ArrayList&lt;&gt;();</span>
    // vector of sprites for all firing lines
<span class="fc" id="L211">    ArrayList&lt;AttackSprite&gt; attackSprites = new ArrayList&lt;&gt;();</span>
    TilesetManager tileManager;
    Shape[] movementPolys;
    Shape[] facingPolys;
    Shape[] finalFacingPolys;
    Shape upArrow;
    Shape downArrow;
    // Image to hold the complete board shadow map
    BufferedImage shadowMap;
<span class="fc" id="L220">    double[] lightDirection = {-19, 7};</span>
    // Initial scale factor for sprites and map
<span class="fc" id="L222">    float scale = 1.00f;</span>
    // Displayables (Chat box, etc.)
<span class="fc" id="L224">    ArrayList&lt;IDisplayable&gt; displayables = new ArrayList&lt;&gt;();</span>
    Coords selected;
    // selected entity and weapon for artillery display
<span class="fc" id="L227">    Entity selectedEntity = null;</span>
<span class="fc" id="L228">    BufferedImage bvBgImage = null;</span>
<span class="fc" id="L229">    boolean bvBgShouldTile = false;</span>
<span class="fc" id="L230">    BufferedImage scrollPaneBgBuffer = null;</span>
<span class="fc" id="L231">    Image scrollPaneBgImg = null;</span>
<span class="fc" id="L232">    List&lt;Image&gt; boardBackgrounds = new ArrayList&lt;&gt;();</span>
    FovHighlightingAndDarkening fovHighlightingAndDarkening;
    /**
     * Cache that stores hex images for different coords
     */
    ImageCache&lt;Coords, HexImageCacheEntry&gt; hexImageCache;
    // Used to track the previous x/y for tooltip display
<span class="fc" id="L239">    int prevTipX = -1, prevTipY = -1;</span>
    /**
     * Flag to indicate if we should display informatin about illegal terrain in hexes.
     */
<span class="fc" id="L243">    boolean displayInvalidHexInfo = false;</span>
    /**
     * A map overlay showing some important keybinds.
     */
    KeyBindingsOverlay keybindOverlay;
<span class="fc" id="L248">    AbstractAction DoNothing = new AbstractAction() {</span>
        private static final long serialVersionUID = 5944877465265121983L;

        @Override
        public void actionPerformed(ActionEvent e) {
<span class="nc" id="L253">        }</span>
    };
    // Set to TRUE to draw hexes with isometric elevation.
<span class="fc" id="L256">    private boolean drawIsometric = GUIPreferences.getInstance().getIsometricEnabled();</span>
<span class="fc" id="L257">    private Font font_hexnum = FONT_10;</span>
<span class="fc" id="L258">    private Font font_elev = FONT_9;</span>
<span class="fc" id="L259">    private Font font_minefield = FONT_12;</span>
    private Dimension boardSize;
<span class="fc" id="L261">    private Dimension preferredSize = new Dimension(0, 0);</span>
    // scrolly stuff:
<span class="fc" id="L263">    private JScrollPane scrollpane = null;</span>
    private JScrollBar vbar;
    private JScrollBar hbar;
<span class="fc" id="L266">    private int scrollXDifference = 0;</span>
<span class="fc" id="L267">    private int scrollYDifference = 0;</span>
    // are we drag-scrolling?
<span class="fc" id="L269">    private boolean dragging = false;</span>
    /**
     * True when the right mouse button was pressed to start a drag
     */
<span class="fc" id="L273">    private boolean shouldScroll = false;</span>
    // entity sprites
<span class="fc" id="L275">    private Queue&lt;EntitySprite&gt; entitySprites = new PriorityQueue&lt;&gt;();</span>
<span class="fc" id="L276">    private Queue&lt;IsometricSprite&gt; isometricSprites = new PriorityQueue&lt;&gt;();</span>
    /**
     * A Map that maps an Entity ID and a secondary position to a Sprite. Note
     * that the key is a List where the first entry will be the Entity ID and
     * the second entry will be which secondary position the sprite belongs to;
     * if the Entity has no secondary positions, the first element will be the
     * ID and the second element will be -1.
     */
<span class="fc" id="L284">    private Map&lt;List&lt;Integer&gt;, EntitySprite&gt; entitySpriteIds = new HashMap&lt;&gt;();</span>
    /**
     * A Map that maps an Entity ID and a secondary position to a Sprite. Note
     * that the key is a List where the first entry will be the Entity ID and
     * the second entry will be which secondary position the sprite belongs to;
     * if the Entity has no secondary positions, the first element will be the
     * ID and the second element will be -1.
     */
<span class="fc" id="L292">    private Map&lt;List&lt;Integer&gt;, IsometricSprite&gt; isometricSpriteIds = new HashMap&lt;&gt;();</span>
    // the player who owns this BoardView's client
<span class="fc" id="L294">    private IPlayer localPlayer = null;</span>
    /**
     * Stores the currently deploying entity, used for highlighting deployment
     * hexes.
     */
<span class="fc" id="L299">    private Entity en_Deployer = null;</span>
    // should be able to turn it off(board editor)
<span class="fc" id="L301">    private boolean useLOSTool = true;</span>
<span class="fc" id="L302">    private ImageCache&lt;Integer, Image&gt; scaledImageCache = new ImageCache&lt;&gt;();</span>
<span class="fc" id="L303">    private long moveWait = 0;</span>
    // moving entity sprites
<span class="fc" id="L305">    private List&lt;MovingEntitySprite&gt; movingEntitySprites = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L306">    private HashMap&lt;Integer, MovingEntitySprite&gt; movingEntitySpriteIds = new HashMap&lt;&gt;();</span>
    // wreck sprites
<span class="fc" id="L308">    private ArrayList&lt;WreckSprite&gt; wreckSprites = new ArrayList&lt;WreckSprite&gt;();</span>
<span class="fc" id="L309">    private ArrayList&lt;IsometricWreckSprite&gt; isometricWreckSprites = new ArrayList&lt;&gt;();</span>
    private Coords rulerStart;
    private Coords rulerEnd;
    private Color rulerStartColor;
    private Color rulerEndColor;
    private Coords lastCursor;
    private Coords highlighted;
    private Coords firstLOS;
    /**
     * stores the theme last selected to override all hex themes
     */
<span class="fc" id="L320">    private String selectedTheme = null;</span>
<span class="fc" id="L321">    private Mounted selectedWeapon = null;</span>
    // hexes with ECM effect
<span class="fc" id="L323">    private Map&lt;Coords, Color&gt; ecmHexes = null;</span>
    // hexes that are teh centers of ECM effects
<span class="fc" id="L325">    private Map&lt;Coords, Color&gt; ecmCenters = null;</span>
    // hexes with ECM effect
<span class="fc" id="L327">    private Map&lt;Coords, Color&gt; eccmHexes = null;</span>
    // hexes that are teh centers of ECCM effects
<span class="fc" id="L329">    private Map&lt;Coords, Color&gt; eccmCenters = null;</span>

    // Soft Centering ---
    // reference to our timertask for redraw
<span class="fc" id="L333">    private TimerTask ourTask = null;</span>
    private long totalTime;
    private long averageTime;
    private int frameCount;
    /**
     * Keeps track of whether we have an active ChatterBox2
     */
<span class="fc" id="L340">    private boolean chatterBoxActive = false;</span>

    // Tooltip Info ---
    /**
     * Keeps track of whether an outside source tells the BoardView that it
     * should ignore keyboard commands.
     */
<span class="fc" id="L347">    private boolean shouldIgnoreKeys = false;</span>
    private long paintCompsStartTime;
<span class="fc" id="L349">    private Rectangle displayablesRect = new Rectangle();</span>
    /**
     * True when the board is in the process of centering to a spot.
     */
<span class="fc" id="L353">    private boolean isSoftCentering = false;</span>
<span class="fc" id="L354">    private Point2D oldCenter = new Point2D.Double();</span>
    private long waitTimer;
<span class="fc" id="L356">    private final GameListener gameListener = new GameListenerAdapter() {</span>

        @Override
        public void gameEntityNew(GameEntityNewEvent e) {
<span class="nc" id="L360">            updateEcmList();</span>
<span class="nc" id="L361">            redrawAllEntities();</span>
<span class="nc bnc" id="L362" title="All 2 branches missed.">            if (game.getPhase() == IGame.Phase.PHASE_MOVEMENT) {</span>
<span class="nc" id="L363">                refreshMoveVectors();</span>
            }
<span class="nc" id="L365">        }</span>

        @Override
        public void gameEntityRemove(GameEntityRemoveEvent e) {
<span class="nc" id="L369">            updateEcmList();</span>
<span class="nc" id="L370">            redrawAllEntities();</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">            if (game.getPhase() == IGame.Phase.PHASE_MOVEMENT) {</span>
<span class="nc" id="L372">                refreshMoveVectors();</span>
            }
<span class="nc" id="L374">        }</span>

        @Override
        public void gameEntityChange(GameEntityChangeEvent e) {
<span class="nc" id="L378">            final Vector&lt;UnitLocation&gt; mp = e.getMovePath();</span>
<span class="nc" id="L379">            final Entity en = e.getEntity();</span>
<span class="nc" id="L380">            final GameOptions gopts = game.getOptions();</span>
<span class="nc" id="L381">            GUIPreferences guip = GUIPreferences.getInstance();</span>

<span class="nc" id="L383">            updateEcmList();</span>

            //For Entities that have converted to another mode, check for a different sprite
<span class="nc bnc" id="L386" title="All 2 branches missed.">            if (game.getPhase() == IGame.Phase.PHASE_MOVEMENT</span>
<span class="nc bnc" id="L387" title="All 2 branches missed.">                    &amp;&amp; en.isConvertingNow()) {</span>
<span class="nc" id="L388">                tileManager.reloadImage(en);</span>
            }

            // for units that have been blown up, damaged or ejected, force a reload
<span class="nc bnc" id="L392" title="All 2 branches missed.">            if ((e.getOldEntity() != null) &amp;&amp;</span>
<span class="nc bnc" id="L393" title="All 2 branches missed.">                    ((en.getDamageLevel() != e.getOldEntity().getDamageLevel()) ||</span>
<span class="nc bnc" id="L394" title="All 2 branches missed.">                            (en.isDestroyed() != e.getOldEntity().isDestroyed()) ||</span>
<span class="nc bnc" id="L395" title="All 2 branches missed.">                            (en.getCrew().isEjected() != e.getOldEntity().getCrew().isEjected()))) {</span>
<span class="nc" id="L396">                tileManager.reloadImage(en);</span>
            }

<span class="nc" id="L399">            redrawAllEntities();</span>
<span class="nc bnc" id="L400" title="All 2 branches missed.">            if (game.getPhase() == IGame.Phase.PHASE_MOVEMENT) {</span>
<span class="nc" id="L401">                refreshMoveVectors();</span>
            }
<span class="nc bnc" id="L403" title="All 6 branches missed.">            if ((mp != null) &amp;&amp; (mp.size() &gt; 0) &amp;&amp; guip.getShowMoveStep()</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">                    &amp;&amp; !gopts.booleanOption(OptionsConstants.INIT_SIMULTANEOUS_MOVEMENT)) {</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">                if ((localPlayer == null)</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">                        || !game.getOptions().booleanOption(OptionsConstants.ADVANCED_DOUBLE_BLIND)</span>
<span class="nc bnc" id="L407" title="All 2 branches missed.">                        || !en.getOwner().isEnemyOf(localPlayer)</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">                        || en.hasSeenEntity(localPlayer)) {</span>
<span class="nc" id="L409">                    addMovingUnit(en, mp);</span>
                }
            }
<span class="nc" id="L412">        }</span>

        @Override
        public void gameNewAction(GameNewActionEvent e) {
<span class="nc" id="L416">            EntityAction ea = e.getAction();</span>
<span class="nc bnc" id="L417" title="All 2 branches missed.">            if (ea instanceof AttackAction) {</span>
<span class="nc" id="L418">                addAttack((AttackAction) ea);</span>
            }
<span class="nc" id="L420">        }</span>

        @Override
        public void gameBoardNew(GameBoardNewEvent e) {
<span class="nc" id="L424">            IBoard b = e.getOldBoard();</span>
<span class="nc bnc" id="L425" title="All 2 branches missed.">            if (b != null) {</span>
<span class="nc" id="L426">                b.removeBoardListener(BoardView1.this);</span>
            }
<span class="nc" id="L428">            b = e.getNewBoard();</span>
<span class="nc bnc" id="L429" title="All 4 branches missed.">            if (b == null || !b.hasBoardBackground()) {</span>
<span class="nc" id="L430">                clearHexImageCache();</span>
<span class="nc" id="L431">                updateBoard();</span>
<span class="nc" id="L432">                clearShadowMap();</span>
<span class="nc" id="L433">                return;</span>
            }
<span class="nc" id="L435">            b.addBoardListener(BoardView1.this);</span>
<span class="nc" id="L436">            boardBackgrounds.clear();</span>
<span class="nc" id="L437">            ListIterator&lt;Boolean&gt; flipItHoriz = b.getFlipBGHoriz()</span>
<span class="nc" id="L438">                    .listIterator();</span>
<span class="nc" id="L439">            ListIterator&lt;Boolean&gt; flipItVert = b.getFlipBGVert()</span>
<span class="nc" id="L440">                    .listIterator();</span>
<span class="nc bnc" id="L441" title="All 2 branches missed.">            for (String path : b.getBackgroundPaths()) {</span>
<span class="nc" id="L442">                boolean flipHoriz = flipItHoriz.next();</span>
<span class="nc" id="L443">                boolean flipVert = flipItVert.next();</span>
<span class="nc bnc" id="L444" title="All 2 branches missed.">                if (path == null) {</span>
<span class="nc" id="L445">                    boardBackgrounds.add(null);</span>
<span class="nc" id="L446">                    continue;</span>
                }
<span class="nc" id="L448">                Image bgImg = ImageUtil.loadImageFromFile(path);</span>
<span class="nc" id="L449">                ImageProducer prod = bgImg.getSource();</span>
<span class="nc bnc" id="L450" title="All 4 branches missed.">                if (flipHoriz || flipVert) {</span>
<span class="nc" id="L451">                    AffineTransform at = new AffineTransform();</span>

<span class="nc bnc" id="L453" title="All 2 branches missed.">                    if (flipHoriz) {</span>
<span class="nc" id="L454">                        at.concatenate(AffineTransform</span>
<span class="nc" id="L455">                                .getScaleInstance(1, -1));</span>
                    }
<span class="nc bnc" id="L457" title="All 2 branches missed.">                    if (flipVert) {</span>
<span class="nc" id="L458">                        at.concatenate(AffineTransform</span>
<span class="nc" id="L459">                                .getTranslateInstance(0,</span>
<span class="nc" id="L460">                                        -bgImg.getHeight(null)));</span>
                    }
<span class="nc" id="L462">                    ((Graphics2D) bgImg.getGraphics()).setTransform(at);</span>
                }
<span class="nc" id="L464">                boardBackgrounds.add(Toolkit.getDefaultToolkit()</span>
<span class="nc" id="L465">                        .createImage(prod));</span>
<span class="nc" id="L466">            }</span>
<span class="nc" id="L467">            clearHexImageCache();</span>
<span class="nc" id="L468">            updateBoard();</span>
<span class="nc" id="L469">            clearShadowMap();</span>
<span class="nc" id="L470">        }</span>

        @Override
        public void gameBoardChanged(GameBoardChangeEvent e) {
<span class="nc" id="L474">            clearHexImageCache();</span>
<span class="nc" id="L475">            boardChanged();</span>
<span class="nc" id="L476">        }</span>

        @Override
        public void gamePhaseChange(GamePhaseChangeEvent e) {
<span class="nc bnc" id="L480" title="All 4 branches missed.">            if (GUIPreferences.getInstance().getGameSummaryBoardView() &amp;&amp; ((e.getOldPhase() == Phase.PHASE_DEPLOYMENT)</span>
<span class="nc bnc" id="L481" title="All 4 branches missed.">                    || (e.getOldPhase() == Phase.PHASE_MOVEMENT) || (e.getOldPhase() == Phase.PHASE_TARGETING)</span>
<span class="nc bnc" id="L482" title="All 4 branches missed.">                    || (e.getOldPhase() == Phase.PHASE_FIRING) || (e.getOldPhase() == Phase.PHASE_PHYSICAL))) {</span>
<span class="nc" id="L483">                File dir = new File(Configuration.gameSummaryImagesBVDir(), game.getUUIDString());</span>
<span class="nc bnc" id="L484" title="All 2 branches missed.">                if (!dir.exists()) {</span>
<span class="nc" id="L485">                    dir.mkdirs();</span>
                }
<span class="nc" id="L487">                File imgFile = new File(dir, &quot;round_&quot; + game.getRoundCount() + &quot;_&quot; + e.getOldPhase().ordinal() + &quot;_&quot;</span>
<span class="nc" id="L488">                        + IGame.Phase.getDisplayableName(e.getOldPhase()) + &quot;.png&quot;);</span>
                try {
<span class="nc" id="L490">                    ImageIO.write(getEntireBoardImage(false), &quot;png&quot;, imgFile);</span>
<span class="nc" id="L491">                } catch (Exception ex) {</span>
<span class="nc" id="L492">                    MegaMek.getLogger().error(ex);</span>
<span class="nc" id="L493">                }</span>
            }

<span class="nc" id="L496">            refreshAttacks();</span>

            // Clear some information regardless of what phase it is
<span class="nc" id="L499">            clearFiringSolutionData();</span>
<span class="nc" id="L500">            clearMovementEnvelope();</span>

<span class="nc bnc" id="L502" title="All 7 branches missed.">            switch (e.getNewPhase()) {</span>
                case PHASE_MOVEMENT:
<span class="nc" id="L504">                    refreshMoveVectors();</span>
                case PHASE_FIRING:
<span class="nc" id="L506">                    clearAllMoveVectors();</span>
                case PHASE_PHYSICAL:
<span class="nc" id="L508">                    refreshAttacks();</span>
<span class="nc" id="L509">                    break;</span>
                case PHASE_INITIATIVE:
<span class="nc" id="L511">                    clearAllAttacks();</span>
<span class="nc" id="L512">                    break;</span>
                case PHASE_END:
                case PHASE_VICTORY:
<span class="nc" id="L515">                    clearSprites();</span>
                case PHASE_LOUNGE:
<span class="nc" id="L517">                    clearHexImageCache();</span>
<span class="nc" id="L518">                    clearAllMoveVectors();</span>
<span class="nc" id="L519">                    clearAllAttacks();</span>
<span class="nc" id="L520">                    clearSprites();</span>
<span class="nc" id="L521">                    select(null);</span>
<span class="nc" id="L522">                    cursor(null);</span>
<span class="nc" id="L523">                    highlight(null);</span>
                default:
            }
<span class="nc bnc" id="L526" title="All 2 branches missed.">            for (Entity en : game.getEntitiesVector()) {</span>
<span class="nc bnc" id="L527" title="All 6 branches missed.">                if ((en.getDamageLevel() != Entity.DMG_NONE) &amp;&amp;</span>
                        ((en.damageThisRound != 0) || (en instanceof GunEmplacement))) {
<span class="nc" id="L529">                    tileManager.reloadImage(en);</span>
                }
<span class="nc" id="L531">            }</span>

<span class="nc" id="L533">        }</span>
    };
    /**
     * Holds the final Coords for a planned movement. Set by MovementDisplay,
     * used to display the distance in the board tooltip.
     */
    private Coords movementTarget;

    /**
     * Construct a new board view for the specified game
     */
    public BoardView1(final IGame game, final MegaMekController controller, ClientGUI clientgui)
<span class="fc" id="L545">            throws java.io.IOException {</span>
<span class="fc" id="L546">        this.game = game;</span>
<span class="fc" id="L547">        this.clientgui = clientgui;</span>

<span class="fc" id="L549">        hexImageCache = new ImageCache&lt;Coords, HexImageCacheEntry&gt;();</span>

<span class="fc" id="L551">        tileManager = new TilesetManager(this);</span>
<span class="fc" id="L552">        ToolTipManager.sharedInstance().registerComponent(this);</span>

<span class="fc" id="L554">        game.addGameListener(gameListener);</span>
<span class="fc" id="L555">        game.getBoard().addBoardListener(this);</span>

<span class="fc" id="L557">        keybindOverlay = new KeyBindingsOverlay(game, clientgui);</span>
<span class="fc" id="L558">        addDisplayable(keybindOverlay);</span>
<span class="fc" id="L559">        ourTask = scheduleRedrawTimer();// call only once</span>
<span class="fc" id="L560">        clearSprites();</span>
<span class="fc" id="L561">        addMouseListener(this);</span>
<span class="fc" id="L562">        addMouseWheelListener(new BoardViewMouseWheelListener());</span>

<span class="fc" id="L564">        MouseMotionListener mouseMotionListener = new BoardViewMouseMotionAdapter();</span>
<span class="fc" id="L565">        addMouseMotionListener(mouseMotionListener);</span>

<span class="pc bpc" id="L567" title="1 of 2 branches missed.">        if (controller != null) {</span>
<span class="fc" id="L568">            registerKeyboardCommands(this, controller);</span>
        }

        // setAutoscrolls(true);

<span class="fc" id="L573">        updateBoardSize();</span>

<span class="fc" id="L575">        hex_size = new Dimension((int) (HEX_W * scale), (int) (HEX_H * scale));</span>

<span class="fc" id="L577">        initPolys();</span>

<span class="fc" id="L579">        cursorSprite = new CursorSprite(this, Color.cyan);</span>
<span class="fc" id="L580">        highlightSprite = new CursorSprite(this, Color.white);</span>
<span class="fc" id="L581">        selectedSprite = new CursorSprite(this, Color.blue);</span>
<span class="fc" id="L582">        firstLOSSprite = new CursorSprite(this, Color.red);</span>
<span class="fc" id="L583">        secondLOSSprite = new CursorSprite(this, Color.red);</span>

<span class="fc" id="L585">        PreferenceManager.getClientPreferences().addPreferenceChangeListener(this);</span>
<span class="fc" id="L586">        GUIPreferences.getInstance().addPreferenceChangeListener(this);</span>

<span class="fc" id="L588">        SpecialHexDisplay.Type.ARTILLERY_HIT.init();</span>
<span class="fc" id="L589">        SpecialHexDisplay.Type.ARTILLERY_INCOMING.init();</span>
<span class="fc" id="L590">        SpecialHexDisplay.Type.ARTILLERY_TARGET.init();</span>
<span class="fc" id="L591">        SpecialHexDisplay.Type.ARTILLERY_ADJUSTED.init();</span>
<span class="fc" id="L592">        SpecialHexDisplay.Type.ARTILLERY_AUTOHIT.init();</span>
<span class="fc" id="L593">        SpecialHexDisplay.Type.PLAYER_NOTE.init();</span>

<span class="fc" id="L595">        fovHighlightingAndDarkening = new FovHighlightingAndDarkening(this);</span>

<span class="fc" id="L597">        flareImage = ImageUtil.loadImageFromFile(</span>
<span class="fc" id="L598">                new MegaMekFile(Configuration.miscImagesDir(), FILENAME_FLARE_IMAGE)</span>
<span class="fc" id="L599">                        .toString());</span>
<span class="fc" id="L600">        radarBlipImage = ImageUtil.loadImageFromFile(</span>
<span class="fc" id="L601">                new MegaMekFile(Configuration.miscImagesDir(),</span>
<span class="fc" id="L602">                        FILENAME_RADAR_BLIP_IMAGE).toString());</span>
<span class="fc" id="L603">    }</span>

    private void registerKeyboardCommands(final BoardView1 bv,
                                          final MegaMekController controller) {
        // Register the action for TOGGLE_ISO
<span class="fc" id="L608">        controller.registerCommandAction(KeyCommandBind.TOGGLE_ISO.cmd,</span>
<span class="fc" id="L609">                new CommandAction() {</span>

                    @Override
                    public boolean shouldPerformAction() {
<span class="nc bnc" id="L613" title="All 2 branches missed.">                        return !shouldIgnoreKeyCommands();</span>
                    }

                    @Override
                    public void performAction() {
<span class="nc" id="L618">                        GUIPreferences guip = GUIPreferences.getInstance();</span>
<span class="nc" id="L619">                        guip.setIsometricEnabled(toggleIsometric());</span>
<span class="nc" id="L620">                    }</span>

                });

        // Register the action for TOGGLE_CHAT
<span class="fc" id="L625">        controller.registerCommandAction(KeyCommandBind.TOGGLE_CHAT.cmd,</span>
<span class="fc" id="L626">                new CommandAction() {</span>

                    @Override
                    public boolean shouldPerformAction() {
<span class="nc bnc" id="L630" title="All 2 branches missed.">                        return !shouldIgnoreKeyCommands();</span>
                    }

                    @Override
                    public void performAction() {
<span class="nc bnc" id="L635" title="All 2 branches missed.">                        if (!getChatterBoxActive()) {</span>
<span class="nc" id="L636">                            setChatterBoxActive(true);</span>
<span class="nc bnc" id="L637" title="All 2 branches missed.">                            for (IDisplayable disp : displayables) {</span>
<span class="nc bnc" id="L638" title="All 2 branches missed.">                                if (disp instanceof ChatterBox2) {</span>
<span class="nc" id="L639">                                    ((ChatterBox2) disp).slideUp();</span>
                                }
<span class="nc" id="L641">                            }</span>
<span class="nc" id="L642">                            requestFocus();</span>
                        }
<span class="nc" id="L644">                    }</span>

                });

        // Register the action for TOGGLE_CHAT
<span class="fc" id="L649">        controller.registerCommandAction(KeyCommandBind.TOGGLE_CHAT_CMD.cmd,</span>
<span class="fc" id="L650">                new CommandAction() {</span>

                    @Override
                    public boolean shouldPerformAction() {
<span class="nc bnc" id="L654" title="All 2 branches missed.">                        return !shouldIgnoreKeyCommands();</span>
                    }

                    @Override
                    public void performAction() {
<span class="nc bnc" id="L659" title="All 2 branches missed.">                        if (!getChatterBoxActive()) {</span>
<span class="nc" id="L660">                            setChatterBoxActive(true);</span>
<span class="nc bnc" id="L661" title="All 2 branches missed.">                            for (IDisplayable disp : displayables) {</span>
<span class="nc bnc" id="L662" title="All 2 branches missed.">                                if (disp instanceof ChatterBox2) {</span>
<span class="nc" id="L663">                                    ((ChatterBox2) disp).slideUp();</span>
<span class="nc" id="L664">                                    ((ChatterBox2) disp).setMessage(&quot;/&quot;);</span>
                                }
<span class="nc" id="L666">                            }</span>
<span class="nc" id="L667">                            requestFocus();</span>
                        }
<span class="nc" id="L669">                    }</span>

                });

        // Register the action for CENTER_ON_SELECTED
<span class="fc" id="L674">        controller.registerCommandAction(KeyCommandBind.CENTER_ON_SELECTED.cmd,</span>
<span class="fc" id="L675">                new CommandAction() {</span>

                    @Override
                    public boolean shouldPerformAction() {
<span class="nc bnc" id="L679" title="All 4 branches missed.">                        return !shouldIgnoreKeyCommands() &amp;&amp; (selectedEntity != null);</span>
                    }

                    @Override
                    public void performAction() {
<span class="nc bnc" id="L684" title="All 2 branches missed.">                        if (selectedEntity != null) {</span>
<span class="nc" id="L685">                            centerOnHex(selectedEntity.getPosition());</span>
                        }
<span class="nc" id="L687">                    }</span>

                });

        // Register the action for SCROLL_NORTH
<span class="fc" id="L692">        controller.registerCommandAction(KeyCommandBind.SCROLL_NORTH.cmd,</span>
<span class="fc" id="L693">                new CommandAction() {</span>

                    @Override
                    public boolean shouldPerformAction() {
<span class="nc bnc" id="L697" title="All 2 branches missed.">                        return !shouldIgnoreKeyCommands();</span>
                    }

                    @Override
                    public void performAction() {
<span class="nc" id="L702">                        controller.stopRepeating(KeyCommandBind.SCROLL_SOUTH);</span>
<span class="nc" id="L703">                        vbar.setValue((int) (vbar.getValue() - (HEX_H * scale)));</span>
<span class="nc" id="L704">                        stopSoftCentering();</span>
<span class="nc" id="L705">                    }</span>

                    @Override
                    public void releaseAction() {
<span class="nc" id="L709">                        pingMinimap();</span>
<span class="nc" id="L710">                    }</span>

                    @Override
                    public boolean hasReleaseAction() {
<span class="nc" id="L714">                        return true;</span>
                    }

                });

        // Register the action for SCROLL_SOUTH
<span class="fc" id="L720">        controller.registerCommandAction(KeyCommandBind.SCROLL_SOUTH.cmd,</span>
<span class="fc" id="L721">                new CommandAction() {</span>

                    @Override
                    public boolean shouldPerformAction() {
<span class="nc bnc" id="L725" title="All 2 branches missed.">                        return !shouldIgnoreKeyCommands();</span>
                    }

                    @Override
                    public void performAction() {
<span class="nc" id="L730">                        controller.stopRepeating(KeyCommandBind.SCROLL_NORTH);</span>
<span class="nc" id="L731">                        vbar.setValue((int) (vbar.getValue() + (HEX_H * scale)));</span>
<span class="nc" id="L732">                        stopSoftCentering();</span>
<span class="nc" id="L733">                    }</span>

                    @Override
                    public void releaseAction() {
<span class="nc" id="L737">                        pingMinimap();</span>
<span class="nc" id="L738">                    }</span>

                    @Override
                    public boolean hasReleaseAction() {
<span class="nc" id="L742">                        return true;</span>
                    }

                });

        // Register the action for SCROLL_EAST
<span class="fc" id="L748">        controller.registerCommandAction(KeyCommandBind.SCROLL_EAST.cmd,</span>
<span class="fc" id="L749">                new CommandAction() {</span>

                    @Override
                    public boolean shouldPerformAction() {
<span class="nc bnc" id="L753" title="All 2 branches missed.">                        return !shouldIgnoreKeyCommands();</span>
                    }

                    @Override
                    public void performAction() {
<span class="nc" id="L758">                        controller.stopRepeating(KeyCommandBind.SCROLL_WEST);</span>
<span class="nc" id="L759">                        hbar.setValue((int) (hbar.getValue() + (HEX_W * scale)));</span>
<span class="nc" id="L760">                        stopSoftCentering();</span>
<span class="nc" id="L761">                    }</span>

                    @Override
                    public void releaseAction() {
<span class="nc" id="L765">                        pingMinimap();</span>
<span class="nc" id="L766">                    }</span>

                    @Override
                    public boolean hasReleaseAction() {
<span class="nc" id="L770">                        return true;</span>
                    }

                });

        // Register the action for SCROLL_WEST
<span class="fc" id="L776">        controller.registerCommandAction(KeyCommandBind.SCROLL_WEST.cmd,</span>
<span class="fc" id="L777">                new CommandAction() {</span>

                    @Override
                    public boolean shouldPerformAction() {
<span class="nc bnc" id="L781" title="All 2 branches missed.">                        return !shouldIgnoreKeyCommands();</span>
                    }

                    @Override
                    public void performAction() {
<span class="nc" id="L786">                        controller.stopRepeating(KeyCommandBind.SCROLL_EAST);</span>
<span class="nc" id="L787">                        hbar.setValue((int) (hbar.getValue() - (HEX_W * scale)));</span>
<span class="nc" id="L788">                        stopSoftCentering();</span>
<span class="nc" id="L789">                    }</span>

                    @Override
                    public void releaseAction() {
<span class="nc" id="L793">                        pingMinimap();</span>
<span class="nc" id="L794">                    }</span>

                    @Override
                    public boolean hasReleaseAction() {
<span class="nc" id="L798">                        return true;</span>
                    }

                });

        // Register the action for Showing the Field of Fire
<span class="fc" id="L804">        controller.registerCommandAction(KeyCommandBind.FIELD_FIRE.cmd,</span>
<span class="fc" id="L805">                new CommandAction() {</span>

                    @Override
                    public boolean shouldPerformAction() {
<span class="nc bnc" id="L809" title="All 2 branches missed.">                        return !shouldIgnoreKeyCommands();</span>
                    }

                    @Override
                    public void performAction() {
<span class="nc" id="L814">                        GUIPreferences guip = GUIPreferences.getInstance();</span>
<span class="nc bnc" id="L815" title="All 2 branches missed.">                        guip.setShowFieldOfFire(!guip.getShowFieldOfFire());</span>
<span class="nc" id="L816">                        repaint();</span>
<span class="nc" id="L817">                    }</span>

                });

        // Register the action for Toggling drawing unit labels
<span class="fc" id="L822">        controller.registerCommandAction(KeyCommandBind.TOGGLE_DRAW_LABELS.cmd,</span>
<span class="fc" id="L823">                new CommandAction() {</span>

                    @Override
                    public boolean shouldPerformAction() {
<span class="nc bnc" id="L827" title="All 2 branches missed.">                        return !shouldIgnoreKeyCommands();</span>
                    }

                    @Override
                    public void performAction() {
<span class="nc" id="L832">                        GUIPreferences guip = GUIPreferences.getInstance();</span>
<span class="nc" id="L833">                        boolean drawLabels = guip.getBoolean(</span>
                                GUIPreferences.ADVANCED_DRAW_ENTITY_LABEL);
<span class="nc bnc" id="L835" title="All 2 branches missed.">                        guip.setValue(GUIPreferences.ADVANCED_DRAW_ENTITY_LABEL,</span>
                                !drawLabels);
<span class="nc" id="L837">                        updateEntityLabels();</span>
<span class="nc bnc" id="L838" title="All 2 branches missed.">                        for (Sprite s : wreckSprites) {</span>
<span class="nc" id="L839">                            s.prepare();</span>
<span class="nc" id="L840">                        }</span>
<span class="nc bnc" id="L841" title="All 2 branches missed.">                        for (Sprite s : isometricWreckSprites) {</span>
<span class="nc" id="L842">                            s.prepare();</span>
<span class="nc" id="L843">                        }</span>
<span class="nc" id="L844">                    }</span>

                });

        // Register the action for TOGGLE_KEYBIND_DISPLAY
<span class="fc" id="L849">        controller.registerCommandAction(KeyCommandBind.TOGGLE_KEYBIND_DISPLAY.cmd,</span>
<span class="fc" id="L850">                new CommandAction() {</span>

                    @Override
                    public boolean shouldPerformAction() {
<span class="nc bnc" id="L854" title="All 2 branches missed.">                        return !shouldIgnoreKeyCommands();</span>
                    }

                    @Override
                    public void performAction() {
<span class="nc" id="L859">                        toggleKeybindsOverlay();</span>
<span class="nc" id="L860">                    }</span>
                });

        // Register the action for TOGGLE_HEX_COORDS
<span class="fc" id="L864">        controller.registerCommandAction(KeyCommandBind.TOGGLE_HEX_COORDS.cmd,</span>
<span class="fc" id="L865">                new CommandAction() {</span>

                    @Override
                    public boolean shouldPerformAction() {
<span class="nc bnc" id="L869" title="All 2 branches missed.">                        return !shouldIgnoreKeyCommands();</span>
                    }

                    @Override
                    public void performAction() {
<span class="nc" id="L874">                        boolean coordsShown = GUIPreferences.getInstance().getBoolean(GUIPreferences.ADVANCED_SHOW_COORDS);</span>
<span class="nc bnc" id="L875" title="All 2 branches missed.">                        GUIPreferences.getInstance().setValue(GUIPreferences.ADVANCED_SHOW_COORDS, !coordsShown);</span>
<span class="nc" id="L876">                    }</span>

                });

<span class="fc" id="L880">    }</span>

    private boolean shouldIgnoreKeyCommands() {
<span class="nc bnc" id="L883" title="All 4 branches missed.">        return getChatterBoxActive() || !isVisible()</span>
<span class="nc bnc" id="L884" title="All 2 branches missed.">                || (game.getPhase() == Phase.PHASE_LOUNGE)</span>
<span class="nc bnc" id="L885" title="All 2 branches missed.">                || (game.getPhase() == Phase.PHASE_END_REPORT)</span>
<span class="nc bnc" id="L886" title="All 2 branches missed.">                || (game.getPhase() == Phase.PHASE_MOVEMENT_REPORT)</span>
<span class="nc bnc" id="L887" title="All 2 branches missed.">                || (game.getPhase() == Phase.PHASE_TARGETING_REPORT)</span>
<span class="nc bnc" id="L888" title="All 2 branches missed.">                || (game.getPhase() == Phase.PHASE_FIRING_REPORT)</span>
<span class="nc bnc" id="L889" title="All 2 branches missed.">                || (game.getPhase() == Phase.PHASE_PHYSICAL_REPORT)</span>
<span class="nc bnc" id="L890" title="All 2 branches missed.">                || (game.getPhase() == Phase.PHASE_OFFBOARD_REPORT)</span>
<span class="nc bnc" id="L891" title="All 4 branches missed.">                || (game.getPhase() == Phase.PHASE_INITIATIVE_REPORT)</span>
                || shouldIgnoreKeys;
    }

    /**
     * this should only be called once!! this will cause a timer to schedule
     * constant screen updates every 20 milliseconds!
     */
    protected TimerTask scheduleRedrawTimer() {
<span class="fc" id="L900">        final TimerTask redraw = new TimerTask() {</span>
            @Override
            public void run() {
                try {
<span class="fc" id="L904">                    SwingUtilities.invokeLater(redrawWorker);</span>
<span class="nc" id="L905">                } catch (Exception ie) {</span>
<span class="nc" id="L906">                    MegaMek.getLogger().error(&quot;Ignoring error: &quot; + ie.getMessage());</span>
<span class="fc" id="L907">                }</span>
<span class="fc" id="L908">            }</span>
        };
<span class="fc" id="L910">        TimerSingleton.getInstance().schedule(redraw, 20, 20);</span>
<span class="fc" id="L911">        return redraw;</span>
    }

    protected void scheduleRedraw() {
        try {
<span class="nc" id="L916">            SwingUtilities.invokeLater(redrawWorker);</span>
<span class="nc" id="L917">        } catch (Exception ie) {</span>
<span class="nc" id="L918">            MegaMek.getLogger().error(&quot;Ignoring error: &quot; + ie.getMessage());</span>
<span class="nc" id="L919">        }</span>
<span class="nc" id="L920">    }</span>

    public void preferenceChange(PreferenceChangeEvent e) {
<span class="nc bnc" id="L923" title="All 2 branches missed.">        if (e.getName().equals(IClientPreferences.MAP_TILESET)) {</span>
<span class="nc" id="L924">            updateBoard();</span>
        }
<span class="nc bnc" id="L926" title="All 2 branches missed.">        if (e.getName().equals(GUIPreferences.ADVANCED_DRAW_ENTITY_LABEL)</span>
<span class="nc bnc" id="L927" title="All 2 branches missed.">                || e.getName().equals(GUIPreferences.UNIT_LABEL_BORDER)</span>
<span class="nc bnc" id="L928" title="All 2 branches missed.">                || e.getName().equals(GUIPreferences.TEAM_COLORING)</span>
<span class="nc bnc" id="L929" title="All 2 branches missed.">                || e.getName().equals(GUIPreferences.SHOW_DAMAGE_DECAL)</span>
<span class="nc bnc" id="L930" title="All 2 branches missed.">                || e.getName().equals(GUIPreferences.SHOW_DAMAGE_LEVEL)) {</span>
<span class="nc" id="L931">            updateEntityLabels();</span>
<span class="nc bnc" id="L932" title="All 2 branches missed.">            for (Sprite s : wreckSprites) {</span>
<span class="nc" id="L933">                s.prepare();</span>
<span class="nc" id="L934">            }</span>
<span class="nc bnc" id="L935" title="All 2 branches missed.">            for (Sprite s : isometricWreckSprites) {</span>
<span class="nc" id="L936">                s.prepare();</span>
<span class="nc" id="L937">            }</span>
        }
<span class="nc bnc" id="L939" title="All 2 branches missed.">        if (e.getName().equals(GUIPreferences.AOHEXSHADOWS)</span>
<span class="nc bnc" id="L940" title="All 2 branches missed.">                || e.getName().equals(GUIPreferences.FLOATINGISO)</span>
<span class="nc bnc" id="L941" title="All 2 branches missed.">                || e.getName().equals(GUIPreferences.LEVELHIGHLIGHT)</span>
<span class="nc bnc" id="L942" title="All 2 branches missed.">                || e.getName().equals(GUIPreferences.ADVANCED_SHOW_COORDS)</span>
<span class="nc bnc" id="L943" title="All 2 branches missed.">                || e.getName().equals(GUIPreferences.FOV_DARKEN)</span>
<span class="nc bnc" id="L944" title="All 2 branches missed.">                || e.getName().equals(GUIPreferences.FOV_DARKEN_ALPHA)</span>
<span class="nc bnc" id="L945" title="All 2 branches missed.">                || e.getName().equals(GUIPreferences.FOV_GRAYSCALE)</span>
<span class="nc bnc" id="L946" title="All 2 branches missed.">                || e.getName().equals(GUIPreferences.FOV_HIGHLIGHT)</span>
<span class="nc bnc" id="L947" title="All 2 branches missed.">                || e.getName().equals(GUIPreferences.FOV_HIGHLIGHT_ALPHA)</span>
<span class="nc bnc" id="L948" title="All 2 branches missed.">                || e.getName().equals(GUIPreferences.FOV_STRIPES)</span>
<span class="nc bnc" id="L949" title="All 2 branches missed.">                || e.getName().equals(GUIPreferences.FOV_HIGHLIGHT_RINGS_COLORS_HSB)</span>
<span class="nc bnc" id="L950" title="All 2 branches missed.">                || e.getName().equals(GUIPreferences.FOV_HIGHLIGHT_RINGS_RADII)</span>
<span class="nc bnc" id="L951" title="All 2 branches missed.">                || e.getName().equals(GUIPreferences.SHADOWMAP)) {</span>
<span class="nc" id="L952">            clearHexImageCache();</span>
<span class="nc" id="L953">            repaint();</span>
        }
<span class="nc bnc" id="L955" title="All 2 branches missed.">        if (e.getName().equals(GUIPreferences.INCLINES)) {</span>
<span class="nc" id="L956">            game.getBoard().initializeAllAutomaticTerrain();</span>
<span class="nc" id="L957">            clearHexImageCache();</span>
<span class="nc" id="L958">            repaint();</span>
        }
<span class="nc" id="L960">    }</span>

    /**
     * Adds the specified board listener to receive board events from this
     * board.
     *
     * @param listener the board listener.
     */
    public void addBoardViewListener(BoardViewListener listener) {
<span class="nc bnc" id="L969" title="All 2 branches missed.">        if (!boardListeners.contains(listener)) {</span>
<span class="nc" id="L970">            boardListeners.add(listener);</span>
        }
<span class="nc" id="L972">    }</span>

    /**
     * Removes the specified board listener.
     *
     * @param listener the board listener.
     */
    public void removeBoardViewListener(BoardViewListener listener) {
<span class="nc" id="L980">        boardListeners.remove(listener);</span>
<span class="nc" id="L981">    }</span>

    /**
     * Notifies attached board listeners of the event.
     *
     * @param event the board event.
     */
    public void processBoardViewEvent(BoardViewEvent event) {
<span class="nc bnc" id="L989" title="All 2 branches missed.">        if (boardListeners == null) {</span>
<span class="nc" id="L990">            return;</span>
        }
<span class="nc bnc" id="L992" title="All 2 branches missed.">        for (BoardViewListener l : boardListeners) {</span>
<span class="nc bnc" id="L993" title="All 9 branches missed.">            switch (event.getType()) {</span>
                case BoardViewEvent.BOARD_HEX_CLICKED:
                case BoardViewEvent.BOARD_HEX_DOUBLECLICKED:
                case BoardViewEvent.BOARD_HEX_DRAGGED:
                case BoardViewEvent.BOARD_HEX_POPUP:
<span class="nc" id="L998">                    l.hexMoused(event);</span>
<span class="nc" id="L999">                    break;</span>
                case BoardViewEvent.BOARD_HEX_CURSOR:
<span class="nc" id="L1001">                    l.hexCursor(event);</span>
<span class="nc" id="L1002">                    break;</span>
                case BoardViewEvent.BOARD_HEX_HIGHLIGHTED:
<span class="nc" id="L1004">                    l.boardHexHighlighted(event);</span>
<span class="nc" id="L1005">                    break;</span>
                case BoardViewEvent.BOARD_HEX_SELECTED:
<span class="nc" id="L1007">                    l.hexSelected(event);</span>
<span class="nc" id="L1008">                    break;</span>
                case BoardViewEvent.BOARD_FIRST_LOS_HEX:
<span class="nc" id="L1010">                    l.firstLOSHex(event);</span>
<span class="nc" id="L1011">                    break;</span>
                case BoardViewEvent.BOARD_SECOND_LOS_HEX:
<span class="nc" id="L1013">                    l.secondLOSHex(event, getFirstLOS());</span>
<span class="nc" id="L1014">                    break;</span>
                case BoardViewEvent.FINISHED_MOVING_UNITS:
<span class="nc" id="L1016">                    l.finishedMovingUnits(event);</span>
<span class="nc" id="L1017">                    break;</span>
                case BoardViewEvent.SELECT_UNIT:
<span class="nc" id="L1019">                    l.unitSelected(event);</span>
                    break;
            }
<span class="nc" id="L1022">        }</span>
<span class="nc" id="L1023">    }</span>

    void addMovingUnit(Entity entity, Vector&lt;UnitLocation&gt; movePath) {
<span class="nc bnc" id="L1026" title="All 2 branches missed.">        if (!movePath.isEmpty()) {</span>
<span class="nc" id="L1027">            MovingUnit m = new MovingUnit(entity, movePath);</span>
<span class="nc" id="L1028">            movingUnits.add(m);</span>

<span class="nc" id="L1030">            GhostEntitySprite ghostSprite = new GhostEntitySprite(this, entity);</span>
<span class="nc" id="L1031">            ghostEntitySprites.add(ghostSprite);</span>

            // Center on the starting hex of the moving unit.
<span class="nc" id="L1034">            UnitLocation loc = movePath.get(0);</span>
<span class="nc" id="L1035">            centerOnHex(loc.getCoords());</span>
        }
<span class="nc" id="L1037">    }</span>

    public void addDisplayable(IDisplayable disp) {
<span class="fc" id="L1040">        displayables.add(disp);</span>
<span class="fc" id="L1041">    }</span>

    public void removeDisplayable(IDisplayable disp) {
<span class="nc" id="L1044">        displayables.remove(disp);</span>
<span class="nc" id="L1045">    }</span>

    /**
     * Draw the screen!
     */
    @Override
    public synchronized void paintComponent(Graphics g) {
<span class="nc" id="L1052">        GUIPreferences guip = GUIPreferences.getInstance();</span>

<span class="nc bnc" id="L1054" title="All 2 branches missed.">        if (guip.getBoolean(GUIPreferences.ADVANCED_SHOW_FPS)) {</span>
<span class="nc" id="L1055">            paintCompsStartTime = System.nanoTime();</span>
        }

<span class="nc bnc" id="L1058" title="All 2 branches missed.">        if (guip.getAntiAliasing()) {</span>
<span class="nc" id="L1059">            ((Graphics2D) g).setRenderingHint(RenderingHints.KEY_ANTIALIASING,</span>
                    RenderingHints.VALUE_ANTIALIAS_ON);
        }

<span class="nc bnc" id="L1063" title="All 2 branches missed.">        if (!isTileImagesLoaded()) {</span>
<span class="nc" id="L1064">            g.drawString(Messages.getString(&quot;BoardView1.loadingImages&quot;), 20, 50);</span>
<span class="nc bnc" id="L1065" title="All 2 branches missed.">            if (!tileManager.isStarted()) {</span>
<span class="nc" id="L1066">                MegaMek.getLogger().info(&quot;Loading images for board&quot;);</span>
<span class="nc" id="L1067">                tileManager.loadNeededImages(game);</span>
            }
            // wait 1 second, then repaint
<span class="nc" id="L1070">            repaint(1000);</span>
<span class="nc" id="L1071">            return;</span>
        }

<span class="nc" id="L1074">        Rectangle viewRect = scrollpane.getVisibleRect();</span>
<span class="nc bnc" id="L1075" title="All 4 branches missed.">        if (bvBgShouldTile &amp;&amp; (bvBgImage != null)) {</span>
<span class="nc" id="L1076">            drawClipping(g);</span>
<span class="nc bnc" id="L1077" title="All 2 branches missed.">        } else if (bvBgImage != null) {</span>
<span class="nc" id="L1078">            g.drawImage(bvBgImage, -getX(), -getY(), (int) viewRect.getWidth(),</span>
<span class="nc" id="L1079">                    (int) viewRect.getHeight(), this);</span>
        } else {
<span class="nc" id="L1081">            MetalTheme theme = new DefaultMetalTheme();</span>
<span class="nc" id="L1082">            g.setColor(theme.getControl());</span>
<span class="nc" id="L1083">            g.fillRect(-getX(), -getY(), (int) viewRect.getWidth(),</span>
<span class="nc" id="L1084">                    (int) viewRect.getHeight());</span>
        }

        // Used to pad the board edge
<span class="nc" id="L1088">        g.translate(HEX_W, HEX_H);</span>

        // Initialize the shadow map when its not yet present
<span class="nc bnc" id="L1091" title="All 2 branches missed.">        if (shadowMap == null) {</span>
<span class="nc" id="L1092">            updateShadowMap();</span>
        }

<span class="nc" id="L1095">        drawHexes(g, g.getClipBounds());</span>

        // draw wrecks
<span class="nc bnc" id="L1098" title="All 4 branches missed.">        if (guip.getShowWrecks() &amp;&amp; !useIsometric()) {</span>
<span class="nc" id="L1099">            drawSprites(g, wreckSprites);</span>
        }

        // Field of Fire
<span class="nc bnc" id="L1103" title="All 4 branches missed.">        if (!useIsometric() &amp;&amp; GUIPreferences.getInstance().getShowFieldOfFire()) {</span>
<span class="nc" id="L1104">            drawSprites(g, fieldofFireSprites);</span>
        }

<span class="nc bnc" id="L1107" title="All 4 branches missed.">        if ((game.getPhase() == Phase.PHASE_MOVEMENT) &amp;&amp; !useIsometric()) {</span>
<span class="nc" id="L1108">            drawSprites(g, moveEnvSprites);</span>
<span class="nc" id="L1109">            drawSprites(g, moveModEnvSprites);</span>
        }

        // Minefield signs all over the place!
<span class="nc" id="L1113">        drawMinefields(g);</span>

        // Artillery targets
<span class="nc" id="L1116">        drawArtilleryHexes(g);</span>

        // draw highlight border
<span class="nc" id="L1119">        drawSprite(g, highlightSprite);</span>

        // draw cursors
<span class="nc" id="L1122">        drawSprite(g, cursorSprite);</span>
<span class="nc" id="L1123">        drawSprite(g, selectedSprite);</span>
<span class="nc" id="L1124">        drawSprite(g, firstLOSSprite);</span>
<span class="nc" id="L1125">        drawSprite(g, secondLOSSprite);</span>

        // draw deployment indicators.
        // For Isometric rendering, this is done during drawHexes
<span class="nc bnc" id="L1129" title="All 4 branches missed.">        if ((en_Deployer != null) &amp;&amp; !useIsometric()) {</span>
<span class="nc" id="L1130">            drawDeployment(g);</span>
        }

<span class="nc bnc" id="L1133" title="All 4 branches missed.">        if ((game.getPhase() == IGame.Phase.PHASE_SET_ARTYAUTOHITHEXES) &amp;&amp; showAllDeployment) {</span>
<span class="nc" id="L1134">            drawAllDeployment(g);</span>
        }

        // draw Flare Sprites
<span class="nc" id="L1138">        drawSprites(g, flareSprites);</span>

        // draw C3 links
<span class="nc" id="L1141">        drawSprites(g, c3Sprites);</span>

        // draw flyover routes
<span class="nc bnc" id="L1144" title="All 2 branches missed.">        if (game.getBoard().onGround()) {</span>
<span class="nc" id="L1145">            drawSprites(g, vtolAttackSprites);</span>
<span class="nc" id="L1146">            drawSprites(g, flyOverSprites);</span>
        }

        // draw onscreen entities
<span class="nc" id="L1150">        drawSprites(g, entitySprites);</span>

        // draw moving onscreen entities
<span class="nc" id="L1153">        drawSprites(g, movingEntitySprites);</span>

        // draw ghost onscreen entities
<span class="nc" id="L1156">        drawSprites(g, ghostEntitySprites);</span>

        // draw onscreen attacks
<span class="nc" id="L1159">        drawSprites(g, attackSprites);</span>

        // draw movement vectors.
<span class="nc bnc" id="L1162" title="All 4 branches missed.">        if (game.useVectorMove() &amp;&amp; (game.getPhase() == IGame.Phase.PHASE_MOVEMENT)) {</span>
<span class="nc" id="L1163">            drawSprites(g, movementSprites);</span>
        }

        // draw movement, if valid
<span class="nc" id="L1167">        drawSprites(g, pathSprites);</span>

        // draw firing solution sprites, but only during the firing phase
<span class="nc bnc" id="L1170" title="All 4 branches missed.">        if ((game.getPhase() == Phase.PHASE_FIRING) || (game.getPhase() == Phase.PHASE_OFFBOARD)) {</span>
<span class="nc" id="L1171">            drawSprites(g, firingSprites);</span>
        }

<span class="nc bnc" id="L1174" title="All 2 branches missed.">        if (game.getPhase() == Phase.PHASE_FIRING) {</span>
<span class="nc bnc" id="L1175" title="All 2 branches missed.">            for (Coords c : strafingCoords) {</span>
<span class="nc" id="L1176">                drawHexBorder(g, getHexLocation(c), Color.yellow, 0, 3);</span>
<span class="nc" id="L1177">            }</span>
        }


        // draw the ruler line
<span class="nc bnc" id="L1182" title="All 2 branches missed.">        if (rulerStart != null) {</span>
<span class="nc" id="L1183">            Point start = getCentreHexLocation(rulerStart);</span>
<span class="nc bnc" id="L1184" title="All 2 branches missed.">            if (rulerEnd != null) {</span>
<span class="nc" id="L1185">                Point end = getCentreHexLocation(rulerEnd);</span>
<span class="nc" id="L1186">                g.setColor(Color.yellow);</span>
<span class="nc" id="L1187">                g.drawLine(start.x, start.y, end.x, end.y);</span>

<span class="nc" id="L1189">                g.setColor(rulerEndColor);</span>
<span class="nc" id="L1190">                g.fillRect(end.x - 1, end.y - 1, 2, 2);</span>
            }

<span class="nc" id="L1193">            g.setColor(rulerStartColor);</span>
<span class="nc" id="L1194">            g.fillRect(start.x - 1, start.y - 1, 2, 2);</span>
        }

        // Undo the previous translation
<span class="nc" id="L1198">        g.translate(-HEX_W, -HEX_H);</span>


        // draw all the &quot;displayables&quot;
<span class="nc bnc" id="L1202" title="All 2 branches missed.">        if (displayablesRect == null) {</span>
<span class="nc" id="L1203">            displayablesRect = new Rectangle();</span>
        }
<span class="nc" id="L1205">        displayablesRect.x = -getX();</span>
<span class="nc" id="L1206">        displayablesRect.y = -getY();</span>
<span class="nc" id="L1207">        displayablesRect.width = scrollpane.getViewport().getViewRect().width;</span>
<span class="nc" id="L1208">        displayablesRect.height = scrollpane.getViewport().getViewRect().height;</span>
<span class="nc bnc" id="L1209" title="All 2 branches missed.">        for (IDisplayable disp : displayables) {</span>
<span class="nc" id="L1210">            disp.draw(g, displayablesRect);</span>
<span class="nc" id="L1211">        }</span>

<span class="nc bnc" id="L1213" title="All 2 branches missed.">        if (guip.getBoolean(GUIPreferences.ADVANCED_SHOW_FPS)) {</span>
<span class="nc bnc" id="L1214" title="All 2 branches missed.">            if (frameCount == FRAMES) {</span>
<span class="nc" id="L1215">                averageTime = totalTime / FRAMES;</span>
<span class="nc" id="L1216">                totalTime = 0;</span>
<span class="nc" id="L1217">                frameCount = 0;</span>
            } else {
<span class="nc" id="L1219">                totalTime += System.nanoTime() - paintCompsStartTime;</span>
<span class="nc" id="L1220">                frameCount++;</span>
            }
<span class="nc" id="L1222">            String s = String.format(&quot;%1$5.3f&quot;, averageTime / 1000000d);</span>
<span class="nc" id="L1223">            g.setFont(fpsFont);</span>
<span class="nc" id="L1224">            g.setColor(Color.YELLOW);</span>
<span class="nc" id="L1225">            g.drawString(s, -getX() + 5, -getY() + 20);</span>
        }

        // debugging method that renders the bounding box of a unit's movement envelope.
        //renderClusters((Graphics2D) g);
        //renderMovementBoundingBox((Graphics2D) g);
        //renderDonut(g, new Coords(10, 10), 2);
        //renderApproxHexDirection((Graphics2D) g);
<span class="nc" id="L1233">    }</span>

    private void drawClipping(Graphics g) {
<span class="nc" id="L1236">        Rectangle clipping = g.getClipBounds();</span>
<span class="nc" id="L1237">        int x = 0;</span>
<span class="nc" id="L1238">        int y = 0;</span>
<span class="nc" id="L1239">        int w = bvBgImage.getWidth();</span>
<span class="nc" id="L1240">        int h = bvBgImage.getHeight();</span>
<span class="nc bnc" id="L1241" title="All 2 branches missed.">        while (y &lt; clipping.getHeight()) {</span>
<span class="nc" id="L1242">            int yRem = 0;</span>
<span class="nc bnc" id="L1243" title="All 2 branches missed.">            if (y == 0) {</span>
<span class="nc" id="L1244">                yRem = clipping.y % h;</span>
            }
<span class="nc" id="L1246">            x = 0;</span>
<span class="nc bnc" id="L1247" title="All 2 branches missed.">            while (x &lt; clipping.getWidth()) {</span>
<span class="nc" id="L1248">                int xRem = 0;</span>
<span class="nc bnc" id="L1249" title="All 2 branches missed.">                if (x == 0) {</span>
<span class="nc" id="L1250">                    xRem = clipping.x % w;</span>
                }
<span class="nc" id="L1252">                drawClipping(g, clipping, x, y, w, h, yRem, xRem);</span>
<span class="nc" id="L1253">                x += w - xRem;</span>
<span class="nc" id="L1254">            }</span>
<span class="nc" id="L1255">            y += h - yRem;</span>
<span class="nc" id="L1256">        }</span>
<span class="nc" id="L1257">    }</span>

    private void drawClipping(Graphics g, Rectangle clipping, int x, int y, int w, int h, int yRem, int xRem) {
<span class="nc bnc" id="L1260" title="All 4 branches missed.">        if ((xRem &gt; 0) || (yRem &gt; 0)) {</span>
            try {
<span class="nc" id="L1262">                g.drawImage(bvBgImage.getSubimage(xRem, yRem, w - xRem, h - yRem),</span>
                        clipping.x + x, clipping.y + y, this);
<span class="nc" id="L1264">            } catch (Exception e) {</span>
                // if we somehow messed up the math, log the error and simply act as if we have no background image.
<span class="nc" id="L1266">                Rectangle rasterBounds = bvBgImage.getRaster().getBounds();</span>

<span class="nc" id="L1268">                String errorData = String.format(&quot;Error drawing background image. Raster Bounds: %.2f, %.2f, width:%.2f, height:%.2f, Attempted Draw Coordinates: %d, %d, width:%d, height:%d&quot;,</span>
<span class="nc" id="L1269">                        rasterBounds.getMinX(), rasterBounds.getMinY(), rasterBounds.getWidth(), rasterBounds.getHeight(),</span>
<span class="nc" id="L1270">                        xRem, yRem, w - xRem, h - yRem);</span>
<span class="nc" id="L1271">                MegaMek.getLogger().error(errorData);</span>
<span class="nc" id="L1272">            }</span>
        } else {
<span class="nc" id="L1274">            g.drawImage(bvBgImage, clipping.x + x, clipping.y + y,</span>
                    this);
        }
<span class="nc" id="L1277">    }</span>

    /**
     * Debugging method that renders a hex in the approximate direction
     * from the selected entity to the selected hex, of both exist.
     *
     * @param g Graphics object on which to draw.
     */
    @SuppressWarnings(&quot;unused&quot;)
    private void renderApproxHexDirection(Graphics2D g) {
<span class="nc bnc" id="L1287" title="All 4 branches missed.">        if (selectedEntity == null || selected == null) {</span>
<span class="nc" id="L1288">            return;</span>
        }

<span class="nc" id="L1291">        int direction = selectedEntity.getPosition().approximateDirection(selected, 0, 0);</span>

<span class="nc" id="L1293">        Coords donutCoords = selectedEntity.getPosition().translated(direction);</span>

<span class="nc" id="L1295">        Point p = getCentreHexLocation(donutCoords.getX(), donutCoords.getY(), true);</span>
<span class="nc" id="L1296">        p.translate(HEX_W / 2, HEX_H / 2);</span>
<span class="nc" id="L1297">        drawHexBorder(g, p, Color.BLUE, 0, 6);</span>
<span class="nc" id="L1298">    }</span>

    /**
     * Debugging method that renders the bounding hex of a unit's movement envelope.
     * Warning: very slow when rendering the bounding hex for really fast units.
     *
     * @param g Graphics object on which to draw.
     */
    @SuppressWarnings(&quot;unused&quot;)
    private void renderMovementBoundingBox(Graphics2D g) {
<span class="nc bnc" id="L1308" title="All 2 branches missed.">        if (selectedEntity != null) {</span>
<span class="nc" id="L1309">            Princess princess = new Princess(&quot;test&quot;, &quot;localhost&quot;, 2020, LogLevel.DEBUG);</span>
<span class="nc" id="L1310">            princess.getGame().setBoard(this.game.getBoard());</span>
<span class="nc" id="L1311">            PathEnumerator pathEnum = new PathEnumerator(princess, this.game);</span>
<span class="nc" id="L1312">            pathEnum.recalculateMovesFor(this.selectedEntity);</span>

<span class="nc" id="L1314">            ConvexBoardArea cba = pathEnum.getUnitMovableAreas().get(this.selectedEntity.getId());</span>
<span class="nc bnc" id="L1315" title="All 2 branches missed.">            for (int x = 0; x &lt; game.getBoard().getWidth(); x++) {</span>
<span class="nc bnc" id="L1316" title="All 2 branches missed.">                for (int y = 0; y &lt; game.getBoard().getHeight(); y++) {</span>
<span class="nc" id="L1317">                    Point p = getCentreHexLocation(x, y, true);</span>
<span class="nc" id="L1318">                    p.translate(HEX_W / 2, HEX_H / 2);</span>
<span class="nc" id="L1319">                    Coords c = new Coords(x, y);</span>

<span class="nc bnc" id="L1321" title="All 2 branches missed.">                    if (cba.contains(c)) {</span>

<span class="nc" id="L1323">                        drawHexBorder(g, p, Color.PINK, 0, 6);</span>
                    }
                }
            }

<span class="nc bnc" id="L1328" title="All 2 branches missed.">            for (Integer x = 0; x &lt; 6; x++) {</span>
<span class="nc" id="L1329">                Coords c = cba.getVertexNum(x);</span>
<span class="nc bnc" id="L1330" title="All 2 branches missed.">                if (c == null) {</span>
<span class="nc" id="L1331">                    continue;</span>
                }

<span class="nc" id="L1334">                Point p = getCentreHexLocation(c.getX(), c.getY(), true);</span>
<span class="nc" id="L1335">                p.translate(HEX_W / 2, HEX_H / 2);</span>

<span class="nc" id="L1337">                drawHexBorder(g, p, Color.yellow, 0, 3);</span>
<span class="nc" id="L1338">                String s = x.toString();</span>
<span class="nc" id="L1339">                this.drawCenteredText(g, s, p, Color.yellow, false);</span>
            }
        }
<span class="nc" id="L1342">    }</span>

    /**
     * Debugging method that renders a hex donut around the given coordinates, with the given radius.
     *
     * @param g Graphics object on which to draw.
     */
    @SuppressWarnings(&quot;unused&quot;)
    private void renderDonut(Graphics2D g, Coords coords, int radius) {
<span class="nc" id="L1351">        List&lt;Coords&gt; donut = coords.allAtDistance(radius);</span>

<span class="nc bnc" id="L1353" title="All 2 branches missed.">        for (Coords donutCoords : donut) {</span>
<span class="nc" id="L1354">            Point p = getCentreHexLocation(donutCoords.getX(), donutCoords.getY(), true);</span>
<span class="nc" id="L1355">            p.translate(HEX_W / 2, HEX_H / 2);</span>
<span class="nc" id="L1356">            drawHexBorder(g, p, Color.PINK, 0, 6);</span>
<span class="nc" id="L1357">        }</span>
<span class="nc" id="L1358">    }</span>

    /**
     * Debugging method that renders a obnoxious pink lines around hexes in &quot;Board Clusters&quot;
     *
     * @param g Graphics object on which to draw.
     */
    @SuppressWarnings(&quot;unused&quot;)
    private void renderClusters(Graphics2D g) {
<span class="nc" id="L1367">        BoardClusterTracker bct = new BoardClusterTracker();</span>
<span class="nc" id="L1368">        Map&lt;Coords, BoardCluster&gt; clusterMap = bct.generateClusters(selectedEntity, false, true);</span>

<span class="nc bnc" id="L1370" title="All 2 branches missed.">        for (BoardCluster cluster : clusterMap.values().stream().distinct().collect(Collectors.toList())) {</span>
<span class="nc bnc" id="L1371" title="All 2 branches missed.">            for (Coords coords : cluster.contents.keySet()) {</span>
<span class="nc" id="L1372">                Point p = getCentreHexLocation(coords.getX(), coords.getY(), true);</span>
<span class="nc" id="L1373">                p.translate(HEX_W / 2, HEX_H / 2);</span>
<span class="nc" id="L1374">                drawHexBorder(g, p, new Color(0, 0, (20 * cluster.id) % 255), 0, 6);</span>
<span class="nc" id="L1375">            }</span>
<span class="nc" id="L1376">        }</span>
<span class="nc" id="L1377">    }</span>

    /**
     * @return a list of {@link Coords} of all hexes on the board.
     * Returns ONLY hexes where board.getHex != null.
     */
    private List&lt;Coords&gt; allBoardHexes() {
<span class="nc" id="L1384">        IBoard board = game.getBoard();</span>
<span class="nc bnc" id="L1385" title="All 2 branches missed.">        if (board == null) {</span>
<span class="nc" id="L1386">            return Collections.emptyList();</span>
        }

<span class="nc" id="L1389">        List&lt;Coords&gt; coordList = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1390" title="All 2 branches missed.">        for (int i = 0; i &lt; board.getWidth(); i++) {</span>
<span class="nc bnc" id="L1391" title="All 2 branches missed.">            for (int j = 0; j &lt; board.getHeight(); j++) {</span>
<span class="nc bnc" id="L1392" title="All 2 branches missed.">                if (board.getHex(i, j) != null) {</span>
<span class="nc" id="L1393">                    coordList.add(new Coords(i, j));</span>
                }
            }
        }

<span class="nc" id="L1398">        return coordList;</span>
    }

    private Image createBlurredShadow(Image orig) {
<span class="nc bnc" id="L1402" title="All 2 branches missed.">        if ((orig == null) ||</span>
<span class="nc bnc" id="L1403" title="All 2 branches missed.">                orig.getWidth(this) &lt; 0 ||</span>
<span class="nc bnc" id="L1404" title="All 2 branches missed.">                orig.getHeight(this) &lt; 0) {</span>
<span class="nc" id="L1405">            return null;</span>
        }
<span class="nc" id="L1407">        BufferedImage mask = shadowImageCache.get(orig.hashCode());</span>
<span class="nc bnc" id="L1408" title="All 2 branches missed.">        if (mask == null) {</span>
            GraphicsConfiguration config = GraphicsEnvironment
<span class="nc" id="L1410">                    .getLocalGraphicsEnvironment().getDefaultScreenDevice()</span>
<span class="nc" id="L1411">                    .getDefaultConfiguration();</span>

            // a slightly bigger image to give room for blurring
<span class="nc" id="L1414">            mask = config.createCompatibleImage(orig.getWidth(this) + 4, orig.getHeight(this) + 4,</span>
                    Transparency.TRANSLUCENT);
<span class="nc" id="L1416">            Graphics g = mask.getGraphics();</span>
<span class="nc" id="L1417">            g.drawImage(orig, 2, 2, null);</span>
<span class="nc" id="L1418">            g.dispose();</span>
<span class="nc" id="L1419">            mask = createShadowMask(mask);</span>
<span class="nc" id="L1420">            mask = blurOp.filter(mask, null);</span>
<span class="nc bnc" id="L1421" title="All 2 branches missed.">            if (game.getPlanetaryConditions().getLight() != PlanetaryConditions.L_DAY) {</span>
<span class="nc" id="L1422">                mask = blurOp.filter(mask, null);</span>
            }
<span class="nc" id="L1424">            shadowImageCache.put(orig.hashCode(), mask);</span>
        }
<span class="nc" id="L1426">        return mask;</span>
    }

    /**
     * Prepares a shadow map for the board, drawing shadows for hills/trees/buildings.
     * The shadow map is an image the size of the whole board.
     */
    private void updateShadowMap() {
        // Issues:
        // Bridge shadows show a gap towards connected hexes. I don't know why.
        // More than one super image on a hex (building+road) doesnt work. how do I get
        //   the super for a hex for a specific terrain? This would also help
        //   with building shadowing other buildings.
        // AO shadows might be handled by this too. But:
        // this seems to need a lot of additional copying (paint shadow on a clean map for this level alone; soften up; copy to real shadow
        // map with clipping area active; get new clean shadow map for next shadowed level;
        // too much hassle currently; it works so beautifully
<span class="nc bnc" id="L1443" title="All 2 branches missed.">        if (!GUIPreferences.getInstance().getShadowMap()) return;</span>

<span class="nc" id="L1445">        IBoard board = game.getBoard();</span>
<span class="nc bnc" id="L1446" title="All 2 branches missed.">        if (board == null) return;</span>
<span class="nc bnc" id="L1447" title="All 2 branches missed.">        if (board.inSpace()) return;</span>
<span class="nc bnc" id="L1448" title="All 2 branches missed.">        if (boardSize == null) updateBoardSize();</span>
<span class="nc bnc" id="L1449" title="All 2 branches missed.">        if (!isTileImagesLoaded()) return;</span>
        // Map editor? No shadows
<span class="nc bnc" id="L1451" title="All 2 branches missed.">        if (game.getPhase() == IGame.Phase.PHASE_UNKNOWN) return;</span>

<span class="nc" id="L1453">        long stT = System.nanoTime();</span>

        // 1) create or get the hex shadow
<span class="nc" id="L1456">        Image hexShadow = createBlurredShadow(tileManager.getHexMask());</span>
<span class="nc bnc" id="L1457" title="All 2 branches missed.">        if (hexShadow == null) {</span>
<span class="nc" id="L1458">            repaint(1000);</span>
<span class="nc" id="L1459">            return;</span>
        }


        // the shadowmap needs to be painted as if scale == 1
        // therefore some of the methods of boardview1 cannot be used
<span class="nc" id="L1465">        int width = game.getBoard().getWidth() * HEX_WC + (HEX_W / 4);</span>
<span class="nc" id="L1466">        int height = game.getBoard().getHeight() * HEX_H + (HEX_H / 2);</span>

        GraphicsConfiguration config = GraphicsEnvironment
<span class="nc" id="L1469">                .getLocalGraphicsEnvironment().getDefaultScreenDevice()</span>
<span class="nc" id="L1470">                .getDefaultConfiguration();</span>

<span class="nc" id="L1472">        shadowMap = config.createCompatibleImage(width, height,</span>
                Transparency.TRANSLUCENT);

<span class="nc" id="L1475">        Graphics2D g = shadowMap.createGraphics();</span>

<span class="nc bnc" id="L1477" title="All 2 branches missed.">        if ((game.getPlanetaryConditions().getLight() == PlanetaryConditions.L_MOONLESS) ||</span>
<span class="nc bnc" id="L1478" title="All 2 branches missed.">                (game.getPlanetaryConditions().getLight() == PlanetaryConditions.L_PITCH_BLACK)) {</span>
<span class="nc" id="L1479">            lightDirection = new double[]{0, 0};</span>
<span class="nc bnc" id="L1480" title="All 2 branches missed.">        } else if (game.getPlanetaryConditions().getLight() == PlanetaryConditions.L_DUSK) {</span>
            // TODO: replace when made user controlled
<span class="nc" id="L1482">            lightDirection = new double[]{-38, 14};</span>
        } else {
<span class="nc" id="L1484">            lightDirection = new double[]{-19, 7};</span>
        }

        // Shadows for elevation
<span class="nc" id="L1488">        HashMap&lt;Integer, Set&lt;Coords&gt;&gt; sortedHexes = new HashMap&lt;Integer, Set&lt;Coords&gt;&gt;();</span>
<span class="nc" id="L1489">        HashMap&lt;Integer, Set&lt;Coords&gt;&gt; shadowCastingHexes = createShadowcastingHexes(board, sortedHexes);</span>

        // 2) Create clipping areas
<span class="nc" id="L1492">        HashMap&lt;Integer, Shape&gt; levelClips = createLevelClips(sortedHexes);</span>

        // 3) Find all level differences
<span class="nc" id="L1495">        final int maxDiff = 35; // limit all diffs to this value</span>
<span class="nc" id="L1496">        Set&lt;Integer&gt; lDiffs = getLevelDifferences(board, levelClips, maxDiff);</span>

        // 4) Elevation Shadow images for all level differences present
<span class="nc" id="L1499">        Map&lt;Integer, BufferedImage&gt; hS = elevationShadow(hexShadow, config, lDiffs);</span>

        // 5) Actually draw the elevation shadows
<span class="nc" id="L1502">        drawElevationShaddows(board, g, shadowCastingHexes, levelClips, maxDiff, hS);</span>

        // 6) woods and bulding shadows
<span class="nc" id="L1505">        woodsAndBuildingShadows(board, g, sortedHexes, levelClips);</span>

<span class="nc" id="L1507">        long tT5 = System.nanoTime() - stT;</span>
<span class="nc" id="L1508">        MegaMek.getLogger().info(&quot;Time to prepare the shadow map: &quot; + tT5 / 1e6 + &quot; ms&quot;);</span>
<span class="nc" id="L1509">    }</span>

    private void woodsAndBuildingShadows(IBoard board, Graphics2D g, HashMap&lt;Integer, Set&lt;Coords&gt;&gt; sortedHexes, HashMap&lt;Integer, Shape&gt; levelClips) {
<span class="nc" id="L1512">        int n = 5;</span>
<span class="nc" id="L1513">        double deltaX = lightDirection[0] / n;</span>
<span class="nc" id="L1514">        double deltaY = lightDirection[1] / n;</span>
<span class="nc" id="L1515">        for (int shadowed = board.getMinElevation();</span>
<span class="nc bnc" id="L1516" title="All 2 branches missed.">             shadowed &lt;= board.getMaxElevation();</span>
<span class="nc" id="L1517">             shadowed++) {</span>
<span class="nc bnc" id="L1518" title="All 2 branches missed.">            if (levelClips.get(shadowed) == null) continue;</span>

<span class="nc" id="L1520">            Shape saveClip = g.getClip();</span>
<span class="nc" id="L1521">            g.setClip(levelClips.get(shadowed));</span>

<span class="nc" id="L1523">            for (int shadowcaster = board.getMinElevation();</span>
<span class="nc bnc" id="L1524" title="All 2 branches missed.">                 shadowcaster &lt;= board.getMaxElevation();</span>
<span class="nc" id="L1525">                 shadowcaster++) {</span>
<span class="nc bnc" id="L1526" title="All 2 branches missed.">                if (levelClips.get(shadowcaster) == null) continue;</span>

<span class="nc bnc" id="L1528" title="All 2 branches missed.">                for (Coords c : sortedHexes.get(shadowcaster)) {</span>
<span class="nc" id="L1529">                    Point2D p0 = getHexLocationLargeTile(c.getX(), c.getY(), 1);</span>
<span class="nc" id="L1530">                    Point2D p1 = new Point2D.Double();</span>

                    // Woods Shadow
<span class="nc" id="L1533">                    IHex hex = board.getHex(c);</span>
<span class="nc" id="L1534">                    List&lt;Image&gt; supers = tileManager.supersFor(hex);</span>

<span class="nc bnc" id="L1536" title="All 2 branches missed.">                    if (woodsAndBuildingShadows(g, n, deltaX, deltaY, shadowed, shadowcaster, p0, p1, hex, supers)) return;</span>

                    // Bridge Shadow
<span class="nc bnc" id="L1539" title="All 2 branches missed.">                    if (!hex.containsTerrain(Terrains.BRIDGE)) {</span>
<span class="nc" id="L1540">                        continue;</span>
                    }
<span class="nc" id="L1542">                    supers = tileManager.orthoFor(hex);</span>
<span class="nc bnc" id="L1543" title="All 2 branches missed.">                    if (supers.isEmpty()) break;</span>
<span class="nc" id="L1544">                    Image maskB = createBlurredShadow(supers.get(supers.size() - 1));</span>
<span class="nc bnc" id="L1545" title="All 2 branches missed.">                    if (maskB == null) {</span>
<span class="nc" id="L1546">                        clearShadowMap();</span>
<span class="nc" id="L1547">                        return;</span>
                    }
<span class="nc" id="L1549">                    int h = hex.terrainLevel(Terrains.BRIDGE_ELEV);</span>
<span class="nc" id="L1550">                    p1.setLocation(p0.getX() + deltaX * n * (shadowcaster + h - shadowed),</span>
<span class="nc" id="L1551">                            p0.getY() + deltaY * n * (shadowcaster + h - shadowed));</span>
                    // the shadowmask is translucent, therefore draw n times
                    // stupid hack
<span class="nc bnc" id="L1554" title="All 2 branches missed.">                    for (int i = 0; i &lt; n; i++)</span>
<span class="nc" id="L1555">                        g.drawImage(maskB, (int) p1.getX(), (int) p1.getY(), null);</span>
<span class="nc" id="L1556">                }</span>
            }
<span class="nc" id="L1558">            g.setClip(saveClip);</span>
        }
<span class="nc" id="L1560">    }</span>

    private boolean woodsAndBuildingShadows(Graphics2D g, int n, double deltaX, double deltaY, int shadowed, int shadowcaster, Point2D p0, Point2D p1, IHex hex, List&lt;Image&gt; supers) {
<span class="nc bnc" id="L1563" title="All 2 branches missed.">        if (!supers.isEmpty()) {</span>
<span class="nc" id="L1564">            Image lastSuper = createBlurredShadow(supers.get(supers.size() - 1));</span>
<span class="nc bnc" id="L1565" title="All 2 branches missed.">            if (lastSuper == null) {</span>
<span class="nc" id="L1566">                clearShadowMap();</span>
<span class="nc" id="L1567">                return true;</span>
            }
<span class="nc bnc" id="L1569" title="All 2 branches missed.">            if (hex.containsTerrain(Terrains.WOODS) ||</span>
<span class="nc bnc" id="L1570" title="All 2 branches missed.">                    hex.containsTerrain(Terrains.JUNGLE)) {</span>
                // Woods are 2 levels high, but then shadows
                // appear very extreme, therefore only
                // 1.5 levels: (shadowcaster+1.5-shadowed)
<span class="nc" id="L1574">                double shadowHeight = .75 * hex.terrainLevel(Terrains.FOLIAGE_ELEV);</span>
<span class="nc" id="L1575">                p1.setLocation(p0);</span>
<span class="nc bnc" id="L1576" title="All 2 branches missed.">                if ((shadowcaster + shadowHeight - shadowed) &gt; 0) {</span>
<span class="nc bnc" id="L1577" title="All 2 branches missed.">                    for (int i = 0; i &lt; n * (shadowcaster + shadowHeight - shadowed); i++) {</span>
<span class="nc" id="L1578">                        g.drawImage(lastSuper, (int) p1.getX(), (int) p1.getY(), null);</span>
<span class="nc" id="L1579">                        p1.setLocation(p1.getX() + deltaX, p1.getY() + deltaY);</span>
                    }
                }
            }


            // Buildings Shadow
<span class="nc bnc" id="L1586" title="All 2 branches missed.">            if (hex.containsTerrain(Terrains.BUILDING)) {</span>
<span class="nc" id="L1587">                int h = hex.terrainLevel(Terrains.BLDG_ELEV);</span>
<span class="nc bnc" id="L1588" title="All 2 branches missed.">                if ((shadowcaster + h - shadowed) &gt; 0) {</span>
<span class="nc" id="L1589">                    p1.setLocation(p0);</span>
<span class="nc bnc" id="L1590" title="All 2 branches missed.">                    for (int i = 0; i &lt; (n * (shadowcaster + h - shadowed)); i++) {</span>
<span class="nc" id="L1591">                        g.drawImage(lastSuper, (int) p1.getX(), (int) p1.getY(), null);</span>
<span class="nc" id="L1592">                        p1.setLocation(p1.getX() + deltaX, p1.getY() + deltaY);</span>
                    }
                }
            }
        }
<span class="nc" id="L1597">        return false;</span>
    }

    private void drawElevationShaddows(IBoard board, Graphics2D g, HashMap&lt;Integer, Set&lt;Coords&gt;&gt; shadowCastingHexes, HashMap&lt;Integer, Shape&gt; levelClips, int maxDiff, Map&lt;Integer, BufferedImage&gt; hS) {
<span class="nc" id="L1601">        for (int shadowed = board.getMinElevation();</span>
<span class="nc bnc" id="L1602" title="All 2 branches missed.">             shadowed &lt; board.getMaxElevation();</span>
<span class="nc" id="L1603">             shadowed++) {</span>
<span class="nc bnc" id="L1604" title="All 2 branches missed.">            if (levelClips.get(shadowed) == null) continue;</span>

<span class="nc" id="L1606">            Shape saveClip = g.getClip();</span>
<span class="nc" id="L1607">            g.setClip(levelClips.get(shadowed));</span>

<span class="nc" id="L1609">            for (int shadowcaster = shadowed + 1;</span>
<span class="nc bnc" id="L1610" title="All 2 branches missed.">                 shadowcaster &lt;= board.getMaxElevation();</span>
<span class="nc" id="L1611">                 shadowcaster++) {</span>
<span class="nc bnc" id="L1612" title="All 2 branches missed.">                if (levelClips.get(shadowcaster) == null) continue;</span>
<span class="nc" id="L1613">                int lDiff = shadowcaster - shadowed;</span>

<span class="nc bnc" id="L1615" title="All 2 branches missed.">                for (Coords c : shadowCastingHexes.get(shadowcaster)) {</span>
<span class="nc" id="L1616">                    Point2D p0 = getHexLocationLargeTile(c.getX(), c.getY(), 1);</span>
<span class="nc" id="L1617">                    g.drawImage(hS.get(Math.min(lDiff, maxDiff)),</span>
<span class="nc" id="L1618">                            (int) p0.getX() - (int) (Math.abs(lightDirection[0]) * Math.min(lDiff, maxDiff) + HEX_W),</span>
<span class="nc" id="L1619">                            (int) p0.getY() - (int) (Math.abs(lightDirection[1]) * Math.min(lDiff, maxDiff) + HEX_H), null);</span>
<span class="nc" id="L1620">                }</span>
            }
<span class="nc" id="L1622">            g.setClip(saveClip);</span>
        }
<span class="nc" id="L1624">    }</span>

    private Map&lt;Integer, BufferedImage&gt; elevationShadow(Image hexShadow, GraphicsConfiguration config, Set&lt;Integer&gt; lDiffs) {
<span class="nc" id="L1627">        int n = 10;</span>
<span class="nc" id="L1628">        double deltaX = lightDirection[0] / n;</span>
<span class="nc" id="L1629">        double deltaY = lightDirection[1] / n;</span>
<span class="nc" id="L1630">        Map&lt;Integer, BufferedImage&gt; hS = new HashMap&lt;Integer, BufferedImage&gt;();</span>
<span class="nc bnc" id="L1631" title="All 2 branches missed.">        for (int lDiff : lDiffs) {</span>
<span class="nc" id="L1632">            Dimension eSize = new Dimension(</span>
<span class="nc" id="L1633">                    (int) (Math.abs(lightDirection[0]) * lDiff + HEX_W) * 2,</span>
<span class="nc" id="L1634">                    (int) (Math.abs(lightDirection[1]) * lDiff + HEX_H) * 2);</span>

<span class="nc" id="L1636">            BufferedImage elevShadow = config.createCompatibleImage(eSize.width, eSize.height,</span>
                    Transparency.TRANSLUCENT);
<span class="nc" id="L1638">            Graphics gS = elevShadow.getGraphics();</span>
<span class="nc" id="L1639">            Point2D p1 = new Point2D.Double(eSize.width / 2, eSize.height / 2);</span>
<span class="nc bnc" id="L1640" title="All 2 branches missed.">            if (GUIPreferences.getInstance().getHexInclines()) {</span>
                // With inclines, the level 1 shadows are only very slight
<span class="nc" id="L1642">                int beg = 4;</span>
<span class="nc" id="L1643">                p1.setLocation(p1.getX() + deltaX * beg, p1.getY() + deltaY * beg);</span>
<span class="nc bnc" id="L1644" title="All 2 branches missed.">                for (int i = beg; i &lt; n * (lDiff - 0.4); i++) {</span>
<span class="nc" id="L1645">                    gS.drawImage(hexShadow, (int) p1.getX(), (int) p1.getY(), null);</span>
<span class="nc" id="L1646">                    p1.setLocation(p1.getX() + deltaX, p1.getY() + deltaY);</span>
                }
<span class="nc" id="L1648">            } else {</span>
<span class="nc bnc" id="L1649" title="All 2 branches missed.">                for (int i = 0; i &lt; n * lDiff; i++) {</span>
<span class="nc" id="L1650">                    gS.drawImage(hexShadow, (int) p1.getX(), (int) p1.getY(), null);</span>
<span class="nc" id="L1651">                    p1.setLocation(p1.getX() + deltaX, p1.getY() + deltaY);</span>
                }

            }
<span class="nc" id="L1655">            gS.dispose();</span>
<span class="nc" id="L1656">            hS.put(lDiff, elevShadow);</span>
<span class="nc" id="L1657">        }</span>
<span class="nc" id="L1658">        return hS;</span>
    }

    private Set&lt;Integer&gt; getLevelDifferences(IBoard board, HashMap&lt;Integer, Shape&gt; levelClips, int maxDiff) {
<span class="nc" id="L1662">        Set&lt;Integer&gt; lDiffs = new TreeSet&lt;Integer&gt;();</span>
<span class="nc" id="L1663">        for (int shadowed = board.getMinElevation();</span>
<span class="nc bnc" id="L1664" title="All 2 branches missed.">             shadowed &lt; board.getMaxElevation();</span>
<span class="nc" id="L1665">             shadowed++) {</span>
<span class="nc bnc" id="L1666" title="All 2 branches missed.">            if (levelClips.get(shadowed) == null) continue;</span>

<span class="nc" id="L1668">            for (int shadowcaster = shadowed + 1;</span>
<span class="nc bnc" id="L1669" title="All 2 branches missed.">                 shadowcaster &lt;= board.getMaxElevation();</span>
<span class="nc" id="L1670">                 shadowcaster++) {</span>
<span class="nc bnc" id="L1671" title="All 2 branches missed.">                if (levelClips.get(shadowcaster) == null) continue;</span>

<span class="nc" id="L1673">                lDiffs.add(Math.min(shadowcaster - shadowed, maxDiff));</span>
            }
        }
<span class="nc" id="L1676">        return lDiffs;</span>
    }

    private HashMap&lt;Integer, Shape&gt; createLevelClips(HashMap&lt;Integer, Set&lt;Coords&gt;&gt; sortedHexes) {
<span class="nc" id="L1680">        HashMap&lt;Integer, Shape&gt; levelClips = new HashMap&lt;Integer, Shape&gt;();</span>
<span class="nc bnc" id="L1681" title="All 2 branches missed.">        for (Integer h : sortedHexes.keySet()) {</span>
<span class="nc" id="L1682">            Path2D path = new Path2D.Float();</span>
<span class="nc bnc" id="L1683" title="All 2 branches missed.">            for (Coords c : sortedHexes.get(h)) {</span>
<span class="nc" id="L1684">                Point p = getHexLocationLargeTile(c.getX(), c.getY(), 1);</span>
<span class="nc" id="L1685">                AffineTransform t = AffineTransform.getTranslateInstance(p.x + HEX_W / 2, p.y + HEX_H / 2);</span>
<span class="nc" id="L1686">                t.scale(1.02, 1.02);</span>
<span class="nc" id="L1687">                t.translate(-HEX_W / 2, -HEX_H / 2);</span>
<span class="nc" id="L1688">                path.append(t.createTransformedShape(hexPoly), false);</span>
<span class="nc" id="L1689">            }</span>
<span class="nc" id="L1690">            levelClips.put(h, path);</span>
<span class="nc" id="L1691">        }</span>
<span class="nc" id="L1692">        return levelClips;</span>
    }

    private HashMap&lt;Integer, Set&lt;Coords&gt;&gt; createShadowcastingHexes(IBoard board, HashMap&lt;Integer, Set&lt;Coords&gt;&gt; sortedHexes) {
        // 1a) Sort the board hexes by elevation
        // 1b) Create a reduced list of shadowcasting hexes
<span class="nc" id="L1698">        HashMap&lt;Integer, Set&lt;Coords&gt;&gt; shadowCastingHexes = new HashMap&lt;Integer, Set&lt;Coords&gt;&gt;();</span>
<span class="nc" id="L1699">        double angle = Math.atan2(-lightDirection[1], lightDirection[0]);</span>
<span class="nc" id="L1700">        int mDir = (int) (0.5 + 1.5 - angle / Math.PI * 3); // +0.5 to counter the (int)</span>
<span class="nc" id="L1701">        int[] sDirs = {mDir % 6, (mDir + 1) % 6, (mDir + 5) % 6};</span>
<span class="nc bnc" id="L1702" title="All 2 branches missed.">        for (Coords c : allBoardHexes()) {</span>
<span class="nc" id="L1703">            IHex hex = board.getHex(c);</span>
<span class="nc" id="L1704">            int level = hex.getLevel();</span>
<span class="nc bnc" id="L1705" title="All 2 branches missed.">            if (!sortedHexes.containsKey(level)) { // no hexes yet for this height</span>
<span class="nc" id="L1706">                sortedHexes.put(level, new HashSet&lt;Coords&gt;());</span>
            }
<span class="nc bnc" id="L1708" title="All 2 branches missed.">            if (!shadowCastingHexes.containsKey(level)) { // no hexes yet for this height</span>
<span class="nc" id="L1709">                shadowCastingHexes.put(level, new HashSet&lt;Coords&gt;());</span>
            }
<span class="nc" id="L1711">            sortedHexes.get(level).add(c);</span>
            // add a hex to the shadowcasting hexes only
            // if it is nor surrounded by same height hexes
<span class="nc" id="L1714">            boolean surrounded = true;</span>
<span class="nc bnc" id="L1715" title="All 2 branches missed.">            for (int dir : sDirs) {</span>
<span class="nc bnc" id="L1716" title="All 2 branches missed.">                if (!board.contains(c.translated(dir))) {</span>
<span class="nc" id="L1717">                    surrounded = false;</span>
                } else {
<span class="nc" id="L1719">                    IHex nhex = board.getHex(c.translated(dir));</span>
<span class="nc" id="L1720">                    int lv = nhex.getLevel();</span>
<span class="nc bnc" id="L1721" title="All 2 branches missed.">                    if (lv &lt; level)</span>
<span class="nc" id="L1722">                        surrounded = false;</span>
                }
            }
<span class="nc bnc" id="L1725" title="All 2 branches missed.">            if (!surrounded) shadowCastingHexes.get(level).add(c);</span>
<span class="nc" id="L1726">        }</span>
<span class="nc" id="L1727">        return shadowCastingHexes;</span>
    }

    public void clearShadowMap() {
<span class="nc" id="L1731">        shadowMap = null;</span>
<span class="nc" id="L1732">    }</span>

    /**
     * Updates the boardSize variable with the proper values for this board.
     */
    private void updateBoardSize() {
<span class="fc" id="L1738">        int width = (game.getBoard().getWidth() * (int) (HEX_WC * scale))</span>
                + (int) ((HEX_W / 4) * scale);
<span class="fc" id="L1740">        int height = (game.getBoard().getHeight() * (int) (HEX_H * scale))</span>
                + (int) ((HEX_H / 2) * scale);
<span class="fc" id="L1742">        boardSize = new Dimension(width, height);</span>
<span class="fc" id="L1743">    }</span>

    /**
     * Looks through a vector of buffered images and draws them if they're
     * onscreen.
     */
    private synchronized void drawSprites(Graphics g,
                                          Collection&lt;? extends Sprite&gt; spriteArrayList) {
<span class="nc bnc" id="L1751" title="All 2 branches missed.">        for (Sprite sprite : spriteArrayList) {</span>
<span class="nc" id="L1752">            drawSprite(g, sprite);</span>
<span class="nc" id="L1753">        }</span>
<span class="nc" id="L1754">    }</span>

    private synchronized void drawHexSpritesForHex(Coords c, Graphics g,
                                                   ArrayList&lt;? extends HexSprite&gt; spriteArrayList) {
<span class="nc" id="L1758">        Rectangle view = g.getClipBounds();</span>

<span class="nc bnc" id="L1760" title="All 2 branches missed.">        for (HexSprite sprite : spriteArrayList) {</span>
<span class="nc" id="L1761">            Coords cp = sprite.getPosition();</span>
            // This can potentially be an expensive operation
<span class="nc" id="L1763">            Rectangle spriteBounds = sprite.getBounds();</span>
<span class="nc bnc" id="L1764" title="All 6 branches missed.">            if (cp.equals(c) &amp;&amp; view.intersects(spriteBounds) &amp;&amp; !sprite.isHidden()) {</span>
<span class="nc bnc" id="L1765" title="All 2 branches missed.">                if (!sprite.isReady()) {</span>
<span class="nc" id="L1766">                    sprite.prepare();</span>
                }
<span class="nc" id="L1768">                sprite.drawOnto(g, spriteBounds.x, spriteBounds.y,</span>
                        this, false);
            }
<span class="nc" id="L1771">        }</span>
<span class="nc" id="L1772">    }</span>

    /**
     * Draws the Entity for the given hex. This function is used by the
     * isometric rendering process so that sprites are drawn in the order that
     * hills are rendered to create the appearance that the sprite is behind the
     * hill.
     *
     * @param c               The Coordinates of the hex that the sprites should be drawn
     *                        for.
     * @param g               The Graphics object for this board.
     * @param spriteArrayList The complete list of all IsometricSprite on the board.
     */
    private synchronized void drawIsometricSpritesForHex(Coords c, Graphics g,
                                                         Collection&lt;IsometricSprite&gt; spriteArrayList) {
<span class="nc" id="L1787">        Rectangle view = g.getClipBounds();</span>
<span class="nc bnc" id="L1788" title="All 2 branches missed.">        for (IsometricSprite sprite : spriteArrayList) {</span>
<span class="nc" id="L1789">            Coords cp = sprite.getPosition();</span>
            // This can potentially be an expensive operation
<span class="nc" id="L1791">            Rectangle spriteBounds = sprite.getBounds();</span>
<span class="nc bnc" id="L1792" title="All 4 branches missed.">            if (cp.equals(c) &amp;&amp; view.intersects(spriteBounds)</span>
<span class="nc bnc" id="L1793" title="All 2 branches missed.">                    &amp;&amp; !sprite.isHidden()) {</span>
<span class="nc bnc" id="L1794" title="All 2 branches missed.">                if (!sprite.isReady()) {</span>
<span class="nc" id="L1795">                    sprite.prepare();</span>
                }
<span class="nc" id="L1797">                sprite.drawOnto(g, spriteBounds.x, spriteBounds.y, this, false);</span>
            }
<span class="nc" id="L1799">        }</span>
<span class="nc" id="L1800">    }</span>

    /**
     * Draws the wrecksprites for the given hex. This function is used by the
     * isometric rendering process so that sprites are drawn in the order that
     * hills are rendered to create the appearance that the sprite is behind the
     * hill.
     *
     * @param c               The Coordinates of the hex that the sprites should be drawn
     *                        for.
     * @param g               The Graphics object for this board.
     * @param spriteArrayList The complete list of all IsometricSprite on the board.
     */
    private synchronized void drawIsometricWreckSpritesForHex(Coords c,
                                                              Graphics g, ArrayList&lt;IsometricWreckSprite&gt; spriteArrayList) {
<span class="nc" id="L1815">        Rectangle view = g.getClipBounds();</span>
<span class="nc bnc" id="L1816" title="All 2 branches missed.">        for (IsometricWreckSprite sprite : spriteArrayList) {</span>
<span class="nc" id="L1817">            Coords cp = sprite.getPosition();</span>
<span class="nc bnc" id="L1818" title="All 4 branches missed.">            if (cp.equals(c) &amp;&amp; view.intersects(sprite.getBounds())</span>
<span class="nc bnc" id="L1819" title="All 2 branches missed.">                    &amp;&amp; !sprite.isHidden()) {</span>
<span class="nc bnc" id="L1820" title="All 2 branches missed.">                if (!sprite.isReady()) {</span>
<span class="nc" id="L1821">                    sprite.prepare();</span>
                }
<span class="nc" id="L1823">                sprite.drawOnto(g, sprite.getBounds().x, sprite.getBounds().y,</span>
                        this, false);
            }
<span class="nc" id="L1826">        }</span>
<span class="nc" id="L1827">    }</span>

    /**
     * Draws a translucent sprite without any of the companion graphics, if it
     * is in the current view. This is used only when performing isometric
     * rending. This function is used to show units (with 50% transparency) that
     * are hidden behind a hill.
     * &lt;p/&gt;
     * TODO: Optimize this function so that it is only applied to sprites that
     * are actually hidden. This implementation performs the second rendering
     * for all sprites.
     */
    private final void drawIsometricSprites(Graphics g,
                                            Collection&lt;IsometricSprite&gt; spriteArrayList) {
<span class="nc" id="L1841">        Rectangle view = g.getClipBounds();</span>
<span class="nc bnc" id="L1842" title="All 2 branches missed.">        for (IsometricSprite sprite : spriteArrayList) {</span>
            // This can potentially be an expensive operation
<span class="nc" id="L1844">            Rectangle spriteBounds = sprite.getBounds();</span>
<span class="nc bnc" id="L1845" title="All 4 branches missed.">            if (view.intersects(spriteBounds) &amp;&amp; !sprite.isHidden()) {</span>
<span class="nc bnc" id="L1846" title="All 2 branches missed.">                if (!sprite.isReady()) {</span>
<span class="nc" id="L1847">                    sprite.prepare();</span>
                }
<span class="nc" id="L1849">                sprite.drawOnto(g, spriteBounds.x, spriteBounds.y,</span>
                        this, true);
            }
<span class="nc" id="L1852">        }</span>
<span class="nc" id="L1853">    }</span>

    /**
     * Draws a sprite, if it is in the current view
     */
    private final void drawSprite(Graphics g, Sprite sprite) {
<span class="nc" id="L1859">        Rectangle view = g.getClipBounds();</span>
        // This can potentially be an expensive operation
<span class="nc" id="L1861">        Rectangle spriteBounds = sprite.getBounds();</span>
<span class="nc bnc" id="L1862" title="All 4 branches missed.">        if (view.intersects(spriteBounds) &amp;&amp; !sprite.isHidden()) {</span>
<span class="nc bnc" id="L1863" title="All 2 branches missed.">            if (!sprite.isReady()) {</span>
<span class="nc" id="L1864">                sprite.prepare();</span>
            }
<span class="nc" id="L1866">            sprite.drawOnto(g, spriteBounds.x, spriteBounds.y, this);</span>
        }
<span class="nc" id="L1868">    }</span>

    /**
     * Darkens a hexes in the viewing area if there is no line of sight between
     * them and the supplied source hex. Used in non-isometric view.
     *
     * @param p
     *            The source hex for which line of sight originates
     * @param g
     *            The graphics object to draw on.
     * @param col
     *            The what color to use.
     * @param outOfFOV
     *            The destination hex for computing the line of sight
     */

    /**
     * Draw an outline around legal deployment hexes
     */
    private void drawDeployment(Graphics g) {
<span class="nc" id="L1888">        Rectangle view = g.getClipBounds();</span>
        // only update visible hexes
<span class="nc" id="L1890">        int drawX = (view.x / (int) (HEX_WC * scale)) - 1;</span>
<span class="nc" id="L1891">        int drawY = (view.y / (int) (HEX_H * scale)) - 1;</span>

<span class="nc" id="L1893">        int drawWidth = (view.width / (int) (HEX_WC * scale)) + 3;</span>
<span class="nc" id="L1894">        int drawHeight = (view.height / (int) (HEX_H * scale)) + 3;</span>

<span class="nc" id="L1896">        IBoard board = game.getBoard();</span>
        // loop through the hexes
<span class="nc bnc" id="L1898" title="All 2 branches missed.">        for (int i = 0; i &lt; drawHeight; i++) {</span>
<span class="nc bnc" id="L1899" title="All 2 branches missed.">            for (int j = 0; j &lt; drawWidth; j++) {</span>
<span class="nc" id="L1900">                Coords c = new Coords(j + drawX, i + drawY);</span>
<span class="nc bnc" id="L1901" title="All 2 branches missed.">                if (board.isLegalDeployment(c, en_Deployer.getStartingPos())) {</span>
<span class="nc" id="L1902">                    drawHexBorder(g, getHexLocation(c), Color.yellow);</span>
                }
            }
        }
<span class="nc" id="L1906">    }</span>

    /**
     * Draw indicators for the deployment zones of all players
     */
    private void drawAllDeployment(Graphics g) {
<span class="nc" id="L1912">        Rectangle view = g.getClipBounds();</span>
        // only update visible hexes
<span class="nc" id="L1914">        int drawX = (view.x / (int) (HEX_WC * scale)) - 1;</span>
<span class="nc" id="L1915">        int drawY = (view.y / (int) (HEX_H * scale)) - 1;</span>

<span class="nc" id="L1917">        int drawWidth = (view.width / (int) (HEX_WC * scale)) + 3;</span>
<span class="nc" id="L1918">        int drawHeight = (view.height / (int) (HEX_H * scale)) + 3;</span>

<span class="nc" id="L1920">        IBoard board = game.getBoard();</span>
        // loop through the hexes
<span class="nc bnc" id="L1922" title="All 2 branches missed.">        for (int i = 0; i &lt; drawHeight; i++) {</span>
<span class="nc bnc" id="L1923" title="All 2 branches missed.">            for (int j = 0; j &lt; drawWidth; j++) {</span>
<span class="nc" id="L1924">                Coords c = new Coords(j + drawX, i + drawY);</span>
<span class="nc" id="L1925">                Enumeration&lt;IPlayer&gt; allP = game.getPlayers();</span>
                IPlayer cp;
<span class="nc" id="L1927">                int pCount = 0;</span>
<span class="nc" id="L1928">                int bThickness = 1 + 10 / game.getNoOfPlayers();</span>
                // loop through all players
<span class="nc bnc" id="L1930" title="All 2 branches missed.">                while (allP.hasMoreElements()) {</span>
<span class="nc" id="L1931">                    cp = allP.nextElement();</span>
<span class="nc bnc" id="L1932" title="All 2 branches missed.">                    if (board.isLegalDeployment(c, cp.getStartingPos())) {</span>
<span class="nc" id="L1933">                        Color bC = cp.getColour().getColour();</span>
<span class="nc" id="L1934">                        drawHexBorder(g, getHexLocation(c), bC, (bThickness + 2)</span>
                                * pCount, bThickness);
<span class="nc" id="L1936">                        pCount++;</span>
<span class="nc" id="L1937">                    }</span>
                }
            }
        }
<span class="nc" id="L1941">    }</span>

    /**
     * Draw a layer of a solid color (alpha possible) on the hex at Point p no
     * padding by default
     */
    void drawHexLayer(Point p, Graphics g, Color col, boolean outOfFOV) {
<span class="nc" id="L1948">        drawHexLayer(p, g, col, outOfFOV, 0);</span>
<span class="nc" id="L1949">    }</span>

    /**
     * Draw a layer of a solid color (alpha possible) on the hex at Point p with
     * some padding around the border
     */
    private void drawHexLayer(Point p, Graphics g, Color col, boolean outOfFOV,
                              double pad) {
<span class="nc" id="L1957">        Graphics2D g2D = (Graphics2D) g;</span>
<span class="nc" id="L1958">        g.setColor(col);</span>

        // create stripe effect for FOV darkening but not for colored weapon
        // ranges
<span class="nc" id="L1962">        int fogStripes = GUIPreferences.getInstance().getFovStripes();</span>
<span class="nc bnc" id="L1963" title="All 6 branches missed.">        if (outOfFOV &amp;&amp; (fogStripes &gt; 0) &amp;&amp; (g instanceof Graphics2D)) {</span>
<span class="nc" id="L1964">            float lineSpacing = fogStripes;</span>
            // totally transparent here hurts the eyes
<span class="nc" id="L1966">            Color c2 = new Color(col.getRed() / 2, col.getGreen() / 2,</span>
<span class="nc" id="L1967">                    col.getBlue() / 2, col.getAlpha() / 2);</span>

            // the numbers make the lines align across hexes
<span class="nc" id="L1970">            GradientPaint gp = new GradientPaint(42.0f / lineSpacing, 0.0f,</span>
                    col, 104.0f / lineSpacing, 106.0f / lineSpacing, c2, true);
<span class="nc" id="L1972">            g2D.setPaint(gp);</span>
        }
<span class="nc" id="L1974">        Composite svComposite = g2D.getComposite();</span>
<span class="nc" id="L1975">        g2D.setComposite(AlphaComposite.SrcAtop);</span>
<span class="nc" id="L1976">        g2D.fillRect(0, 0, hex_size.width, hex_size.height);</span>
<span class="nc" id="L1977">        g2D.setComposite(svComposite);</span>
<span class="nc" id="L1978">    }</span>

    private void drawHexBorder(Graphics g, Color col, double pad,
                               double linewidth) {
<span class="nc" id="L1982">        drawHexBorder(g, new Point(0, 0), col, pad, linewidth);</span>
<span class="nc" id="L1983">    }</span>

    public void drawHexBorder(Graphics g, Point p, Color col, double pad,
                              double linewidth) {
<span class="nc" id="L1987">        g.setColor(col);</span>
<span class="nc" id="L1988">        ((Graphics2D) g).fill(</span>
<span class="nc" id="L1989">                AffineTransform.getTranslateInstance(p.x, p.y).createTransformedShape(</span>
<span class="nc" id="L1990">                        AffineTransform.getScaleInstance(scale, scale).createTransformedShape(</span>
<span class="nc" id="L1991">                                HexDrawUtilities.getHexFullBorderArea(linewidth, pad))));</span>
<span class="nc" id="L1992">    }</span>

    /**
     * Draw an outline around the hex at Point p no padding and a width of 1
     */
    private void drawHexBorder(Graphics g, Point p, Color col) {
<span class="nc" id="L1998">        drawHexBorder(g, p, col, 0);</span>
<span class="nc" id="L1999">    }</span>

    /**
     * Draw an outline around the hex at Point p padded around the border by pad
     * and a line-width of 1
     */
    private void drawHexBorder(Graphics g, Point p, Color col, double pad) {
<span class="nc" id="L2006">        drawHexBorder(g, p, col, pad, 1);</span>
<span class="nc" id="L2007">    }</span>

    /*
     * NOTENOTENOTE: (itmo) wouldnt this be simpler with two arrays. One with
     * the strings {&quot;BoardView1.thunderblaablaa&quot;,&quot;BoardView1.Conventi..&quot;} one
     * with the offsets {51,51,42} etc Preferably indexed by an enum: enum{
     * Conventional, Thunder; } or something?
     */

    /**
     * returns the weapon selected in the mech display, or null if none selected
     * or it is not artillery or null if the selected entity is not owned
     */
    public Mounted getSelectedArtilleryWeapon() {
        // We don't want to display artillery auto-hit/adjusted fire hexes
        // during
        // the artyautohithexes phase. These could be displayed if the player
        // uses the /reset command in some situations
<span class="nc bnc" id="L2025" title="All 2 branches missed.">        if (game.getPhase() == IGame.Phase.PHASE_SET_ARTYAUTOHITHEXES) {</span>
<span class="nc" id="L2026">            return null;</span>
        }

<span class="nc bnc" id="L2029" title="All 4 branches missed.">        if ((selectedEntity == null) || (selectedWeapon == null)) {</span>
<span class="nc" id="L2030">            return null;</span>
        }

<span class="nc bnc" id="L2033" title="All 2 branches missed.">        if (!selectedEntity.getOwner().equals(localPlayer)) {</span>
<span class="nc" id="L2034">            return null; // Not my business to see this</span>
        }

<span class="nc bnc" id="L2037" title="All 2 branches missed.">        if (selectedEntity.getEquipmentNum(selectedWeapon) == -1) {</span>
<span class="nc" id="L2038">            return null; // inconsistent state - weapon not on entity</span>
        }

<span class="nc bnc" id="L2041" title="All 2 branches missed.">        if (!((selectedWeapon.getType() instanceof WeaponType) &amp;&amp; selectedWeapon</span>
<span class="nc bnc" id="L2042" title="All 2 branches missed.">                .getType().hasFlag(WeaponType.F_ARTILLERY))) {</span>
<span class="nc" id="L2043">            return null; // not artillery</span>
        }

        // otherwise, a weapon is selected, and it is artillery
<span class="nc" id="L2047">        return selectedWeapon;</span>
    }

    /**
     * Display artillery modifier in pretargeted hexes
     */
    private void drawArtilleryHexes(Graphics g) {
<span class="nc" id="L2054">        Mounted weapon = getSelectedArtilleryWeapon();</span>
<span class="nc" id="L2055">        Rectangle view = g.getClipBounds();</span>

        // Compute the origin of the viewing area
<span class="nc" id="L2058">        int drawX = (view.x / (int) (HEX_WC * scale)) - 1;</span>
<span class="nc" id="L2059">        int drawY = (view.y / (int) (HEX_H * scale)) - 1;</span>

        // Compute size of viewing area
<span class="nc" id="L2062">        int drawWidth = (view.width / (int) (HEX_WC * scale)) + 3;</span>
<span class="nc" id="L2063">        int drawHeight = (view.height / (int) (HEX_H * scale)) + 3;</span>

        Image artyIconImage;

        // Draw incoming artillery sprites - requires server to update client's
        // view of game
<span class="nc" id="L2069">        for (Enumeration&lt;ArtilleryAttackAction&gt; attacks = game.getArtilleryAttacks();</span>
<span class="nc bnc" id="L2070" title="All 2 branches missed.">             attacks.hasMoreElements(); ) {</span>
<span class="nc" id="L2071">            final ArtilleryAttackAction attack = attacks.nextElement();</span>
<span class="nc" id="L2072">            final Targetable target = attack.getTarget(game);</span>
<span class="nc bnc" id="L2073" title="All 2 branches missed.">            if (target == null) {</span>
<span class="nc" id="L2074">                continue;</span>
            }
<span class="nc" id="L2076">            final Coords c = target.getPosition();</span>
            // Is the Coord within the viewing area?
<span class="nc bnc" id="L2078" title="All 4 branches missed.">            if ((c.getX() &gt;= drawX) &amp;&amp; (c.getX() &lt;= (drawX + drawWidth))</span>
<span class="nc bnc" id="L2079" title="All 4 branches missed.">                    &amp;&amp; (c.getY() &gt;= drawY) &amp;&amp; (c.getY() &lt;= (drawY + drawHeight))) {</span>
<span class="nc" id="L2080">                Point p = getHexLocation(c);</span>
<span class="nc" id="L2081">                artyIconImage = tileManager.getArtilleryTarget(TilesetManager.ARTILLERY_INCOMING);</span>
<span class="nc" id="L2082">                g.drawImage(getScaledImage(artyIconImage, true), p.x, p.y, this);</span>
            }
<span class="nc" id="L2084">        }</span>

        // Draw pre-designated auto-hit hexes
<span class="nc bnc" id="L2087" title="All 2 branches missed.">        if (localPlayer != null) { // Could be null, like in map-editor</span>
<span class="nc bnc" id="L2088" title="All 2 branches missed.">            for (Coords c : localPlayer.getArtyAutoHitHexes()) {</span>
                // Is the Coord within the viewing area?
<span class="nc bnc" id="L2090" title="All 4 branches missed.">                if ((c.getX() &gt;= drawX) &amp;&amp; (c.getX() &lt;= (drawX + drawWidth))</span>
<span class="nc bnc" id="L2091" title="All 4 branches missed.">                        &amp;&amp; (c.getY() &gt;= drawY) &amp;&amp; (c.getY() &lt;= (drawY + drawHeight))) {</span>

<span class="nc" id="L2093">                    Point p = getHexLocation(c);</span>
<span class="nc" id="L2094">                    artyIconImage = tileManager.getArtilleryTarget(TilesetManager.ARTILLERY_AUTOHIT);</span>
<span class="nc" id="L2095">                    g.drawImage(getScaledImage(artyIconImage, true), p.x, p.y, this);</span>
                }
<span class="nc" id="L2097">            }</span>
        }

        // Draw modifiers for selected entity and weapon
<span class="nc bnc" id="L2101" title="All 2 branches missed.">        if (weapon != null) {</span>
            // Loop through all of the attack modifiers for this weapon
<span class="nc bnc" id="L2103" title="All 2 branches missed.">            for (ArtilleryTracker.ArtilleryModifier attackMod : selectedEntity.aTracker</span>
<span class="nc" id="L2104">                    .getWeaponModifiers(weapon)) {</span>
<span class="nc" id="L2105">                Coords c = attackMod.getCoords();</span>
                // Is the Coord within the viewing area?
<span class="nc bnc" id="L2107" title="All 4 branches missed.">                if ((c.getX() &gt;= drawX) &amp;&amp; (c.getX() &lt;= (drawX + drawWidth))</span>
<span class="nc bnc" id="L2108" title="All 4 branches missed.">                        &amp;&amp; (c.getY() &gt;= drawY) &amp;&amp; (c.getY() &lt;= (drawY + drawHeight))) {</span>

<span class="nc" id="L2110">                    Point p = getHexLocation(c);</span>
                    // draw the crosshairs
<span class="nc bnc" id="L2112" title="All 2 branches missed.">                    if (attackMod.getModifier() == TargetRoll.AUTOMATIC_SUCCESS) {</span>
                        // predesignated or already hit
<span class="nc" id="L2114">                        artyIconImage = tileManager</span>
<span class="nc" id="L2115">                                .getArtilleryTarget(TilesetManager.ARTILLERY_AUTOHIT);</span>
                    } else {
<span class="nc" id="L2117">                        artyIconImage = tileManager</span>
<span class="nc" id="L2118">                                .getArtilleryTarget(TilesetManager.ARTILLERY_ADJUSTED);</span>
                    }
<span class="nc" id="L2120">                    g.drawImage(getScaledImage(artyIconImage, true), p.x, p.y, this);</span>
                }
<span class="nc" id="L2122">            }</span>
        }
<span class="nc" id="L2124">    }</span>

    /**
     * Writes &quot;MINEFIELD&quot; in minefield hexes...
     */
    private void drawMinefields(Graphics g) {
<span class="nc" id="L2130">        Rectangle view = g.getClipBounds();</span>
        // only update visible hexes
<span class="nc" id="L2132">        int drawX = (view.x / (int) (HEX_WC * scale)) - 1;</span>
<span class="nc" id="L2133">        int drawY = (view.y / (int) (HEX_H * scale)) - 1;</span>

<span class="nc" id="L2135">        int drawWidth = (view.width / (int) (HEX_WC * scale)) + 3;</span>
<span class="nc" id="L2136">        int drawHeight = (view.height / (int) (HEX_H * scale)) + 3;</span>

<span class="nc" id="L2138">        int maxX = drawX + drawWidth;</span>
<span class="nc" id="L2139">        int maxY = drawY + drawHeight;</span>

<span class="nc" id="L2141">        IBoard board = game.getBoard();</span>
<span class="nc" id="L2142">        for (Enumeration&lt;Coords&gt; minedCoords = game.getMinedCoords();</span>
<span class="nc bnc" id="L2143" title="All 2 branches missed.">             minedCoords.hasMoreElements(); ) {</span>
<span class="nc" id="L2144">            Coords c = minedCoords.nextElement();</span>
            // If the coords aren't visible, skip
<span class="nc bnc" id="L2146" title="All 8 branches missed.">            if ((c.getX() &lt; drawX) || (c.getX() &gt; maxX) || (c.getY() &lt; drawY) || (c.getY() &gt; maxY)</span>
<span class="nc bnc" id="L2147" title="All 2 branches missed.">                    || !board.contains(c)) {</span>
<span class="nc" id="L2148">                continue;</span>
            }

<span class="nc" id="L2151">            Point p = getHexLocation(c);</span>
<span class="nc" id="L2152">            Image mineImg = getScaledImage(tileManager.getMinefieldSign(), true);</span>
<span class="nc" id="L2153">            g.drawImage(mineImg, p.x + (int) (13 * scale), p.y</span>
                    + (int) (13 * scale), this);

<span class="nc" id="L2156">            g.setColor(Color.black);</span>
<span class="nc" id="L2157">            int nbrMfs = game.getNbrMinefields(c);</span>
<span class="nc bnc" id="L2158" title="All 2 branches missed.">            if (nbrMfs &gt; 1) {</span>
<span class="nc" id="L2159">                drawCenteredString(</span>
<span class="nc" id="L2160">                        Messages.getString(&quot;BoardView1.Multiple&quot;), //$NON-NLS-1$</span>
                        p.x, p.y + (int) (51 * scale), font_minefield, g);
<span class="nc bnc" id="L2162" title="All 2 branches missed.">            } else if (nbrMfs == 1) {</span>
<span class="nc" id="L2163">                Minefield mf = game.getMinefields(c).get(0);</span>

<span class="nc bnc" id="L2165" title="All 6 branches missed.">                switch (mf.getType()) {</span>
                    case (Minefield.TYPE_CONVENTIONAL):
<span class="nc" id="L2167">                        drawCenteredString(</span>
<span class="nc" id="L2168">                                Messages.getString(&quot;BoardView1.Conventional&quot;) //$NON-NLS-1$</span>
<span class="nc" id="L2169">                                        + mf.getDensity() + &quot;)&quot;, //$NON-NLS-1$</span>
                                p.x, p.y + (int) (51 * scale),
                                font_minefield, g);
<span class="nc" id="L2172">                        break;</span>
                    case (Minefield.TYPE_INFERNO):
<span class="nc" id="L2174">                        drawCenteredString(</span>
<span class="nc" id="L2175">                                Messages.getString(&quot;BoardView1.Inferno&quot;) //$NON-NLS-1$</span>
<span class="nc" id="L2176">                                        + mf.getDensity() + &quot;)&quot;, //$NON-NLS-1$</span>
                                p.x, p.y + (int) (51 * scale),
                                font_minefield, g);
<span class="nc" id="L2179">                        break;</span>
                    case (Minefield.TYPE_ACTIVE):
<span class="nc" id="L2181">                        drawCenteredString(</span>
<span class="nc" id="L2182">                                Messages.getString(&quot;BoardView1.Active&quot;) //$NON-NLS-1$</span>
<span class="nc" id="L2183">                                        + mf.getDensity() + &quot;)&quot;,  //$NON-NLS-2$</span>
                                p.x, p.y + (int) (51 * scale),
                                font_minefield, g);
<span class="nc" id="L2186">                        break;</span>
                    case (Minefield.TYPE_COMMAND_DETONATED):
<span class="nc" id="L2188">                        drawCenteredString(</span>
<span class="nc" id="L2189">                                Messages.getString(&quot;BoardView1.Command-&quot;), //$NON-NLS-1$</span>
                                p.x, p.y + (int) (51 * scale),
                                font_minefield, g);
<span class="nc" id="L2192">                        drawCenteredString(</span>
<span class="nc" id="L2193">                                Messages.getString(&quot;BoardView1.detonated&quot; //$NON-NLS-1$</span>
<span class="nc" id="L2194">                                        + mf.getDensity() + &quot;)&quot;), //$NON-NLS-1$</span>
                                p.x, p.y + (int) (60 * scale),
                                font_minefield, g);
<span class="nc" id="L2197">                        break;</span>
                    case (Minefield.TYPE_VIBRABOMB):
<span class="nc" id="L2199">                        drawCenteredString(</span>
<span class="nc" id="L2200">                                Messages.getString(&quot;BoardView1.Vibrabomb&quot;), //$NON-NLS-1$</span>
                                p.x, p.y + (int) (51 * scale),
                                font_minefield, g);
<span class="nc bnc" id="L2203" title="All 2 branches missed.">                        if (mf.getPlayerId() == localPlayer.getId()) {</span>
<span class="nc" id="L2204">                            drawCenteredString(&quot;(&quot; //$NON-NLS-1$</span>
<span class="nc" id="L2205">                                            + mf.getSetting() + &quot;)&quot;, //$NON-NLS-1$</span>
                                    p.x, p.y + (int) (60 * scale),
                                    font_minefield, g);
                        }
                        break;
                }
            }
<span class="nc" id="L2212">        }</span>
<span class="nc" id="L2213">    }</span>

    private void drawCenteredString(String string, int x, int y, Font font,
                                    Graphics graph) {
<span class="nc" id="L2217">        FontMetrics currentMetrics = getFontMetrics(font);</span>
<span class="nc" id="L2218">        int stringWidth = currentMetrics.stringWidth(string);</span>

<span class="nc" id="L2220">        x += ((hex_size.width - stringWidth) / 2);</span>

<span class="nc" id="L2222">        graph.setFont(font);</span>
<span class="nc" id="L2223">        graph.drawString(string, x, y);</span>
<span class="nc" id="L2224">    }</span>

    /**
     * This method creates an image the size of the entire board (all
     * mapsheets), draws the hexes onto it, and returns that image.
     */
    public BufferedImage getEntireBoardImage(boolean ignoreUnits) {
        // Set zoom to base, so we get a consist board image

<span class="nc" id="L2233">        int oldZoom = zoomIndex;</span>
<span class="nc" id="L2234">        zoomIndex = BASE_ZOOM_INDEX;</span>
<span class="nc" id="L2235">        zoom();</span>

<span class="nc" id="L2237">        Image entireBoard = createImage(boardSize.width, boardSize.height);</span>
<span class="nc" id="L2238">        Graphics2D boardGraph = (Graphics2D) entireBoard.getGraphics();</span>
<span class="nc" id="L2239">        boardGraph.setClip(0, 0, boardSize.width, boardSize.height);</span>
<span class="nc bnc" id="L2240" title="All 2 branches missed.">        if (GUIPreferences.getInstance().getAntiAliasing()) {</span>
<span class="nc" id="L2241">            boardGraph.setRenderingHint(RenderingHints.KEY_ANTIALIASING,</span>
                    RenderingHints.VALUE_ANTIALIAS_ON);
        }

<span class="nc bnc" id="L2245" title="All 2 branches missed.">        if (shadowMap == null) {</span>
<span class="nc" id="L2246">            updateShadowMap();</span>
        }

        // Draw hexes
<span class="nc" id="L2250">        drawHexes(boardGraph, new Rectangle(boardSize), ignoreUnits);</span>

        // If we aren't ignoring units, draw everything else
<span class="nc bnc" id="L2253" title="All 2 branches missed.">        if (!ignoreUnits) {</span>
            // draw wrecks
<span class="nc bnc" id="L2255" title="All 2 branches missed.">            if (GUIPreferences.getInstance().getShowWrecks()</span>
<span class="nc bnc" id="L2256" title="All 2 branches missed.">                    &amp;&amp; !useIsometric()) {</span>
<span class="nc" id="L2257">                drawSprites(boardGraph, wreckSprites);</span>
            }

            // Field of Fire
<span class="nc bnc" id="L2261" title="All 2 branches missed.">            if (!useIsometric()</span>
<span class="nc bnc" id="L2262" title="All 2 branches missed.">                    &amp;&amp; GUIPreferences.getInstance().getShowFieldOfFire()) {</span>
<span class="nc" id="L2263">                drawSprites(boardGraph, fieldofFireSprites);</span>
            }

<span class="nc bnc" id="L2266" title="All 4 branches missed.">            if ((game.getPhase() == Phase.PHASE_MOVEMENT) &amp;&amp; !useIsometric()) {</span>
<span class="nc" id="L2267">                drawSprites(boardGraph, moveEnvSprites);</span>
<span class="nc" id="L2268">                drawSprites(boardGraph, moveModEnvSprites);</span>
            }

            // Minefield signs all over the place!
<span class="nc" id="L2272">            drawMinefields(boardGraph);</span>

            // Artillery targets
<span class="nc" id="L2275">            drawArtilleryHexes(boardGraph);</span>

            // draw highlight border
<span class="nc" id="L2278">            drawSprite(boardGraph, highlightSprite);</span>

            // draw cursors
<span class="nc" id="L2281">            drawSprite(boardGraph, cursorSprite);</span>
<span class="nc" id="L2282">            drawSprite(boardGraph, selectedSprite);</span>
<span class="nc" id="L2283">            drawSprite(boardGraph, firstLOSSprite);</span>
<span class="nc" id="L2284">            drawSprite(boardGraph, secondLOSSprite);</span>

            // draw deployment indicators.
            // For Isometric rendering, this is done during drawHexes
<span class="nc bnc" id="L2288" title="All 4 branches missed.">            if ((en_Deployer != null) &amp;&amp; !useIsometric()) {</span>
<span class="nc" id="L2289">                drawDeployment(boardGraph);</span>
            }

<span class="nc bnc" id="L2292" title="All 4 branches missed.">            if ((game.getPhase() == IGame.Phase.PHASE_SET_ARTYAUTOHITHEXES)</span>
                    &amp;&amp; (showAllDeployment)) {
<span class="nc" id="L2294">                drawAllDeployment(boardGraph);</span>
            }

            // draw Flare Sprites
<span class="nc" id="L2298">            drawSprites(boardGraph, flareSprites);</span>

            // draw C3 links
<span class="nc" id="L2301">            drawSprites(boardGraph, c3Sprites);</span>

            // draw flyover routes
<span class="nc bnc" id="L2304" title="All 2 branches missed.">            if (game.getBoard().onGround()) {</span>
<span class="nc" id="L2305">                drawSprites(boardGraph, vtolAttackSprites);</span>
<span class="nc" id="L2306">                drawSprites(boardGraph, flyOverSprites);</span>
            }

            // draw onscreen entities
<span class="nc" id="L2310">            drawSprites(boardGraph, entitySprites);</span>

            // draw moving onscreen entities
<span class="nc" id="L2313">            drawSprites(boardGraph, movingEntitySprites);</span>

            // draw ghost onscreen entities
<span class="nc" id="L2316">            drawSprites(boardGraph, ghostEntitySprites);</span>

            // draw onscreen attacks
<span class="nc" id="L2319">            drawSprites(boardGraph, attackSprites);</span>

            // draw movement vectors.
<span class="nc bnc" id="L2322" title="All 2 branches missed.">            if (game.useVectorMove()</span>
<span class="nc bnc" id="L2323" title="All 2 branches missed.">                    &amp;&amp; (game.getPhase() == IGame.Phase.PHASE_MOVEMENT)) {</span>
<span class="nc" id="L2324">                drawSprites(boardGraph, movementSprites);</span>
            }

            // draw movement, if valid
<span class="nc" id="L2328">            drawSprites(boardGraph, pathSprites);</span>

            // draw firing solution sprites, but only during the firing phase
<span class="nc bnc" id="L2331" title="All 2 branches missed.">            if ((game.getPhase() == Phase.PHASE_FIRING) ||</span>
<span class="nc bnc" id="L2332" title="All 2 branches missed.">                    (game.getPhase() == Phase.PHASE_OFFBOARD)) {</span>
<span class="nc" id="L2333">                drawSprites(boardGraph, firingSprites);</span>
            }

<span class="nc bnc" id="L2336" title="All 2 branches missed.">            if (game.getPhase() == Phase.PHASE_FIRING) {</span>
<span class="nc bnc" id="L2337" title="All 2 branches missed.">                for (Coords c : strafingCoords) {</span>
<span class="nc" id="L2338">                    drawHexBorder(boardGraph, getHexLocation(c), Color.yellow, 0, 3);</span>
<span class="nc" id="L2339">                }</span>
            }
        }
<span class="nc" id="L2342">        boardGraph.dispose();</span>

        // Restore the zoom setting
<span class="nc" id="L2345">        zoomIndex = oldZoom;</span>
<span class="nc" id="L2346">        zoom();</span>

<span class="nc" id="L2348">        return (BufferedImage) entireBoard;</span>
    }

    private void drawHexes(Graphics g, Rectangle view) {
<span class="nc" id="L2352">        drawHexes(g, view, false);</span>
<span class="nc" id="L2353">    }</span>

    /**
     * Redraws all hexes in the specified rectangle
     */
    private void drawHexes(Graphics g, Rectangle view, boolean saveBoardImage) {
        // only update visible hexes
<span class="nc" id="L2360">        double xs = (int) (HEX_WC * scale);</span>
<span class="nc" id="L2361">        double ys = (int) (HEX_H * scale);</span>

<span class="nc" id="L2363">        int drawX = (int) (view.x / xs) - 1;</span>
<span class="nc" id="L2364">        int drawY = (int) (view.y / ys) - 1;</span>

<span class="nc" id="L2366">        int drawWidth = (int) (view.width / xs) + 3;</span>
<span class="nc" id="L2367">        int drawHeight = (int) (view.height / ys) + 3;</span>

        // draw some hexes.
<span class="nc bnc" id="L2370" title="All 2 branches missed.">        if (!useIsometric()) {</span>
            // Draw hexes without regard to elevation when
            // not using Isometric, since it does not matter.
<span class="nc bnc" id="L2373" title="All 2 branches missed.">            for (int i = 0; i &lt; drawHeight; i++) {</span>
<span class="nc bnc" id="L2374" title="All 2 branches missed.">                for (int j = 0; j &lt; drawWidth; j++) {</span>
<span class="nc" id="L2375">                    Coords c = new Coords(j + drawX, i + drawY);</span>
<span class="nc" id="L2376">                    drawHex(c, g, saveBoardImage);</span>
                }
            }
<span class="nc" id="L2379">            return;</span>
        }
<span class="nc" id="L2381">        IBoard board = game.getBoard();</span>
<span class="nc bnc" id="L2382" title="All 2 branches missed.">        for (int y = 0; y &lt; drawHeight; y++) {</span>
            // Half of each row is one-half hex
            // farther back (above) the other; draw those first
<span class="nc bnc" id="L2385" title="All 2 branches missed.">            for (int s = 0; s &lt;= 1; s++) {</span>
<span class="nc bnc" id="L2386" title="All 2 branches missed.">                for (int x = s; x &lt; drawWidth + s + 1; x = x + 2) {</span>
                    // For s == 0 the x coordinate MUST be an even number
                    // to get correct occlusion; drawX may be any int though
<span class="nc" id="L2389">                    Coords c = new Coords(x + drawX / 2 * 2, y + drawY);</span>
<span class="nc" id="L2390">                    IHex hex = board.getHex(c);</span>
<span class="nc bnc" id="L2391" title="All 2 branches missed.">                    if ((hex == null)) {</span>
<span class="nc" id="L2392">                        continue;</span>
                    }
<span class="nc" id="L2394">                    drawHex(c, g, saveBoardImage);</span>
<span class="nc" id="L2395">                    if (GUIPreferences.getInstance()</span>
<span class="nc bnc" id="L2396" title="All 2 branches missed.">                            .getShowFieldOfFire()) {</span>
<span class="nc" id="L2397">                        drawHexSpritesForHex(c, g, fieldofFireSprites);</span>
                    }
<span class="nc" id="L2399">                    drawHexSpritesForHex(c, g, moveEnvSprites);</span>
<span class="nc" id="L2400">                    drawHexSpritesForHex(c, g, moveModEnvSprites);</span>
<span class="nc bnc" id="L2401" title="All 2 branches missed.">                    if ((en_Deployer != null)</span>
<span class="nc bnc" id="L2402" title="All 2 branches missed.">                            &amp;&amp; board.isLegalDeployment(c, en_Deployer.getStartingPos())) {</span>
<span class="nc" id="L2403">                        drawHexBorder(g, getHexLocation(c), Color.yellow);</span>
                    }
<span class="nc" id="L2405">                    drawOrthograph(c, g);</span>
                }
            }
<span class="nc bnc" id="L2408" title="All 2 branches missed.">            for (int x = 0; x &lt; drawWidth; x++) {</span>
<span class="nc" id="L2409">                Coords c = new Coords(x + drawX, y + drawY);</span>
<span class="nc" id="L2410">                IHex hex = board.getHex(c);</span>
<span class="nc bnc" id="L2411" title="All 4 branches missed.">                if (hex == null || saveBoardImage) {</span>
<span class="nc" id="L2412">                    continue;</span>
                }
<span class="nc bnc" id="L2414" title="All 2 branches missed.">                if (GUIPreferences.getInstance().getShowWrecks()) {</span>
<span class="nc" id="L2415">                    drawIsometricWreckSpritesForHex(c, g, isometricWreckSprites);</span>
                }
<span class="nc" id="L2417">                drawIsometricSpritesForHex(c, g, isometricSprites);</span>
            }
        }
<span class="nc bnc" id="L2420" title="All 2 branches missed.">        if (!saveBoardImage) {</span>
            // If we are using Isometric rendering, redraw the entity
            // sprites at 50% transparent so sprites hidden behind hills can
            // still be seen by the user.
<span class="nc" id="L2424">            drawIsometricSprites(g, isometricSprites);</span>
        }
<span class="nc" id="L2426">    }</span>

    /**
     * Draws a hex onto the board buffer. This assumes that drawRect is current,
     * and does not check if the hex is visible.
     */
    private void drawHex(Coords c, Graphics boardGraph,
                         boolean saveBoardImage) {
<span class="nc bnc" id="L2434" title="All 2 branches missed.">        if (!game.getBoard().contains(c)) {</span>
<span class="nc" id="L2435">            return;</span>
        }

<span class="nc" id="L2438">        final GUIPreferences guip = GUIPreferences.getInstance();</span>
<span class="nc" id="L2439">        final IHex hex = game.getBoard().getHex(c);</span>
<span class="nc" id="L2440">        final Point hexLoc = getHexLocation(c);</span>

        // Check the cache to see if we already have the image
<span class="nc" id="L2443">        HexImageCacheEntry cacheEntry = hexImageCache.get(c);</span>
<span class="nc bnc" id="L2444" title="All 4 branches missed.">        if ((cacheEntry != null) &amp;&amp; !cacheEntry.needsUpdating) {</span>
<span class="nc" id="L2445">            boardGraph.drawImage(cacheEntry.hexImage, hexLoc.x, hexLoc.y, this);</span>
<span class="nc" id="L2446">            return;</span>
        }

<span class="nc" id="L2449">        Image boardBgHexImg = getBoardBackgroundHexImage(c, hex);</span>
        // get the base tile image
        Image baseImage, scaledImage;
<span class="nc bnc" id="L2452" title="All 2 branches missed.">        if (boardBgHexImg != null) {</span>
<span class="nc" id="L2453">            baseImage = boardBgHexImg;</span>
<span class="nc" id="L2454">            scaledImage = boardBgHexImg;</span>
        } else {
<span class="nc" id="L2456">            baseImage = tileManager.baseFor(hex);</span>
<span class="nc" id="L2457">            scaledImage = getScaledImage(baseImage, true);</span>
        }

        // Some hex images shouldn't be cached, like if they are animated
<span class="nc" id="L2461">        boolean dontCache = animatedImages.contains(baseImage.hashCode());</span>

        // check if this is a standard tile image 84x72 or something different
<span class="nc bnc" id="L2464" title="All 2 branches missed.">        boolean standardTile = (baseImage.getHeight(null) == HEX_H)</span>
<span class="nc bnc" id="L2465" title="All 2 branches missed.">                &amp;&amp; (baseImage.getWidth(null) == HEX_W);</span>

<span class="nc" id="L2467">        int imgWidth = Math.min(scaledImage.getWidth(null), (int) (HEX_W * scale));</span>
<span class="nc" id="L2468">        int imgHeight = Math.min(scaledImage.getHeight(null), (int) (HEX_H * scale));</span>
<span class="nc" id="L2469">        imgHeight += getIsometricImgHeight(c, hex);</span>

        // If the base image isn't ready, we should signal a repaint and stop
<span class="nc bnc" id="L2472" title="All 4 branches missed.">        if ((imgWidth &lt; 0) || (imgHeight &lt; 0)) {</span>
<span class="nc" id="L2473">            repaint();</span>
<span class="nc" id="L2474">            return;</span>
        }

<span class="nc" id="L2477">        BufferedImage hexImage = new BufferedImage(imgWidth, imgHeight,</span>
                BufferedImage.TYPE_INT_ARGB);

<span class="nc" id="L2480">        Graphics2D g = drawImage(c, scaledImage, standardTile, hexImage);</span>

        // To place roads under the shadow map, supers for hexes with roads
        // have to be drawn before the shadow map, otherwise the supers are
        // drawn after.  Unfortunately I dont think the supers images
        // themselves can be checked for roads.
<span class="nc bnc" id="L2486" title="All 4 branches missed.">        if (hex.containsTerrain(Terrains.ROAD) || hex.containsTerrain(Terrains.WATER)) {</span>
<span class="nc" id="L2487">            dontCache = drawSupers(dontCache, g, hex);</span>
<span class="nc" id="L2488">            addTerrainAndBuildingShadows(c, g);</span>
        } else {
<span class="nc" id="L2490">            addTerrainAndBuildingShadows(c, g);</span>
<span class="nc" id="L2491">            dontCache = drawSupers(dontCache, g, hex);</span>
        }

        // AO Hex Shadow in this hex when a higher one is adjacent
<span class="nc bnc" id="L2495" title="All 2 branches missed.">        if (guip.getBoolean(GUIPreferences.AOHEXSHADOWS)) {</span>
<span class="nc bnc" id="L2496" title="All 2 branches missed.">            for (int dir : allDirections) {</span>
<span class="nc" id="L2497">                Shape ShadowShape = getElevationShadowArea(c, dir);</span>
<span class="nc" id="L2498">                GradientPaint gpl = getElevationShadowGP(c, dir);</span>
<span class="nc bnc" id="L2499" title="All 4 branches missed.">                if (ShadowShape != null &amp;&amp; gpl != null) {</span>
<span class="nc" id="L2500">                    g.setPaint(gpl);</span>
<span class="nc" id="L2501">                    g.fill(getElevationShadowArea(c, dir));</span>
                }
            }
        }

        // Orthos (bridges)
<span class="nc" id="L2507">        dontCache = drawOrthos(hex, dontCache, g);</span>

<span class="nc" id="L2509">        shadeHexes(c, g);</span>

<span class="nc" id="L2511">        highlightHexes(c, g);</span>

        // Darken the hex for night-time, if applicable
<span class="nc" id="L2514">        darkenHex(c, guip, hexImage);</span>

        // Set the text color according to Preferences or Light Gray in space
<span class="nc" id="L2517">        g.setColor(guip.getMapTextColor());</span>
<span class="nc bnc" id="L2518" title="All 2 branches missed.">        if (game.getBoard().inSpace()) {</span>
<span class="nc" id="L2519">            g.setColor(Color.LIGHT_GRAY);</span>
        }

        // draw special stuff for the hex
        try {
<span class="nc" id="L2524">            drawSpecials(c, g);</span>
<span class="nc" id="L2525">        } catch (Exception e) {</span>
<span class="nc" id="L2526">            MegaMek.getLogger().error(&quot;Exception, probably can't load file.&quot;, e);</span>
<span class="nc" id="L2527">            drawCenteredString(&quot;Loading Error&quot;, 0, (int) (50 * scale), font_note, g);</span>
<span class="nc" id="L2528">            return;</span>
<span class="nc" id="L2529">        }</span>

        // write hex coordinate unless deactivated or scale factor too small
<span class="nc bnc" id="L2532" title="All 4 branches missed.">        if (guip.getBoolean(GUIPreferences.ADVANCED_SHOW_COORDS) &amp;&amp; (scale &gt;= 0.5)) {</span>
<span class="nc" id="L2533">            drawCenteredString(c.getBoardNum(), 0, (int) (12 * scale), font_hexnum, g);</span>
        }

<span class="nc bnc" id="L2536" title="All 4 branches missed.">        if (getDisplayInvalidHexInfo() &amp;&amp; !hex.isValid(null)) {</span>
<span class="nc" id="L2537">            Point hexCenter = new Point((int) (HEX_W / 2 * scale), (int) (HEX_H / 2 * scale));</span>
<span class="nc" id="L2538">            drawCenteredText(g, Messages.getString(&quot;BoardEditor.INVALID&quot;), hexCenter, Color.RED,</span>
                    false, new Font(SansSerif, Font.BOLD, 14));
        }

        // write terrain level / water depth / building height
<span class="nc" id="L2543">        writeLevelDepthHeight(hex, g);</span>

<span class="nc" id="L2545">        drawElevationBorders(c, g);</span>

<span class="nc" id="L2547">        boolean hasLoS = fovHighlightingAndDarkening.draw(g, c, 0, 0,</span>
                saveBoardImage);

        // draw mapsheet borders
<span class="nc" id="L2551">        drawMapsheetBorders(c, g);</span>

<span class="nc bnc" id="L2553" title="All 4 branches missed.">        if (!hasLoS &amp;&amp; guip.getFovGrayscale()) {</span>
            // rework the pixels to grayscale
<span class="nc bnc" id="L2555" title="All 2 branches missed.">            for (int x = 0; x &lt; hexImage.getWidth(); ++x) {</span>
<span class="nc bnc" id="L2556" title="All 2 branches missed.">                for (int y = 0; y &lt; hexImage.getHeight(); ++y) {</span>
<span class="nc" id="L2557">                    int rgb = hexImage.getRGB(x, y);</span>
<span class="nc" id="L2558">                    int rd = (rgb &gt;&gt; 16) &amp; 0xFF;</span>
<span class="nc" id="L2559">                    int gr = (rgb &gt;&gt; 8) &amp; 0xFF;</span>
<span class="nc" id="L2560">                    int bl = (rgb &amp; 0xFF);</span>
<span class="nc" id="L2561">                    int al = (rgb &gt;&gt; 24);</span>

<span class="nc" id="L2563">                    int grayLevel = (rd + gr + bl) / 3;</span>
<span class="nc" id="L2564">                    int gray = (al &lt;&lt; 24) + (grayLevel &lt;&lt; 16) + (grayLevel &lt;&lt; 8) + grayLevel;</span>
<span class="nc" id="L2565">                    hexImage.setRGB(x, y, gray);</span>
                }
            }
        }

<span class="nc" id="L2570">        cacheEntry = new HexImageCacheEntry(hexImage);</span>
<span class="nc bnc" id="L2571" title="All 2 branches missed.">        if (!dontCache) {</span>
<span class="nc" id="L2572">            hexImageCache.put(c, cacheEntry);</span>
        }
<span class="nc" id="L2574">        boardGraph.drawImage(cacheEntry.hexImage, hexLoc.x, hexLoc.y, this);</span>
<span class="nc" id="L2575">    }</span>

    private float getIsometricImgHeight(Coords c, IHex hex) {
<span class="nc bnc" id="L2578" title="All 2 branches missed.">        if (!useIsometric()) {</span>
<span class="nc" id="L2579">            return 0;</span>
        }
<span class="nc" id="L2581">        int largestLevelDiff = 0;</span>
<span class="nc bnc" id="L2582" title="All 2 branches missed.">        for (int dir : allDirections) {</span>
<span class="nc" id="L2583">            IHex adjHex = game.getBoard().getHexInDir(c, dir);</span>
<span class="nc bnc" id="L2584" title="All 2 branches missed.">            if (adjHex == null) {</span>
<span class="nc" id="L2585">                continue;</span>
            }
<span class="nc" id="L2587">            int levelDiff = Math.abs(hex.getLevel() - adjHex.getLevel());</span>
<span class="nc bnc" id="L2588" title="All 2 branches missed.">            if (levelDiff &gt; largestLevelDiff) {</span>
<span class="nc" id="L2589">                largestLevelDiff = levelDiff;</span>
            }
        }
<span class="nc" id="L2592">        return HEX_ELEV * scale * largestLevelDiff;</span>
    }

    private void drawMapsheetBorders(Coords c, Graphics2D g) {
<span class="nc" id="L2596">        int s21 = (int) (21 * scale);</span>
<span class="nc" id="L2597">        int s71 = (int) (71 * scale);</span>
<span class="nc" id="L2598">        int s35 = (int) (35 * scale);</span>
<span class="nc" id="L2599">        int s36 = (int) (36 * scale);</span>
<span class="nc" id="L2600">        int s62 = (int) (62 * scale);</span>
<span class="nc" id="L2601">        int s83 = (int) (83 * scale);</span>

<span class="nc bnc" id="L2603" title="All 2 branches missed.">        if (!GUIPreferences.getInstance().getShowMapsheets()) {</span>
<span class="nc" id="L2604">            return;</span>
        }

<span class="nc" id="L2607">        g.setColor(GUIPreferences.getInstance().getColor(GUIPreferences.ADVANCED_MAPSHEET_COLOR));</span>
<span class="nc bnc" id="L2608" title="All 2 branches missed.">        if ((c.getX() % 16) == 0) {</span>
            // left edge of sheet (edge 4 &amp; 5)
<span class="nc" id="L2610">            g.drawLine(s21, s71, 0, s36);</span>
<span class="nc" id="L2611">            g.drawLine(0, s35, s21, 0);</span>
<span class="nc bnc" id="L2612" title="All 2 branches missed.">        } else if ((c.getX() % 16) == 15) {</span>
            // right edge of sheet (edge 1 &amp; 2)
<span class="nc" id="L2614">            g.drawLine(s62, 0, s83, s35);</span>
<span class="nc" id="L2615">            g.drawLine(s83, s36, s62, s71);</span>
        }
<span class="nc bnc" id="L2617" title="All 2 branches missed.">        if ((c.getY() % 17) == 0) {</span>
            // top edge of sheet (edge 0 and possible 1 &amp; 5)
<span class="nc" id="L2619">            g.drawLine(s21, 0, s62, 0);</span>
<span class="nc bnc" id="L2620" title="All 2 branches missed.">            if ((c.getX() % 2) == 0) {</span>
<span class="nc" id="L2621">                g.drawLine(s62, 0, s83, s35);</span>
<span class="nc" id="L2622">                g.drawLine(0, s35, s21, 0);</span>
            }
<span class="nc bnc" id="L2624" title="All 2 branches missed.">        } else if ((c.getY() % 17) == 16) {</span>
            // bottom edge of sheet (edge 3 and possible 2 &amp; 4)
<span class="nc" id="L2626">            g.drawLine(s62, s71, s21, s71);</span>
<span class="nc bnc" id="L2627" title="All 2 branches missed.">            if ((c.getX() % 2) == 1) {</span>
<span class="nc" id="L2628">                g.drawLine(s83, s36, s62, s71);</span>
<span class="nc" id="L2629">                g.drawLine(s21, s71, 0, s36);</span>
            }
        }
<span class="nc" id="L2632">    }</span>

    private void drawElevationBorders(Coords c, Graphics2D g) {
<span class="nc" id="L2635">        int s21 = (int) (21 * scale);</span>
<span class="nc" id="L2636">        int s71 = (int) (71 * scale);</span>
<span class="nc" id="L2637">        int s35 = (int) (35 * scale);</span>
<span class="nc" id="L2638">        int s36 = (int) (36 * scale);</span>
<span class="nc" id="L2639">        int s62 = (int) (62 * scale);</span>
<span class="nc" id="L2640">        int s83 = (int) (83 * scale);</span>

<span class="nc" id="L2642">        Point p1 = new Point(s62, 0);</span>
<span class="nc" id="L2643">        Point p2 = new Point(s21, 0);</span>
<span class="nc" id="L2644">        Point p3 = new Point(s83, s35);</span>
<span class="nc" id="L2645">        Point p4 = new Point(s83, s36);</span>
<span class="nc" id="L2646">        Point p5 = new Point(s62, s71);</span>
<span class="nc" id="L2647">        Point p6 = new Point(s21, s71);</span>
<span class="nc" id="L2648">        Point p7 = new Point(0, s36);</span>
<span class="nc" id="L2649">        Point p8 = new Point(0, s35);</span>

<span class="nc" id="L2651">        GUIPreferences guip = GUIPreferences.getInstance();</span>

<span class="nc" id="L2653">        g.setColor(Color.black);</span>
<span class="nc" id="L2654">        g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,</span>
                1f));

        // draw elevation borders
<span class="nc bnc" id="L2658" title="All 2 branches missed.">        if (drawElevationLine(c, 0)) {</span>
<span class="nc" id="L2659">            drawIsometricElevation(c, Color.GRAY, p1, p2, 0, g);</span>
<span class="nc bnc" id="L2660" title="All 2 branches missed.">            if (guip.getBoolean(GUIPreferences.LEVELHIGHLIGHT)) {</span>
<span class="nc" id="L2661">                g.drawLine(s21, 0, s62, 0);</span>
            }
        }

<span class="nc bnc" id="L2665" title="All 2 branches missed.">        if (drawElevationLine(c, 1)) {</span>
<span class="nc" id="L2666">            drawIsometricElevation(c, Color.DARK_GRAY, p3, p1, 1, g);</span>
<span class="nc bnc" id="L2667" title="All 2 branches missed.">            if (guip.getBoolean(GUIPreferences.LEVELHIGHLIGHT)) {</span>
<span class="nc" id="L2668">                g.drawLine(s62, 0, s83, s35);</span>
            }
        }

<span class="nc bnc" id="L2672" title="All 2 branches missed.">        if (drawElevationLine(c, 2)) {</span>
<span class="nc" id="L2673">            drawIsometricElevation(c, Color.LIGHT_GRAY, p4, p5, 2, g);</span>
<span class="nc bnc" id="L2674" title="All 2 branches missed.">            if (guip.getBoolean(GUIPreferences.LEVELHIGHLIGHT)) {</span>
<span class="nc" id="L2675">                g.drawLine(s83, s36, s62, s71);</span>
            }
        }

<span class="nc bnc" id="L2679" title="All 2 branches missed.">        if (drawElevationLine(c, 3)) {</span>
<span class="nc" id="L2680">            drawIsometricElevation(c, Color.GRAY, p6, p5, 3, g);</span>
<span class="nc bnc" id="L2681" title="All 2 branches missed.">            if (guip.getBoolean(GUIPreferences.LEVELHIGHLIGHT)) {</span>
<span class="nc" id="L2682">                g.drawLine(s62, s71, s21, s71);</span>
            }
        }

<span class="nc bnc" id="L2686" title="All 2 branches missed.">        if (drawElevationLine(c, 4)) {</span>
<span class="nc" id="L2687">            drawIsometricElevation(c, Color.DARK_GRAY, p7, p6, 4, g);</span>
<span class="nc bnc" id="L2688" title="All 2 branches missed.">            if (guip.getBoolean(GUIPreferences.LEVELHIGHLIGHT)) {</span>
<span class="nc" id="L2689">                g.drawLine(s21, s71, 0, s36);</span>
            }
        }

<span class="nc bnc" id="L2693" title="All 2 branches missed.">        if (drawElevationLine(c, 5)) {</span>
<span class="nc" id="L2694">            drawIsometricElevation(c, Color.LIGHT_GRAY, p8, p2, 5, g);</span>
<span class="nc bnc" id="L2695" title="All 2 branches missed.">            if (guip.getBoolean(GUIPreferences.LEVELHIGHLIGHT)) {</span>
<span class="nc" id="L2696">                g.drawLine(0, s35, s21, 0);</span>
            }

        }
<span class="nc" id="L2700">    }</span>

    private boolean drawOrthos(IHex hex, boolean dontCache, Graphics2D g) {
<span class="nc" id="L2703">        List&lt;Image&gt; orthos = tileManager.orthoFor(hex);</span>
<span class="nc bnc" id="L2704" title="All 2 branches missed.">        if (orthos == null) {</span>
<span class="nc" id="L2705">            return dontCache;</span>
        }
<span class="nc bnc" id="L2707" title="All 2 branches missed.">        for (Image image : orthos) {</span>
<span class="nc bnc" id="L2708" title="All 2 branches missed.">            if (animatedImages.contains(image.hashCode())) {</span>
<span class="nc" id="L2709">                dontCache = true;</span>
            }
<span class="nc" id="L2711">            Image scaledImage = getScaledImage(image, true);</span>
<span class="nc bnc" id="L2712" title="All 2 branches missed.">            if (!useIsometric()) {</span>
<span class="nc" id="L2713">                g.drawImage(scaledImage, 0, 0, this);</span>
            }
            // draw a shadow for bridge hex.
<span class="nc bnc" id="L2716" title="All 2 branches missed.">            if (useIsometric()</span>
<span class="nc bnc" id="L2717" title="All 2 branches missed.">                    &amp;&amp; !GUIPreferences.getInstance().getBoolean(GUIPreferences.SHADOWMAP)</span>
<span class="nc bnc" id="L2718" title="All 2 branches missed.">                    &amp;&amp; (hex.terrainLevel(Terrains.BRIDGE_ELEV) &gt; 0)) {</span>
<span class="nc" id="L2719">                Image shadow = createShadowMask(scaledImage);</span>
<span class="nc" id="L2720">                g.drawImage(shadow, 0, 0, this);</span>
            }
<span class="nc" id="L2722">        }</span>
<span class="nc" id="L2723">        return dontCache;</span>
    }

    private void drawSpecials(Coords c, Graphics2D g) {
<span class="nc" id="L2727">        final Collection&lt;SpecialHexDisplay&gt; shdList = game.getBoard().getSpecialHexDisplay(c);</span>
<span class="nc bnc" id="L2728" title="All 2 branches missed.">        if (shdList == null) {</span>
<span class="nc" id="L2729">            return;</span>
        }
<span class="nc bnc" id="L2731" title="All 2 branches missed.">        for (SpecialHexDisplay shd : shdList) {</span>
<span class="nc bnc" id="L2732" title="All 2 branches missed.">            if (shd.drawNow(game.getPhase(), game.getRoundCount(), localPlayer)) {</span>
<span class="nc" id="L2733">                Image scaledImage = getScaledImage(shd.getType().getDefaultImage(), true);</span>
<span class="nc" id="L2734">                g.drawImage(scaledImage, 0, 0, this);</span>
            }
<span class="nc" id="L2736">        }</span>
<span class="nc" id="L2737">    }</span>

    private void darkenHex(Coords c, GUIPreferences guip, BufferedImage hexImage) {
<span class="nc bnc" id="L2740" title="All 2 branches missed.">        if (guip.getBoolean(GUIPreferences.ADVANCED_DARKEN_MAP_AT_NIGHT)</span>
<span class="nc bnc" id="L2741" title="All 2 branches missed.">                &amp;&amp; (game.isPositionIlluminated(c) == IGame.ILLUMINATED_NONE)</span>
<span class="nc bnc" id="L2742" title="All 2 branches missed.">                &amp;&amp; (game.getPlanetaryConditions().getLight() &gt; PlanetaryConditions.L_DAY)) {</span>
<span class="nc bnc" id="L2743" title="All 2 branches missed.">            for (int x = 0; x &lt; hexImage.getWidth(); ++x) {</span>
<span class="nc bnc" id="L2744" title="All 2 branches missed.">                for (int y = 0; y &lt; hexImage.getHeight(); ++y) {</span>
<span class="nc" id="L2745">                    hexImage.setRGB(x, y, getNightDarkenedColor(hexImage.getRGB(x, y)));</span>
                }
            }
        }
<span class="nc" id="L2749">    }</span>

    private void highlightHexes(Coords c, Graphics2D g) {
        // Highlight hexes that contain the source of an ECM field
<span class="nc bnc" id="L2753" title="All 2 branches missed.">        if (ecmCenters != null) {</span>
<span class="nc" id="L2754">            Color tint = ecmCenters.get(c);</span>
<span class="nc bnc" id="L2755" title="All 2 branches missed.">            if (tint != null) {</span>
<span class="nc" id="L2756">                drawHexBorder(g, tint.darker(), 5, 10);</span>
            }
        }

        // Highlight hexes that contain the source of an ECCM field
<span class="nc bnc" id="L2761" title="All 2 branches missed.">        if (eccmCenters != null) {</span>
<span class="nc" id="L2762">            Color tint = eccmCenters.get(c);</span>
<span class="nc bnc" id="L2763" title="All 2 branches missed.">            if (tint != null) {</span>
<span class="nc" id="L2764">                drawHexBorder(g, tint.darker(), 5, 10);</span>
            }
        }
<span class="nc" id="L2767">    }</span>

    private void shadeHexes(Coords c, Graphics2D g) {
        // Shade and add static noise to hexes that are in an ECM field
<span class="nc bnc" id="L2771" title="All 2 branches missed.">        if (ecmHexes != null) {</span>
<span class="nc" id="L2772">            Color tint = ecmHexes.get(c);</span>
<span class="nc bnc" id="L2773" title="All 2 branches missed.">            if (tint != null) {</span>
<span class="nc" id="L2774">                Color origColor = g.getColor();</span>
<span class="nc" id="L2775">                g.setColor(tint);</span>
<span class="nc" id="L2776">                AffineTransform sc = new AffineTransform();</span>
<span class="nc" id="L2777">                sc.scale(scale, scale);</span>
<span class="nc" id="L2778">                g.fill(sc.createTransformedShape(hexPoly));</span>
<span class="nc" id="L2779">                g.setColor(origColor);</span>
<span class="nc" id="L2780">                Image staticImage = getScaledImage(</span>
<span class="nc" id="L2781">                        tileManager.getEcmStaticImage(tint), false);</span>
<span class="nc" id="L2782">                g.drawImage(staticImage, 0, 0, staticImage.getWidth(null),</span>
<span class="nc" id="L2783">                        staticImage.getHeight(null), this);</span>
            }
        }
        // Shade hexes that are in an ECCM field
<span class="nc bnc" id="L2787" title="All 2 branches missed.">        if (eccmHexes != null) {</span>
<span class="nc" id="L2788">            Color tint = eccmHexes.get(c);</span>
<span class="nc bnc" id="L2789" title="All 2 branches missed.">            if (tint != null) {</span>
<span class="nc" id="L2790">                Color origColor = g.getColor();</span>
<span class="nc" id="L2791">                g.setColor(tint);</span>
<span class="nc" id="L2792">                AffineTransform sc = new AffineTransform();</span>
<span class="nc" id="L2793">                sc.scale(scale, scale);</span>
<span class="nc" id="L2794">                g.fill(sc.createTransformedShape(hexPoly));</span>
<span class="nc" id="L2795">                g.setColor(origColor);</span>
            }
        }
<span class="nc" id="L2798">    }</span>

    private boolean drawSupers(boolean dontCache, Graphics2D g, IHex hex) {
<span class="nc" id="L2801">        List&lt;Image&gt; supers = tileManager.supersFor(hex);</span>
<span class="nc bnc" id="L2802" title="All 2 branches missed.">        if (supers == null) {</span>
<span class="nc" id="L2803">            return dontCache;</span>
        }
<span class="nc bnc" id="L2805" title="All 2 branches missed.">        for (Image image : supers) {</span>
<span class="nc bnc" id="L2806" title="All 2 branches missed.">            if (image == null) {</span>
<span class="nc" id="L2807">                continue;</span>
            }
<span class="nc bnc" id="L2809" title="All 2 branches missed.">            if (animatedImages.contains(image.hashCode())) {</span>
<span class="nc" id="L2810">                dontCache = true;</span>
            }
<span class="nc" id="L2812">            Image scaledImage = getScaledImage(image, true);</span>
<span class="nc" id="L2813">            g.drawImage(scaledImage, 0, 0, this);</span>
<span class="nc" id="L2814">        }</span>
<span class="nc" id="L2815">        return dontCache;</span>
    }

    private void writeLevelDepthHeight(IHex hex, Graphics2D g) {
<span class="nc bnc" id="L2819" title="All 2 branches missed.">        if (scale &lt;= 0.5f) {</span>
<span class="nc" id="L2820">            return;</span>
        }
<span class="nc" id="L2822">        int level = hex.getLevel();</span>
<span class="nc" id="L2823">        int depth = hex.depth(false);</span>
<span class="nc" id="L2824">        ITerrain basement = hex.getTerrain(Terrains.BLDG_BASEMENT_TYPE);</span>
<span class="nc bnc" id="L2825" title="All 2 branches missed.">        if (basement != null) {</span>
<span class="nc" id="L2826">            depth = 0;</span>
        }

<span class="nc" id="L2829">        int height = Math.max(hex.terrainLevel(Terrains.BLDG_ELEV),</span>
<span class="nc" id="L2830">                hex.terrainLevel(Terrains.BRIDGE_ELEV));</span>
<span class="nc" id="L2831">        height = Math.max(height, hex.terrainLevel(Terrains.INDUSTRIAL));</span>

<span class="nc" id="L2833">        int ypos = HEX_H - 2;</span>
<span class="nc bnc" id="L2834" title="All 2 branches missed.">        if (level != 0) {</span>
<span class="nc" id="L2835">            drawCenteredString(</span>
<span class="nc" id="L2836">                    Messages.getString(&quot;BoardView1.LEVEL&quot;) + level, //$NON-NLS-1$</span>
                    0, (int) (ypos * scale), font_elev, g);
<span class="nc" id="L2838">            ypos -= 10;</span>
        }
<span class="nc bnc" id="L2840" title="All 2 branches missed.">        if (depth != 0) {</span>
<span class="nc" id="L2841">            drawCenteredString(</span>
<span class="nc" id="L2842">                    Messages.getString(&quot;BoardView1.DEPTH&quot;) + depth, //$NON-NLS-1$</span>
                    0, (int) (ypos * scale), font_elev, g);
<span class="nc" id="L2844">            ypos -= 10;</span>
        }
<span class="nc bnc" id="L2846" title="All 2 branches missed.">        if (height &gt; 0) {</span>
<span class="nc" id="L2847">            g.setColor(GUIPreferences.getInstance().getColor(</span>
                    &quot;AdvancedBuildingTextColor&quot;));                 //$NON-NLS-1$
<span class="nc" id="L2849">            drawCenteredString(</span>
<span class="nc" id="L2850">                    Messages.getString(&quot;BoardView1.HEIGHT&quot;) + height, //$NON-NLS-1$</span>
                    0, (int) (ypos * scale), font_elev, g);
<span class="nc" id="L2852">            ypos -= 10;</span>
        }
<span class="nc bnc" id="L2854" title="All 2 branches missed.">        if (hex.terrainLevel(Terrains.FOLIAGE_ELEV) == 1) {</span>
<span class="nc" id="L2855">            g.setColor(GUIPreferences.getInstance().getColor(</span>
                    GUIPreferences.ADVANCED_LOW_FOLIAGE_COLOR));
<span class="nc" id="L2857">            drawCenteredString(Messages.getString(&quot;BoardView1.LowFoliage&quot;),</span>
                    0, (int) (ypos * scale), font_elev, g);
<span class="nc" id="L2859">            ypos -= 10;</span>
        }
<span class="nc" id="L2861">    }</span>

    private void addTerrainAndBuildingShadows(Coords c, Graphics2D g) {
<span class="nc bnc" id="L2864" title="All 4 branches missed.">        if (GUIPreferences.getInstance().getBoolean(GUIPreferences.SHADOWMAP) &amp;&amp; (shadowMap != null)) {</span>
<span class="nc" id="L2865">            Point p1SRC = getHexLocationLargeTile(c.getX(), c.getY(), 1);</span>
<span class="nc" id="L2866">            Point p2SRC = new Point(p1SRC.x + HEX_W, p1SRC.y + HEX_H);</span>
<span class="nc" id="L2867">            Point p2DST = new Point(hex_size.width, hex_size.height);</span>

<span class="nc" id="L2869">            Composite svComp = g.getComposite();</span>
<span class="nc bnc" id="L2870" title="All 2 branches missed.">            if (game.getPlanetaryConditions().getLight() == PlanetaryConditions.L_DAY) {</span>
<span class="nc" id="L2871">                g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_ATOP, 0.55f));</span>
            } else {
<span class="nc" id="L2873">                g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_ATOP, 0.45f));</span>
            }

            // paint the right slice from the big pic
<span class="nc" id="L2877">            g.drawImage(shadowMap, 0, 0, p2DST.x, p2DST.y, p1SRC.x, p1SRC.y,</span>
                    p2SRC.x, p2SRC.y, null);
<span class="nc" id="L2879">            g.setComposite(svComp);</span>
        }
<span class="nc" id="L2881">    }</span>

    private Graphics2D drawImage(Coords c, Image scaledImage, boolean standardTile, BufferedImage hexImage) {
<span class="nc" id="L2884">        int origImgWidth = scaledImage.getWidth(null);</span>
<span class="nc" id="L2885">        int origImgHeight = scaledImage.getHeight(null);</span>

<span class="nc" id="L2887">        Graphics2D g = (Graphics2D) (hexImage.getGraphics());</span>
<span class="nc" id="L2888">        GUIPreferences.AntiAliasifSet(g);</span>

<span class="nc bnc" id="L2890" title="All 2 branches missed.">        if (standardTile) { // is the image hex-sized, 84*72?</span>
<span class="nc" id="L2891">            g.drawImage(scaledImage, 0, 0, this);</span>
        } else { // Draw image for a texture larger than a hex
<span class="nc" id="L2893">            Point p1SRC = getHexLocationLargeTile(c.getX(), c.getY());</span>
<span class="nc" id="L2894">            p1SRC.x = p1SRC.x % origImgWidth;</span>
<span class="nc" id="L2895">            p1SRC.y = p1SRC.y % origImgHeight;</span>
<span class="nc" id="L2896">            Point p2SRC = new Point((int) (p1SRC.x + HEX_W * scale),</span>
                    (int) (p1SRC.y + HEX_H * scale));
<span class="nc" id="L2898">            Point p2DST = new Point((int) (HEX_W * scale),</span>
                    (int) (HEX_H * scale));

            // hex mask to limit drawing to the hex shape
            // TODO: this is not ideal yet but at least it draws
            // without leaving gaps at any zoom
<span class="nc" id="L2904">            Image hexMask = getScaledImage(tileManager.getHexMask(), true);</span>
<span class="nc" id="L2905">            g.drawImage(hexMask, 0, 0, this);</span>
<span class="nc" id="L2906">            Composite svComp = g.getComposite();</span>
<span class="nc" id="L2907">            g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_ATOP,</span>
                    1f));

            // paint the right slice from the big pic
<span class="nc" id="L2911">            g.drawImage(scaledImage, 0, 0, p2DST.x, p2DST.y, p1SRC.x, p1SRC.y,</span>
                    p2SRC.x, p2SRC.y, null);

            // Handle wrapping of the image
<span class="nc bnc" id="L2915" title="All 4 branches missed.">            if (p2SRC.x &gt; origImgWidth &amp;&amp; p2SRC.y &lt;= origImgHeight) {</span>
<span class="nc" id="L2916">                g.drawImage(scaledImage, origImgWidth - p1SRC.x, 0, p2DST.x,</span>
                        p2DST.y, 0, p1SRC.y, p2SRC.x - origImgWidth, p2SRC.y,
                        null); // paint addtl slice on the left side
<span class="nc bnc" id="L2919" title="All 4 branches missed.">            } else if (p2SRC.x &lt;= origImgWidth &amp;&amp; p2SRC.y &gt; origImgHeight) {</span>
<span class="nc" id="L2920">                g.drawImage(scaledImage, 0, origImgHeight - p1SRC.y, p2DST.x,</span>
                        p2DST.y, p1SRC.x, 0, p2SRC.x, p2SRC.y - origImgHeight,
                        null); // paint addtl slice on the top
<span class="nc bnc" id="L2923" title="All 2 branches missed.">            } else if (p2SRC.x &gt; origImgWidth) {</span>
<span class="nc" id="L2924">                g.drawImage(scaledImage, origImgWidth - p1SRC.x, 0, p2DST.x,</span>
                        p2DST.y, 0, p1SRC.y, p2SRC.x - origImgWidth, p2SRC.y,
                        null); // paint addtl slice on the top
<span class="nc" id="L2927">                g.drawImage(scaledImage, 0, origImgHeight - p1SRC.y, p2DST.x,</span>
                        p2DST.y, p1SRC.x, 0, p2SRC.x, p2SRC.y - origImgHeight,
                        null); // paint addtl slice on the left side
                // paint addtl slice on the top left side
<span class="nc" id="L2931">                g.drawImage(scaledImage, origImgWidth - p1SRC.x, origImgHeight</span>
                        - p1SRC.y, p2DST.x, p2DST.y, 0, 0, p2SRC.x
                        - origImgWidth, p2SRC.y - origImgHeight, null);
            }
<span class="nc" id="L2935">            g.setComposite(svComp);</span>
        }
<span class="nc" id="L2937">        return g;</span>
    }

    /**
     * Draws a orthographic hex onto the board buffer. This assumes that
     * drawRect is current, and does not check if the hex is visible.
     */
    private void drawOrthograph(Coords c, Graphics boardGraph) {
<span class="nc bnc" id="L2945" title="All 2 branches missed.">        if (!game.getBoard().contains(c)) {</span>
<span class="nc" id="L2946">            return;</span>
        }

<span class="nc" id="L2949">        final IHex oHex = game.getBoard().getHex(c);</span>
<span class="nc" id="L2950">        final Point oHexLoc = getHexLocation(c);</span>

        // We need to adjust the height based on several cases
<span class="nc" id="L2953">        int elevOffset = oHex.terrainLevel(Terrains.BRIDGE_ELEV);</span>

<span class="nc" id="L2955">        int orthX = oHexLoc.x;</span>
<span class="nc" id="L2956">        int orthY = oHexLoc.y - (int) (HEX_ELEV * scale * elevOffset);</span>
<span class="nc bnc" id="L2957" title="All 2 branches missed.">        if (!useIsometric()) {</span>
<span class="nc" id="L2958">            orthY = oHexLoc.y;</span>
        }
<span class="nc bnc" id="L2960" title="All 2 branches missed.">        if (tileManager.orthoFor(oHex) == null) {</span>
<span class="nc" id="L2961">            return;</span>
        }
<span class="nc bnc" id="L2963" title="All 2 branches missed.">        for (Image image : tileManager.orthoFor(oHex)) {</span>
<span class="nc" id="L2964">            BufferedImage scaledImage = ImageUtil.createAcceleratedImage(getScaledImage(image, true));</span>

            // Darken the hex for night-time, if applicable
<span class="nc bnc" id="L2967" title="All 2 branches missed.">            if (GUIPreferences.getInstance().getBoolean(GUIPreferences.ADVANCED_DARKEN_MAP_AT_NIGHT)</span>
<span class="nc bnc" id="L2968" title="All 2 branches missed.">                    &amp;&amp; (game.isPositionIlluminated(c) == IGame.ILLUMINATED_NONE)</span>
<span class="nc bnc" id="L2969" title="All 2 branches missed.">                    &amp;&amp; (game.getPlanetaryConditions().getLight() &gt; PlanetaryConditions.L_DAY)) {</span>
<span class="nc bnc" id="L2970" title="All 2 branches missed.">                for (int x = 0; x &lt; scaledImage.getWidth(null); ++x) {</span>
<span class="nc bnc" id="L2971" title="All 2 branches missed.">                    for (int y = 0; y &lt; scaledImage.getHeight(); ++y) {</span>
<span class="nc" id="L2972">                        scaledImage.setRGB(x, y, getNightDarkenedColor(scaledImage.getRGB(x, y)));</span>
                    }
                }
            }

            // draw orthogonal
<span class="nc" id="L2978">            boardGraph.drawImage(scaledImage, orthX, orthY, this);</span>
<span class="nc" id="L2979">        }</span>
<span class="nc" id="L2980">    }</span>

    final boolean useIsometric() {
<span class="nc" id="L2983">        return drawIsometric;</span>
    }

    /**
     * Draws the Isometric elevation for the hex at the given coordinates (c) on
     * the side indicated by the direction (dir). This method only draws a
     * triangle for the elevation, the companion triangle representing the
     * adjacent hex is also needed. The two triangles when drawn together make a
     * complete rectangle representing the complete elevated hex side.
     * &lt;p/&gt;
     * By drawing the elevated hex as two separate triangles we avoid clipping
     * problems with other hexes because the lower elevation is rendered before
     * the higher elevation. Thus any hexes that have a higher elevation than
     * the lower hex will overwrite the lower hex.
     * &lt;p/&gt;
     * The Triangle for each hex side is formed by points p1, p2, and p3. Where
     * p1 and p2 are the original hex edges, and p3 has the same X value as p1,
     * but the y value has been increased (or decreased) based on the difference
     * in elevation between the given hex and the adjacent hex.
     *
     * @param c     Coordinates of the source hex.
     * @param color Color to use for the elevation polygons.
     * @param p1    The First point on the edge of the hex.
     * @param p2    The second point on the edge of the hex.
     * @param dir   The side of the hex to have the elevation drawn on.
     * @param g
     */
    private final void drawIsometricElevation(Coords c, Color color, Point p1,
                                              Point p2, int dir, Graphics g) {
<span class="nc" id="L3012">        final IHex dest = game.getBoard().getHexInDir(c, dir);</span>
<span class="nc" id="L3013">        final IHex src = game.getBoard().getHex(c);</span>

<span class="nc bnc" id="L3015" title="All 2 branches missed.">        if (!useIsometric() ||</span>
<span class="nc bnc" id="L3016" title="All 2 branches missed.">                GUIPreferences.getInstance().getBoolean(GUIPreferences.FLOATINGISO)) {</span>
<span class="nc" id="L3017">            return;</span>
        }

        // Pad polygon size slightly to avoid rounding errors from scale float.
<span class="nc" id="L3021">        int fudge = -1;</span>
<span class="nc bnc" id="L3022" title="All 6 branches missed.">        if ((dir == 2) || (dir == 4) || (dir == 3)) {</span>
<span class="nc" id="L3023">            fudge = 1;</span>
        }

<span class="nc" id="L3026">        final int elev = src.getLevel();</span>
        // If the Destination is null, draw the complete elevation side.
<span class="nc bnc" id="L3028" title="All 10 branches missed.">        if ((dest == null) &amp;&amp; (elev &gt; 0)</span>
                &amp;&amp; ((dir == 2) || (dir == 3) || (dir == 4))) {

            // Determine the depth of the edge that needs to be drawn.
<span class="nc" id="L3032">            int height = elev;</span>
<span class="nc" id="L3033">            IHex southHex = game.getBoard().getHexInDir(c, 3);</span>
<span class="nc bnc" id="L3034" title="All 4 branches missed.">            if ((dir != 3) &amp;&amp; (southHex != null)</span>
<span class="nc bnc" id="L3035" title="All 2 branches missed.">                    &amp;&amp; (elev &gt; southHex.getLevel())) {</span>
<span class="nc" id="L3036">                height = elev - southHex.getLevel();</span>
            }
<span class="nc" id="L3038">            int scaledHeight = (int) (HEX_ELEV * scale * height);</span>

<span class="nc" id="L3040">            Polygon p = new Polygon(new int[]{p1.x, p2.x, p2.x, p1.x},</span>
                    new int[]{p1.y + fudge, p2.y + fudge,
                            p2.y + scaledHeight, p1.y + scaledHeight}, 4);
<span class="nc" id="L3043">            g.setColor(color);</span>
<span class="nc" id="L3044">            g.drawPolygon(p);</span>
<span class="nc" id="L3045">            g.fillPolygon(p);</span>

<span class="nc" id="L3047">            g.setColor(Color.BLACK);</span>
<span class="nc bnc" id="L3048" title="All 4 branches missed.">            if ((dir == 2) || (dir == 4)) {</span>
<span class="nc" id="L3049">                g.drawLine(p1.x, p1.y, p1.x, p1.y + scaledHeight);</span>
            }
<span class="nc" id="L3051">            return;</span>
<span class="nc bnc" id="L3052" title="All 2 branches missed.">        } else if (dest == null) {</span>
<span class="nc" id="L3053">            return;</span>
        }

<span class="nc" id="L3056">        int delta = elev - dest.getLevel();</span>
        // Don't draw the elevation if there is no exposed edge for the player
        // to see.
<span class="nc bnc" id="L3059" title="All 18 branches missed.">        if ((delta == 0)</span>
                || (((dir == 0) || (dir == 1) || (dir == 5)) &amp;&amp; (delta &gt; 0))
                || (((dir == 2) || (dir == 3) || (dir == 4)) &amp;&amp; (delta &lt; 0))) {
<span class="nc" id="L3062">            return;</span>
        }

<span class="nc bnc" id="L3065" title="All 2 branches missed.">        if (dir == 1) {</span>
            /*
            // Draw a little bit of shadow to improve the 3d isometric effect.
            Polygon shadow1 = new Polygon(new int[] { p1.x, p2.x,
                    p2.x - (int) (HEX_ELEV * scale) }, new int[] { p1.y, p2.y,
                    p2.y }, 3);
            if ((p2.x - (int) (HEX_ELEV * scale)) &lt; 0) {
                MegaMek.getLogger().info(&quot;Negative X value!: &quot; + (p2.x - (int) (HEX_ELEV * scale)));
            }
            g.setColor(new Color(0, 0, 0, 0.4f));
            g.fillPolygon(shadow1);*/
            // not necessary with the shadowmap
            // people not using the shadowmap will probably not need this shadow either
        }

<span class="nc bnc" id="L3080" title="All 6 branches missed.">        if ((dir == 2) || (dir == 3) || (dir == 4)) {</span>
<span class="nc" id="L3081">            int scaledDelta = (int) (HEX_ELEV * scale * delta);</span>
<span class="nc" id="L3082">            Point p3 = new Point(p1.x, p1.y + scaledDelta + fudge);</span>

<span class="nc" id="L3084">            Polygon p = new Polygon(new int[]{p1.x, p2.x, p2.x, p1.x},</span>
                    new int[]{p1.y + fudge, p2.y + fudge,
                            p2.y + fudge + scaledDelta,
                            p1.y + fudge + scaledDelta}, 4);

<span class="nc bnc" id="L3089" title="All 2 branches missed.">            if ((p1.y + fudge) &lt; 0) {</span>
<span class="nc" id="L3090">                MegaMek.getLogger().info(&quot;Negative Y value (Fudge)!: &quot; + (p1.y + fudge));</span>
            }
<span class="nc bnc" id="L3092" title="All 2 branches missed.">            if ((p2.y + fudge) &lt; 0) {</span>
<span class="nc" id="L3093">                MegaMek.getLogger().info(&quot;Negative Y value (Fudge)!: &quot; + (p2.y + fudge));</span>
            }

<span class="nc bnc" id="L3096" title="All 2 branches missed.">            if ((p2.y + fudge + scaledDelta) &lt; 0) {</span>
<span class="nc" id="L3097">                MegaMek.getLogger().info(&quot;Negative Y value!: &quot; + (p2.y + fudge + scaledDelta));</span>
            }
<span class="nc bnc" id="L3099" title="All 2 branches missed.">            if ((p1.y + fudge + scaledDelta) &lt; 0) {</span>
<span class="nc" id="L3100">                MegaMek.getLogger().info(&quot;Negative Y value!: &quot; + (p1.y + fudge + scaledDelta));</span>
            }
<span class="nc" id="L3102">            g.setColor(color);</span>
<span class="nc" id="L3103">            g.drawPolygon(p);</span>
<span class="nc" id="L3104">            g.fillPolygon(p);</span>

<span class="nc" id="L3106">            g.setColor(Color.BLACK);</span>
<span class="nc bnc" id="L3107" title="All 8 branches missed.">            if ((dir == 1) || (dir == 2) || (dir == 5) || (dir == 4)) {</span>
<span class="nc" id="L3108">                g.drawLine(p1.x, p1.y, p3.x, p3.y);</span>
            }
        }
<span class="nc" id="L3111">    }</span>

    /**
     * Returns true if an elevation line should be drawn between the starting
     * hex and the hex in the direction specified. Results should be transitive,
     * that is, if a line is drawn in one direction, it should be drawn in the
     * opposite direction as well.
     */
    private final boolean drawElevationLine(Coords src, int direction) {
<span class="nc" id="L3120">        final IHex srcHex = game.getBoard().getHex(src);</span>
<span class="nc" id="L3121">        final IHex destHex = game.getBoard().getHexInDir(src, direction);</span>
<span class="nc bnc" id="L3122" title="All 4 branches missed.">        if ((destHex == null) &amp;&amp; (srcHex.getLevel() != 0)) {</span>
<span class="nc" id="L3123">            return true;</span>
<span class="nc bnc" id="L3124" title="All 2 branches missed.">        } else if (destHex == null) {</span>
<span class="nc" id="L3125">            return false;</span>
<span class="nc bnc" id="L3126" title="All 2 branches missed.">        } else if (srcHex.getLevel() != destHex.getLevel()) {</span>
<span class="nc" id="L3127">            return true;</span>
        } else {
<span class="nc bnc" id="L3129" title="All 2 branches missed.">            return (srcHex.floor() != destHex.floor());</span>
        }
    }

    /**
     * Given an int-packed RGB value, apply a modifier for the light level and return the result.
     *
     * @param rgb int-packed ARGB value.
     * @return An int-packed ARGB value, which is an adjusted value of the input, based on the light level
     */
    public int getNightDarkenedColor(int rgb) {
<span class="nc" id="L3140">        int rd = (rgb &gt;&gt; 16) &amp; 0xFF;</span>
<span class="nc" id="L3141">        int gr = (rgb &gt;&gt; 8) &amp; 0xFF;</span>
<span class="nc" id="L3142">        int bl = rgb &amp; 0xFF;</span>
<span class="nc" id="L3143">        int al = (rgb &gt;&gt; 24);</span>

<span class="nc bnc" id="L3145" title="All 4 branches missed.">        switch (game.getPlanetaryConditions().getLight()) {</span>
            case PlanetaryConditions.L_FULL_MOON:
            case PlanetaryConditions.L_MOONLESS:
<span class="nc" id="L3148">                rd = rd / 4; // 1/4 red</span>
<span class="nc" id="L3149">                gr = gr / 4; // 1/4 green</span>
<span class="nc" id="L3150">                bl = bl / 2; // half blue</span>
<span class="nc" id="L3151">                break;</span>
            case PlanetaryConditions.L_PITCH_BLACK:
<span class="nc" id="L3153">                int gy = (rd + gr + bl) / 16;</span>
<span class="nc bnc" id="L3154" title="All 2 branches missed.">                if (Math.random() &lt; 0.3) {</span>
<span class="nc" id="L3155">                    gy = gy * 4 / 5;</span>
                }
<span class="nc bnc" id="L3157" title="All 2 branches missed.">                if (Math.random() &lt; 0.3) {</span>
<span class="nc" id="L3158">                    gy = gy * 5 / 4;</span>
                }
<span class="nc" id="L3160">                rd = gy + rd / 5;</span>
<span class="nc" id="L3161">                gr = gy + gr / 5;</span>
<span class="nc" id="L3162">                bl = gy + bl / 5;</span>
<span class="nc" id="L3163">                break;</span>
            case PlanetaryConditions.L_DUSK:
<span class="nc" id="L3165">                bl = bl * 3 / 4;</span>
<span class="nc" id="L3166">                break;</span>
            default:
        }

<span class="nc" id="L3170">        return (al &lt;&lt; 24) + (rd &lt;&lt; 16) + (gr &lt;&lt; 8) + bl;</span>
    }

    /**
     * Generates a Shape drawing area for the hex shadow effect in a lower hex
     * when a higher hex is found in direction.
     */
    private Shape getElevationShadowArea(Coords src, int direction) {
<span class="nc" id="L3178">        final IHex srcHex = game.getBoard().getHex(src);</span>
<span class="nc" id="L3179">        final IHex destHex = game.getBoard().getHexInDir(src, direction);</span>

        // When at the board edge, create a shadow in hexes of level &lt; 0
<span class="nc bnc" id="L3182" title="All 2 branches missed.">        if (destHex == null) {</span>
<span class="nc bnc" id="L3183" title="All 2 branches missed.">            if (srcHex.getLevel() &gt;= 0) return null;</span>
        } else {
            // no shadow area when the current hex is not lower than the next hex in direction
<span class="nc bnc" id="L3186" title="All 2 branches missed.">            if (srcHex.getLevel() &gt;= destHex.getLevel()) return null;</span>
<span class="nc bnc" id="L3187" title="All 2 branches missed.">            if (GUIPreferences.getInstance().getHexInclines()</span>
<span class="nc bnc" id="L3188" title="All 2 branches missed.">                    &amp;&amp; (destHex.getLevel() - srcHex.getLevel() &lt; 2)</span>
<span class="nc bnc" id="L3189" title="All 2 branches missed.">                    &amp;&amp; !destHex.hasCliffTopTowards(srcHex)) {</span>
<span class="nc" id="L3190">                return null;</span>
            }
        }

<span class="nc" id="L3194">        return (AffineTransform.getScaleInstance(scale, scale).createTransformedShape(</span>
<span class="nc" id="L3195">                HexDrawUtilities.getHexBorderArea(direction, HexDrawUtilities.CUT_BORDER, 36)));</span>
    }

    /**
     * Generates a fill gradient which is rotated and aligned properly for
     * the drawing area for a hex shadow effect in a lower hex.
     */
    private GradientPaint getElevationShadowGP(Coords src, int direction) {
<span class="nc" id="L3203">        final IHex srcHex = game.getBoard().getHex(src);</span>
<span class="nc" id="L3204">        final IHex destHex = game.getBoard().getHexInDir(src, direction);</span>

<span class="nc bnc" id="L3206" title="All 2 branches missed.">        if (destHex == null) return null;</span>

<span class="nc" id="L3208">        int ldiff = destHex.getLevel() - srcHex.getLevel();</span>
        // the shadow strength depends on the level difference,
        // but only to a maximum difference of 3 levels
<span class="nc" id="L3211">        ldiff = Math.min(ldiff * 5, 15);</span>

<span class="nc" id="L3213">        Color c1 = new Color(30, 30, 50, 255); // dark end of shadow</span>
<span class="nc" id="L3214">        Color c2 = new Color(50, 50, 70, 0);   // light end of shadow</span>

<span class="nc" id="L3216">        Point2D p1 = new Point2D.Double(41.5, -25 + ldiff);</span>
<span class="nc" id="L3217">        Point2D p2 = new Point2D.Double(41.5, 8.0 + ldiff);</span>

<span class="nc" id="L3219">        AffineTransform t = new AffineTransform();</span>
<span class="nc" id="L3220">        t.scale(scale, scale);</span>
<span class="nc" id="L3221">        t.rotate(Math.toRadians(direction * 60), 41.5, 35.5);</span>
<span class="nc" id="L3222">        t.transform(p1, p1);</span>
<span class="nc" id="L3223">        t.transform(p2, p2);</span>

<span class="nc" id="L3225">        return (new GradientPaint(p1, c1, p2, c2));</span>
    }

    /**
     * Returns the absolute position of the upper-left hand corner of the hex
     * graphic
     */
    private Point getHexLocation(int x, int y, boolean ignoreElevation) {
<span class="nc" id="L3233">        float elevationAdjust = 0.0f;</span>

<span class="nc" id="L3235">        IHex hex = game.getBoard().getHex(x, y);</span>
<span class="nc bnc" id="L3236" title="All 6 branches missed.">        if ((hex != null) &amp;&amp; useIsometric() &amp;&amp; !ignoreElevation) {</span>
<span class="nc" id="L3237">            elevationAdjust = hex.getLevel() * HEX_ELEV * scale * -1.0f;</span>
        }
<span class="nc" id="L3239">        int ypos = (y * (int) (HEX_H * scale))</span>
<span class="nc bnc" id="L3240" title="All 2 branches missed.">                + ((x &amp; 1) == 1 ? (int) ((HEX_H / 2) * scale) : 0);</span>
<span class="nc" id="L3241">        return new Point(x * (int) (HEX_WC * scale), ypos + (int) elevationAdjust);</span>
    }

    /**
     * For large tile texture: Returns the absolute position of the upper-left
     * hand corner of the hex graphic When using large tiles multiplying the
     * rounding errors from the (int) cast must be avoided however this cannot
     * be used for small tiles as it will make gaps appear between hexes This
     * will not factor in Isometric as this would be incorrect for large tiles
     */
    private Point getHexLocationLargeTile(int x, int y, float tscale) {
<span class="nc" id="L3252">        int ypos = (int) (y * HEX_H * tscale)</span>
<span class="nc bnc" id="L3253" title="All 2 branches missed.">                + ((x &amp; 1) == 1 ? (int) ((HEX_H / 2) * tscale) : 0);</span>
<span class="nc" id="L3254">        return new Point((int) (x * HEX_WC * tscale), ypos);</span>
    }

    private Point getHexLocationLargeTile(int x, int y) {
<span class="nc" id="L3258">        return getHexLocationLargeTile(x, y, scale);</span>
    }

    Point getHexLocation(Coords c) {
<span class="nc" id="L3262">        return getHexLocation(c.getX(), c.getY(), false);</span>
    }

    /**
     * Returns the absolute position of the centre of the hex graphic
     */
    private Point getCentreHexLocation(int x, int y, boolean ignoreElevation) {
<span class="nc" id="L3269">        Point p = getHexLocation(x, y, ignoreElevation);</span>
<span class="nc" id="L3270">        p.x += ((HEX_W / 2) * scale);</span>
<span class="nc" id="L3271">        p.y += ((HEX_H / 2) * scale);</span>
<span class="nc" id="L3272">        return p;</span>
    }

    public Point getCentreHexLocation(Coords c) {
<span class="nc" id="L3276">        return getCentreHexLocation(c.getX(), c.getY(), false);</span>
    }

    public Point getCentreHexLocation(Coords c, boolean ignoreElevation) {
<span class="nc" id="L3280">        return getCentreHexLocation(c.getX(), c.getY(), ignoreElevation);</span>
    }

    public void drawRuler(Coords s, Coords e, Color sc, Color ec) {
<span class="nc" id="L3284">        rulerStart = s;</span>
<span class="nc" id="L3285">        rulerEnd = e;</span>
<span class="nc" id="L3286">        rulerStartColor = sc;</span>
<span class="nc" id="L3287">        rulerEndColor = ec;</span>

<span class="nc" id="L3289">        repaint();</span>
<span class="nc" id="L3290">    }</span>

    /**
     * Returns the coords at the specified point
     */
    Coords getCoordsAt(Point p) {
        // We must account for the board translation to add padding
<span class="nc" id="L3297">        p.x -= HEX_W;</span>
<span class="nc" id="L3298">        p.y -= HEX_H;</span>

        // base values
<span class="nc" id="L3301">        int x = p.x / (int) (HEX_WC * scale);</span>
<span class="nc" id="L3302">        int y = p.y / (int) (HEX_H * scale);</span>
        // correction for the displaced odd columns
<span class="nc bnc" id="L3304" title="All 2 branches missed.">        if ((float) p.y / (scale * HEX_H) - y &lt; 0.5)</span>
<span class="nc" id="L3305">            y -= x % 2;</span>

        // check the surrounding hexes if they contain p
        // checking at most 3 hexes would be sufficient
        // but which ones? This is failsafer.
<span class="nc" id="L3310">        Coords cc = new Coords(x, y);</span>
<span class="nc bnc" id="L3311" title="All 2 branches missed.">        if (!HexDrawUtilities.getHexFull(getHexLocation(cc), scale).contains(p)) {</span>
<span class="nc" id="L3312">            boolean hasMatch = false;</span>
<span class="nc bnc" id="L3313" title="All 4 branches missed.">            for (int dir = 0; dir &lt; 6 &amp;&amp; !hasMatch; dir++) {</span>
<span class="nc" id="L3314">                Coords cn = cc.translated(dir);</span>
<span class="nc bnc" id="L3315" title="All 2 branches missed.">                if (HexDrawUtilities.getHexFull(getHexLocation(cn), scale).contains(p)) {</span>
<span class="nc" id="L3316">                    cc = cn;</span>
<span class="nc" id="L3317">                    hasMatch = true;</span>
                }
            }
        }

<span class="nc bnc" id="L3322" title="All 2 branches missed.">        if (!useIsometric()) {</span>
            // not Isometric
<span class="nc" id="L3324">            return cc;</span>
        }
        // When using isometric rendering, a lower hex can obscure the
        // normal hex. Iterate over all hexes from highest to lowest,
        // looking for a hex that contains the selected mouse click point.
<span class="nc" id="L3329">        final int minElev = Math.min(0, game.getBoard().getMinElevation());</span>
<span class="nc" id="L3330">        final int maxElev = Math.max(0, game.getBoard().getMaxElevation());</span>
<span class="nc" id="L3331">        final int delta = (int) Math</span>
<span class="nc" id="L3332">                .ceil(((double) maxElev - minElev) / 3.0f);</span>
<span class="nc" id="L3333">        final int minHexSpan = Math.max(y - delta, 0);</span>
<span class="nc" id="L3334">        final int maxHexSpan = Math.min(y + delta, game.getBoard()</span>
<span class="nc" id="L3335">                .getHeight());</span>
<span class="nc bnc" id="L3336" title="All 2 branches missed.">        for (int elev = maxElev; elev &gt;= minElev; elev--) {</span>
<span class="nc bnc" id="L3337" title="All 2 branches missed.">            for (int i = minHexSpan; i &lt;= maxHexSpan; i++) {</span>
<span class="nc bnc" id="L3338" title="All 2 branches missed.">                for (int dx = -1; dx &lt; 2; dx++) {</span>
<span class="nc" id="L3339">                    Coords c1 = new Coords(x + dx, i);</span>
<span class="nc" id="L3340">                    IHex hexAlt = game.getBoard().getHex(c1);</span>
<span class="nc bnc" id="L3341" title="All 4 branches missed.">                    if (HexDrawUtilities.getHexFull(getHexLocation(c1), scale).contains(p)</span>
                            &amp;&amp; (hexAlt != null)
<span class="nc bnc" id="L3343" title="All 2 branches missed.">                            &amp;&amp; (hexAlt.getLevel() == elev)) {</span>
                        // Return immediately with highest hex found.
<span class="nc" id="L3345">                        return c1;</span>
                    }
                }
            }
        }
        // nothing found
<span class="nc" id="L3351">        return new Coords(-1, -1);</span>
    }

    public void redrawMovingEntity(Entity entity, Coords position, int facing,
                                   int elevation) {
<span class="nc" id="L3356">        Integer entityId = entity.getId();</span>
<span class="nc" id="L3357">        List&lt;Integer&gt; spriteKey = getIdAndLoc(entityId, -1);</span>
<span class="nc" id="L3358">        EntitySprite sprite = entitySpriteIds.get(spriteKey);</span>
<span class="nc" id="L3359">        IsometricSprite isoSprite = isometricSpriteIds.get(spriteKey);</span>
        // We can ignore secondary locations for now, as we don't have moving
        // multi-location entitys (will need to change for mobile structures)

        PriorityQueue&lt;EntitySprite&gt; newSprites;
        PriorityQueue&lt;IsometricSprite&gt; isoSprites;
        HashMap&lt;List&lt;Integer&gt;, EntitySprite&gt; newSpriteIds;
        HashMap&lt;List&lt;Integer&gt;, IsometricSprite&gt; newIsoSpriteIds;

        // Remove sprite for Entity, so it's not displayed while moving
<span class="nc bnc" id="L3369" title="All 2 branches missed.">        if (sprite != null) {</span>
<span class="nc" id="L3370">            newSprites = new PriorityQueue&lt;EntitySprite&gt;(entitySprites);</span>
<span class="nc" id="L3371">            newSpriteIds = new HashMap&lt;&gt;(entitySpriteIds);</span>

<span class="nc" id="L3373">            newSprites.remove(sprite);</span>
<span class="nc" id="L3374">            newSpriteIds.remove(spriteKey);</span>

<span class="nc" id="L3376">            entitySprites = newSprites;</span>
<span class="nc" id="L3377">            entitySpriteIds = newSpriteIds;</span>
        }
        // Remove iso sprite for Entity, so it's not displayed while moving
<span class="nc bnc" id="L3380" title="All 2 branches missed.">        if (isoSprite != null) {</span>
<span class="nc" id="L3381">            isoSprites = new PriorityQueue&lt;IsometricSprite&gt;(isometricSprites);</span>
<span class="nc" id="L3382">            newIsoSpriteIds = new HashMap&lt;&gt;(isometricSpriteIds);</span>

<span class="nc" id="L3384">            isoSprites.remove(isoSprite);</span>
<span class="nc" id="L3385">            newIsoSpriteIds.remove(spriteKey);</span>

<span class="nc" id="L3387">            isometricSprites = isoSprites;</span>
<span class="nc" id="L3388">            isometricSpriteIds = newIsoSpriteIds;</span>
        }

<span class="nc" id="L3391">        MovingEntitySprite mSprite = movingEntitySpriteIds.get(entityId);</span>
<span class="nc" id="L3392">        List&lt;MovingEntitySprite&gt; newMovingSprites = new ArrayList&lt;&gt;(</span>
                movingEntitySprites);
<span class="nc" id="L3394">        HashMap&lt;Integer, MovingEntitySprite&gt; newMovingSpriteIds = new HashMap&lt;&gt;(</span>
                movingEntitySpriteIds);
        // Remove any old movement sprite
<span class="nc bnc" id="L3397" title="All 2 branches missed.">        if (mSprite != null) {</span>
<span class="nc" id="L3398">            newMovingSprites.remove(mSprite);</span>
        }
        // Create new movement sprite
<span class="nc bnc" id="L3401" title="All 2 branches missed.">        if (entity.getPosition() != null) {</span>
<span class="nc" id="L3402">            mSprite = new MovingEntitySprite(this, entity, position, facing,</span>
                    elevation);
<span class="nc" id="L3404">            newMovingSprites.add(mSprite);</span>
<span class="nc" id="L3405">            newMovingSpriteIds.put(entityId, mSprite);</span>
        }

<span class="nc" id="L3408">        movingEntitySprites = newMovingSprites;</span>
<span class="nc" id="L3409">        movingEntitySpriteIds = newMovingSpriteIds;</span>
<span class="nc" id="L3410">    }</span>

    public boolean isMovingUnits() {
<span class="nc bnc" id="L3413" title="All 2 branches missed.">        return movingUnits.size() &gt; 0;</span>
    }

    /**
     * Clears the sprite for an entity and prepares it to be re-drawn. Replaces
     * the old sprite with the new! Try to prevent annoying
     * ConcurrentModificationExceptions
     */
    public void redrawEntity(Entity entity) {
<span class="nc" id="L3422">        redrawEntity(entity, null);</span>
<span class="nc" id="L3423">    }</span>

    /**
     * Convenience method for returning a Key value for the entitySpriteIds and
     * isometricSprite maps. The List contains as the first element the Entity
     * ID and as the second element it's location ID: either -1 if the Entity
     * has no secondary locations, or the index of its secondary location.
     *
     * @param entityId     The Entity ID
     * @param secondaryLoc the secondary loc index, or -1 for Entitys without secondary
     *                     positions
     * @return
     */
    private List&lt;Integer&gt; getIdAndLoc(Integer entityId, int secondaryLoc) {
<span class="nc" id="L3437">        List&lt;Integer&gt; idLoc = new ArrayList&lt;Integer&gt;(2);</span>
<span class="nc" id="L3438">        idLoc.add(entityId);</span>
<span class="nc" id="L3439">        idLoc.add(secondaryLoc);</span>
<span class="nc" id="L3440">        return idLoc;</span>
    }

    /**
     * Clears the sprite for an entity and prepares it to be re-drawn. Replaces
     * the old sprite with the new! Takes a reference to the Entity object
     * before changes, in case it contained important state information, like
     * Dropships taking off (airborne dropships lose their secondary hexes). Try
     * to prevent annoying ConcurrentModificationExceptions
     */
    public void redrawEntity(Entity entity, Entity oldEntity) {
<span class="nc bnc" id="L3451" title="All 2 branches missed.">        if (oldEntity == null) {</span>
<span class="nc" id="L3452">            oldEntity = entity;</span>
        }

        // If the entity we are updating doesn't have a position, ensure we
        // remove all of its old sprites
<span class="nc bnc" id="L3457" title="All 2 branches missed.">        if (entity.getPosition() == null) {</span>
<span class="nc" id="L3458">            removeOldSprites(entity);</span>
        }

<span class="nc" id="L3461">        updateSprites(entity, oldEntity);</span>

        // Remove C3 sprites
<span class="nc bnc" id="L3464" title="All 2 branches missed.">        c3Sprites.removeIf(c3sprite -&gt; (c3sprite.entityId == entity.getId())</span>
<span class="nc bnc" id="L3465" title="All 2 branches missed.">                || (c3sprite.masterId == entity.getId()));</span>

        // Update C3 link, if necessary
<span class="nc bnc" id="L3468" title="All 8 branches missed.">        if (entity.hasC3() || entity.hasC3i() || entity.hasActiveNovaCEWS() || entity.hasNavalC3()) {</span>
<span class="nc" id="L3469">            addC3Link(entity);</span>
        }

<span class="nc bnc" id="L3472" title="All 2 branches missed.">        vtolAttackSprites.removeIf(s -&gt; s.getEntity().getId() == entity.getId());</span>

        // Remove Flyover Sprites
<span class="nc bnc" id="L3475" title="All 2 branches missed.">        flyOverSprites.removeIf(flyOverSprite -&gt; flyOverSprite.getEntityId() == entity.getId());</span>

        // Add Flyover path, if necessary
<span class="nc bnc" id="L3478" title="All 4 branches missed.">        if ((entity.isAirborne() || entity.isMakingVTOLGroundAttack())</span>
<span class="nc bnc" id="L3479" title="All 2 branches missed.">                &amp;&amp; (entity.getPassedThrough().size() &gt; 1)) {</span>
<span class="nc" id="L3480">            addFlyOverPath(entity);</span>
        }

<span class="nc" id="L3483">        updateEcmList();</span>
<span class="nc" id="L3484">        highlightSelectedEntity();</span>
<span class="nc" id="L3485">        scheduleRedraw();</span>
<span class="nc" id="L3486">    }</span>

    private void updateSprites(Entity entity, Entity oldEntity) {
<span class="nc" id="L3489">        Integer entityId = entity.getId();</span>
        // Create a copy of the sprite list
<span class="nc" id="L3491">        Queue&lt;EntitySprite&gt; newSprites = new PriorityQueue&lt;&gt;(entitySprites);</span>
<span class="nc" id="L3492">        HashMap&lt;List&lt;Integer&gt;, EntitySprite&gt; newSpriteIds = new HashMap&lt;&gt;(entitySpriteIds);</span>
<span class="nc" id="L3493">        Queue&lt;IsometricSprite&gt; isoSprites = new PriorityQueue&lt;&gt;(isometricSprites);</span>
<span class="nc" id="L3494">        HashMap&lt;List&lt;Integer&gt;, IsometricSprite&gt; newIsoSpriteIds = new HashMap&lt;&gt;(isometricSpriteIds);</span>

        // Remove the sprites we are going to update
<span class="nc" id="L3497">        EntitySprite sprite = entitySpriteIds.get(getIdAndLoc(entityId, -1));</span>
<span class="nc" id="L3498">        IsometricSprite isoSprite = isometricSpriteIds.get(getIdAndLoc(entityId, -1));</span>
<span class="nc bnc" id="L3499" title="All 2 branches missed.">        if (sprite != null) {</span>
<span class="nc" id="L3500">            newSprites.remove(sprite);</span>
        }
<span class="nc bnc" id="L3502" title="All 2 branches missed.">        if (isoSprite != null) {</span>
<span class="nc" id="L3503">            isoSprites.remove(isoSprite);</span>
        }
<span class="nc bnc" id="L3505" title="All 2 branches missed.">        for (int secondaryPos : oldEntity.getSecondaryPositions().keySet()) {</span>
<span class="nc" id="L3506">            sprite = entitySpriteIds.get(getIdAndLoc(entityId, secondaryPos));</span>
<span class="nc bnc" id="L3507" title="All 2 branches missed.">            if (sprite != null) {</span>
<span class="nc" id="L3508">                newSprites.remove(sprite);</span>
            }
<span class="nc" id="L3510">            isoSprite = isometricSpriteIds.get(getIdAndLoc(entityId,</span>
                    secondaryPos));
<span class="nc bnc" id="L3512" title="All 2 branches missed.">            if (isoSprite != null) {</span>
<span class="nc" id="L3513">                isoSprites.remove(isoSprite);</span>
            }
<span class="nc" id="L3515">        }</span>

        // Create the new sprites
<span class="nc" id="L3518">        Coords position = entity.getPosition();</span>
<span class="nc" id="L3519">        boolean canSee = EntityVisibilityUtils.detectedOrHasVisual(localPlayer, game, entity);</span>

<span class="nc bnc" id="L3521" title="All 4 branches missed.">        if ((position != null) &amp;&amp; canSee) {</span>
            // Add new EntitySprite
            // If no secondary positions, add a sprite for the central position
<span class="nc bnc" id="L3524" title="All 2 branches missed.">            if (entity.getSecondaryPositions().isEmpty()) {</span>
<span class="nc" id="L3525">                sprite = new EntitySprite(this, entity, -1, radarBlipImage);</span>
<span class="nc" id="L3526">                newSprites.add(sprite);</span>
<span class="nc" id="L3527">                newSpriteIds.put(getIdAndLoc(entityId, -1), sprite);</span>
            } else { // Add all secondary position sprites, which includes a
                // sprite for the central hex
<span class="nc bnc" id="L3530" title="All 2 branches missed.">                for (int secondaryPos : entity.getSecondaryPositions().keySet()) {</span>
<span class="nc" id="L3531">                    sprite = new EntitySprite(this, entity, secondaryPos,</span>
                            radarBlipImage);
<span class="nc" id="L3533">                    newSprites.add(sprite);</span>
<span class="nc" id="L3534">                    newSpriteIds.put(getIdAndLoc(entityId, secondaryPos),</span>
                            sprite);
<span class="nc" id="L3536">                }</span>
            }

            // Add new IsometricSprite
            // If no secondary positions, add a sprite for the central position
<span class="nc bnc" id="L3541" title="All 2 branches missed.">            if (entity.getSecondaryPositions().isEmpty()) {</span>
<span class="nc" id="L3542">                isoSprite = new IsometricSprite(this, entity, -1,</span>
                        radarBlipImage);
<span class="nc" id="L3544">                isoSprites.add(isoSprite);</span>
<span class="nc" id="L3545">                newIsoSpriteIds.put(getIdAndLoc(entityId, -1), isoSprite);</span>
            } else { // Add all secondary position sprites, which includes a
                // sprite for the central hex
<span class="nc bnc" id="L3548" title="All 2 branches missed.">                for (int secondaryPos : entity.getSecondaryPositions().keySet()) {</span>
<span class="nc" id="L3549">                    isoSprite = new IsometricSprite(this, entity, secondaryPos,</span>
                            radarBlipImage);
<span class="nc" id="L3551">                    isoSprites.add(isoSprite);</span>
<span class="nc" id="L3552">                    newIsoSpriteIds.put(getIdAndLoc(entityId, secondaryPos),</span>
                            isoSprite);
<span class="nc" id="L3554">                }</span>
            }
        }

        // Update Sprite state with new collections
<span class="nc" id="L3559">        entitySprites = newSprites;</span>
<span class="nc" id="L3560">        entitySpriteIds = newSpriteIds;</span>
<span class="nc" id="L3561">        isometricSprites = isoSprites;</span>
<span class="nc" id="L3562">        isometricSpriteIds = newIsoSpriteIds;</span>
<span class="nc" id="L3563">    }</span>

    private void removeOldSprites(Entity entity) {
        Iterator&lt;EntitySprite&gt; spriteIter;

        // Remove Entity Sprites
<span class="nc" id="L3569">        spriteIter = entitySprites.iterator();</span>
<span class="nc bnc" id="L3570" title="All 2 branches missed.">        while (spriteIter.hasNext()) {</span>
<span class="nc" id="L3571">            EntitySprite sprite = spriteIter.next();</span>
<span class="nc bnc" id="L3572" title="All 2 branches missed.">            if (sprite.entity.equals(entity)) {</span>
<span class="nc" id="L3573">                spriteIter.remove();</span>
            }
<span class="nc" id="L3575">        }</span>

        //  Update ID -&gt; Sprite map
<span class="nc" id="L3578">        spriteIter = entitySpriteIds.values().iterator();</span>
<span class="nc bnc" id="L3579" title="All 2 branches missed.">        while (spriteIter.hasNext()) {</span>
<span class="nc" id="L3580">            EntitySprite sprite = spriteIter.next();</span>
<span class="nc bnc" id="L3581" title="All 2 branches missed.">            if (sprite.entity.equals(entity)) {</span>
<span class="nc" id="L3582">                spriteIter.remove();</span>
            }
<span class="nc" id="L3584">        }</span>

        Iterator&lt;IsometricSprite&gt; isoSpriteIter;

        // Remove IsometricSprites
<span class="nc" id="L3589">        isoSpriteIter = isometricSprites.iterator();</span>
<span class="nc bnc" id="L3590" title="All 2 branches missed.">        while (isoSpriteIter.hasNext()) {</span>
<span class="nc" id="L3591">            IsometricSprite sprite = isoSpriteIter.next();</span>
<span class="nc bnc" id="L3592" title="All 2 branches missed.">            if (sprite.entity.equals(entity)) {</span>
<span class="nc" id="L3593">                isoSpriteIter.remove();</span>
            }
<span class="nc" id="L3595">        }</span>

        // Update ID -&gt; Iso Sprite Map
<span class="nc" id="L3598">        isoSpriteIter = isometricSpriteIds.values().iterator();</span>
<span class="nc bnc" id="L3599" title="All 2 branches missed.">        while (isoSpriteIter.hasNext()) {</span>
<span class="nc" id="L3600">            IsometricSprite sprite = isoSpriteIter.next();</span>
<span class="nc bnc" id="L3601" title="All 2 branches missed.">            if (sprite.entity.equals(entity)) {</span>
<span class="nc" id="L3602">                isoSpriteIter.remove();</span>
            }
<span class="nc" id="L3604">        }</span>
<span class="nc" id="L3605">    }</span>

    /**
     * Clears all old entity sprites out of memory and sets up new ones.
     */
    void redrawAllEntities() {
<span class="nc" id="L3611">        int numEntities = game.getNoOfEntities();</span>
        // Prevent IllegalArgumentException
<span class="nc" id="L3613">        numEntities = Math.max(1, numEntities);</span>
<span class="nc" id="L3614">        Queue&lt;EntitySprite&gt; newSprites = new PriorityQueue&lt;EntitySprite&gt;(</span>
                numEntities);
<span class="nc" id="L3616">        Queue&lt;IsometricSprite&gt; newIsometricSprites = new PriorityQueue&lt;&gt;(</span>
                numEntities);
<span class="nc" id="L3618">        Map&lt;List&lt;Integer&gt;, EntitySprite&gt; newSpriteIds = new HashMap&lt;&gt;(</span>
                numEntities);
<span class="nc" id="L3620">        Map&lt;List&lt;Integer&gt;, IsometricSprite&gt; newIsoSpriteIds = new HashMap&lt;&gt;(</span>
                numEntities);

<span class="nc" id="L3623">        ArrayList&lt;WreckSprite&gt; newWrecks = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L3624">        ArrayList&lt;IsometricWreckSprite&gt; newIsometricWrecks = new ArrayList&lt;&gt;();</span>

<span class="nc" id="L3626">        Enumeration&lt;Entity&gt; e = game.getWreckedEntities();</span>
<span class="nc bnc" id="L3627" title="All 2 branches missed.">        while (e.hasMoreElements()) {</span>
<span class="nc" id="L3628">            Entity entity = e.nextElement();</span>
<span class="nc bnc" id="L3629" title="All 4 branches missed.">            if (!(entity instanceof Infantry) &amp;&amp; (entity.getPosition() != null)) {</span>
                WreckSprite ws;
                IsometricWreckSprite iws;
<span class="nc bnc" id="L3632" title="All 2 branches missed.">                if (entity.getSecondaryPositions().isEmpty()) {</span>
<span class="nc" id="L3633">                    ws = new WreckSprite(this, entity, -1);</span>
<span class="nc" id="L3634">                    newWrecks.add(ws);</span>
<span class="nc" id="L3635">                    iws = new IsometricWreckSprite(this, entity, -1);</span>
<span class="nc" id="L3636">                    newIsometricWrecks.add(iws);</span>
                } else {
<span class="nc bnc" id="L3638" title="All 2 branches missed.">                    for (int secondaryPos : entity.getSecondaryPositions()</span>
<span class="nc" id="L3639">                            .keySet()) {</span>
<span class="nc" id="L3640">                        ws = new WreckSprite(this, entity, secondaryPos);</span>
<span class="nc" id="L3641">                        newWrecks.add(ws);</span>
<span class="nc" id="L3642">                        iws = new IsometricWreckSprite(this, entity,</span>
                                secondaryPos);
<span class="nc" id="L3644">                        newIsometricWrecks.add(iws);</span>
<span class="nc" id="L3645">                    }</span>
                }
            }
<span class="nc" id="L3648">        }</span>

<span class="nc" id="L3650">        clearC3Networks();</span>
<span class="nc" id="L3651">        clearFlyOverPaths();</span>
<span class="nc bnc" id="L3652" title="All 2 branches missed.">        for (Entity entity : game.getEntitiesVector()) {</span>
<span class="nc bnc" id="L3653" title="All 2 branches missed.">            if (entity.getPosition() == null) {</span>
<span class="nc" id="L3654">                continue;</span>
            }
<span class="nc bnc" id="L3656" title="All 2 branches missed.">            if ((localPlayer != null)</span>
<span class="nc bnc" id="L3657" title="All 2 branches missed.">                    &amp;&amp; game.getOptions().booleanOption(OptionsConstants.ADVANCED_DOUBLE_BLIND)</span>
<span class="nc bnc" id="L3658" title="All 2 branches missed.">                    &amp;&amp; entity.getOwner().isEnemyOf(localPlayer)</span>
<span class="nc bnc" id="L3659" title="All 2 branches missed.">                    &amp;&amp; !entity.hasSeenEntity(localPlayer)</span>
<span class="nc bnc" id="L3660" title="All 2 branches missed.">                    &amp;&amp; !entity.hasDetectedEntity(localPlayer)) {</span>
<span class="nc" id="L3661">                continue;</span>
            }
<span class="nc bnc" id="L3663" title="All 2 branches missed.">            if ((localPlayer != null)</span>
<span class="nc bnc" id="L3664" title="All 2 branches missed.">                    &amp;&amp; game.getOptions().booleanOption(OptionsConstants.ADVANCED_HIDDEN_UNITS)</span>
<span class="nc bnc" id="L3665" title="All 2 branches missed.">                    &amp;&amp; entity.getOwner().isEnemyOf(localPlayer)</span>
<span class="nc bnc" id="L3666" title="All 2 branches missed.">                    &amp;&amp; entity.isHidden()) {</span>
<span class="nc" id="L3667">                continue;</span>
            }
<span class="nc bnc" id="L3669" title="All 2 branches missed.">            if (entity.getSecondaryPositions().isEmpty()) {</span>
<span class="nc" id="L3670">                EntitySprite sprite = new EntitySprite(this, entity, -1,</span>
                        radarBlipImage);
<span class="nc" id="L3672">                newSprites.add(sprite);</span>
<span class="nc" id="L3673">                newSpriteIds.put(getIdAndLoc(entity.getId(), -1), sprite);</span>
<span class="nc" id="L3674">                IsometricSprite isosprite = new IsometricSprite(this, entity,</span>
                        -1, radarBlipImage);
<span class="nc" id="L3676">                newIsometricSprites.add(isosprite);</span>
<span class="nc" id="L3677">                newIsoSpriteIds.put(getIdAndLoc(entity.getId(), -1), isosprite);</span>
<span class="nc" id="L3678">            } else {</span>
<span class="nc bnc" id="L3679" title="All 2 branches missed.">                for (int secondaryPos : entity.getSecondaryPositions().keySet()) {</span>
<span class="nc" id="L3680">                    EntitySprite sprite = new EntitySprite(this, entity,</span>
                            secondaryPos, radarBlipImage);
<span class="nc" id="L3682">                    newSprites.add(sprite);</span>
<span class="nc" id="L3683">                    newSpriteIds.put(getIdAndLoc(entity.getId(), secondaryPos),</span>
                            sprite);

<span class="nc" id="L3686">                    IsometricSprite isosprite = new IsometricSprite(this,</span>
                            entity, secondaryPos, radarBlipImage);
<span class="nc" id="L3688">                    newIsometricSprites.add(isosprite);</span>
<span class="nc" id="L3689">                    newIsoSpriteIds.put(</span>
<span class="nc" id="L3690">                            getIdAndLoc(entity.getId(), secondaryPos),</span>
                            isosprite);
<span class="nc" id="L3692">                }</span>
            }

<span class="nc bnc" id="L3695" title="All 8 branches missed.">            if (entity.hasC3() || entity.hasC3i() || entity.hasActiveNovaCEWS() || entity.hasNavalC3()) {</span>
<span class="nc" id="L3696">                addC3Link(entity);</span>
            }

<span class="nc bnc" id="L3699" title="All 4 branches missed.">            if ((entity.isAirborne() || entity.isMakingVTOLGroundAttack())</span>
<span class="nc bnc" id="L3700" title="All 2 branches missed.">                    &amp;&amp; (entity.getPassedThrough().size() &gt; 1)) {</span>
<span class="nc" id="L3701">                addFlyOverPath(entity);</span>
            }
<span class="nc" id="L3703">        }</span>

<span class="nc" id="L3705">        entitySprites = newSprites;</span>
<span class="nc" id="L3706">        entitySpriteIds = newSpriteIds;</span>

<span class="nc" id="L3708">        isometricSprites = newIsometricSprites;</span>
<span class="nc" id="L3709">        isometricSpriteIds = newIsoSpriteIds;</span>

<span class="nc" id="L3711">        wreckSprites = newWrecks;</span>
<span class="nc" id="L3712">        isometricWreckSprites = newIsometricWrecks;</span>

        // Update ECM list, to ensure that Sprites are updated with ECM info
<span class="nc" id="L3715">        updateEcmList();</span>
        // Re-highlight a selected entity, if present
<span class="nc" id="L3717">        highlightSelectedEntity();</span>

<span class="nc" id="L3719">        scheduleRedraw();</span>
<span class="nc" id="L3720">    }</span>

    private void redrawAllFlares() {
<span class="nc" id="L3723">        flareSprites.clear();</span>
<span class="nc bnc" id="L3724" title="All 2 branches missed.">        for (Flare f : game.getFlares()) {</span>
<span class="nc" id="L3725">            flareSprites.add(new FlareSprite(this, f));</span>
<span class="nc" id="L3726">        }</span>
<span class="nc" id="L3727">    }</span>

    public Image getFlareImage() {
<span class="nc" id="L3730">        return flareImage;</span>
    }

    /**
     * Moves the cursor to the new position, or hides it, if newPos is null
     */
    private void moveCursor(CursorSprite cursor, Coords newPos) {
<span class="nc" id="L3737">        final Rectangle oldBounds = new Rectangle(cursor.getBounds());</span>
<span class="nc bnc" id="L3738" title="All 2 branches missed.">        if (newPos != null) {</span>
<span class="nc" id="L3739">            cursor.setHexLocation(newPos);</span>
        } else {
<span class="nc" id="L3741">            cursor.setOffScreen();</span>
        }
        // repaint affected area
<span class="nc" id="L3744">        repaint(oldBounds);</span>
<span class="nc" id="L3745">        repaint(cursor.getBounds());</span>
<span class="nc" id="L3746">    }</span>

    /**
     * Centers the board on hex c. Uses smooth centering
     * if activated in the client settings.
     */
    public void centerOnHex(Coords c) {
<span class="nc bnc" id="L3753" title="All 2 branches missed.">        if (c == null) return;</span>

<span class="nc bnc" id="L3755" title="All 2 branches missed.">        if (GUIPreferences.getInstance().getBoolean(&quot;SOFTCENTER&quot;)) {</span>
            // Soft Centering:
            // set the target point
<span class="nc" id="L3758">            Point p = getCentreHexLocation(c);</span>
<span class="nc" id="L3759">            softCenterTarget.setLocation(</span>
<span class="nc" id="L3760">                    (double) p.x / boardSize.getWidth(),</span>
<span class="nc" id="L3761">                    (double) p.y / boardSize.getHeight());</span>

            // adjust the target point because the board can't
            // center on points too close to an edge
<span class="nc" id="L3765">            double w = scrollpane.getViewport().getWidth();</span>
<span class="nc" id="L3766">            double h = scrollpane.getViewport().getHeight();</span>
<span class="nc" id="L3767">            double bw = boardSize.getWidth();</span>
<span class="nc" id="L3768">            double bh = boardSize.getHeight();</span>

<span class="nc" id="L3770">            double minX = (w / 2 - HEX_W) / bw;</span>
<span class="nc" id="L3771">            double minY = (h / 2 - HEX_H) / bh;</span>
<span class="nc" id="L3772">            double maxX = (bw + HEX_W - w / 2) / bw;</span>
<span class="nc" id="L3773">            double maxY = (bh + HEX_H - h / 2) / bh;</span>

            // here the order is important because the top/left
            // edges always stop the board, the bottom/right
            // only when the board is big enough
<span class="nc" id="L3778">            softCenterTarget.setLocation(</span>
<span class="nc" id="L3779">                    Math.min(softCenterTarget.getX(), maxX),</span>
<span class="nc" id="L3780">                    Math.min(softCenterTarget.getY(), maxY));</span>

<span class="nc" id="L3782">            softCenterTarget.setLocation(</span>
<span class="nc" id="L3783">                    Math.max(softCenterTarget.getX(), minX),</span>
<span class="nc" id="L3784">                    Math.max(softCenterTarget.getY(), minY));</span>

            // get the current board center point
<span class="nc" id="L3787">            double[] v = getVisibleArea();</span>
<span class="nc" id="L3788">            oldCenter.setLocation((v[0] + v[2]) / 2, (v[1] + v[3]) / 2);</span>

<span class="nc" id="L3790">            waitTimer = 0;</span>
<span class="nc" id="L3791">            isSoftCentering = true;</span>

<span class="nc" id="L3793">        } else {</span>
            // no soft centering:
            // center on c directly
<span class="nc" id="L3796">            Point p = getCentreHexLocation(c);</span>
<span class="nc" id="L3797">            centerOnPointRel(</span>
<span class="nc" id="L3798">                    (double) p.x / boardSize.getWidth(),</span>
<span class="nc" id="L3799">                    (double) p.y / boardSize.getHeight());</span>
        }
<span class="nc" id="L3801">    }</span>

    /**
     * Moves the board one step towards the final
     * position in during soft centering.
     */
    private synchronized void centerOnHexSoftStep(long deltaTime) {
<span class="nc bnc" id="L3808" title="All 2 branches missed.">        if (isSoftCentering) {</span>
            // don't move the board if 20ms haven't passed since the last move
<span class="nc" id="L3810">            waitTimer += deltaTime;</span>
<span class="nc bnc" id="L3811" title="All 2 branches missed.">            if (waitTimer &lt; 20) return;</span>
<span class="nc" id="L3812">            waitTimer = 0;</span>

            // move the board by a fraction of the distance to the target
<span class="nc" id="L3815">            Point2D newCenter = new Point2D.Double(</span>
<span class="nc" id="L3816">                    oldCenter.getX() + (softCenterTarget.getX() - oldCenter.getX()) / SOFT_CENTER_SPEED,</span>
<span class="nc" id="L3817">                    oldCenter.getY() + (softCenterTarget.getY() - oldCenter.getY()) / SOFT_CENTER_SPEED);</span>
<span class="nc" id="L3818">            centerOnPointRel(newCenter.getX(), newCenter.getY());</span>

<span class="nc" id="L3820">            oldCenter = newCenter;</span>

            // stop the motion when close enough to the final position
<span class="nc bnc" id="L3823" title="All 2 branches missed.">            if (softCenterTarget.distance(newCenter) &lt; 0.0005) {</span>
<span class="nc" id="L3824">                stopSoftCentering();</span>
<span class="nc" id="L3825">                pingMinimap();</span>
            }
        }
<span class="nc" id="L3828">    }</span>

    public void stopSoftCentering() {
<span class="nc" id="L3831">        isSoftCentering = false;</span>
<span class="nc" id="L3832">    }</span>

    private void adjustVisiblePosition(Coords c, Point dispPoint, double ihdx, double ihdy) {
<span class="nc bnc" id="L3835" title="All 4 branches missed.">        if ((c == null) || (dispPoint == null)) return;</span>

<span class="nc" id="L3837">        Point hexPoint = getCentreHexLocation(c);</span>
        // correct for upper left board padding
<span class="nc" id="L3839">        hexPoint.translate(HEX_W, HEX_H);</span>
<span class="nc" id="L3840">        JScrollBar hscroll = scrollpane.getHorizontalScrollBar();</span>
<span class="nc" id="L3841">        hscroll.setValue(hexPoint.x - dispPoint.x + (int) (ihdx * scale * HEX_W));</span>
<span class="nc" id="L3842">        JScrollBar vscroll = scrollpane.getVerticalScrollBar();</span>
<span class="nc" id="L3843">        vscroll.setValue(hexPoint.y - dispPoint.y + (int) (ihdy * scale * HEX_H));</span>
<span class="nc" id="L3844">        pingMinimap();</span>
<span class="nc" id="L3845">        repaint();</span>
<span class="nc" id="L3846">    }</span>

    /**
     * Centers the board to a point
     *
     * @param xrel the x position relative to board width.
     * @param yrel the y position relative to board height.
     *             Both xrel and yrel should be between 0 and 1.
     *             The method will clip both values to this range.
     */
    public void centerOnPointRel(double xrel, double yrel) {
        // restrict both values to between 0 and 1
<span class="nc" id="L3858">        xrel = Math.max(0, xrel);</span>
<span class="nc" id="L3859">        xrel = Math.min(1, xrel);</span>
<span class="nc" id="L3860">        yrel = Math.max(0, yrel);</span>
<span class="nc" id="L3861">        yrel = Math.min(1, yrel);</span>
<span class="nc" id="L3862">        Point p = new Point(</span>
<span class="nc" id="L3863">                (int) (boardSize.getWidth() * xrel) + HEX_W,</span>
<span class="nc" id="L3864">                (int) (boardSize.getHeight() * yrel) + HEX_H);</span>
<span class="nc" id="L3865">        JScrollBar vscroll = scrollpane.getVerticalScrollBar();</span>
<span class="nc" id="L3866">        vscroll.setValue(p.y - (vscroll.getVisibleAmount() / 2));</span>
<span class="nc" id="L3867">        JScrollBar hscroll = scrollpane.getHorizontalScrollBar();</span>
<span class="nc" id="L3868">        hscroll.setValue(p.x - (hscroll.getVisibleAmount() / 2));</span>
<span class="nc" id="L3869">        repaint();</span>
<span class="nc" id="L3870">    }</span>

    /**
     * Returns the currently visible area of the board.
     *
     * @return an array of 4 double values indicating the relative size,
     * where the first two values indicate the x and y position of the upper left
     * corner of the visible area and the second two values the x and y position of
     * the lower right corner.
     * So when the whole board is visible, the values should be 0,0,1,1.
     * When the lower right corner of the board is visible
     * and 90% of width and height: 0.1,0.1,1,1
     * Due to board padding the values can be outside of [0;1]
     */
    public double[] getVisibleArea() {
<span class="nc" id="L3885">        double[] values = new double[4];</span>
<span class="nc" id="L3886">        double x = scrollpane.getViewport().getViewPosition().getX();</span>
<span class="nc" id="L3887">        double y = scrollpane.getViewport().getViewPosition().getY();</span>
<span class="nc" id="L3888">        double w = scrollpane.getViewport().getWidth();</span>
<span class="nc" id="L3889">        double h = scrollpane.getViewport().getHeight();</span>
<span class="nc" id="L3890">        double bw = boardSize.getWidth();</span>
<span class="nc" id="L3891">        double bh = boardSize.getHeight();</span>

<span class="nc" id="L3893">        values[0] = (x - HEX_W) / bw;</span>
<span class="nc" id="L3894">        values[1] = (y - HEX_H) / bh;</span>
<span class="nc" id="L3895">        values[2] = (x - HEX_W + w) / bw;</span>
<span class="nc" id="L3896">        values[3] = (y - HEX_H + h) / bh;</span>

<span class="nc" id="L3898">        return values;</span>
    }

    /**
     * Clears the old movement data and draws the new.
     */
    public void drawMovementData(Entity entity, MovePath md) {
<span class="nc" id="L3905">        MoveStep previousStep = null;</span>

<span class="nc" id="L3907">        clearMovementData();</span>

        // Nothing to do if we don't have a MovePath
<span class="nc bnc" id="L3910" title="All 2 branches missed.">        if (md == null) {</span>
<span class="nc" id="L3911">            movementTarget = null;</span>
<span class="nc" id="L3912">            return;</span>
        }
        // need to update the movement sprites based on the move path for this
        // entity
        // only way to do this is to clear and refresh (seems wasteful)

        // first get the color for the vector
<span class="nc" id="L3919">        Color col = Color.blue;</span>
<span class="nc bnc" id="L3920" title="All 2 branches missed.">        if (md.getLastStep() != null) {</span>
<span class="nc bnc" id="L3921" title="All 5 branches missed.">            switch (md.getLastStep().getMovementType(true)) {</span>
                case MOVE_RUN:
                case MOVE_VTOL_RUN:
                case MOVE_OVER_THRUST:
<span class="nc" id="L3925">                    col = GUIPreferences.getInstance().getColor(</span>
                            &quot;AdvancedMoveRunColor&quot;);
<span class="nc" id="L3927">                    break;</span>
                case MOVE_SPRINT:
                case MOVE_VTOL_SPRINT:
<span class="nc" id="L3930">                    col = GUIPreferences.getInstance().getColor(</span>
                            &quot;AdvancedMoveSprintColor&quot;);
<span class="nc" id="L3932">                    break;</span>
                case MOVE_JUMP:
<span class="nc" id="L3934">                    col = GUIPreferences.getInstance().getColor(</span>
                            &quot;AdvancedMoveJumpColor&quot;);
<span class="nc" id="L3936">                    break;</span>
                case MOVE_ILLEGAL:
<span class="nc" id="L3938">                    col = GUIPreferences.getInstance().getColor(</span>
                            &quot;AdvancedMoveIllegalColor&quot;);
<span class="nc" id="L3940">                    break;</span>
                default:
<span class="nc" id="L3942">                    col = GUIPreferences.getInstance().getColor(</span>
                            &quot;AdvancedMoveDefaultColor&quot;);
                    break;
            }
<span class="nc" id="L3946">            movementTarget = md.getLastStep().getPosition();</span>
        } else {
<span class="nc" id="L3948">            movementTarget = null;</span>
        }

<span class="nc" id="L3951">        refreshMoveVectors(entity, md, col);</span>

<span class="nc bnc" id="L3953" title="All 2 branches missed.">        for (Enumeration&lt;MoveStep&gt; i = md.getSteps(); i.hasMoreElements(); ) {</span>
<span class="nc" id="L3954">            final MoveStep step = i.nextElement();</span>
<span class="nc bnc" id="L3955" title="All 2 branches missed.">            if ((null != previousStep)</span>
<span class="nc bnc" id="L3956" title="All 2 branches missed.">                    &amp;&amp; ((step.getType() == MoveStepType.UP)</span>
<span class="nc bnc" id="L3957" title="All 2 branches missed.">                    || (step.getType() == MoveStepType.DOWN)</span>
<span class="nc bnc" id="L3958" title="All 2 branches missed.">                    || (step.getType() == MoveStepType.ACC)</span>
<span class="nc bnc" id="L3959" title="All 2 branches missed.">                    || (step.getType() == MoveStepType.DEC)</span>
<span class="nc bnc" id="L3960" title="All 2 branches missed.">                    || (step.getType() == MoveStepType.ACCN)</span>
<span class="nc bnc" id="L3961" title="All 2 branches missed.">                    || (step.getType() == MoveStepType.DECN))) {</span>
                // Mark the previous elevation change sprite hidden
                // so that we can draw a new one in it's place without
                // having overlap.
<span class="nc" id="L3965">                pathSprites.get(pathSprites.size() - 1).setHidden(true);</span>
            }

<span class="nc bnc" id="L3968" title="All 2 branches missed.">            if (previousStep != null</span>
                    // for advanced movement, we always need to hide prior
                    // because costs will overlap and we only want the current
                    // facing
<span class="nc bnc" id="L3972" title="All 2 branches missed.">                    &amp;&amp; (game.useVectorMove()</span>
                    // A LAM converting from AirMech to Biped uses two convert steps and we
                    // only want to show the last.
<span class="nc bnc" id="L3975" title="All 2 branches missed.">                    || (step.getType() == MoveStepType.CONVERT_MODE</span>
<span class="nc bnc" id="L3976" title="All 2 branches missed.">                    &amp;&amp; previousStep.getType() == MoveStepType.CONVERT_MODE)</span>
<span class="nc bnc" id="L3977" title="All 2 branches missed.">                    || step.getType() == MoveStepType.BOOTLEGGER)) {</span>
<span class="nc" id="L3978">                pathSprites.get(pathSprites.size() - 1).setHidden(true);</span>
            }

<span class="nc" id="L3981">            pathSprites.add(new StepSprite(this, step, md.isEndStep(step)));</span>
<span class="nc" id="L3982">            previousStep = step;</span>
<span class="nc" id="L3983">        }</span>
<span class="nc" id="L3984">        repaint(100);</span>
<span class="nc" id="L3985">    }</span>

    /**
     * Clears current movement data from the screen
     */
    public void clearMovementData() {
<span class="nc" id="L3991">        pathSprites = new ArrayList&lt;StepSprite&gt;();</span>
<span class="nc" id="L3992">        movementTarget = null;</span>
<span class="nc" id="L3993">        checkFoVHexImageCacheClear();</span>
<span class="nc" id="L3994">        repaint();</span>
<span class="nc" id="L3995">        refreshMoveVectors();</span>
<span class="nc" id="L3996">    }</span>

    public void setFiringSolutions(Entity attacker,
                                   Map&lt;Integer, FiringSolution&gt; firingSolutions) {

<span class="nc" id="L4001">        clearFiringSolutionData();</span>
<span class="nc bnc" id="L4002" title="All 2 branches missed.">        if (firingSolutions == null) {</span>
<span class="nc" id="L4003">            return;</span>
        }
<span class="nc bnc" id="L4005" title="All 2 branches missed.">        for (FiringSolution sln : firingSolutions.values()) {</span>
<span class="nc" id="L4006">            FiringSolutionSprite sprite = new FiringSolutionSprite(this, sln);</span>
<span class="nc" id="L4007">            firingSprites.add(sprite);</span>
<span class="nc" id="L4008">        }</span>
<span class="nc" id="L4009">    }</span>

    public void clearFiringSolutionData() {
<span class="nc" id="L4012">        firingSprites.clear();</span>
<span class="nc" id="L4013">        repaint();</span>
<span class="nc" id="L4014">    }</span>

    public void addStrafingCoords(Coords c) {
<span class="nc" id="L4017">        strafingCoords.add(c);</span>
<span class="nc" id="L4018">    }</span>

    public void clearStrafingCoords() {
<span class="nc" id="L4021">        strafingCoords.clear();</span>
<span class="nc" id="L4022">    }</span>

    public void setMovementEnvelope(Map&lt;Coords, Integer&gt; mvEnvData, int walk,
                                    int run, int jump, int gear) {
<span class="nc" id="L4026">        clearMovementEnvelope();</span>

<span class="nc bnc" id="L4028" title="All 2 branches missed.">        if (mvEnvData == null) {</span>
<span class="nc" id="L4029">            return;</span>
        }

<span class="nc" id="L4032">        GUIPreferences guip = GUIPreferences.getInstance();</span>
<span class="nc bnc" id="L4033" title="All 2 branches missed.">        for (Coords loc : mvEnvData.keySet()) {</span>
<span class="nc" id="L4034">            Color spriteColor = null;</span>
<span class="nc" id="L4035">            int mvType = -1;</span>
<span class="nc bnc" id="L4036" title="All 4 branches missed.">            if (gear == MovementDisplay.GEAR_JUMP || gear == MovementDisplay.GEAR_DFA) {</span>
<span class="nc bnc" id="L4037" title="All 2 branches missed.">                if (mvEnvData.get(loc) &lt;= jump) {</span>
<span class="nc" id="L4038">                    spriteColor = guip</span>
<span class="nc" id="L4039">                            .getColor(GUIPreferences.ADVANCED_MOVE_JUMP_COLOR);</span>
<span class="nc" id="L4040">                    mvType = 1;</span>
                }
            } else {
<span class="nc bnc" id="L4043" title="All 2 branches missed.">                if (mvEnvData.get(loc) &lt;= walk) {</span>
<span class="nc" id="L4044">                    spriteColor = guip</span>
<span class="nc" id="L4045">                            .getColor(GUIPreferences.ADVANCED_MOVE_DEFAULT_COLOR);</span>
<span class="nc" id="L4046">                    mvType = 2;</span>

<span class="nc bnc" id="L4048" title="All 2 branches missed.">                } else if (mvEnvData.get(loc) &lt;= run) {</span>
<span class="nc" id="L4049">                    spriteColor = guip</span>
<span class="nc" id="L4050">                            .getColor(GUIPreferences.ADVANCED_MOVE_RUN_COLOR);</span>
<span class="nc" id="L4051">                    mvType = 3;</span>
                } else {
<span class="nc" id="L4053">                    spriteColor = guip</span>
<span class="nc" id="L4054">                            .getColor(GUIPreferences.ADVANCED_MOVE_SPRINT_COLOR);</span>
<span class="nc" id="L4055">                    mvType = 4;</span>
                }
            }

            // Next: check the adjacent hexes and find
            // those with the same movement type,
            // send this to the Sprite so it paints only
            // the borders of the movement type areas
<span class="nc" id="L4063">            int edgesToPaint = 0;</span>
            // cycle through hexes
<span class="nc bnc" id="L4065" title="All 2 branches missed.">            for (int dir = 0; dir &lt; 6; dir++) {</span>
<span class="nc" id="L4066">                int mvAdjType = 0;</span>
<span class="nc" id="L4067">                Coords adjacentHex = loc.translated(dir);</span>
                // get the movement type
<span class="nc" id="L4069">                Integer Adjmv = mvEnvData.get(adjacentHex);</span>
<span class="nc bnc" id="L4070" title="All 2 branches missed.">                if (Adjmv == null) {</span>
<span class="nc" id="L4071">                    edgesToPaint += (1 &lt;&lt; dir);</span>
<span class="nc" id="L4072">                    continue;</span>
                }
<span class="nc bnc" id="L4074" title="All 2 branches missed.">                if (gear == MovementDisplay.GEAR_JUMP) {</span>
<span class="nc bnc" id="L4075" title="All 2 branches missed.">                    if (Adjmv &lt;= jump) mvAdjType = 1;</span>
                } else {
<span class="nc bnc" id="L4077" title="All 2 branches missed.">                    if (Adjmv &lt;= walk) mvAdjType = 2;</span>
<span class="nc bnc" id="L4078" title="All 2 branches missed.">                    else if (Adjmv &lt;= run) mvAdjType = 3;</span>
<span class="nc" id="L4079">                    else mvAdjType = 4;</span>
                }
                // other movement type: paint a border in this direction
<span class="nc bnc" id="L4082" title="All 2 branches missed.">                if (mvAdjType != mvType) edgesToPaint += (1 &lt;&lt; dir);</span>
            }

<span class="nc bnc" id="L4085" title="All 2 branches missed.">            if (spriteColor != null) {</span>
<span class="nc" id="L4086">                MovementEnvelopeSprite mvSprite = new MovementEnvelopeSprite(</span>
                        this, spriteColor, loc, edgesToPaint);
<span class="nc" id="L4088">                moveEnvSprites.add(mvSprite);</span>
            }
<span class="nc" id="L4090">        }</span>

<span class="nc" id="L4092">        repaint();</span>

<span class="nc" id="L4094">    }</span>

    public void setMovementModifierEnvelope(Collection&lt;MovePath&gt; movePaths) {
<span class="nc" id="L4097">        moveModEnvSprites.clear();</span>
<span class="nc bnc" id="L4098" title="All 2 branches missed.">        for (MovePath mp : movePaths) {</span>
<span class="nc" id="L4099">            moveModEnvSprites.add(new MovementModifierEnvelopeSprite(this, mp));</span>
<span class="nc" id="L4100">        }</span>
<span class="nc" id="L4101">        repaint();</span>
<span class="nc" id="L4102">    }</span>

    public void clearMovementEnvelope() {
<span class="nc" id="L4105">        moveEnvSprites.clear();</span>
<span class="nc" id="L4106">        moveModEnvSprites.clear();</span>
<span class="nc" id="L4107">        repaint();</span>
<span class="nc" id="L4108">    }</span>

    /**
     * Draws the given &lt;code&gt;text&lt;/code&gt; in the currently active font of the Graphics &lt;code&gt;g2D&lt;/code&gt;
     * at font size &lt;code&gt;fontSize&lt;/code&gt;. The text is centered in both
     * x and y directions around the position &lt;code&gt;pos&lt;/code&gt;. The text is colored with
     * the given &lt;code&gt;color&lt;/code&gt;, made translucent if the flag is set. The outline of the text
     * will be dark gray.
     *
     * @param g2D         the graphics to draw to, as &lt;code&gt;Graphics2D&lt;/code&gt;
     * @param text        the string to write
     * @param pos         the board pixel position
     * @param fontSize    the font size. This will be scaled by the current board zoom
     * @param color       the color to draw the text in
     * @param translucent (optional)  makes the text translucent if set to true. Defaults to false
     * @param cOutline    (optional) the color of the outline. Defaults to Color.DARK_GRAY
     */
    public void drawOutlineText(Graphics2D g2D, String text, Point pos,
                                float fontSize, Color color, boolean translucent, Color cOutline) {
<span class="nc" id="L4127">        g2D.setFont(g2D.getFont().deriveFont(fontSize));</span>
<span class="nc" id="L4128">        FontMetrics fm = g2D.getFontMetrics(g2D.getFont());</span>
        // Center the text around pos
<span class="nc" id="L4130">        int cx = pos.x - (fm.stringWidth(text) / 2);</span>
<span class="nc" id="L4131">        int cy = pos.y + (fm.getAscent() - fm.getDescent()) / 2;</span>

        // get text shape and position it
<span class="nc" id="L4134">        GlyphVector gv = g2D.getFont().createGlyphVector(g2D.getFontRenderContext(), text);</span>
<span class="nc" id="L4135">        Shape shape = gv.getOutline();</span>
<span class="nc" id="L4136">        shape = AffineTransform.getTranslateInstance(cx, cy).</span>
<span class="nc" id="L4137">                createTransformedShape(shape);</span>

        // text area fill
<span class="nc bnc" id="L4140" title="All 2 branches missed.">        if (translucent)</span>
<span class="nc" id="L4141">            color = new Color(color.getRGB() &amp; 0x00FFFFFF | 0xA0000000, true);</span>
<span class="nc" id="L4142">        g2D.setColor(color);</span>
<span class="nc" id="L4143">        g2D.fill(shape);</span>

        // outline
<span class="nc" id="L4146">        g2D.setStroke(new BasicStroke(0.5f));</span>
<span class="nc" id="L4147">        Color lineColor = cOutline;</span>
<span class="nc bnc" id="L4148" title="All 2 branches missed.">        if (translucent)</span>
<span class="nc" id="L4149">            lineColor = new Color(lineColor.getRGB() &amp; 0x00FFFFFF | 0xA0000000, true);</span>
<span class="nc" id="L4150">        g2D.setColor(lineColor);</span>
<span class="nc" id="L4151">        g2D.draw(shape);</span>
<span class="nc" id="L4152">    }</span>

    public void drawOutlineText(Graphics2D g2D, String text, Point pos,
                                float fontSize, Color color, boolean translucent) {
<span class="nc" id="L4156">        drawOutlineText(g2D, text, pos, fontSize, color, translucent, Color.DARK_GRAY);</span>
<span class="nc" id="L4157">    }</span>

    public void drawOutlineText(Graphics2D g2D, String text, Point pos,
                                float fontSize, Color color) {
<span class="nc" id="L4161">        drawOutlineText(g2D, text, pos, fontSize, color, false, Color.DARK_GRAY);</span>
<span class="nc" id="L4162">    }</span>

    public void drawTextShadow(Graphics2D g2D, String text, Point pos,
                               Font font) {
<span class="nc" id="L4166">        g2D.setFont(font);</span>
        // to keep the shadow always 1 px wide,
        // counteract the current graph scaling
<span class="nc" id="L4169">        double scX = g2D.getTransform().getScaleX();</span>
<span class="nc" id="L4170">        double scY = g2D.getTransform().getScaleY();</span>

<span class="nc" id="L4172">        drawCenteredText(g2D, text, (float) pos.x + (1.0f) / (float) scX, (float) pos.y, Color.BLACK, false);</span>
<span class="nc" id="L4173">        drawCenteredText(g2D, text, (float) pos.x - (1.0f) / (float) scX, (float) pos.y, Color.BLACK, false);</span>
<span class="nc" id="L4174">        drawCenteredText(g2D, text, (float) pos.x, (float) pos.y + (1.0f) / (float) scY, Color.BLACK, false);</span>
<span class="nc" id="L4175">        drawCenteredText(g2D, text, (float) pos.x, (float) pos.y - (1.0f) / (float) scY, Color.BLACK, false);</span>
<span class="nc" id="L4176">    }</span>

    public void drawCenteredText(Graphics2D g2D, String text, Point pos,
                                 Color color, boolean translucent) {
<span class="nc" id="L4180">        FontMetrics fm = g2D.getFontMetrics(g2D.getFont());</span>
        // Center the text around pos
<span class="nc" id="L4182">        int cx = pos.x - (fm.stringWidth(text) / 2);</span>
<span class="nc" id="L4183">        int cy = pos.y - fm.getAscent() / 2 - fm.getDescent() / 2 + fm.getAscent();</span>

<span class="nc bnc" id="L4185" title="All 2 branches missed.">        if (translucent)</span>
<span class="nc" id="L4186">            color = new Color(color.getRGB() &amp; 0x00FFFFFF | 0xA0000000, true);</span>
<span class="nc" id="L4187">        g2D.setColor(color);</span>
<span class="nc" id="L4188">        g2D.drawString(text, cx, cy);</span>
<span class="nc" id="L4189">    }</span>

    // This method is used to draw text shadows even when the g2D is scaled
    public void drawCenteredText(Graphics2D g2D, String text, float posx, float posy,
                                 Color color, boolean translucent) {
<span class="nc" id="L4194">        FontMetrics fm = g2D.getFontMetrics(g2D.getFont());</span>
        // Center the text around pos
<span class="nc" id="L4196">        float cx = posx - (fm.stringWidth(text) / 2);</span>
<span class="nc" id="L4197">        float cy = posy - fm.getAscent() / 2 - fm.getDescent() / 2 + fm.getAscent();</span>

<span class="nc bnc" id="L4199" title="All 2 branches missed.">        if (translucent)</span>
<span class="nc" id="L4200">            color = new Color(color.getRGB() &amp; 0x00FFFFFF | 0xA0000000, true);</span>
<span class="nc" id="L4201">        g2D.setColor(color);</span>
<span class="nc" id="L4202">        g2D.drawString(text, cx, cy);</span>
<span class="nc" id="L4203">    }</span>

    public void drawCenteredText(Graphics2D g2D, String text, Point pos,
                                 Color color, boolean translucent, Font font) {
<span class="nc" id="L4207">        g2D.setFont(font);</span>
<span class="nc" id="L4208">        drawCenteredText(g2D, text, pos, color, translucent);</span>
<span class="nc" id="L4209">    }</span>

    public void drawCenteredText(Graphics2D g2D, String text, Point pos,
                                 Color color, boolean translucent, int fontSize) {
<span class="nc" id="L4213">        g2D.setFont(g2D.getFont().deriveFont(fontSize));</span>
<span class="nc" id="L4214">        drawCenteredText(g2D, text, pos, color, translucent);</span>
<span class="nc" id="L4215">    }</span>

    public IPlayer getLocalPlayer() {
<span class="nc" id="L4218">        return localPlayer;</span>
    }

    public void setLocalPlayer(IPlayer p) {
<span class="nc" id="L4222">        localPlayer = p;</span>
<span class="nc" id="L4223">    }</span>

    /**
     * Specifies that this should mark the deployment hexes for a player. If the
     * player is set to null, no hexes will be marked.
     */
    public void markDeploymentHexesFor(Entity ce) {
<span class="nc" id="L4230">        en_Deployer = ce;</span>
<span class="nc" id="L4231">        repaint(100);</span>
<span class="nc" id="L4232">    }</span>

    /**
     * Returns the entity that is currently being deployed
     */
    public Entity getDeployingEntity() {
<span class="nc" id="L4238">        return en_Deployer;</span>
    }

    /**
     * add a fly over path to the sprite list
     */
    public void addFlyOverPath(Entity e) {
<span class="nc bnc" id="L4245" title="All 2 branches missed.">        if (e.getPosition() == null) {</span>
<span class="nc" id="L4246">            return;</span>
        }

<span class="nc bnc" id="L4249" title="All 2 branches missed.">        if (e.isMakingVTOLGroundAttack()) {</span>
<span class="nc" id="L4250">            vtolAttackSprites.add(new VTOLAttackSprite(this, e));</span>
        }
<span class="nc" id="L4252">        flyOverSprites.add(new FlyOverSprite(this, e));</span>
<span class="nc" id="L4253">    }</span>

    public List&lt;Entity&gt; getEntitiesFlyingOver(Coords c) {
<span class="nc" id="L4256">        List&lt;Entity&gt; entities = new ArrayList&lt;Entity&gt;();</span>
<span class="nc bnc" id="L4257" title="All 2 branches missed.">        for (FlyOverSprite fsprite : flyOverSprites) {</span>
            //Spaceborne units shouldn't count here. They show up incorrectly in the firing display when sensors are in use.
<span class="nc bnc" id="L4259" title="All 4 branches missed.">            if (fsprite.getEntity().getPassedThrough().contains(c) &amp;&amp; !fsprite.getEntity().isSpaceborne()) {</span>
<span class="nc" id="L4260">                entities.add(fsprite.getEntity());</span>
            }
<span class="nc" id="L4262">        }</span>
<span class="nc" id="L4263">        return entities;</span>
    }

    /**
     * Adds a c3 line to the sprite list.
     */
    public void addC3Link(Entity e) {
<span class="nc bnc" id="L4270" title="All 2 branches missed.">        if (e.getPosition() == null) {</span>
<span class="nc" id="L4271">            return;</span>
        }

<span class="nc bnc" id="L4274" title="All 2 branches missed.">        if (e.hasC3i()) {</span>
<span class="nc bnc" id="L4275" title="All 2 branches missed.">            for (Entity fe : game.getEntitiesVector()) {</span>
<span class="nc bnc" id="L4276" title="All 2 branches missed.">                if (fe.getPosition() == null) {</span>
<span class="nc" id="L4277">                    return;</span>
                }
<span class="nc bnc" id="L4279" title="All 2 branches missed.">                if (e.onSameC3NetworkAs(fe)</span>
<span class="nc bnc" id="L4280" title="All 2 branches missed.">                        &amp;&amp; !fe.equals(e)</span>
<span class="nc bnc" id="L4281" title="All 2 branches missed.">                        &amp;&amp; !ComputeECM.isAffectedByECM(e, e.getPosition(),</span>
<span class="nc" id="L4282">                        fe.getPosition())) {</span>
<span class="nc" id="L4283">                    c3Sprites.add(new C3Sprite(this, e, fe));</span>
                }
<span class="nc" id="L4285">            }</span>
<span class="nc bnc" id="L4286" title="All 2 branches missed.">        } else if (e.hasNavalC3()) {</span>
<span class="nc bnc" id="L4287" title="All 2 branches missed.">            for (Entity fe : game.getEntitiesVector()) {</span>
<span class="nc bnc" id="L4288" title="All 2 branches missed.">                if (fe.getPosition() == null) {</span>
<span class="nc" id="L4289">                    return;</span>
                }
<span class="nc bnc" id="L4291" title="All 4 branches missed.">                if (e.onSameC3NetworkAs(fe) &amp;&amp; !fe.equals(e)) {</span>
<span class="nc" id="L4292">                    c3Sprites.add(new C3Sprite(this, e, fe));</span>
                }
<span class="nc" id="L4294">            }</span>
<span class="nc bnc" id="L4295" title="All 2 branches missed.">        } else if (e.hasActiveNovaCEWS()) {</span>
            // WOR Nova CEWS
<span class="nc bnc" id="L4297" title="All 2 branches missed.">            for (Entity fe : game.getEntitiesVector()) {</span>
<span class="nc bnc" id="L4298" title="All 2 branches missed.">                if (fe.getPosition() == null) {</span>
<span class="nc" id="L4299">                    return;</span>
                }
<span class="nc" id="L4301">                ECMInfo ecmInfo = ComputeECM.getECMEffects(e, e.getPosition(),</span>
<span class="nc" id="L4302">                        fe.getPosition(), true, null);</span>
<span class="nc bnc" id="L4303" title="All 2 branches missed.">                if (e.onSameC3NetworkAs(fe)</span>
<span class="nc bnc" id="L4304" title="All 4 branches missed.">                        &amp;&amp; !fe.equals(e)</span>
                        &amp;&amp; (ecmInfo != null)
<span class="nc bnc" id="L4306" title="All 2 branches missed.">                        &amp;&amp; !ecmInfo.isNovaECM()) {</span>
<span class="nc" id="L4307">                    c3Sprites.add(new C3Sprite(this, e, fe));</span>
                }
<span class="nc" id="L4309">            }</span>
<span class="nc bnc" id="L4310" title="All 2 branches missed.">        } else if (e.getC3Master() != null) {</span>
<span class="nc" id="L4311">            Entity eMaster = e.getC3Master();</span>
<span class="nc bnc" id="L4312" title="All 2 branches missed.">            if (eMaster.getPosition() == null) {</span>
<span class="nc" id="L4313">                return;</span>
            }

            // ECM cuts off the network
<span class="nc" id="L4317">            boolean blocked = false;</span>
<span class="nc bnc" id="L4318" title="All 4 branches missed.">            if (e.hasBoostedC3() &amp;&amp; eMaster.hasBoostedC3()) {</span>
<span class="nc bnc" id="L4319" title="All 2 branches missed.">                blocked = ComputeECM.isAffectedByAngelECM(e, e.getPosition(),</span>
<span class="nc" id="L4320">                        eMaster.getPosition())</span>
<span class="nc bnc" id="L4321" title="All 2 branches missed.">                        || ComputeECM.isAffectedByAngelECM(eMaster,</span>
<span class="nc" id="L4322">                        eMaster.getPosition(), eMaster.getPosition());</span>
            } else {
<span class="nc bnc" id="L4324" title="All 2 branches missed.">                blocked = ComputeECM.isAffectedByECM(e, e.getPosition(),</span>
<span class="nc" id="L4325">                        eMaster.getPosition())</span>
<span class="nc bnc" id="L4326" title="All 2 branches missed.">                        || ComputeECM.isAffectedByECM(eMaster,</span>
<span class="nc" id="L4327">                        eMaster.getPosition(), eMaster.getPosition());</span>
            }

<span class="nc bnc" id="L4330" title="All 2 branches missed.">            if (!blocked) {</span>
<span class="nc" id="L4331">                c3Sprites.add(new C3Sprite(this, e, e.getC3Master()));</span>
            }
        }
<span class="nc" id="L4334">    }</span>

    /**
     * Adds an attack to the sprite list.
     */
    public synchronized void addAttack(AttackAction aa) {
        // Don't make sprites for unknown entities and sensor returns
<span class="nc" id="L4341">        Entity ae = game.getEntity(aa.getEntityId());</span>
<span class="nc" id="L4342">        Targetable t = game.getTarget(aa.getTargetType(), aa.getTargetId());</span>
<span class="nc bnc" id="L4343" title="All 4 branches missed.">        if ((ae == null) || (t == null)</span>
<span class="nc bnc" id="L4344" title="All 2 branches missed.">                || (t.getTargetType() == Targetable.TYPE_INARC_POD)</span>
<span class="nc bnc" id="L4345" title="All 4 branches missed.">                || (t.getPosition() == null) || (ae.getPosition() == null)) {</span>
<span class="nc" id="L4346">            return;</span>
        }
<span class="nc" id="L4348">        EntitySprite eSprite = entitySpriteIds.get(getIdAndLoc(ae.getId(),</span>
<span class="nc bnc" id="L4349" title="All 2 branches missed.">                ae.getSecondaryPositions().size() &gt; 0 ? 0 : -1));</span>
<span class="nc bnc" id="L4350" title="All 4 branches missed.">        if (eSprite != null &amp;&amp; eSprite.onlyDetectedBySensors()) {</span>
<span class="nc" id="L4351">            return;</span>
        }

<span class="nc" id="L4354">        repaint(100);</span>
<span class="nc bnc" id="L4355" title="All 2 branches missed.">        for (AttackSprite sprite : attackSprites) {</span>
            // can we just add this attack to an existing one?
<span class="nc bnc" id="L4357" title="All 2 branches missed.">            if ((sprite.getEntityId() == aa.getEntityId())</span>
<span class="nc bnc" id="L4358" title="All 2 branches missed.">                    &amp;&amp; (sprite.getTargetId() == aa.getTargetId())) {</span>
                // use existing attack, but add this weapon
<span class="nc bnc" id="L4360" title="All 2 branches missed.">                if (aa instanceof WeaponAttackAction) {</span>
<span class="nc" id="L4361">                    WeaponAttackAction waa = (WeaponAttackAction) aa;</span>
<span class="nc bnc" id="L4362" title="All 2 branches missed.">                    if (aa.getTargetType() != Targetable.TYPE_HEX_ARTILLERY) {</span>
<span class="nc" id="L4363">                        sprite.addWeapon(waa);</span>
<span class="nc" id="L4364">                    } else if (waa.getEntity(game).getOwner().getId() == localPlayer</span>
<span class="nc bnc" id="L4365" title="All 2 branches missed.">                            .getId()) {</span>
<span class="nc" id="L4366">                        sprite.addWeapon(waa);</span>
                    }
                }
<span class="nc bnc" id="L4369" title="All 2 branches missed.">                if (aa instanceof KickAttackAction) {</span>
<span class="nc" id="L4370">                    sprite.addWeapon((KickAttackAction) aa);</span>
                }
<span class="nc bnc" id="L4372" title="All 2 branches missed.">                if (aa instanceof PunchAttackAction) {</span>
<span class="nc" id="L4373">                    sprite.addWeapon((PunchAttackAction) aa);</span>
                }
<span class="nc bnc" id="L4375" title="All 2 branches missed.">                if (aa instanceof PushAttackAction) {</span>
<span class="nc" id="L4376">                    sprite.addWeapon((PushAttackAction) aa);</span>
                }
<span class="nc bnc" id="L4378" title="All 2 branches missed.">                if (aa instanceof ClubAttackAction) {</span>
<span class="nc" id="L4379">                    sprite.addWeapon((ClubAttackAction) aa);</span>
                }
<span class="nc bnc" id="L4381" title="All 2 branches missed.">                if (aa instanceof ChargeAttackAction) {</span>
<span class="nc" id="L4382">                    sprite.addWeapon((ChargeAttackAction) aa);</span>
                }
<span class="nc bnc" id="L4384" title="All 2 branches missed.">                if (aa instanceof DfaAttackAction) {</span>
<span class="nc" id="L4385">                    sprite.addWeapon((DfaAttackAction) aa);</span>
                }
<span class="nc bnc" id="L4387" title="All 2 branches missed.">                if (aa instanceof ProtomechPhysicalAttackAction) {</span>
<span class="nc" id="L4388">                    sprite.addWeapon((ProtomechPhysicalAttackAction) aa);</span>
                }
<span class="nc bnc" id="L4390" title="All 2 branches missed.">                if (aa instanceof SearchlightAttackAction) {</span>
<span class="nc" id="L4391">                    sprite.addWeapon((SearchlightAttackAction) aa);</span>
                }
<span class="nc" id="L4393">                return;</span>
            }
<span class="nc" id="L4395">        }</span>
        // no re-use possible, add a new one
        // don't add a sprite for an artillery attack made by the other player
<span class="nc bnc" id="L4398" title="All 2 branches missed.">        if (aa instanceof WeaponAttackAction) {</span>
<span class="nc" id="L4399">            WeaponAttackAction waa = (WeaponAttackAction) aa;</span>
<span class="nc bnc" id="L4400" title="All 2 branches missed.">            if (aa.getTargetType() != Targetable.TYPE_HEX_ARTILLERY) {</span>
<span class="nc" id="L4401">                attackSprites.add(new AttackSprite(this, aa));</span>
<span class="nc" id="L4402">            } else if (waa.getEntity(game).getOwner().getId() == localPlayer</span>
<span class="nc bnc" id="L4403" title="All 2 branches missed.">                    .getId()) {</span>
<span class="nc" id="L4404">                attackSprites.add(new AttackSprite(this, aa));</span>
            }
<span class="nc" id="L4406">        } else {</span>
<span class="nc" id="L4407">            attackSprites.add(new AttackSprite(this, aa));</span>
        }
<span class="nc" id="L4409">    }</span>

    /**
     * Removes all attack sprites from a certain entity
     */
    public synchronized void removeAttacksFor(Entity e) {
<span class="nc bnc" id="L4415" title="All 2 branches missed.">        if (e == null) {</span>
<span class="nc" id="L4416">            return;</span>
        }
<span class="nc" id="L4418">        int entityId = e.getId();</span>
<span class="nc bnc" id="L4419" title="All 2 branches missed.">        attackSprites.removeIf(sprite -&gt; sprite.getEntityId() == entityId);</span>
<span class="nc" id="L4420">        repaint(100);</span>
<span class="nc" id="L4421">    }</span>

    /**
     * Clears out all attacks and re-adds the ones in the current game.
     */
    public void refreshAttacks() {
<span class="nc" id="L4427">        clearAllAttacks();</span>
<span class="nc" id="L4428">        for (Enumeration&lt;EntityAction&gt; i = game.getActions(); i</span>
<span class="nc bnc" id="L4429" title="All 2 branches missed.">                .hasMoreElements(); ) {</span>
<span class="nc" id="L4430">            EntityAction ea = i.nextElement();</span>
<span class="nc bnc" id="L4431" title="All 2 branches missed.">            if (ea instanceof AttackAction) {</span>
<span class="nc" id="L4432">                addAttack((AttackAction) ea);</span>
            }
<span class="nc" id="L4434">        }</span>
<span class="nc" id="L4435">        for (Enumeration&lt;AttackAction&gt; i = game.getCharges(); i</span>
<span class="nc bnc" id="L4436" title="All 2 branches missed.">                .hasMoreElements(); ) {</span>
<span class="nc" id="L4437">            AttackAction ea = i.nextElement();</span>
<span class="nc bnc" id="L4438" title="All 2 branches missed.">            if (ea instanceof PhysicalAttackAction) {</span>
<span class="nc" id="L4439">                addAttack(ea);</span>
            }
<span class="nc" id="L4441">        }</span>
<span class="nc" id="L4442">        repaint(100);</span>
<span class="nc" id="L4443">    }</span>

    public void refreshMoveVectors() {
<span class="nc" id="L4446">        clearAllMoveVectors();</span>
<span class="nc bnc" id="L4447" title="All 2 branches missed.">        for (Entity e : game.getEntitiesVector()) {</span>
<span class="nc bnc" id="L4448" title="All 2 branches missed.">            if (e.getPosition() != null) {</span>
<span class="nc" id="L4449">                movementSprites.add(new MovementSprite(this, e, e.getVectors(),</span>
                        Color.gray, false));
            }
<span class="nc" id="L4452">        }</span>
<span class="nc" id="L4453">    }</span>

    public void refreshMoveVectors(Entity en, MovePath md, Color col) {
<span class="nc" id="L4456">        clearAllMoveVectors();</span>
        // same as normal but when I find the active entity I used the MovePath
        // to get vector
<span class="nc bnc" id="L4459" title="All 2 branches missed.">        for (Entity e : game.getEntitiesVector()) {</span>
<span class="nc bnc" id="L4460" title="All 2 branches missed.">            if (e.getPosition() != null) {</span>
<span class="nc bnc" id="L4461" title="All 4 branches missed.">                if ((en != null) &amp;&amp; (e.getId() == en.getId())) {</span>
<span class="nc" id="L4462">                    movementSprites.add(new MovementSprite(this, e, md</span>
<span class="nc" id="L4463">                            .getFinalVectors(), col, true));</span>
                } else {
<span class="nc" id="L4465">                    movementSprites.add(new MovementSprite(this, e, e.getVectors(),</span>
                            col, false));
                }
            }
<span class="nc" id="L4469">        }</span>
<span class="nc" id="L4470">    }</span>

    public void clearC3Networks() {
<span class="nc" id="L4473">        c3Sprites.clear();</span>
<span class="nc" id="L4474">    }</span>

    public void clearFlyOverPaths() {
<span class="nc" id="L4477">        vtolAttackSprites.clear();</span>
<span class="nc" id="L4478">        flyOverSprites.clear();</span>
<span class="nc" id="L4479">    }</span>

    /**
     * Clears out all attacks that were being drawn
     */
    public void clearAllAttacks() {
<span class="nc" id="L4485">        attackSprites.clear();</span>
<span class="nc" id="L4486">    }</span>

    /**
     * Clears out all movement vectors that were being drawn
     */
    public void clearAllMoveVectors() {
<span class="nc" id="L4492">        movementSprites.clear();</span>
<span class="nc" id="L4493">    }</span>

    protected void firstLOSHex(Coords c) {
<span class="nc bnc" id="L4496" title="All 2 branches missed.">        if (useLOSTool) {</span>
<span class="nc" id="L4497">            moveCursor(secondLOSSprite, null);</span>
<span class="nc" id="L4498">            moveCursor(firstLOSSprite, c);</span>
        }
<span class="nc" id="L4500">    }</span>

    protected void secondLOSHex(Coords c2, Coords c1) {
<span class="nc bnc" id="L4503" title="All 2 branches missed.">        if (!useLOSTool) {</span>
<span class="nc" id="L4504">            return;</span>
        }

<span class="nc" id="L4507">        Entity ae = chooseEntity(c1);</span>
<span class="nc" id="L4508">        Entity te = chooseEntity(c2);</span>

<span class="nc" id="L4510">        StringBuilder message = new StringBuilder();</span>
        LosEffects le;
<span class="nc bnc" id="L4512" title="All 4 branches missed.">        if ((ae == null) || (te == null)) {</span>
<span class="nc" id="L4513">            boolean mechInFirst = GUIPreferences.getInstance()</span>
<span class="nc" id="L4514">                    .getMechInFirst();</span>
<span class="nc" id="L4515">            boolean mechInSecond = GUIPreferences.getInstance()</span>
<span class="nc" id="L4516">                    .getMechInSecond();</span>
<span class="nc" id="L4517">            LosEffects.AttackInfo ai = new LosEffects.AttackInfo();</span>
<span class="nc" id="L4518">            ai.attackPos = c1;</span>
<span class="nc" id="L4519">            ai.targetPos = c2;</span>
<span class="nc bnc" id="L4520" title="All 2 branches missed.">            ai.attackHeight = mechInFirst ? 1 : 0;</span>
<span class="nc bnc" id="L4521" title="All 2 branches missed.">            ai.targetHeight = mechInSecond ? 1 : 0;</span>
<span class="nc" id="L4522">            ai.targetIsMech = mechInSecond;</span>
<span class="nc" id="L4523">            ai.attackerIsMech = mechInFirst;</span>
<span class="nc" id="L4524">            ai.attackAbsHeight = game.getBoard().getHex(c1).floor()</span>
                    + ai.attackHeight;
<span class="nc" id="L4526">            ai.targetAbsHeight = game.getBoard().getHex(c2).floor()</span>
                    + ai.targetHeight;
<span class="nc" id="L4528">            le = LosEffects.calculateLos(game, ai);</span>
<span class="nc" id="L4529">            message.append(Messages</span>
<span class="nc" id="L4530">                    .getString(</span>
                            &quot;BoardView1.Attacker&quot;, //$NON-NLS-1$
<span class="nc bnc" id="L4532" title="All 2 branches missed.">                            mechInFirst ? Messages</span>
<span class="nc" id="L4533">                                    .getString(&quot;BoardView1.Mech&quot;) : Messages.getString(&quot;BoardView1.NonMech&quot;), //$NON-NLS-1$ //$NON-NLS-2$</span>
<span class="nc" id="L4534">                            c1.getBoardNum()));</span>
<span class="nc" id="L4535">            message.append(Messages</span>
<span class="nc" id="L4536">                    .getString(</span>
                            &quot;BoardView1.Target&quot;, //$NON-NLS-1$
<span class="nc bnc" id="L4538" title="All 2 branches missed.">                            mechInSecond ? Messages</span>
<span class="nc" id="L4539">                                    .getString(&quot;BoardView1.Mech&quot;) : Messages.getString(&quot;BoardView1.NonMech&quot;), //$NON-NLS-1$ //$NON-NLS-2$</span>
<span class="nc" id="L4540">                            c2.getBoardNum()));</span>
<span class="nc" id="L4541">        } else {</span>
<span class="nc" id="L4542">            le = LosEffects.calculateLos(game, ae.getId(), te);</span>
<span class="nc" id="L4543">            message.append(Messages.getString(</span>
                    &quot;BoardView1.Attacker&quot;, //$NON-NLS-1$
<span class="nc" id="L4545">                    ae.getDisplayName(), c1.getBoardNum()));</span>
<span class="nc" id="L4546">            message.append(Messages.getString(</span>
                    &quot;BoardView1.Target&quot;, //$NON-NLS-1$
<span class="nc" id="L4548">                    te.getDisplayName(), c2.getBoardNum()));</span>
        }
        // Check to see if LoS is blocked
<span class="nc bnc" id="L4551" title="All 2 branches missed.">        if (!le.canSee()) {</span>
<span class="nc" id="L4552">            message.append(Messages.getString(&quot;BoardView1.LOSBlocked&quot;,</span>
                    //$NON-NLS-1$
<span class="nc" id="L4554">                    c1.distance(c2)));</span>
<span class="nc" id="L4555">            ToHitData thd = le.losModifiers(game);</span>
<span class="nc" id="L4556">            message.append(&quot;\t&quot;).append(thd.getDesc()).append(&quot;\n&quot;);</span>
<span class="nc" id="L4557">        } else {</span>
<span class="nc" id="L4558">            message.append(Messages.getString(&quot;BoardView1.LOSNotBlocked&quot;,</span>
                    //$NON-NLS-1$
<span class="nc" id="L4560">                    c1.distance(c2)));</span>
<span class="nc bnc" id="L4561" title="All 2 branches missed.">            if (le.getHeavyWoods() &gt; 0) {</span>
<span class="nc" id="L4562">                message.append(Messages.getString(</span>
                        &quot;BoardView1.HeavyWoods&quot;, //$NON-NLS-1$
<span class="nc" id="L4564">                        le.getHeavyWoods()));</span>
            }
<span class="nc bnc" id="L4566" title="All 2 branches missed.">            if (le.getLightWoods() &gt; 0) {</span>
<span class="nc" id="L4567">                message.append(Messages.getString(</span>
                        &quot;BoardView1.LightWoods&quot;, //$NON-NLS-1$
<span class="nc" id="L4569">                        le.getLightWoods()));</span>
            }
<span class="nc bnc" id="L4571" title="All 2 branches missed.">            if (le.getLightSmoke() &gt; 0) {</span>
<span class="nc" id="L4572">                message.append(Messages.getString(</span>
                        &quot;BoardView1.LightSmoke&quot;, //$NON-NLS-1$
<span class="nc" id="L4574">                        le.getLightSmoke()));</span>
            }
<span class="nc bnc" id="L4576" title="All 2 branches missed.">            if (le.getHeavySmoke() &gt; 0) {</span>
<span class="nc" id="L4577">                message.append(Messages.getString(</span>
                        &quot;BoardView1.HeavySmoke&quot;, //$NON-NLS-1$
<span class="nc" id="L4579">                        le.getHeavySmoke()));</span>
            }
<span class="nc bnc" id="L4581" title="All 4 branches missed.">            if (le.isTargetCover() &amp;&amp; le.canSee()) {</span>
<span class="nc" id="L4582">                message.append(Messages</span>
<span class="nc" id="L4583">                        .getString(</span>
                                &quot;BoardView1.TargetPartialCover&quot;, //$NON-NLS-1$
<span class="nc" id="L4585">                                LosEffects.getCoverName(</span>
<span class="nc" id="L4586">                                        le.getTargetCover(), true)));</span>
            }
<span class="nc bnc" id="L4588" title="All 4 branches missed.">            if (le.isAttackerCover() &amp;&amp; le.canSee()) {</span>
<span class="nc" id="L4589">                message.append(Messages.getString(</span>
                        &quot;BoardView1.AttackerPartialCover&quot;, //$NON-NLS-1$
<span class="nc" id="L4591">                        LosEffects.getCoverName(le.getAttackerCover(),</span>
                                false)));
            }
        }
<span class="nc" id="L4595">        JOptionPane.showMessageDialog(getRootPane(), message.toString(),</span>
<span class="nc" id="L4596">                Messages.getString(&quot;BoardView1.LOSTitle&quot;),</span>
                JOptionPane.INFORMATION_MESSAGE);
<span class="nc" id="L4598">    }</span>

    /**
     * Initializes the various overlay polygons with their vertices.
     */
    public void initPolys() {

<span class="fc" id="L4605">        AffineTransform facingRotate = new AffineTransform();</span>

        // facing polygons
<span class="fc" id="L4608">        Polygon facingPolyTmp = new Polygon();</span>
<span class="fc" id="L4609">        facingPolyTmp.addPoint(41, 3);</span>
<span class="fc" id="L4610">        facingPolyTmp.addPoint(35, 9);</span>
<span class="fc" id="L4611">        facingPolyTmp.addPoint(41, 7);</span>
<span class="fc" id="L4612">        facingPolyTmp.addPoint(42, 7);</span>
<span class="fc" id="L4613">        facingPolyTmp.addPoint(48, 9);</span>
<span class="fc" id="L4614">        facingPolyTmp.addPoint(42, 3);</span>

        // create the rotated shapes
<span class="fc" id="L4617">        facingPolys = new Shape[8];</span>
<span class="fc bfc" id="L4618" title="All 2 branches covered.">        for (int dir : allDirections) {</span>
<span class="fc" id="L4619">            facingPolys[dir] = facingRotate.createTransformedShape(facingPolyTmp);</span>
<span class="fc" id="L4620">            facingRotate.rotate(Math.toRadians(60), HEX_W / 2, HEX_H / 2);</span>
        }

        // final facing polygons
<span class="fc" id="L4624">        Polygon finalFacingPolyTmp = new Polygon();</span>
<span class="fc" id="L4625">        finalFacingPolyTmp.addPoint(41, 3);</span>
<span class="fc" id="L4626">        finalFacingPolyTmp.addPoint(21, 18);</span>
<span class="fc" id="L4627">        finalFacingPolyTmp.addPoint(41, 14);</span>
<span class="fc" id="L4628">        finalFacingPolyTmp.addPoint(42, 14);</span>
<span class="fc" id="L4629">        finalFacingPolyTmp.addPoint(61, 18);</span>
<span class="fc" id="L4630">        finalFacingPolyTmp.addPoint(42, 3);</span>

        // create the rotated shapes
<span class="fc" id="L4633">        facingRotate.setToIdentity();</span>
<span class="fc" id="L4634">        finalFacingPolys = new Shape[8];</span>
<span class="fc bfc" id="L4635" title="All 2 branches covered.">        for (int dir : allDirections) {</span>
<span class="fc" id="L4636">            finalFacingPolys[dir] = facingRotate.createTransformedShape(finalFacingPolyTmp);</span>
<span class="fc" id="L4637">            facingRotate.rotate(Math.toRadians(60), HEX_W / 2, HEX_H / 2);</span>
        }

        // movement polygons
<span class="fc" id="L4641">        Polygon movementPolyTmp = new Polygon();</span>
<span class="fc" id="L4642">        movementPolyTmp.addPoint(47, 67);</span>
<span class="fc" id="L4643">        movementPolyTmp.addPoint(48, 66);</span>
<span class="fc" id="L4644">        movementPolyTmp.addPoint(42, 62);</span>
<span class="fc" id="L4645">        movementPolyTmp.addPoint(41, 62);</span>
<span class="fc" id="L4646">        movementPolyTmp.addPoint(35, 66);</span>
<span class="fc" id="L4647">        movementPolyTmp.addPoint(36, 67);</span>

<span class="fc" id="L4649">        movementPolyTmp.addPoint(47, 67);</span>
<span class="fc" id="L4650">        movementPolyTmp.addPoint(45, 68);</span>
<span class="fc" id="L4651">        movementPolyTmp.addPoint(38, 68);</span>
<span class="fc" id="L4652">        movementPolyTmp.addPoint(38, 69);</span>
<span class="fc" id="L4653">        movementPolyTmp.addPoint(45, 69);</span>
<span class="fc" id="L4654">        movementPolyTmp.addPoint(45, 68);</span>

<span class="fc" id="L4656">        movementPolyTmp.addPoint(45, 70);</span>
<span class="fc" id="L4657">        movementPolyTmp.addPoint(38, 70);</span>
<span class="fc" id="L4658">        movementPolyTmp.addPoint(38, 71);</span>
<span class="fc" id="L4659">        movementPolyTmp.addPoint(45, 71);</span>
<span class="fc" id="L4660">        movementPolyTmp.addPoint(45, 68);</span>

        // create the rotated shapes
<span class="fc" id="L4663">        facingRotate.setToIdentity();</span>
<span class="fc" id="L4664">        movementPolys = new Shape[8];</span>
<span class="fc bfc" id="L4665" title="All 2 branches covered.">        for (int dir : allDirections) {</span>
<span class="fc" id="L4666">            movementPolys[dir] = facingRotate.createTransformedShape(movementPolyTmp);</span>
<span class="fc" id="L4667">            facingRotate.rotate(Math.toRadians(60), HEX_W / 2, HEX_H / 2);</span>
        }

        // Up and Down Arrows
<span class="fc" id="L4671">        facingRotate.setToIdentity();</span>
<span class="fc" id="L4672">        facingRotate.translate(0, -31);</span>
<span class="fc" id="L4673">        upArrow = facingRotate.createTransformedShape(movementPolyTmp);</span>

<span class="fc" id="L4675">        facingRotate.setToIdentity();</span>
<span class="fc" id="L4676">        facingRotate.rotate(Math.toRadians(180), HEX_W / 2, HEX_H / 2);</span>
<span class="fc" id="L4677">        facingRotate.translate(0, -31);</span>
<span class="fc" id="L4678">        downArrow = facingRotate.createTransformedShape(movementPolyTmp);</span>
<span class="fc" id="L4679">    }</span>

    synchronized boolean doMoveUnits(long idleTime) {
<span class="nc bnc" id="L4682" title="All 2 branches missed.">        if (movingUnits.size() &lt;= 0) {</span>
<span class="nc" id="L4683">            return false;</span>
        }
<span class="nc bnc" id="L4685" title="All 2 branches missed.">        if (moveWait &lt;= GUIPreferences.getInstance().getInt(&quot;AdvancedMoveStepDelay&quot;)) {</span>
<span class="nc" id="L4686">            return false;</span>
        }
<span class="nc" id="L4688">        boolean movingSomething = false;</span>
<span class="nc" id="L4689">        moveWait += idleTime;</span>

<span class="nc" id="L4691">        ArrayList&lt;MovingUnit&gt; spent = new ArrayList&lt;MovingUnit&gt;();</span>

<span class="nc bnc" id="L4693" title="All 2 branches missed.">        for (MovingUnit move : movingUnits) {</span>
<span class="nc" id="L4694">            movingSomething = true;</span>
<span class="nc" id="L4695">            Entity ge = game.getEntity(move.entity.getId());</span>
<span class="nc bnc" id="L4696" title="All 2 branches missed.">            if (move.path.size() &gt; 0) {</span>

<span class="nc" id="L4698">                UnitLocation loc = move.path.get(0);</span>

<span class="nc bnc" id="L4700" title="All 2 branches missed.">                if (ge != null) {</span>
<span class="nc" id="L4701">                    redrawMovingEntity(move.entity, loc.getCoords(),</span>
<span class="nc" id="L4702">                            loc.getFacing(), loc.getElevation());</span>
                }
<span class="nc" id="L4704">                move.path.remove(0);</span>
<span class="nc" id="L4705">            } else {</span>
<span class="nc bnc" id="L4706" title="All 2 branches missed.">                if (ge != null) {</span>
<span class="nc" id="L4707">                    redrawEntity(ge);</span>
                }
<span class="nc" id="L4709">                spent.add(move);</span>
            }

<span class="nc" id="L4712">        }</span>

<span class="nc bnc" id="L4714" title="All 2 branches missed.">        for (MovingUnit move : spent) {</span>
<span class="nc" id="L4715">            movingUnits.remove(move);</span>
<span class="nc" id="L4716">        }</span>
<span class="nc" id="L4717">        moveWait = 0;</span>

<span class="nc bnc" id="L4719" title="All 2 branches missed.">        if (movingUnits.size() == 0) {</span>
<span class="nc" id="L4720">            movingEntitySpriteIds.clear();</span>
<span class="nc" id="L4721">            movingEntitySprites.clear();</span>
<span class="nc" id="L4722">            ghostEntitySprites.clear();</span>
<span class="nc" id="L4723">            processBoardViewEvent(new BoardViewEvent(this,</span>
                    BoardViewEvent.FINISHED_MOVING_UNITS));
        }
<span class="nc" id="L4726">        return movingSomething;</span>
    }

    //
    // MouseListener
    //
    public void mousePressed(MouseEvent me) {
<span class="nc" id="L4733">        requestFocusInWindow();</span>
<span class="nc" id="L4734">        stopSoftCentering();</span>
<span class="nc" id="L4735">        Point point = me.getPoint();</span>
<span class="nc bnc" id="L4736" title="All 2 branches missed.">        if (null == point) {</span>
<span class="nc" id="L4737">            return;</span>
        }

        // Button 4: Hide/Show the minimap and unitDisplay
<span class="nc bnc" id="L4741" title="All 2 branches missed.">        if (me.getButton() == 4) {</span>
<span class="nc bnc" id="L4742" title="All 2 branches missed.">            if (clientgui != null) clientgui.toggleMMUDDisplays();</span>
        }

        // we clicked the right mouse button,
        // remember the position if we start to scroll
        // if we drag, we should scroll
<span class="nc bnc" id="L4748" title="All 2 branches missed.">        if (SwingUtilities.isRightMouseButton(me)) {</span>
<span class="nc" id="L4749">            scrollXDifference = me.getX();</span>
<span class="nc" id="L4750">            scrollYDifference = me.getY();</span>
<span class="nc" id="L4751">            shouldScroll = true;</span>
        }

<span class="nc bnc" id="L4754" title="All 4 branches missed.">        if (me.isPopupTrigger() &amp;&amp; !dragging) {</span>
<span class="nc" id="L4755">            mouseAction(getCoordsAt(point), BOARD_HEX_POPUP, me.getModifiers());</span>
<span class="nc" id="L4756">            return;</span>
        }
<span class="nc bnc" id="L4758" title="All 2 branches missed.">        for (IDisplayable disp : displayables) {</span>
<span class="nc" id="L4759">            double width = scrollpane.getViewport().getSize()</span>
<span class="nc" id="L4760">                    .getWidth();</span>
<span class="nc" id="L4761">            double height = scrollpane.getViewport().getSize()</span>
<span class="nc" id="L4762">                    .getHeight();</span>
<span class="nc" id="L4763">            Dimension dispDimension = new Dimension();</span>
<span class="nc" id="L4764">            dispDimension.setSize(width, height);</span>
            // we need to adjust the point, because it should be against the
            // displayable dimension
<span class="nc" id="L4767">            Point dispPoint = new Point();</span>
<span class="nc" id="L4768">            dispPoint.setLocation(point.x + getBounds().x, point.y</span>
<span class="nc" id="L4769">                    + getBounds().y);</span>
<span class="nc bnc" id="L4770" title="All 2 branches missed.">            if (disp.isHit(dispPoint, dispDimension)) {</span>
<span class="nc" id="L4771">                return;</span>
            }
<span class="nc" id="L4773">        }</span>
<span class="nc" id="L4774">        mouseAction(getCoordsAt(point), BOARD_HEX_DRAG, me.getModifiers());</span>
<span class="nc" id="L4775">    }</span>

    public void mouseReleased(MouseEvent me) {
        // don't show the popup if we are drag-scrolling
<span class="nc bnc" id="L4779" title="All 4 branches missed.">        if (me.isPopupTrigger() &amp;&amp; !dragging) {</span>
<span class="nc" id="L4780">            mouseAction(getCoordsAt(me.getPoint()), BOARD_HEX_POPUP,</span>
<span class="nc" id="L4781">                    me.getModifiers());</span>
            // stop scrolling
<span class="nc" id="L4783">            shouldScroll = false;</span>
<span class="nc" id="L4784">            return;</span>
        }

        // if we released the right mouse button, there's no more
        // scrolling
<span class="nc bnc" id="L4789" title="All 2 branches missed.">        if (SwingUtilities.isRightMouseButton(me)) {</span>
<span class="nc" id="L4790">            scrollXDifference = 0;</span>
<span class="nc" id="L4791">            scrollYDifference = 0;</span>
<span class="nc" id="L4792">            dragging = false;</span>
<span class="nc" id="L4793">            shouldScroll = false;</span>
<span class="nc" id="L4794">            setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));</span>
        }
<span class="nc bnc" id="L4796" title="All 2 branches missed.">        for (IDisplayable disp : displayables) {</span>
<span class="nc bnc" id="L4797" title="All 2 branches missed.">            if (disp.isReleased()) {</span>
<span class="nc" id="L4798">                return;</span>
            }
<span class="nc" id="L4800">        }</span>

<span class="nc bnc" id="L4802" title="All 2 branches missed.">        if (me.getClickCount() == 1) {</span>
<span class="nc" id="L4803">            mouseAction(getCoordsAt(me.getPoint()), BOARD_HEX_CLICK,</span>
<span class="nc" id="L4804">                    me.getModifiers());</span>
        } else {
<span class="nc" id="L4806">            mouseAction(getCoordsAt(me.getPoint()), BOARD_HEX_DOUBLECLICK,</span>
<span class="nc" id="L4807">                    me.getModifiers());</span>
        }
<span class="nc" id="L4809">    }</span>

    public void mouseEntered(MouseEvent me) {
<span class="nc" id="L4812">    }</span>

    public void mouseExited(MouseEvent me) {
        // Reset the tooltip dismissal delay to the preference
        // value so that elements outside the boardview can
        // use tooltips
<span class="nc bnc" id="L4818" title="All 2 branches missed.">        if (GUIPreferences.getInstance().getTooltipDismissDelay() &gt;= 0) {</span>
<span class="nc" id="L4819">            ToolTipManager.sharedInstance().setDismissDelay(</span>
<span class="nc" id="L4820">                    GUIPreferences.getInstance().getTooltipDismissDelay());</span>
        } else {
<span class="nc" id="L4822">            ToolTipManager.sharedInstance().setDismissDelay(dismissDelay);</span>
        }
<span class="nc" id="L4824">    }</span>

    public void mouseClicked(MouseEvent me) {
<span class="nc" id="L4827">    }</span>

    /**
     * Determine if the tile manager's images have been loaded.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if all images have been loaded.
     * &lt;code&gt;false&lt;/code&gt; if more need to be loaded.
     */
    public boolean isTileImagesLoaded() {
<span class="nc" id="L4836">        return tileManager.isLoaded();</span>
    }

    public void setUseLOSTool(boolean use) {
<span class="nc" id="L4840">        useLOSTool = use;</span>
<span class="nc" id="L4841">    }</span>

    public TilesetManager getTilesetManager() {
<span class="nc" id="L4844">        return tileManager;</span>
    }

    /**
     * @return Returns the lastCursor.
     */
    public Coords getLastCursor() {
<span class="nc" id="L4851">        return lastCursor;</span>
    }

    /**
     * @param lastCursor The lastCursor to set.
     */
    public void setLastCursor(Coords lastCursor) {
<span class="nc" id="L4858">        this.lastCursor = lastCursor;</span>
<span class="nc" id="L4859">    }</span>

    /**
     * @return Returns the highlighted.
     */
    public Coords getHighlighted() {
<span class="nc" id="L4865">        return highlighted;</span>
    }

    /**
     * @param highlighted The highlighted to set.
     */
    public void setHighlighted(Coords highlighted) {
<span class="nc" id="L4872">        this.highlighted = highlighted;</span>
<span class="nc" id="L4873">    }</span>

    /**
     * @return Returns the selected.
     */
    public Coords getSelected() {
<span class="nc" id="L4879">        return selected;</span>
    }

    /**
     * @param selected The selected to set.
     */
    public void setSelected(Coords selected) {
<span class="nc bnc" id="L4886" title="All 2 branches missed.">        if (this.selected != selected) {</span>
<span class="nc" id="L4887">            this.selected = selected;</span>
<span class="nc" id="L4888">            checkFoVHexImageCacheClear();</span>
        }
<span class="nc" id="L4890">    }</span>

    /**
     * @return Returns the firstLOS.
     */
    public Coords getFirstLOS() {
<span class="nc" id="L4896">        return firstLOS;</span>
    }

    /**
     * @param firstLOS The firstLOS to set.
     */
    public void setFirstLOS(Coords firstLOS) {
<span class="nc" id="L4903">        this.firstLOS = firstLOS;</span>
<span class="nc" id="L4904">    }</span>

    /**
     * Determines if this Board contains the Coords, and if so, &quot;selects&quot; that
     * Coords.
     *
     * @param coords the Coords.
     */
    public void select(Coords coords) {
<span class="nc bnc" id="L4913" title="All 4 branches missed.">        if ((coords == null) || game.getBoard().contains(coords)) {</span>
<span class="nc" id="L4914">            setSelected(coords);</span>
<span class="nc" id="L4915">            moveCursor(selectedSprite, coords);</span>
<span class="nc" id="L4916">            moveCursor(firstLOSSprite, null);</span>
<span class="nc" id="L4917">            moveCursor(secondLOSSprite, null);</span>
<span class="nc" id="L4918">            processBoardViewEvent(new BoardViewEvent(this, coords, null,</span>
                    BoardViewEvent.BOARD_HEX_SELECTED, 0));
        }
<span class="nc" id="L4921">    }</span>

    /**
     * &quot;Selects&quot; the specified Coords.
     *
     * @param x the x coordinate.
     * @param y the y coordinate.
     */
    public void select(int x, int y) {
<span class="nc" id="L4930">        select(new Coords(x, y));</span>
<span class="nc" id="L4931">    }</span>

    /**
     * Determines if this Board contains the Coords, and if so, highlights that
     * Coords.
     *
     * @param coords the Coords.
     */
    public void highlight(Coords coords) {
<span class="nc bnc" id="L4940" title="All 4 branches missed.">        if ((coords == null) || game.getBoard().contains(coords)) {</span>
<span class="nc" id="L4941">            setHighlighted(coords);</span>
<span class="nc" id="L4942">            moveCursor(highlightSprite, coords);</span>
<span class="nc" id="L4943">            moveCursor(firstLOSSprite, null);</span>
<span class="nc" id="L4944">            moveCursor(secondLOSSprite, null);</span>
<span class="nc" id="L4945">            processBoardViewEvent(new BoardViewEvent(this, coords, null,</span>
                    BoardViewEvent.BOARD_HEX_HIGHLIGHTED, 0));
        }
<span class="nc" id="L4948">    }</span>

    public void setHighlightColor(Color c) {
<span class="nc" id="L4951">        highlightSprite.setColor(c);</span>
<span class="nc" id="L4952">        highlightSprite.prepare();</span>
<span class="nc" id="L4953">        repaint();</span>
<span class="nc" id="L4954">    }</span>

    /**
     * Highlights the specified Coords.
     *
     * @param x the x coordinate.
     * @param y the y coordinate.
     */
    public void highlight(int x, int y) {
<span class="nc" id="L4963">        highlight(new Coords(x, y));</span>
<span class="nc" id="L4964">    }</span>

    public synchronized void highlightSelectedEntity() {
<span class="nc bnc" id="L4967" title="All 2 branches missed.">        for (EntitySprite sprite : entitySprites) {</span>
<span class="nc" id="L4968">            sprite.setSelected(sprite.entity.equals(selectedEntity));</span>
<span class="nc" id="L4969">        }</span>
<span class="nc" id="L4970">    }</span>

    /**
     * Determines if this Board contains the Coords, and if so, &quot;cursors&quot; that
     * Coords.
     *
     * @param coords the Coords.
     */
    public void cursor(Coords coords) {
<span class="nc bnc" id="L4979" title="All 4 branches missed.">        if ((coords == null) || game.getBoard().contains(coords)) {</span>
<span class="nc bnc" id="L4980" title="All 4 branches missed.">            if ((getLastCursor() == null) || (coords == null)</span>
<span class="nc bnc" id="L4981" title="All 2 branches missed.">                    || !coords.equals(getLastCursor())) {</span>
<span class="nc" id="L4982">                setLastCursor(coords);</span>
<span class="nc" id="L4983">                moveCursor(cursorSprite, coords);</span>
<span class="nc" id="L4984">                moveCursor(firstLOSSprite, null);</span>
<span class="nc" id="L4985">                moveCursor(secondLOSSprite, null);</span>
<span class="nc" id="L4986">                processBoardViewEvent(new BoardViewEvent(this, coords, null,</span>
                        BoardViewEvent.BOARD_HEX_CURSOR, 0));
            } else {
<span class="nc" id="L4989">                setLastCursor(coords);</span>
            }
        }
<span class="nc" id="L4992">    }</span>

    /**
     * &quot;Cursors&quot; the specified Coords.
     *
     * @param x the x coordinate.
     * @param y the y coordinate.
     */
    public void cursor(int x, int y) {
<span class="nc" id="L5001">        cursor(new Coords(x, y));</span>
<span class="nc" id="L5002">    }</span>

    public void checkLOS(Coords c) {
<span class="nc bnc" id="L5005" title="All 4 branches missed.">        if ((c == null) || game.getBoard().contains(c)) {</span>
<span class="nc bnc" id="L5006" title="All 2 branches missed.">            if (getFirstLOS() == null) {</span>
<span class="nc" id="L5007">                setFirstLOS(c);</span>
<span class="nc" id="L5008">                firstLOSHex(c);</span>
<span class="nc" id="L5009">                processBoardViewEvent(new BoardViewEvent(this, c, null,</span>
                        BoardViewEvent.BOARD_FIRST_LOS_HEX, 0));
            } else {
<span class="nc" id="L5012">                secondLOSHex(c, getFirstLOS());</span>
<span class="nc" id="L5013">                processBoardViewEvent(new BoardViewEvent(this, c, null,</span>
                        BoardViewEvent.BOARD_SECOND_LOS_HEX, 0));
<span class="nc" id="L5015">                setFirstLOS(null);</span>
            }
        }
<span class="nc" id="L5018">    }</span>

    /**
     * Determines if this Board contains the (x, y) Coords, and if so, notifies
     * listeners about the specified mouse action.
     */
    public void mouseAction(int x, int y, int mtype, int modifiers) {
<span class="nc bnc" id="L5025" title="All 2 branches missed.">        if (game.getBoard().contains(x, y)) {</span>
<span class="nc" id="L5026">            Coords c = new Coords(x, y);</span>
<span class="nc bnc" id="L5027" title="All 5 branches missed.">            switch (mtype) {</span>
                case BOARD_HEX_CLICK:
<span class="nc bnc" id="L5029" title="All 2 branches missed.">                    if ((modifiers &amp; java.awt.event.InputEvent.CTRL_MASK) != 0) {</span>
<span class="nc" id="L5030">                        checkLOS(c);</span>
                    } else {
<span class="nc" id="L5032">                        processBoardViewEvent(new BoardViewEvent(this, c, null,</span>
                                BoardViewEvent.BOARD_HEX_CLICKED, modifiers));
                    }
<span class="nc" id="L5035">                    break;</span>
                case BOARD_HEX_DOUBLECLICK:
<span class="nc" id="L5037">                    processBoardViewEvent(new BoardViewEvent(this, c, null,</span>
                            BoardViewEvent.BOARD_HEX_DOUBLECLICKED, modifiers));
<span class="nc" id="L5039">                    break;</span>
                case BOARD_HEX_DRAG:
<span class="nc" id="L5041">                    processBoardViewEvent(new BoardViewEvent(this, c, null,</span>
                            BoardViewEvent.BOARD_HEX_DRAGGED, modifiers));
<span class="nc" id="L5043">                    break;</span>
                case BOARD_HEX_POPUP:
<span class="nc" id="L5045">                    processBoardViewEvent(new BoardViewEvent(this, c, null,</span>
                            BoardViewEvent.BOARD_HEX_POPUP, modifiers));
                    break;
            }
        }
<span class="nc" id="L5050">    }</span>

    /**
     * Notifies listeners about the specified mouse action.
     *
     * @param coords the Coords.
     */
    public void mouseAction(Coords coords, int mtype, int modifiers) {
<span class="nc" id="L5058">        mouseAction(coords.getX(), coords.getY(), mtype, modifiers);</span>
<span class="nc" id="L5059">    }</span>

    /*
     * (non-Javadoc)
     *
     * @see
     * megamek.common.BoardListener#boardNewBoard(megamek.common.BoardEvent)
     */
    public void boardNewBoard(BoardEvent b) {
<span class="nc" id="L5068">        updateBoard();</span>
<span class="nc" id="L5069">        clearHexImageCache();</span>
<span class="nc" id="L5070">        clearShadowMap();</span>
<span class="nc" id="L5071">        repaint();</span>
<span class="nc" id="L5072">    }</span>

    /*
     * (non-Javadoc)
     *
     * @see
     * megamek.common.BoardListener#boardChangedHex(megamek.common.BoardEvent)
     */
    public void boardChangedHex(BoardEvent b) {
<span class="nc" id="L5081">        hexImageCache.remove(b.getCoords());</span>
        // Also repaint the surrounding hexes because of shadows, border etc.
<span class="nc bnc" id="L5083" title="All 2 branches missed.">        for (int dir : allDirections) {</span>
<span class="nc" id="L5084">            hexImageCache.remove(b.getCoords().translated(dir));</span>
        }
<span class="nc" id="L5086">        clearShadowMap();</span>
<span class="nc" id="L5087">        repaint();</span>
<span class="nc" id="L5088">    }</span>

    /*
     * (non-Javadoc)
     *
     * @see
     * megamek.common.BoardListener#boardChangedHex(megamek.common.BoardEvent)
     */
    public synchronized void boardChangedAllHexes(BoardEvent b) {
<span class="nc" id="L5097">        clearHexImageCache();</span>
<span class="nc" id="L5098">        clearShadowMap();</span>
<span class="nc" id="L5099">        repaint();</span>
<span class="nc" id="L5100">    }</span>

    synchronized void boardChanged() {
<span class="nc" id="L5103">        redrawAllEntities();</span>
<span class="nc" id="L5104">        redrawAllFlares();</span>
<span class="nc" id="L5105">    }</span>

    void clearSprites() {
<span class="fc" id="L5108">        pathSprites.clear();</span>
<span class="fc" id="L5109">        firingSprites.clear();</span>
<span class="fc" id="L5110">        attackSprites.clear();</span>
<span class="fc" id="L5111">        c3Sprites.clear();</span>
<span class="fc" id="L5112">        vtolAttackSprites.clear();</span>
<span class="fc" id="L5113">        flyOverSprites.clear();</span>
<span class="fc" id="L5114">        movementSprites.clear();</span>
<span class="fc" id="L5115">        fieldofFireSprites.clear();</span>
<span class="fc" id="L5116">    }</span>

    public synchronized void updateBoard() {
<span class="nc" id="L5119">        updateBoardSize();</span>
<span class="nc" id="L5120">        redrawAllEntities();</span>
<span class="nc" id="L5121">    }</span>

    public synchronized void selectEntity(Entity e) {
<span class="nc" id="L5124">        selectedEntity = e;</span>
<span class="nc" id="L5125">        checkFoVHexImageCacheClear();</span>
        // If we don't do this, the selectedWeapon might not correspond to this
        // entity
<span class="nc" id="L5128">        selectedWeapon = null;</span>
<span class="nc" id="L5129">        updateEcmList();</span>
<span class="nc" id="L5130">        highlightSelectedEntity();</span>
<span class="nc" id="L5131">    }</span>

    public synchronized void weaponSelected(MechDisplayEvent b) {
<span class="nc" id="L5134">        selectedEntity = b.getEntity();</span>
<span class="nc" id="L5135">        selectedWeapon = b.getEquip();</span>
<span class="nc" id="L5136">        repaint();</span>
<span class="nc" id="L5137">    }</span>

    /**
     * Updates maps that determine how to shade hexes affected by E(C)CM. This
     * is expensive, so precalculate only when entity changes occur
     **/
    public void updateEcmList() {
<span class="nc" id="L5144">        Map&lt;Coords, Color&gt; newECMHexes = new HashMap&lt;Coords, Color&gt;();</span>
<span class="nc" id="L5145">        Map&lt;Coords, Color&gt; newECMCenters = new HashMap&lt;Coords, Color&gt;();</span>
<span class="nc" id="L5146">        Map&lt;Coords, Color&gt; newECCMHexes = new HashMap&lt;Coords, Color&gt;();</span>
<span class="nc" id="L5147">        Map&lt;Coords, Color&gt; newECCMCenters = new HashMap&lt;Coords, Color&gt;();</span>

        // Compute info about all E(C)CM on the board
<span class="nc" id="L5150">        final List&lt;ECMInfo&gt; allEcmInfo = ComputeECM</span>
<span class="nc" id="L5151">                .computeAllEntitiesECMInfo(game.getEntitiesVector());</span>

        // First, mark the sources of E(C)CM
        // Used for highlighting hexes and tooltips
<span class="nc bnc" id="L5155" title="All 2 branches missed.">        for (Entity e : game.getEntitiesVector()) {</span>
<span class="nc bnc" id="L5156" title="All 2 branches missed.">            if (e.getPosition() == null) {</span>
<span class="nc" id="L5157">                continue;</span>
            }
            // If this unit isn't spotted somehow, it's ECM doesn't show up
<span class="nc bnc" id="L5160" title="All 2 branches missed.">            if ((localPlayer != null)</span>
<span class="nc bnc" id="L5161" title="All 2 branches missed.">                    &amp;&amp; game.getOptions().booleanOption(OptionsConstants.ADVANCED_DOUBLE_BLIND)</span>
<span class="nc bnc" id="L5162" title="All 2 branches missed.">                    &amp;&amp; e.getOwner().isEnemyOf(localPlayer)</span>
<span class="nc bnc" id="L5163" title="All 2 branches missed.">                    &amp;&amp; !e.hasSeenEntity(localPlayer)</span>
<span class="nc bnc" id="L5164" title="All 2 branches missed.">                    &amp;&amp; !e.hasDetectedEntity(localPlayer)) {</span>
<span class="nc" id="L5165">                continue;</span>
            }

<span class="nc" id="L5168">            final Color ecmColor = ECMEffects.getECMColor(e.getOwner());</span>
            // Update ECM center information
<span class="nc bnc" id="L5170" title="All 2 branches missed.">            if (e.getECMInfo() != null) {</span>
<span class="nc" id="L5171">                newECMCenters.put(e.getPosition(), ecmColor);</span>
            }
            // Update ECCM center information
<span class="nc bnc" id="L5174" title="All 2 branches missed.">            if (e.getECCMInfo() != null) {</span>
<span class="nc" id="L5175">                newECCMCenters.put(e.getPosition(), ecmColor);</span>
            }
            // Update Entity sprite's ECM status
<span class="nc" id="L5178">            int secondaryIdx = -1;</span>
<span class="nc bnc" id="L5179" title="All 2 branches missed.">            if (e.getSecondaryPositions().size() &gt; 0) {</span>
<span class="nc" id="L5180">                secondaryIdx = 0;</span>
            }
<span class="nc" id="L5182">            EntitySprite eSprite = entitySpriteIds.get(getIdAndLoc(e.getId(),</span>
                    secondaryIdx));
<span class="nc bnc" id="L5184" title="All 2 branches missed.">            if (eSprite != null) {</span>
<span class="nc" id="L5185">                Coords pos = e.getPosition();</span>
<span class="nc" id="L5186">                eSprite.setAffectedByECM(ComputeECM.isAffectedByECM(e, pos,</span>
                        pos, allEcmInfo));
            }
<span class="nc" id="L5189">        }</span>

        // Keep track of allied ECM and enemy ECCM
<span class="nc" id="L5192">        Map&lt;Coords, ECMEffects&gt; ecmAffectedCoords =</span>
                new HashMap&lt;Coords, ECMEffects&gt;();
        // Keep track of allied ECCM and enemy ECM
<span class="nc" id="L5195">        Map&lt;Coords, ECMEffects&gt; eccmAffectedCoords =</span>
                new HashMap&lt;Coords, ECMEffects&gt;();
<span class="nc bnc" id="L5197" title="All 2 branches missed.">        for (ECMInfo ecmInfo : allEcmInfo) {</span>
            // Can't see ECM field of unspotted unit
<span class="nc bnc" id="L5199" title="All 4 branches missed.">            if ((ecmInfo.getEntity() != null) &amp;&amp; (localPlayer != null)</span>
<span class="nc bnc" id="L5200" title="All 2 branches missed.">                    &amp;&amp; game.getOptions().booleanOption(OptionsConstants.ADVANCED_DOUBLE_BLIND)</span>
<span class="nc bnc" id="L5201" title="All 2 branches missed.">                    &amp;&amp; ecmInfo.getEntity().getOwner().isEnemyOf(localPlayer)</span>
<span class="nc bnc" id="L5202" title="All 2 branches missed.">                    &amp;&amp; !ecmInfo.getEntity().hasSeenEntity(localPlayer)</span>
<span class="nc bnc" id="L5203" title="All 2 branches missed.">                    &amp;&amp; !ecmInfo.getEntity().hasDetectedEntity(localPlayer)) {</span>
<span class="nc" id="L5204">                continue;</span>
            }

            // Add each Coords within range to the list of ECM Coords
<span class="nc" id="L5208">            addCoordsToECMCoords(ecmAffectedCoords, eccmAffectedCoords, ecmInfo);</span>
<span class="nc" id="L5209">        }</span>

        // Finally, determine the color for each affected hex
<span class="nc bnc" id="L5212" title="All 2 branches missed.">        for (Coords c : ecmAffectedCoords.keySet()) {</span>
<span class="nc" id="L5213">            ECMEffects ecm = ecmAffectedCoords.get(c);</span>
<span class="nc" id="L5214">            ECMEffects eccm = eccmAffectedCoords.get(c);</span>
<span class="nc" id="L5215">            processAffectedCoords(c, ecm, eccm, newECMHexes, newECCMHexes);</span>
<span class="nc" id="L5216">        }</span>
<span class="nc bnc" id="L5217" title="All 2 branches missed.">        for (Coords c : eccmAffectedCoords.keySet()) {</span>
<span class="nc" id="L5218">            ECMEffects ecm = ecmAffectedCoords.get(c);</span>
<span class="nc" id="L5219">            ECMEffects eccm = eccmAffectedCoords.get(c);</span>
            // Already processed all ECM affected coords
<span class="nc bnc" id="L5221" title="All 2 branches missed.">            if (ecm != null) {</span>
<span class="nc" id="L5222">                continue;</span>
            }
<span class="nc" id="L5224">            processAffectedCoords(c, ecm, eccm, newECMHexes, newECCMHexes);</span>
<span class="nc" id="L5225">        }</span>

<span class="nc" id="L5227">        Set&lt;Coords&gt; updatedHexes = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L5228" title="All 2 branches missed.">        if (ecmHexes != null) {</span>
<span class="nc" id="L5229">            updatedHexes.addAll(ecmHexes.keySet());</span>
        }
<span class="nc bnc" id="L5231" title="All 2 branches missed.">        if (eccmHexes != null) {</span>
<span class="nc" id="L5232">            updatedHexes.addAll(eccmHexes.keySet());</span>
        }
<span class="nc" id="L5234">        updatedHexes.addAll(newECMHexes.keySet());</span>
<span class="nc" id="L5235">        updatedHexes.addAll(newECCMHexes.keySet());</span>
<span class="nc" id="L5236">        clearHexImageCache(updatedHexes);</span>

<span class="nc" id="L5238">        synchronized (this) {</span>
<span class="nc" id="L5239">            ecmHexes = newECMHexes;</span>
<span class="nc" id="L5240">            ecmCenters = newECMCenters;</span>
<span class="nc" id="L5241">            eccmHexes = newECCMHexes;</span>
<span class="nc" id="L5242">            eccmCenters = newECCMCenters;</span>
<span class="nc" id="L5243">        }</span>

<span class="nc" id="L5245">        repaint();</span>
<span class="nc" id="L5246">    }</span>

    private void addCoordsToECMCoords(Map&lt;Coords, ECMEffects&gt; ecmAffectedCoords, Map&lt;Coords, ECMEffects&gt; eccmAffectedCoords, ECMInfo ecmInfo) {
<span class="nc" id="L5249">        final Coords ecmPos = ecmInfo.getPos();</span>
<span class="nc" id="L5250">        final int range = ecmInfo.getRange();</span>

<span class="nc bnc" id="L5252" title="All 2 branches missed.">        for (int x = -range; x &lt;= range; x++) {</span>
<span class="nc bnc" id="L5253" title="All 2 branches missed.">            for (int y = -range; y &lt;= range; y++) {</span>
<span class="nc" id="L5254">                Coords c = new Coords(x + ecmPos.getX(), y + ecmPos.getY());</span>
<span class="nc" id="L5255">                int dist = ecmPos.distance(c);</span>
<span class="nc" id="L5256">                int dir = ecmInfo.getDirection();</span>
                // Direction is the facing of the owning Entity
<span class="nc bnc" id="L5258" title="All 2 branches missed.">                boolean inArc = (dir == -1)</span>
                        || Compute
<span class="nc bnc" id="L5260" title="All 2 branches missed.">                        .isInArc(ecmPos, dir, c, Compute.ARC_NOSE);</span>
<span class="nc bnc" id="L5261" title="All 4 branches missed.">                if ((dist &gt; range) || !inArc) {</span>
<span class="nc" id="L5262">                    continue;</span>
                }

                // Check for allied ECCM or enemy ECM
<span class="nc bnc" id="L5266" title="All 4 branches missed.">                if ((!ecmInfo.isOpposed(localPlayer) &amp;&amp; ecmInfo.isECCM())</span>
<span class="nc bnc" id="L5267" title="All 4 branches missed.">                        || (ecmInfo.isOpposed(localPlayer) &amp;&amp; ecmInfo.isECCM())) {</span>
<span class="nc" id="L5268">                    ECMEffects ecmEffects = eccmAffectedCoords.get(c);</span>
<span class="nc bnc" id="L5269" title="All 2 branches missed.">                    if (ecmEffects == null) {</span>
<span class="nc" id="L5270">                        ecmEffects = new ECMEffects();</span>
<span class="nc" id="L5271">                        eccmAffectedCoords.put(c, ecmEffects);</span>
                    }
<span class="nc" id="L5273">                    ecmEffects.addECM(ecmInfo);</span>
<span class="nc" id="L5274">                } else {</span>
<span class="nc" id="L5275">                    ECMEffects ecmEffects = ecmAffectedCoords.get(c);</span>
<span class="nc bnc" id="L5276" title="All 2 branches missed.">                    if (ecmEffects == null) {</span>
<span class="nc" id="L5277">                        ecmEffects = new ECMEffects();</span>
<span class="nc" id="L5278">                        ecmAffectedCoords.put(c, ecmEffects);</span>
                    }
<span class="nc" id="L5280">                    ecmEffects.addECM(ecmInfo);</span>
                }
            }
        }
<span class="nc" id="L5284">    }</span>

    private void processAffectedCoords(Coords c, ECMEffects ecm,
                                       ECMEffects eccm, Map&lt;Coords, Color&gt; newECMHexes,
                                       Map&lt;Coords, Color&gt; newECCMHexes) {
<span class="nc" id="L5289">        Color hexColorECM = null;</span>
<span class="nc bnc" id="L5290" title="All 2 branches missed.">        if (ecm != null) {</span>
<span class="nc" id="L5291">            hexColorECM = ecm.getHexColor();</span>
        }
<span class="nc" id="L5293">        Color hexColorECCM = null;</span>
<span class="nc bnc" id="L5294" title="All 2 branches missed.">        if (eccm != null) {</span>
<span class="nc" id="L5295">            hexColorECCM = eccm.getHexColor();</span>
        }
        // Hex color is null if all effects cancel out
<span class="nc bnc" id="L5298" title="All 4 branches missed.">        if ((hexColorECM == null) &amp;&amp; (hexColorECCM == null)) {</span>
<span class="nc" id="L5299">            return;</span>
<span class="nc bnc" id="L5300" title="All 4 branches missed.">        } else if ((hexColorECM != null) &amp;&amp; (hexColorECCM == null)) {</span>
<span class="nc bnc" id="L5301" title="All 2 branches missed.">            if (ecm.isECCM()) {</span>
<span class="nc" id="L5302">                newECCMHexes.put(c, hexColorECM);</span>
            } else {
<span class="nc" id="L5304">                newECMHexes.put(c, hexColorECM);</span>
            }
<span class="nc bnc" id="L5306" title="All 4 branches missed.">        } else if ((hexColorECM == null) &amp;&amp; (hexColorECCM != null)) {</span>
<span class="nc bnc" id="L5307" title="All 2 branches missed.">            if (eccm.isECCM()) {</span>
<span class="nc" id="L5308">                newECCMHexes.put(c, hexColorECCM);</span>
            } else {
<span class="nc" id="L5310">                newECMHexes.put(c, hexColorECCM);</span>
            }
        } else { // Both are non-null
<span class="nc" id="L5313">            newECMHexes.put(c, hexColorECM);</span>
<span class="nc" id="L5314">            newECCMHexes.put(c, hexColorECCM);</span>
        }
<span class="nc" id="L5316">    }</span>

    public Dimension getPreferredScrollableViewportSize() {
<span class="nc" id="L5319">        return getPreferredSize();</span>
    }

    public int getScrollableBlockIncrement(Rectangle arg0, int arg1, int arg2) {
<span class="nc" id="L5323">        final Dimension size = scrollpane.getViewport().getSize();</span>
<span class="nc bnc" id="L5324" title="All 2 branches missed.">        if (arg1 == SwingConstants.VERTICAL) {</span>
<span class="nc" id="L5325">            return size.height;</span>
        }
<span class="nc" id="L5327">        return size.width;</span>
    }

    public boolean getScrollableTracksViewportHeight() {
<span class="nc" id="L5331">        return false;</span>
    }

    public boolean getScrollableTracksViewportWidth() {
<span class="nc" id="L5335">        return false;</span>
    }

    public int getScrollableUnitIncrement(Rectangle arg0, int arg1, int arg2) {
<span class="nc bnc" id="L5339" title="All 2 branches missed.">        if (arg1 == SwingConstants.VERTICAL) {</span>
<span class="nc" id="L5340">            return (int) ((scale * HEX_H) / 2.0);</span>
        }
<span class="nc" id="L5342">        return (int) ((scale * HEX_W) / 2.0);</span>
    }

    @Override
    public Dimension getPreferredSize() {
        // If the board is small, we want the preferred size to fill the whole
        //  ScrollPane viewport, for purposes of drawing the tiled background
        //  icon.
        // However, we also need the scrollable client to be as big as the
        //  board plus the pad size.
<span class="nc" id="L5352">        return new Dimension(</span>
<span class="nc" id="L5353">                Math.max(boardSize.width + (2 * HEX_W), preferredSize.width),</span>
<span class="nc" id="L5354">                Math.max(boardSize.height + (2 * HEX_W), preferredSize.height));</span>
    }

    @Override
    public void setPreferredSize(Dimension d) {
<span class="nc" id="L5359">        super.setPreferredSize(d);</span>
<span class="nc" id="L5360">        preferredSize = new Dimension(d);</span>
<span class="nc" id="L5361">    }</span>

    /**
     * Have the player select an Entity from the entities at the given coords.
     *
     * @param pos - the &lt;code&gt;Coords&lt;/code&gt; containing targets.
     */
    private Entity chooseEntity(Coords pos) {

        // Assume that we have *no* choice.
<span class="nc" id="L5371">        Entity choice = null;</span>

        // Get the available choices.
<span class="nc" id="L5374">        List&lt;Entity&gt; entities = game.getEntitiesVector(pos);</span>


        // Do we have a single choice?
<span class="nc bnc" id="L5378" title="All 2 branches missed.">        if (entities.size() == 1) {</span>
            // Return that choice.
<span class="nc" id="L5380">            choice = entities.get(0);</span>
        }

        // If we have multiple choices, display a selection dialog.
<span class="nc bnc" id="L5384" title="All 2 branches missed.">        else if (entities.size() &gt; 1) {</span>
<span class="nc" id="L5385">            String input = (String) JOptionPane</span>
<span class="nc" id="L5386">                    .showInputDialog(</span>
                            null,
<span class="nc" id="L5388">                            Messages.getString(</span>
<span class="nc" id="L5389">                                    &quot;BoardView1.ChooseEntityDialog.message&quot;, pos.getBoardNum()), //$NON-NLS-1$</span>
<span class="nc" id="L5390">                            Messages.getString(&quot;BoardView1.ChooseEntityDialog.title&quot;), //$NON-NLS-1$</span>
                            JOptionPane.QUESTION_MESSAGE, null, SharedUtility
<span class="nc" id="L5392">                                    .getDisplayArray(entities), null);</span>
<span class="nc" id="L5393">            choice = (Entity) SharedUtility.getTargetPicked(entities, input);</span>
        } // End have-choices

        // Return the chosen unit.
<span class="nc" id="L5397">        return choice;</span>
    }

    /**
     * The text to be displayed when the mouse is at a certain point.
     */
    @Override
    public String getToolTipText(MouseEvent e) {
        // If new instance of mouse event, redraw obscured hexes and elevations.
<span class="nc" id="L5406">        repaint();</span>

<span class="nc" id="L5408">        StringBuilder txt = new StringBuilder();</span>
<span class="nc" id="L5409">        IHex mhex = null;</span>
<span class="nc" id="L5410">        final Point point = e.getPoint();</span>
<span class="nc bnc" id="L5411" title="All 4 branches missed.">        if (prevTipX &gt; 0 &amp;&amp; prevTipY &gt; 0) {</span>
<span class="nc" id="L5412">            int deltaX = point.x - prevTipX;</span>
<span class="nc" id="L5413">            int deltaY = point.y - prevTipY;</span>
<span class="nc" id="L5414">            double deltaMagnitude = Math.sqrt(deltaX * deltaX + deltaY * deltaY);</span>
<span class="nc bnc" id="L5415" title="All 2 branches missed.">            if (deltaMagnitude &gt; GUIPreferences.getInstance().getTooltipDistSuppression()) {</span>
<span class="nc" id="L5416">                prevTipX = -1;</span>
<span class="nc" id="L5417">                prevTipY = -1;</span>
                // Set the dismissal delay to 0 so that the tooltip
                // goes away and does not reappear until the mouse
                // has moved more than the suppression distance
<span class="nc" id="L5421">                ToolTipManager.sharedInstance().setDismissDelay(0);</span>
<span class="nc" id="L5422">                return &quot;&quot;; //$NON-NLS-1$</span>
            }
        }
<span class="nc" id="L5425">        prevTipX = point.x;</span>
<span class="nc" id="L5426">        prevTipY = point.y;</span>
<span class="nc" id="L5427">        final Coords mcoords = getCoordsAt(point);</span>

<span class="nc bnc" id="L5429" title="All 2 branches missed.">        if (game.getBoard().contains(mcoords))</span>
<span class="nc" id="L5430">            mhex = game.getBoard().getHex(mcoords);</span>

<span class="nc" id="L5432">        txt.append(&quot;&lt;html&gt;&quot;); //$NON-NLS-1$</span>


        // Hex Terrain
<span class="nc bnc" id="L5436" title="All 4 branches missed.">        if (GUIPreferences.getInstance().getShowMapHexPopup() &amp;&amp; (mhex != null)) {</span>
<span class="nc" id="L5437">            txt.append(getHexTerrainText(mhex, mcoords));</span>
        }

        // Show the player(s) that may deploy here
        // in the artillery autohit designation phase
<span class="nc bnc" id="L5442" title="All 4 branches missed.">        if ((game.getPhase() == IGame.Phase.PHASE_SET_ARTYAUTOHITHEXES) &amp;&amp; (mhex != null)) {</span>
<span class="nc" id="L5443">            txt.append(getDeployPlayersText(mcoords));</span>
        }


        // check if it's on any flares
<span class="nc bnc" id="L5448" title="All 2 branches missed.">        for (FlareSprite fSprite : flareSprites) {</span>
<span class="nc bnc" id="L5449" title="All 2 branches missed.">            if (fSprite.isInside(point)) {</span>
<span class="nc" id="L5450">                txt.append(fSprite.getTooltip().toString());</span>
            }
<span class="nc" id="L5452">        }</span>

        // check if it's on any attacks
<span class="nc bnc" id="L5455" title="All 2 branches missed.">        for (AttackSprite aSprite : attackSprites) {</span>
<span class="nc bnc" id="L5456" title="All 2 branches missed.">            if (aSprite.isInside(point)) {</span>
<span class="nc" id="L5457">                txt.append(&quot;&lt;TABLE BORDER=0 BGCOLOR=#FFDDDD width=100%&gt;&lt;TR&gt;&lt;TD&gt;&lt;FONT color=\&quot;black\&quot;&gt;&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L5458">                txt.append(aSprite.getTooltip().toString());</span>
<span class="nc" id="L5459">                txt.append(&quot;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&quot;); //$NON-NLS-1$</span>
            }
<span class="nc" id="L5461">        }</span>

<span class="nc" id="L5463">        txt.append(getEntityText(point, mcoords));</span>

<span class="nc" id="L5465">        txt.append(getArtilleryAttackText(mcoords));</span>

<span class="nc" id="L5467">        txt.append(getSpecialHexDisplayText(mcoords));</span>

<span class="nc" id="L5469">        txt.append(&quot;&lt;/html&gt;&quot;); //$NON-NLS-1$</span>

        // Check to see if the tool tip is completely empty
<span class="nc bnc" id="L5472" title="All 2 branches missed.">        if (txt.toString().equals(&quot;&lt;html&gt;&lt;/html&gt;&quot;)) { //$NON-NLS-1$</span>
<span class="nc" id="L5473">            return &quot;&quot;; //$NON-NLS-1$</span>
        }

        // Now that a valid tooltip text seems to be present,
        // (re)set the tooltip dismissal delay time to the preference
        // value so that the tooltip actually appears
<span class="nc bnc" id="L5479" title="All 2 branches missed.">        if (GUIPreferences.getInstance().getTooltipDismissDelay() &gt;= 0) {</span>
<span class="nc" id="L5480">            ToolTipManager.sharedInstance().setDismissDelay(</span>
<span class="nc" id="L5481">                    GUIPreferences.getInstance().getTooltipDismissDelay());</span>
        } else {
<span class="nc" id="L5483">            ToolTipManager.sharedInstance().setDismissDelay(dismissDelay);</span>
        }

<span class="nc" id="L5486">        return txt.toString();</span>
    }

    private String getSpecialHexDisplayText(Coords mcoords) {
<span class="nc" id="L5490">        StringBuilder txt = new StringBuilder();</span>
<span class="nc" id="L5491">        final Collection&lt;SpecialHexDisplay&gt; shdList = game.getBoard().getSpecialHexDisplay(mcoords);</span>
<span class="nc bnc" id="L5492" title="All 2 branches missed.">        if (shdList == null) {</span>
<span class="nc" id="L5493">            return &quot;&quot;;</span>
        }

<span class="nc" id="L5496">        final Phase currPhase = game.getPhase();</span>
<span class="nc" id="L5497">        int round = game.getRoundCount();</span>
<span class="nc" id="L5498">        boolean isHexAutoHit = localPlayer.getArtyAutoHitHexes().contains(mcoords);</span>
<span class="nc bnc" id="L5499" title="All 2 branches missed.">        for (SpecialHexDisplay shd : shdList) {</span>
<span class="nc bnc" id="L5500" title="All 2 branches missed.">            boolean isTypeAutoHit = shd.getType() == SpecialHexDisplay.Type.ARTILLERY_AUTOHIT;</span>
            // Don't draw if this SHD is obscured from this player
            // The SHD list may also contain stale SHDs, so don't show
            // tooltips for SHDs that aren't drawn.
            // The exception is auto hits.  There will be an icon for auto
            // hits, so we need to draw a tooltip
<span class="nc bnc" id="L5506" title="All 2 branches missed.">            if (!shd.isObscured(localPlayer)</span>
<span class="nc bnc" id="L5507" title="All 6 branches missed.">                    &amp;&amp; (shd.drawNow(currPhase, round, localPlayer)</span>
                    || (isHexAutoHit &amp;&amp; isTypeAutoHit))) {
<span class="nc bnc" id="L5509" title="All 2 branches missed.">                if (shd.getType() == SpecialHexDisplay.Type.PLAYER_NOTE) {</span>
<span class="nc bnc" id="L5510" title="All 2 branches missed.">                    if (localPlayer.equals(shd.getOwner())) {</span>
<span class="nc" id="L5511">                        txt.append(&quot;Note: &quot;);</span>
                    } else {
<span class="nc" id="L5513">                        txt.append(&quot;Note (&quot; + shd.getOwner().getName() + &quot;): &quot;);</span>
                    }
                }
<span class="nc" id="L5516">                String buf = shd.getInfo();</span>
<span class="nc" id="L5517">                buf = buf.replaceAll(&quot;\\n&quot;, &quot;&lt;br&gt;&quot;);</span>
<span class="nc" id="L5518">                txt.append(buf);</span>
<span class="nc" id="L5519">                txt.append(&quot;&lt;br&gt;&quot;); //$NON-NLS-1$</span>
            }
<span class="nc" id="L5521">        }</span>
<span class="nc" id="L5522">        return txt.toString();</span>
    }

    private String getArtilleryAttackText(Coords mcoords) {
<span class="nc" id="L5526">        StringBuilder txt = new StringBuilder();</span>

<span class="nc bnc" id="L5528" title="All 2 branches missed.">        for (ArtilleryAttackAction aaa : getArtilleryAttacksAtLocation(mcoords)) {</span>
            // Default texts if no real names can be found
<span class="nc" id="L5530">            String wpName = Messages.getString(&quot;BoardView1.Artillery&quot;);</span>
<span class="nc" id="L5531">            String ammoName = &quot;Unknown&quot;;</span>

            // Get real weapon and ammo name
<span class="nc" id="L5534">            final Entity artyEnt = game.getEntity(aaa.getEntityId());</span>
<span class="nc bnc" id="L5535" title="All 2 branches missed.">            if (artyEnt != null) {</span>
<span class="nc bnc" id="L5536" title="All 2 branches missed.">                if (aaa.getWeaponId() &gt; -1) {</span>
<span class="nc" id="L5537">                    wpName = artyEnt.getEquipment(aaa.getWeaponId()).getName();</span>
<span class="nc bnc" id="L5538" title="All 2 branches missed.">                    if (aaa.getAmmoId() &gt; -1) {</span>
<span class="nc" id="L5539">                        ammoName = artyEnt.getEquipment(aaa.getAmmoId()).getName();</span>
                    }
                }
            }

<span class="nc" id="L5544">            txt.append(&quot;&lt;TABLE BORDER=0 BGCOLOR=#FFDDDD width=100%&gt;&lt;TR&gt;&lt;TD&gt;&lt;FONT color=\&quot;black\&quot;&gt;&quot;);</span>
<span class="nc bnc" id="L5545" title="All 2 branches missed.">            if (aaa.getTurnsTilHit() == 1)</span>
<span class="nc" id="L5546">                txt.append(Messages.getString(&quot;BoardView1.Tooltip.ArtilleryAttack1&quot;,</span>
                        wpName, ammoName));
            else
<span class="nc" id="L5549">                txt.append(Messages.getString(&quot;BoardView1.Tooltip.ArtilleryAttackN&quot;,</span>
<span class="nc" id="L5550">                        wpName, ammoName, aaa.getTurnsTilHit()));</span>
<span class="nc" id="L5551">            txt.append(&quot;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&quot;);</span>
<span class="nc" id="L5552">        }</span>

        // Artillery fire adjustment
<span class="nc" id="L5555">        final Mounted curWeapon = getSelectedArtilleryWeapon();</span>
<span class="nc bnc" id="L5556" title="All 4 branches missed.">        if ((curWeapon != null) &amp;&amp; (selectedEntity != null)) {</span>
            // process targetted hexes
<span class="nc" id="L5558">            int amod = 0;</span>
            // Check the predesignated hexes
<span class="nc bnc" id="L5560" title="All 2 branches missed.">            if (selectedEntity.getOwner().getArtyAutoHitHexes().contains(mcoords)) {</span>
<span class="nc" id="L5561">                amod = TargetRoll.AUTOMATIC_SUCCESS;</span>
            } else {
<span class="nc" id="L5563">                amod = selectedEntity.aTracker.getModifier(curWeapon, mcoords);</span>
            }

<span class="nc bnc" id="L5566" title="All 2 branches missed.">            if (amod == TargetRoll.AUTOMATIC_SUCCESS) {</span>
<span class="nc" id="L5567">                txt.append(Messages.getString(&quot;BoardView1.ArtilleryAutohit&quot;)); //$NON-NLS-1$</span>
<span class="nc" id="L5568">                txt.append(&quot;&lt;br&gt;&quot;); //$NON-NLS-1$</span>
            } else {
<span class="nc" id="L5570">                txt.append(Messages.getString(&quot;BoardView1.ArtilleryAdjustment&quot;, amod)); //$NON-NLS-1$</span>
<span class="nc" id="L5571">                txt.append(&quot;&lt;br&gt;&quot;); //$NON-NLS-1$</span>
            }
        }
<span class="nc" id="L5574">        return txt.toString();</span>
    }

    private String getEntityText(Point point, Coords mcoords) {
<span class="nc" id="L5578">        StringBuilder txt = new StringBuilder();</span>

        // Entity tooltips
<span class="nc" id="L5581">        int entityCount = 0;</span>
        // Maximum number of entities to show in the tooltip
<span class="nc" id="L5583">        int maxShown = 4;</span>

<span class="nc" id="L5585">        Set&lt;Entity&gt; coordEnts = new HashSet&lt;&gt;(game.getEntitiesVector(mcoords));</span>
<span class="nc" id="L5586">        Set&lt;Entity&gt; usedSet = new HashSet&lt;Entity&gt;(entitySprites.size());</span>
<span class="nc bnc" id="L5587" title="All 2 branches missed.">        for (EntitySprite eSprite : entitySprites) {</span>
<span class="nc bnc" id="L5588" title="All 4 branches missed.">            if ((eSprite.isInside(point) || coordEnts.contains(eSprite.entity))</span>
<span class="nc bnc" id="L5589" title="All 2 branches missed.">                    &amp;&amp; !usedSet.contains(eSprite.entity)) {</span>
<span class="nc" id="L5590">                usedSet.add(eSprite.entity);</span>
<span class="nc" id="L5591">                entityCount++;</span>

                // List only the first four units
<span class="nc bnc" id="L5594" title="All 2 branches missed.">                if (entityCount &lt;= maxShown) {</span>
                    // Table to add a bar to the left of an entity in
                    // the player's color
<span class="nc" id="L5597">                    txt.append(&quot;&lt;hr style=width:90%&gt;&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L5598">                    txt.append(&quot;&lt;TABLE&gt;&lt;TR&gt;&lt;TD bgcolor=#&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L5599">                    txt.append(eSprite.getPlayerColor());</span>
<span class="nc" id="L5600">                    txt.append(&quot; width=6&gt;&lt;/TD&gt;&lt;TD&gt;&quot;); //$NON-NLS-1$</span>

                    // TT generated by Sprite
<span class="nc" id="L5603">                    txt.append(eSprite.getTooltip());</span>

                    // ECM and ECCM source
<span class="nc bnc" id="L5606" title="All 2 branches missed.">                    if (eSprite.entity.hasActiveECM()) {</span>
<span class="nc" id="L5607">                        txt.append(&quot;&lt;br&gt;&lt;FONT SIZE=-2&gt;&lt;img src=file:&quot; //$NON-NLS-1$</span>
<span class="nc" id="L5608">                                + Configuration.widgetsDir()</span>
                                + &quot;/Tooltip/ECM_BW.png&gt;&amp;nbsp;&quot;); //$NON-NLS-1$
<span class="nc" id="L5610">                        txt.append(Messages.getString(&quot;BoardView1.ecmSource&quot;)); //$NON-NLS-1$</span>
<span class="nc" id="L5611">                        txt.append(&quot;&lt;/FONT&gt;&quot;); //$NON-NLS-1$</span>
                    }
<span class="nc bnc" id="L5613" title="All 2 branches missed.">                    if (eSprite.entity.hasActiveECCM()) {</span>
<span class="nc" id="L5614">                        txt.append(&quot;&lt;br&gt;&lt;FONT SIZE=-2&gt;&lt;img src=file:&quot; //$NON-NLS-1$</span>
<span class="nc" id="L5615">                                + Configuration.widgetsDir()</span>
                                + &quot;/Tooltip/ECM_BW.png&gt;&amp;nbsp;&quot;); //$NON-NLS-1$
<span class="nc" id="L5617">                        txt.append(Messages.getString(&quot;BoardView1.eccmSource&quot;)); //$NON-NLS-1$</span>
<span class="nc" id="L5618">                        txt.append(&quot;&lt;/FONT&gt;&quot;);</span>
                    }

<span class="nc" id="L5621">                    txt.append(&quot;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&quot;); //$NON-NLS-1$</span>
                }
            }
<span class="nc" id="L5624">        }</span>
        // Info block if there are more than 4 units in that hex
<span class="nc bnc" id="L5626" title="All 2 branches missed.">        if (entityCount &gt; maxShown) {</span>
<span class="nc" id="L5627">            txt.append(&quot;&lt;TABLE BORDER=0 BGCOLOR=#000060 width=100%&gt;&lt;TR&gt;&lt;TD&gt;&lt;FONT COLOR=WHITE&gt;There &quot;);</span>
<span class="nc bnc" id="L5628" title="All 2 branches missed.">            if (entityCount - maxShown == 1)</span>
<span class="nc" id="L5629">                txt.append(&quot;is 1 more&lt;BR&gt;unit&quot;);</span>
            else
<span class="nc" id="L5631">                txt.append(&quot;are &quot; + (entityCount - maxShown) + &quot; more&lt;BR&gt;units&quot;);</span>
<span class="nc" id="L5632">            txt.append(&quot; in this hex...&lt;/FONT&gt;&quot;);</span>
<span class="nc" id="L5633">            txt.append(&quot;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&quot;);</span>
        }
<span class="nc" id="L5635">        return txt.toString();</span>
    }

    private String getDeployPlayersText(Coords mcoords) {
<span class="nc" id="L5639">        StringBuilder txt = new StringBuilder();</span>
<span class="nc" id="L5640">        txt.append(&quot;&lt;TABLE BORDER=0 width=100%&gt;&lt;TR&gt;&lt;TD&gt;&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L5641">        Enumeration&lt;IPlayer&gt; allP = game.getPlayers();</span>
<span class="nc" id="L5642">        boolean foundPlayer = false;</span>
        // loop through all players
<span class="nc bnc" id="L5644" title="All 2 branches missed.">        while (allP.hasMoreElements()) {</span>
<span class="nc" id="L5645">            IPlayer cp = allP.nextElement();</span>
<span class="nc bnc" id="L5646" title="All 2 branches missed.">            if (game.getBoard().isLegalDeployment(mcoords, cp.getStartingPos())) {</span>
<span class="nc bnc" id="L5647" title="All 2 branches missed.">                if (!foundPlayer) {</span>
<span class="nc" id="L5648">                    foundPlayer = true;</span>
<span class="nc" id="L5649">                    txt.append(Messages.getString(&quot;BoardView1.Tooltip.ArtyAutoHeader&quot;)); //$NON-NLS-1$</span>
                }
<span class="nc" id="L5651">                txt.append(&quot;&lt;B&gt;&lt;FONT COLOR=#&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L5652">                txt.append(cp.getColour().getHexString());</span>
<span class="nc" id="L5653">                txt.append(&quot;&gt;&amp;nbsp;&amp;nbsp;&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L5654">                txt.append(cp.getName());</span>
<span class="nc" id="L5655">                txt.append(&quot;&lt;/FONT&gt;&lt;/B&gt;&lt;BR&gt;&quot;); //$NON-NLS-1$</span>
            }
<span class="nc" id="L5657">        }</span>
<span class="nc bnc" id="L5658" title="All 2 branches missed.">        if (foundPlayer) txt.append(&quot;&lt;BR&gt;&quot;); //$NON-NLS-1$</span>

        // Add a hint with keybind that the zones can be shown graphically
<span class="nc" id="L5661">        String keybindText = InputEvent.getModifiersExText(KeyCommandBind.getBindByCmd(&quot;autoArtyDeployZone&quot;).modifiers);</span>
<span class="nc bnc" id="L5662" title="All 2 branches missed.">        if (!keybindText.isEmpty()) keybindText += &quot;+&quot;;</span>
<span class="nc" id="L5663">        keybindText += KeyEvent.getKeyText(KeyCommandBind.getBindByCmd(&quot;autoArtyDeployZone&quot;).key);</span>
<span class="nc" id="L5664">        txt.append(Messages.getString(&quot;BoardView1.Tooltip.ArtyAutoHint&quot;, keybindText));</span>

<span class="nc" id="L5666">        txt.append(&quot;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L5667">        return txt.toString();</span>
    }

    private String getHexTerrainText(IHex mhex, Coords mcoords) {
<span class="nc" id="L5671">        StringBuilder txt = new StringBuilder();</span>
<span class="nc" id="L5672">        txt.append(getHexTerrainTableText(mhex, mcoords));</span>

        // Distance from the selected unit and a planned movement end point
<span class="nc bnc" id="L5675" title="All 4 branches missed.">        if ((selectedEntity != null) &amp;&amp; (selectedEntity.getPosition() != null)) {</span>
<span class="nc" id="L5676">            txt.append(getDistanceFromUnitToEndpoint(mcoords));</span>
        }

        // Fuel Tank
<span class="nc bnc" id="L5680" title="All 2 branches missed.">        if (mhex.containsTerrain(Terrains.FUEL_TANK)) {</span>
<span class="nc" id="L5681">            txt.append(getTankText(mhex, mcoords));</span>
        }

        // Building
<span class="nc bnc" id="L5685" title="All 2 branches missed.">        if (mhex.containsTerrain(Terrains.BUILDING)) {</span>
<span class="nc" id="L5686">            txt.append(getBuildingText(mhex, mcoords));</span>
        }

        // Bridge
<span class="nc bnc" id="L5690" title="All 2 branches missed.">        if (mhex.containsTerrain(Terrains.BRIDGE)) {</span>
<span class="nc" id="L5691">            txt.append(getBridgeText(mhex, mcoords));</span>
        }

        // Minefields
<span class="nc bnc" id="L5695" title="All 2 branches missed.">        if (game.containsMinefield(mcoords)) {</span>
<span class="nc" id="L5696">            Vector&lt;Minefield&gt; minefields = game.getMinefields(mcoords);</span>
<span class="nc bnc" id="L5697" title="All 2 branches missed.">            for (Minefield mf : minefields) {</span>
<span class="nc" id="L5698">                txt.append(getMinefieldText(mf));</span>
<span class="nc" id="L5699">            }</span>
        }

<span class="nc bnc" id="L5702" title="All 2 branches missed.">        if (displayInvalidHexInfo) {</span>
<span class="nc" id="L5703">            StringBuffer errBuff = new StringBuffer();</span>
<span class="nc bnc" id="L5704" title="All 2 branches missed.">            if (!mhex.isValid(errBuff)) {</span>
<span class="nc" id="L5705">                txt.append(Messages.getString(&quot;BoardView1.invalidHex&quot;));</span>
<span class="nc" id="L5706">                txt.append(&quot;&lt;br&gt;&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L5707">                String errors = errBuff.toString();</span>
<span class="nc" id="L5708">                errors = errors.replace(&quot;\n&quot;, &quot;&lt;br&gt;&quot;);</span>
<span class="nc" id="L5709">                txt.append(errors);</span>
<span class="nc" id="L5710">                txt.append(&quot;&lt;br&gt;&quot;); //$NON-NLS-1$</span>
            }
        }
<span class="nc" id="L5713">        return txt.toString();</span>
    }

    private String getMinefieldText(Minefield mf) {
<span class="nc" id="L5717">        StringBuilder txt = new StringBuilder();</span>
<span class="nc" id="L5718">        String owner = &quot; (&quot; //$NON-NLS-1$</span>
<span class="nc" id="L5719">                + game.getPlayer(mf.getPlayerId()).getName()</span>
                + &quot;)&quot;; //$NON-NLS-1$

<span class="nc bnc" id="L5722" title="All 4 branches missed.">        switch (mf.getType()) {</span>
            case (Minefield.TYPE_CONVENTIONAL):
            case (Minefield.TYPE_COMMAND_DETONATED):
<span class="nc" id="L5725">                txt.append(mf.getName()</span>
<span class="nc" id="L5726">                        + Messages.getString(&quot;BoardView1.minefield&quot;) //$NON-NLS-1$</span>
<span class="nc" id="L5727">                        + &quot;(&quot; + mf.getDensity() + &quot;)&quot; + &quot; &quot; + owner); //$NON-NLS-1$ //$NON-NLS-2$</span>
<span class="nc" id="L5728">                break;</span>
            case (Minefield.TYPE_VIBRABOMB):
<span class="nc bnc" id="L5730" title="All 2 branches missed.">                if (mf.getPlayerId() == localPlayer.getId()) {</span>
<span class="nc" id="L5731">                    txt.append(mf.getName()</span>
                            + Messages
<span class="nc" id="L5733">                            .getString(&quot;BoardView1.minefield&quot;) //$NON-NLS-1$</span>
<span class="nc" id="L5734">                            + &quot;(&quot; + mf.getDensity() + &quot;)&quot; + &quot;(&quot; //$NON-NLS-1$</span>
<span class="nc" id="L5735">                            + mf.getSetting() + &quot;) &quot; + owner); //$NON-NLS-1$ //$NON-NLS-2$</span>
                } else {
<span class="nc" id="L5737">                    txt.append(mf.getName()</span>
                            + Messages
<span class="nc" id="L5739">                            .getString(&quot;BoardView1.minefield&quot;) //$NON-NLS-1$</span>
<span class="nc" id="L5740">                            + &quot;(&quot; + mf.getDensity() + &quot;)&quot; + &quot; &quot; + owner); //$NON-NLS-1$ //$NON-NLS-2$</span>
                }
<span class="nc" id="L5742">                break;</span>
            case (Minefield.TYPE_ACTIVE):
            case (Minefield.TYPE_INFERNO):
<span class="nc" id="L5745">                txt.append(mf.getName()</span>
<span class="nc" id="L5746">                        + Messages.getString(&quot;BoardView1.minefield&quot;) //$NON-NLS-1$</span>
<span class="nc" id="L5747">                        + &quot;(&quot; + mf.getDensity() + &quot;)&quot; + owner); //$NON-NLS-1$ //$NON-NLS-2$</span>
                break;
        }
<span class="nc" id="L5750">        txt.append(&quot;&lt;br&gt;&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L5751">        return txt.toString();</span>
    }

    private String getBridgeText(IHex mhex, Coords mcoords) {
<span class="nc" id="L5755">        StringBuilder txt = new StringBuilder();</span>
        // In the BoardEditor, buildings have no entry in the
        // buildings list of the board, so get the info from the hex
<span class="nc bnc" id="L5758" title="All 2 branches missed.">        if (clientgui == null) {</span>
<span class="nc" id="L5759">            txt.append(&quot;&lt;TABLE BORDER=0 BGCOLOR=#999999 width=100%&gt;&lt;TR&gt;&lt;TD&gt;&lt;FONT color=\&quot;black\&quot;&gt;&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L5760">            txt.append(Messages.getString(&quot;BoardView1.Tooltip.Bridge&quot;, //$NON-NLS-1$</span>
<span class="nc" id="L5761">                    mhex.terrainLevel(Terrains.BRIDGE_ELEV),</span>
<span class="nc" id="L5762">                    Terrains.getEditorName(Terrains.BRIDGE),</span>
<span class="nc" id="L5763">                    mhex.terrainLevel(Terrains.BRIDGE_CF)));</span>
        } else {
<span class="nc" id="L5765">            Building bldg = game.getBoard().getBuildingAt(mcoords);</span>
<span class="nc" id="L5766">            txt.append(&quot;&lt;TABLE BORDER=0 BGCOLOR=#999999 width=100%&gt;&lt;TR&gt;&lt;TD&gt;&lt;FONT color=\&quot;black\&quot;&gt;&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L5767">            txt.append(Messages.getString(&quot;BoardView1.Tooltip.Bridge&quot;, //$NON-NLS-1$</span>
<span class="nc" id="L5768">                    mhex.terrainLevel(Terrains.BRIDGE_ELEV),</span>
<span class="nc" id="L5769">                    bldg.toString(),</span>
<span class="nc" id="L5770">                    bldg.getCurrentCF(mcoords)));</span>
        }
<span class="nc" id="L5772">        txt.append(&quot;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L5773">        return txt.toString();</span>
    }

    private String getBuildingText(IHex mhex, Coords mcoords) {
<span class="nc" id="L5777">        StringBuilder txt = new StringBuilder();</span>
        // In the BoardEditor, buildings have no entry in the
        // buildings list of the board, so get the info from the hex
<span class="nc bnc" id="L5780" title="All 2 branches missed.">        if (clientgui == null) {</span>
<span class="nc" id="L5781">            txt.append(&quot;&lt;TABLE BORDER=0 BGCOLOR=#999999 width=100%&gt;&lt;TR&gt;&lt;TD&gt;&lt;FONT color=\&quot;black\&quot;&gt;&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L5782">            txt.append(Messages.getString(&quot;BoardView1.Tooltip.Building&quot;, //$NON-NLS-1$</span>
<span class="nc" id="L5783">                    mhex.terrainLevel(Terrains.BLDG_ELEV),</span>
<span class="nc" id="L5784">                    Terrains.getEditorName(Terrains.BUILDING),</span>
<span class="nc" id="L5785">                    mhex.terrainLevel(Terrains.BLDG_CF),</span>
<span class="nc" id="L5786">                    Math.max(mhex.terrainLevel(Terrains.BLDG_ARMOR), 0),</span>
<span class="nc" id="L5787">                    BasementType.getType(mhex.terrainLevel(Terrains.BLDG_BASEMENT_TYPE)).toString()));</span>
        } else {
<span class="nc" id="L5789">            Building bldg = game.getBoard().getBuildingAt(mcoords);</span>
<span class="nc" id="L5790">            txt.append(&quot;&lt;TABLE BORDER=0 BGCOLOR=#CCCC99 width=100%&gt;&lt;TR&gt;&lt;TD&gt;&lt;FONT color=\&quot;black\&quot;&gt;&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L5791">            txt.append(Messages.getString(&quot;BoardView1.Tooltip.Building&quot;, //$NON-NLS-1$</span>
<span class="nc" id="L5792">                    mhex.terrainLevel(Terrains.BLDG_ELEV),</span>
<span class="nc" id="L5793">                    bldg.toString(),</span>
<span class="nc" id="L5794">                    bldg.getCurrentCF(mcoords),</span>
<span class="nc" id="L5795">                    bldg.getArmor(mcoords),</span>
<span class="nc" id="L5796">                    bldg.getBasement(mcoords).getDesc()));</span>

<span class="nc bnc" id="L5798" title="All 2 branches missed.">            if (bldg.getBasementCollapsed(mcoords)) {</span>
<span class="nc" id="L5799">                txt.append(Messages</span>
<span class="nc" id="L5800">                        .getString(&quot;BoardView1.Tooltip.BldgBasementCollapsed&quot;)); //$NON-NLS-1$</span>
            }
        }
<span class="nc" id="L5803">        txt.append(&quot;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L5804">        return txt.toString();</span>
    }

    private String getTankText(IHex mhex, Coords mcoords) {
<span class="nc" id="L5808">        StringBuilder txt = new StringBuilder();</span>
        // In the BoardEditor, buildings have no entry in the
        // buildings list of the board, so get the info from the hex
<span class="nc bnc" id="L5811" title="All 2 branches missed.">        if (clientgui == null) {</span>
<span class="nc" id="L5812">            txt.append(&quot;&lt;TABLE BORDER=0 BGCOLOR=#999999 width=100%&gt;&lt;TR&gt;&lt;TD&gt;&lt;FONT color=\&quot;black\&quot;&gt;&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L5813">            txt.append(Messages.getString(&quot;BoardView1.Tooltip.FuelTank&quot;, //$NON-NLS-1$</span>
<span class="nc" id="L5814">                    mhex.terrainLevel(Terrains.FUEL_TANK_ELEV),</span>
<span class="nc" id="L5815">                    Terrains.getEditorName(Terrains.FUEL_TANK),</span>
<span class="nc" id="L5816">                    mhex.terrainLevel(Terrains.FUEL_TANK_CF),</span>
<span class="nc" id="L5817">                    mhex.terrainLevel(Terrains.FUEL_TANK_MAGN)));</span>
        } else {
<span class="nc" id="L5819">            Building bldg = game.getBoard().getBuildingAt(mcoords);</span>
<span class="nc" id="L5820">            txt.append(&quot;&lt;TABLE BORDER=0 BGCOLOR=#999999 width=100%&gt;&lt;TR&gt;&lt;TD&gt;&lt;FONT color=\&quot;black\&quot;&gt;&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L5821">            txt.append(Messages.getString(&quot;BoardView1.Tooltip.FuelTank&quot;, //$NON-NLS-1$</span>
<span class="nc" id="L5822">                    mhex.terrainLevel(Terrains.FUEL_TANK_ELEV),</span>
<span class="nc" id="L5823">                    bldg.toString(),</span>
<span class="nc" id="L5824">                    bldg.getCurrentCF(mcoords)));</span>
        }
<span class="nc" id="L5826">        txt.append(&quot;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L5827">        return txt.toString();</span>
    }

    private String getDistanceFromUnitToEndpoint(Coords mcoords) {
<span class="nc" id="L5831">        StringBuilder txt = new StringBuilder();</span>
<span class="nc" id="L5832">        int distance = selectedEntity.getPosition().distance(mcoords);</span>
<span class="nc" id="L5833">        txt.append(&quot;&lt;TABLE BORDER=0 BGCOLOR=#FFDDDD width=100%&gt;&lt;TR&gt;&lt;TD&gt;&lt;FONT color=\&quot;black\&quot;&gt;&quot;); //$NON-NLS-1$</span>
<span class="nc bnc" id="L5834" title="All 2 branches missed.">        if (distance == 1) {</span>
<span class="nc" id="L5835">            txt.append(Messages.getString(&quot;BoardView1.Tooltip.Distance1&quot;)); //$NON-NLS-1$</span>
        } else {
<span class="nc" id="L5837">            txt.append(Messages.getString(&quot;BoardView1.Tooltip.DistanceN&quot;, //$NON-NLS-1$</span>
<span class="nc" id="L5838">                    distance));</span>
        }

<span class="nc bnc" id="L5841" title="All 2 branches missed.">        if (game.getOptions().booleanOption(OptionsConstants.ADVANCED_TACOPS_SENSORS)) {</span>
<span class="nc" id="L5842">            LosEffects los = fovHighlightingAndDarkening.getCachedLosEffects(selectedEntity.getPosition(), mcoords);</span>
<span class="nc" id="L5843">            int bracket = Compute.getSensorRangeBracket(selectedEntity, null,</span>
                    fovHighlightingAndDarkening.cachedAllECMInfo);
<span class="nc" id="L5845">            int range = Compute.getSensorRangeByBracket(game, selectedEntity, null, los);</span>

<span class="nc" id="L5847">            int maxSensorRange = bracket * range;</span>
<span class="nc" id="L5848">            int minSensorRange = Math.max((bracket - 1) * range, 0);</span>
<span class="nc bnc" id="L5849" title="All 2 branches missed.">            if (game.getOptions().booleanOption(OptionsConstants.ADVANCED_INCLUSIVE_SENSOR_RANGE)) {</span>
<span class="nc" id="L5850">                minSensorRange = 0;</span>
            }
<span class="nc" id="L5852">            txt.append(&quot;&lt;BR&gt;&quot;);</span>
<span class="nc bnc" id="L5853" title="All 4 branches missed.">            if ((distance &gt; minSensorRange) &amp;&amp; (distance &lt;= maxSensorRange)) {</span>
<span class="nc" id="L5854">                txt.append(Messages.getString(&quot;BoardView1.Tooltip.SensorsHexInRange&quot;));</span>
            } else {
<span class="nc" id="L5856">                txt.append(Messages.getString(&quot;BoardView1.Tooltip.SensorsHexNotInRange&quot;));</span>
            }
        }

<span class="nc bnc" id="L5860" title="All 4 branches missed.">        if ((game.getPhase() == Phase.PHASE_MOVEMENT) &amp;&amp;</span>
                (movementTarget != null)) {
<span class="nc" id="L5862">            txt.append(&quot;&lt;BR&gt;&quot;);</span>
<span class="nc" id="L5863">            int disPM = movementTarget.distance(mcoords);</span>
<span class="nc bnc" id="L5864" title="All 2 branches missed.">            if (disPM == 1) {</span>
<span class="nc" id="L5865">                txt.append(Messages.getString(&quot;BoardView1.Tooltip.DistanceMove1&quot;)); //$NON-NLS-1$</span>
            } else {
<span class="nc" id="L5867">                txt.append(Messages.getString(&quot;BoardView1.Tooltip.DistanceMoveN&quot;, //$NON-NLS-1$</span>
<span class="nc" id="L5868">                        disPM));</span>
            }
        }

<span class="nc" id="L5872">        txt.append(&quot;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L5873">        return txt.toString();</span>
    }

    private String getHexTerrainTableText(IHex mhex, Coords mcoords) {
<span class="nc" id="L5877">        StringBuilder txt = new StringBuilder();</span>
<span class="nc" id="L5878">        txt.append(&quot;&lt;TABLE BORDER=0 BGCOLOR=#DDFFDD width=100%&gt;&lt;TR&gt;&lt;TD&gt;&lt;FONT color=\&quot;black\&quot;&gt;&quot;); //$NON-NLS-1$</span>

<span class="nc" id="L5880">        txt.append(Messages.getString(&quot;BoardView1.Tooltip.Hex&quot;, //$NON-NLS-1$</span>
<span class="nc" id="L5881">                mcoords.getBoardNum(), mhex.getLevel()));</span>
<span class="nc" id="L5882">        txt.append(&quot;&lt;br&gt;&quot;); //$NON-NLS-1$</span>

        // cycle through the terrains and report types found
        // this will skip buildings and other constructed units
<span class="nc" id="L5886">        int[] terrainTypes = mhex.getTerrainTypes();</span>
<span class="nc bnc" id="L5887" title="All 2 branches missed.">        for (int terType : terrainTypes) {</span>
<span class="nc bnc" id="L5888" title="All 2 branches missed.">            if (mhex.containsTerrain(terType)) {</span>
<span class="nc" id="L5889">                int tf = mhex.getTerrain(terType).getTerrainFactor();</span>
<span class="nc" id="L5890">                int ttl = mhex.getTerrain(terType).getLevel();</span>
<span class="nc" id="L5891">                String name = Terrains.getDisplayName(terType, ttl);</span>
<span class="nc bnc" id="L5892" title="All 2 branches missed.">                if (tf &gt; 0) {</span>
<span class="nc" id="L5893">                    name = name + &quot; (TF: &quot; + tf + &quot;)&quot;; //$NON-NLS-1$ //$NON-NLS-2$</span>
                }
<span class="nc bnc" id="L5895" title="All 2 branches missed.">                if (name != null) {</span>
<span class="nc" id="L5896">                    txt.append(name);</span>
<span class="nc" id="L5897">                    txt.append(&quot;&lt;br&gt;&quot;); //$NON-NLS-1$</span>
                }
            }
        }
<span class="nc" id="L5901">        txt.append(&quot;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L5902">        return txt.toString();</span>
    }

    private ArrayList&lt;ArtilleryAttackAction&gt; getArtilleryAttacksAtLocation(Coords c) {
<span class="nc" id="L5906">        ArrayList&lt;ArtilleryAttackAction&gt; v = new ArrayList&lt;ArtilleryAttackAction&gt;();</span>
<span class="nc" id="L5907">        for (Enumeration&lt;ArtilleryAttackAction&gt; attacks = game</span>
<span class="nc bnc" id="L5908" title="All 2 branches missed.">                .getArtilleryAttacks(); attacks.hasMoreElements(); ) {</span>
<span class="nc" id="L5909">            ArtilleryAttackAction a = attacks.nextElement();</span>
<span class="nc bnc" id="L5910" title="All 2 branches missed.">            if (a.getTarget(game).getPosition().equals(c)) {</span>
<span class="nc" id="L5911">                v.add(a);</span>
            }
<span class="nc" id="L5913">        }</span>
<span class="nc" id="L5914">        return v;</span>
    }

    public Component getComponent() {
<span class="nc" id="L5918">        return getComponent(false);</span>
    }

    public Component getComponent(boolean scrollBars) {
        // If we're already configured, return the scrollpane
<span class="nc bnc" id="L5923" title="All 2 branches missed.">        if (scrollpane != null) {</span>
<span class="nc" id="L5924">            return scrollpane;</span>
        }

<span class="nc" id="L5927">        SkinSpecification bvSkinSpec = SkinXMLHandler</span>
<span class="nc" id="L5928">                .getSkin(SkinSpecification.UIComponents.BoardView.getComp());</span>

        // Setup background icons
        try {
            File file;
<span class="nc bnc" id="L5933" title="All 2 branches missed.">            if (bvSkinSpec.backgrounds.size() &gt; 0) {</span>
<span class="nc" id="L5934">                file = new MegaMekFile(Configuration.widgetsDir(),</span>
<span class="nc" id="L5935">                        bvSkinSpec.backgrounds.get(0)).getFile();</span>
<span class="nc bnc" id="L5936" title="All 2 branches missed.">                if (!file.exists()) {</span>
<span class="nc" id="L5937">                    MegaMek.getLogger().error(&quot;BoardView1 Error: icon doesn't exist: &quot;</span>
<span class="nc" id="L5938">                            + file.getAbsolutePath());</span>
                } else {
<span class="nc" id="L5940">                    bvBgImage = (BufferedImage) ImageUtil.loadImageFromFile(</span>
<span class="nc" id="L5941">                            file.getAbsolutePath());</span>
<span class="nc" id="L5942">                    bvBgShouldTile = bvSkinSpec.tileBackground;</span>
                }
            }
<span class="nc bnc" id="L5945" title="All 2 branches missed.">            if (bvSkinSpec.backgrounds.size() &gt; 1) {</span>
<span class="nc" id="L5946">                file = new MegaMekFile(Configuration.widgetsDir(),</span>
<span class="nc" id="L5947">                        bvSkinSpec.backgrounds.get(1)).getFile();</span>
<span class="nc bnc" id="L5948" title="All 2 branches missed.">                if (!file.exists()) {</span>
<span class="nc" id="L5949">                    MegaMek.getLogger().error(&quot;BoardView1 Error: icon doesn't exist: &quot;</span>
<span class="nc" id="L5950">                            + file.getAbsolutePath());</span>
                } else {
<span class="nc" id="L5952">                    scrollPaneBgImg = ImageUtil.loadImageFromFile(file.getAbsolutePath());</span>
                }
            }
<span class="nc" id="L5955">        } catch (Exception e) {</span>
<span class="nc" id="L5956">            MegaMek.getLogger().error(&quot;Error loading BoardView background images!&quot;, e);</span>
<span class="nc" id="L5957">        }</span>

        // Place the board viewer in a set of scrollbars.
<span class="nc" id="L5960">        scrollpane = new JScrollPane(this) {</span>
            private static final long serialVersionUID = 5973610449428194319L;

            @Override
            protected void paintComponent(Graphics g) {
<span class="nc bnc" id="L5965" title="All 2 branches missed.">                if (scrollPaneBgImg == null) {</span>
<span class="nc" id="L5966">                    super.paintComponent(g);</span>
<span class="nc" id="L5967">                    return;</span>
                }
<span class="nc" id="L5969">                int w = getWidth();</span>
<span class="nc" id="L5970">                int h = getHeight();</span>
<span class="nc" id="L5971">                int iW = scrollPaneBgImg.getWidth(null);</span>
<span class="nc" id="L5972">                int iH = scrollPaneBgImg.getHeight(null);</span>
<span class="nc bnc" id="L5973" title="All 2 branches missed.">                if ((scrollPaneBgBuffer == null)</span>
<span class="nc bnc" id="L5974" title="All 2 branches missed.">                        || (scrollPaneBgBuffer.getWidth() != w)</span>
<span class="nc bnc" id="L5975" title="All 2 branches missed.">                        || (scrollPaneBgBuffer.getHeight() != h)) {</span>
<span class="nc" id="L5976">                    scrollPaneBgBuffer = new BufferedImage(w, h,</span>
                            BufferedImage.TYPE_INT_RGB);
<span class="nc" id="L5978">                    Graphics bgGraph = scrollPaneBgBuffer.getGraphics();</span>
                    // If the unit icon not loaded, prevent infinite loop
<span class="nc bnc" id="L5980" title="All 4 branches missed.">                    if ((iW &lt; 1) || (iH &lt; 1)) {</span>
<span class="nc" id="L5981">                        return;</span>
                    }
<span class="nc bnc" id="L5983" title="All 2 branches missed.">                    for (int x = 0; x &lt; w; x += iW) {</span>
<span class="nc bnc" id="L5984" title="All 2 branches missed.">                        for (int y = 0; y &lt; h; y += iH) {</span>
<span class="nc" id="L5985">                            bgGraph.drawImage(scrollPaneBgImg, x, y, null);</span>
                        }
                    }
<span class="nc" id="L5988">                    bgGraph.dispose();</span>
                }
<span class="nc" id="L5990">                g.drawImage(scrollPaneBgBuffer, 0, 0, null);</span>
<span class="nc" id="L5991">            }</span>
        };
<span class="nc" id="L5993">        scrollpane.setBorder(new MegamekBorder(bvSkinSpec));</span>
<span class="nc" id="L5994">        scrollpane.setLayout(new ScrollPaneLayout());</span>
        // we need to use the simple scroll mode because otherwise the
        // IDisplayables that are drawn in fixed positions in the viewport
        // leave artifacts when scrolling
<span class="nc" id="L5998">        scrollpane.getViewport().setScrollMode(JViewport.SIMPLE_SCROLL_MODE);</span>

        // Prevent the default arrow key scrolling
<span class="nc" id="L6001">        scrollpane.getActionMap().put(&quot;unitScrollRight&quot;, DoNothing);</span>
<span class="nc" id="L6002">        scrollpane.getActionMap().put(&quot;unitScrollDown&quot;, DoNothing);</span>
<span class="nc" id="L6003">        scrollpane.getActionMap().put(&quot;unitScrollLeft&quot;, DoNothing);</span>
<span class="nc" id="L6004">        scrollpane.getActionMap().put(&quot;unitScrollUp&quot;, DoNothing);</span>

<span class="nc" id="L6006">        vbar = scrollpane.getVerticalScrollBar();</span>
<span class="nc" id="L6007">        hbar = scrollpane.getHorizontalScrollBar();</span>

<span class="nc bnc" id="L6009" title="All 4 branches missed.">        if (!scrollBars &amp;&amp; !bvSkinSpec.showScrollBars) {</span>
<span class="nc" id="L6010">            vbar.setPreferredSize(new Dimension(0, vbar.getHeight()));</span>
<span class="nc" id="L6011">            hbar.setPreferredSize(new Dimension(hbar.getWidth(), 0));</span>
        }

<span class="nc" id="L6014">        return scrollpane;</span>
    }

    /**
     * refresh the IDisplayables
     */
    public void refreshDisplayables() {
<span class="nc" id="L6021">        repaint();</span>
<span class="nc" id="L6022">    }</span>

    private void pingMinimap() {
        // send the minimap a hex moused event to make it
        // update the visible area rectangle
<span class="nc" id="L6027">        BoardViewEvent bve = new BoardViewEvent(this, BoardViewEvent.BOARD_HEX_DRAGGED);</span>
<span class="nc bnc" id="L6028" title="All 2 branches missed.">        if (boardListeners != null) {</span>
<span class="nc bnc" id="L6029" title="All 2 branches missed.">            for (BoardViewListener l : boardListeners) l.hexMoused(bve);</span>
        }
<span class="nc" id="L6031">    }</span>

    public void showPopup(Object popup, Coords c) {
<span class="nc" id="L6034">        Point p = getHexLocation(c);</span>
<span class="nc" id="L6035">        p.x += ((int) (HEX_WC * scale) - scrollpane.getX()) + HEX_W;</span>
<span class="nc" id="L6036">        p.y += ((int) ((HEX_H * scale) / 2) - scrollpane.getY()) + HEX_H;</span>
<span class="nc bnc" id="L6037" title="All 2 branches missed.">        if (((JPopupMenu) popup).getParent() == null) {</span>
<span class="nc" id="L6038">            add((JPopupMenu) popup);</span>
        }
<span class="nc" id="L6040">        ((JPopupMenu) popup).show(this, p.x, p.y);</span>
<span class="nc" id="L6041">    }</span>

    public void refreshMinefields() {
<span class="nc" id="L6044">        repaint();</span>
<span class="nc" id="L6045">    }</span>

    /**
     * Increases zoomIndex and refreshes the map.
     */
    public void zoomIn() {
<span class="nc bnc" id="L6051" title="All 2 branches missed.">        if (zoomIndex == (ZOOM_FACTORS.length - 1)) {</span>
<span class="nc" id="L6052">            return;</span>
        }
<span class="nc" id="L6054">        zoomIndex++;</span>
<span class="nc" id="L6055">        zoom();</span>
<span class="nc" id="L6056">    }</span>

    /**
     * Decreases zoomIndex and refreshes the map.
     */
    public void zoomOut() {
<span class="nc bnc" id="L6062" title="All 2 branches missed.">        if (zoomIndex == 0) {</span>
<span class="nc" id="L6063">            return;</span>
        }
<span class="nc" id="L6065">        zoomIndex--;</span>
<span class="nc" id="L6066">        zoom();</span>
<span class="nc" id="L6067">    }</span>

    public void hideTooltip() {
<span class="nc" id="L6070">        throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);</span>
    }

    private void checkZoomIndex() {
<span class="nc bnc" id="L6074" title="All 2 branches missed.">        if (zoomIndex &gt; (ZOOM_FACTORS.length - 1)) {</span>
<span class="nc" id="L6075">            zoomIndex = ZOOM_FACTORS.length - 1;</span>
        }
<span class="nc bnc" id="L6077" title="All 2 branches missed.">        if (zoomIndex &lt; 0) {</span>
<span class="nc" id="L6078">            zoomIndex = 0;</span>
        }
<span class="nc" id="L6080">    }</span>

    /**
     * Changes hex dimensions and refreshes the map with the new scale
     */
    private void zoom() {

<span class="nc" id="L6087">        checkZoomIndex();</span>
<span class="nc" id="L6088">        stopSoftCentering();</span>
<span class="nc" id="L6089">        scale = ZOOM_FACTORS[zoomIndex];</span>
<span class="nc" id="L6090">        GUIPreferences.getInstance().setMapZoomIndex(zoomIndex);</span>

<span class="nc" id="L6092">        hex_size = new Dimension((int) (HEX_W * scale), (int) (HEX_H * scale));</span>

<span class="nc" id="L6094">        scaledImageCache = new ImageCache&lt;Integer, Image&gt;();</span>

<span class="nc" id="L6096">        cursorSprite.prepare();</span>
<span class="nc" id="L6097">        highlightSprite.prepare();</span>
<span class="nc" id="L6098">        selectedSprite.prepare();</span>
<span class="nc" id="L6099">        firstLOSSprite.prepare();</span>
<span class="nc" id="L6100">        secondLOSSprite.prepare();</span>
<span class="nc bnc" id="L6101" title="All 2 branches missed.">        for (Sprite spr : moveEnvSprites) {</span>
<span class="nc" id="L6102">            spr.prepare();</span>
<span class="nc" id="L6103">        }</span>
<span class="nc bnc" id="L6104" title="All 2 branches missed.">        for (Sprite spr : moveModEnvSprites) {</span>
<span class="nc" id="L6105">            spr.prepare();</span>
<span class="nc" id="L6106">        }</span>
<span class="nc bnc" id="L6107" title="All 2 branches missed.">        for (Sprite spr : fieldofFireSprites) {</span>
<span class="nc" id="L6108">            spr.prepare();</span>
<span class="nc" id="L6109">        }</span>

<span class="nc" id="L6111">        updateFontSizes();</span>
<span class="nc" id="L6112">        updateBoard();</span>
<span class="nc bnc" id="L6113" title="All 2 branches missed.">        for (StepSprite sprite : pathSprites) {</span>
<span class="nc" id="L6114">            sprite.refreshZoomLevel();</span>
<span class="nc" id="L6115">        }</span>
<span class="nc bnc" id="L6116" title="All 2 branches missed.">        for (FiringSolutionSprite sprite : firingSprites) {</span>
<span class="nc" id="L6117">            sprite.prepare();</span>
<span class="nc" id="L6118">        }</span>
<span class="nc" id="L6119">        this.setSize(boardSize);</span>

<span class="nc" id="L6121">        clearHexImageCache();</span>
<span class="nc" id="L6122">        repaint();</span>
<span class="nc" id="L6123">    }</span>

    private void updateFontSizes() {
<span class="nc bnc" id="L6126" title="All 2 branches missed.">        if (zoomIndex &lt;= 4) {</span>
<span class="nc" id="L6127">            font_elev = FONT_7;</span>
<span class="nc" id="L6128">            font_hexnum = FONT_7;</span>
<span class="nc" id="L6129">            font_minefield = FONT_7;</span>
        }
<span class="nc bnc" id="L6131" title="All 6 branches missed.">        if ((zoomIndex &lt;= 5) &amp; (zoomIndex &gt; 4)) {</span>
<span class="nc" id="L6132">            font_elev = FONT_8;</span>
<span class="nc" id="L6133">            font_hexnum = FONT_8;</span>
<span class="nc" id="L6134">            font_minefield = FONT_8;</span>
        }
<span class="nc bnc" id="L6136" title="All 2 branches missed.">        if (zoomIndex &gt; 5) {</span>
<span class="nc" id="L6137">            font_elev = FONT_9;</span>
<span class="nc" id="L6138">            font_hexnum = FONT_9;</span>
<span class="nc" id="L6139">            font_minefield = FONT_9;</span>
        }
<span class="nc" id="L6141">    }</span>

    /**
     * Return a scaled version of the input.  If the useCache flag is set, the
     * scaled image will be stored in an image cache for later retrieval.
     *
     * @param base     The image to get a scaled copy of.  The current zoom level
     *                 is used to determine the scale.
     * @param useCache This flag determines whether the scaled image should
     *                 be stored in a cache for later retrieval.
     */
    Image getScaledImage(Image base, boolean useCache) {
<span class="nc bnc" id="L6153" title="All 2 branches missed.">        if (base == null) {</span>
<span class="nc" id="L6154">            return null;</span>
        }
<span class="nc bnc" id="L6156" title="All 2 branches missed.">        if (zoomIndex == BASE_ZOOM_INDEX) {</span>
<span class="nc" id="L6157">            return base;</span>
        }


        Image scaled;
<span class="nc bnc" id="L6162" title="All 2 branches missed.">        if (useCache) {</span>
            // Check the cache
<span class="nc" id="L6164">            scaled = scaledImageCache.get(base.hashCode());</span>
        } else {
<span class="nc" id="L6166">            scaled = null;</span>
        }
        // Compute the scaled image
<span class="nc bnc" id="L6169" title="All 2 branches missed.">        if (scaled == null) {</span>
<span class="nc" id="L6170">            MediaTracker tracker = new MediaTracker(this);</span>
<span class="nc bnc" id="L6171" title="All 4 branches missed.">            if ((base.getWidth(null) == -1) || (base.getHeight(null) == -1)) {</span>
<span class="nc" id="L6172">                tracker.addImage(base, 0);</span>
                try {
<span class="nc" id="L6174">                    tracker.waitForID(0);</span>
<span class="nc" id="L6175">                } catch (InterruptedException e) {</span>
<span class="nc" id="L6176">                    MegaMek.getLogger().error(e);</span>
<span class="nc" id="L6177">                }</span>
<span class="nc bnc" id="L6178" title="All 2 branches missed.">                if (tracker.isErrorAny()) {</span>
<span class="nc" id="L6179">                    return null;</span>
                }
<span class="nc" id="L6181">                tracker.removeImage(base);</span>
            }
<span class="nc" id="L6183">            int width = (int) (base.getWidth(null) * scale);</span>
<span class="nc" id="L6184">            int height = (int) (base.getHeight(null) * scale);</span>

<span class="nc bnc" id="L6186" title="All 4 branches missed.">            if ((width &lt; 1) || (height &lt; 1)) {</span>
<span class="nc" id="L6187">                return null;</span>
            }

<span class="nc" id="L6190">            scaled = scale(base, width, height);</span>
<span class="nc" id="L6191">            tracker.addImage(scaled, 1);</span>
            // Wait for image to load
            try {
<span class="nc" id="L6194">                tracker.waitForID(1);</span>
<span class="nc" id="L6195">            } catch (InterruptedException e) {</span>
<span class="nc" id="L6196">                MegaMek.getLogger().error(e);</span>
<span class="nc" id="L6197">            }</span>
<span class="nc" id="L6198">            tracker.removeImage(scaled);</span>
            // Cache the image if the flag is set
<span class="nc bnc" id="L6200" title="All 2 branches missed.">            if (useCache) {</span>
<span class="nc" id="L6201">                scaledImageCache.put(base.hashCode(), scaled);</span>
            }
        }
<span class="nc" id="L6204">        return scaled;</span>
    }

    /**
     * The actual scaling code.
     */
    private Image scale(Image img, int width, int height) {
<span class="nc" id="L6211">        return ImageUtil.getScaledImage(img, width, height,</span>
                ZOOM_SCALE_TYPES[zoomIndex]);
    }

    public boolean toggleIsometric() {
<span class="nc bnc" id="L6216" title="All 2 branches missed.">        drawIsometric = !drawIsometric;</span>
<span class="nc bnc" id="L6217" title="All 2 branches missed.">        for (Sprite spr : moveEnvSprites) spr.prepare();</span>
<span class="nc bnc" id="L6218" title="All 2 branches missed.">        for (Sprite spr : moveModEnvSprites) spr.prepare();</span>
<span class="nc bnc" id="L6219" title="All 2 branches missed.">        for (Sprite spr : fieldofFireSprites) spr.prepare();</span>
<span class="nc" id="L6220">        clearHexImageCache();</span>
<span class="nc" id="L6221">        updateBoard();</span>
<span class="nc bnc" id="L6222" title="All 2 branches missed.">        for (MovementEnvelopeSprite sprite : moveEnvSprites)</span>
<span class="nc" id="L6223">            sprite.updateBounds();</span>
<span class="nc bnc" id="L6224" title="All 2 branches missed.">        for (MovementModifierEnvelopeSprite sprite : moveModEnvSprites)</span>
<span class="nc" id="L6225">            sprite.updateBounds();</span>
<span class="nc" id="L6226">        repaint();</span>
<span class="nc" id="L6227">        return drawIsometric;</span>
    }

    public void updateEntityLabels() {
<span class="nc bnc" id="L6231" title="All 2 branches missed.">        for (Entity e : game.getEntitiesVector()) {</span>
<span class="nc" id="L6232">            e.generateShortName();</span>
<span class="nc" id="L6233">        }</span>
<span class="nc bnc" id="L6234" title="All 2 branches missed.">        for (EntitySprite eS : entitySprites) {</span>
<span class="nc" id="L6235">            eS.prepare();</span>
<span class="nc" id="L6236">        }</span>
<span class="nc" id="L6237">        repaint();</span>
<span class="nc" id="L6238">    }</span>

    BufferedImage createShadowMask(Image image) {
<span class="nc" id="L6241">        int hashCode = image.hashCode();</span>
<span class="nc" id="L6242">        BufferedImage mask = shadowImageCache.get(hashCode);</span>
<span class="nc bnc" id="L6243" title="All 2 branches missed.">        if (mask != null) {</span>
<span class="nc" id="L6244">            return mask;</span>
        }
<span class="nc" id="L6246">        mask = new BufferedImage(image.getWidth(null),</span>
<span class="nc" id="L6247">                image.getHeight(null), BufferedImage.TYPE_INT_ARGB);</span>
<span class="nc" id="L6248">        float opacity = 0.4f;</span>
<span class="nc" id="L6249">        Graphics2D g2d = mask.createGraphics();</span>
<span class="nc" id="L6250">        g2d.drawImage(image, 0, 0, null);</span>
<span class="nc" id="L6251">        g2d.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_IN,</span>
                opacity));
<span class="nc" id="L6253">        g2d.setColor(Color.BLACK);</span>
<span class="nc" id="L6254">        g2d.fillRect(0, 0, image.getWidth(null), image.getHeight(null));</span>
<span class="nc" id="L6255">        g2d.dispose();</span>
<span class="nc" id="L6256">        shadowImageCache.put(hashCode, mask);</span>
<span class="nc" id="L6257">        return mask;</span>
    }

    public void die() {
<span class="nc" id="L6261">        ourTask.cancel();</span>
<span class="nc" id="L6262">        fovHighlightingAndDarkening.die();</span>
<span class="nc" id="L6263">    }</span>

    /**
     * Returns true if the BoardView has an active chatter box else false.
     *
     * @return
     */
    public boolean getChatterBoxActive() {
<span class="nc" id="L6271">        return chatterBoxActive;</span>
    }

    /**
     * Sets whether the BoardView has an active chatter box or not.
     *
     * @param cba
     */
    public void setChatterBoxActive(boolean cba) {
<span class="nc" id="L6280">        chatterBoxActive = cba;</span>
<span class="nc" id="L6281">    }</span>

    public void setShouldIgnoreKeys(boolean shouldIgnoreKeys) {
<span class="nc" id="L6284">        this.shouldIgnoreKeys = shouldIgnoreKeys;</span>
<span class="nc" id="L6285">    }</span>

    @Override
    public boolean imageUpdate(Image img, int flags, int x, int y, int w, int h) {
        // If FRAMEBITS is set, then new frame from a multi-frame image is ready
        // This indicates an animated image, which shouldn't be cached
<span class="nc bnc" id="L6291" title="All 2 branches missed.">        if ((flags &amp; ImageObserver.FRAMEBITS) != 0) {</span>
<span class="nc" id="L6292">            animatedImages.add(img.hashCode());</span>
        }
<span class="nc" id="L6294">        return super.imageUpdate(img, flags, x, y, w, h);</span>
    }

    public void clearHexImageCache() {
<span class="nc" id="L6298">        hexImageCache.clear();</span>
<span class="nc" id="L6299">    }</span>

    /**
     * Clear a specific list of Coords from the hex image cache.
     *
     * @param coords
     */
    public void clearHexImageCache(Set&lt;Coords&gt; coords) {
<span class="nc bnc" id="L6307" title="All 2 branches missed.">        for (Coords c : coords) {</span>
<span class="nc" id="L6308">            hexImageCache.remove(c);</span>
<span class="nc" id="L6309">        }</span>
<span class="nc" id="L6310">    }</span>

    /**
     * Check to see if the HexImageCache should be cleared because of
     * field-of-view changes.
     */
    public void checkFoVHexImageCacheClear() {
<span class="nc" id="L6317">        boolean darken = GUIPreferences.getInstance().getBoolean(</span>
                GUIPreferences.FOV_DARKEN);
<span class="nc" id="L6319">        boolean highlight = GUIPreferences.getInstance().getBoolean(</span>
                GUIPreferences.FOV_HIGHLIGHT);
<span class="nc bnc" id="L6321" title="All 6 branches missed.">        if ((game.getPhase() == Phase.PHASE_MOVEMENT)</span>
                &amp;&amp; (darken || highlight)) {
<span class="nc" id="L6323">            clearHexImageCache();</span>
        }
<span class="nc" id="L6325">    }</span>

    public Polygon getHexPoly() {
<span class="nc" id="L6328">        return hexPoly;</span>
    }

    public void clearFieldofF() {
<span class="nc" id="L6332">        fieldofFireWpArc = -1;</span>
<span class="nc" id="L6333">        fieldofFireUnit = null;</span>
<span class="nc" id="L6334">        fieldofFireSprites.clear();</span>
<span class="nc" id="L6335">        repaint();</span>
<span class="nc" id="L6336">    }</span>

    // this is called from MovementDisplay and checks if
    // the unit ends up underwater
    public void setWeaponFieldofFire(Entity ce, MovePath cmd) {
        // if lack of data: clear and return
<span class="nc bnc" id="L6342" title="All 6 branches missed.">        if ((fieldofFireUnit == null)</span>
                || (ce == null)
                || (cmd == null)) {
<span class="nc" id="L6345">            clearFieldofF();</span>
<span class="nc" id="L6346">            return;</span>
        }

        // If the field of fire is not dispalyed
        // for the active unit, then don't change anything
<span class="nc bnc" id="L6351" title="All 2 branches missed.">        if (!fieldofFireUnit.equals(ce)) {</span>
<span class="nc" id="L6352">            return;</span>
        }

<span class="nc" id="L6355">        fieldofFireWpUnderwater = 0;</span>
        // check if the weapon ends up underwater
<span class="nc" id="L6357">        IHex hex = game.getBoard().getHex(cmd.getFinalCoords());</span>

<span class="nc bnc" id="L6359" title="All 6 branches missed.">        if ((hex.terrainLevel(Terrains.WATER) &gt; 0) &amp;&amp; !cmd.isJumping() &amp;&amp; (cmd.getFinalElevation() &lt; 0)) {</span>
<span class="nc bnc" id="L6360" title="All 6 branches missed.">            if ((fieldofFireUnit instanceof Mech) &amp;&amp; !fieldofFireUnit.isProne() &amp;&amp; (hex.terrainLevel(Terrains.WATER) == 1)) {</span>
<span class="nc bnc" id="L6361" title="All 4 branches missed.">                if ((fieldofFireWpLoc == Mech.LOC_RLEG) || (fieldofFireWpLoc == Mech.LOC_LLEG))</span>
<span class="nc" id="L6362">                    fieldofFireWpUnderwater = 1;</span>

<span class="nc bnc" id="L6364" title="All 2 branches missed.">                if (fieldofFireUnit instanceof QuadMech) {</span>
<span class="nc bnc" id="L6365" title="All 4 branches missed.">                    if ((fieldofFireWpLoc == Mech.LOC_RARM) || (fieldofFireWpLoc == Mech.LOC_LARM))</span>
<span class="nc" id="L6366">                        fieldofFireWpUnderwater = 1;</span>
                }
<span class="nc bnc" id="L6368" title="All 2 branches missed.">                if (fieldofFireUnit instanceof TripodMech) {</span>
<span class="nc bnc" id="L6369" title="All 2 branches missed.">                    if (fieldofFireWpLoc == Mech.LOC_CLEG)</span>
<span class="nc" id="L6370">                        fieldofFireWpUnderwater = 1;</span>
                }
            } else {
<span class="nc" id="L6373">                fieldofFireWpUnderwater = 1;</span>
            }
        }
<span class="nc" id="L6376">        setWeaponFieldofFire(cmd.getFinalFacing(), cmd.getFinalCoords());</span>
<span class="nc" id="L6377">    }</span>

    // prepares the sprites for a field of fire
    public void setWeaponFieldofFire(int fac, Coords c) {
<span class="nc bnc" id="L6381" title="All 2 branches missed.">        if (fieldofFireUnit == null) {</span>
<span class="nc" id="L6382">            clearFieldofF();</span>
<span class="nc" id="L6383">            return;</span>
        }

        // Do not display anything for offboard units
<span class="nc bnc" id="L6387" title="All 2 branches missed.">        if (fieldofFireUnit.isOffBoard()) {</span>
<span class="nc" id="L6388">            clearFieldofF();</span>
<span class="nc" id="L6389">            return;</span>
        }

        // check if extreme range is used
<span class="nc" id="L6393">        int maxrange = 4;</span>
<span class="nc" id="L6394">        if (game.getOptions().</span>
<span class="nc bnc" id="L6395" title="All 2 branches missed.">                booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_RANGE)) maxrange = 5;</span>

        // create the lists of hexes
<span class="nc" id="L6398">        List&lt;Set&lt;Coords&gt;&gt; fieldFire = new ArrayList&lt;Set&lt;Coords&gt;&gt;(5);</span>
<span class="nc" id="L6399">        int range = 1;</span>
        // for all available range brackets Min/S/M/L/E ...
<span class="nc bnc" id="L6401" title="All 2 branches missed.">        for (int bracket = 0; bracket &lt; maxrange; bracket++) {</span>
<span class="nc" id="L6402">            fieldFire.add(new HashSet&lt;Coords&gt;());</span>
            // Add all hexes up to the weapon range to separate lists
<span class="nc bnc" id="L6404" title="All 2 branches missed.">            while (range &lt;= fieldofFireRanges[fieldofFireWpUnderwater][bracket]) {</span>
<span class="nc" id="L6405">                fieldFire.get(bracket).addAll(c.allAtDistance(range));</span>
<span class="nc" id="L6406">                range++;</span>
<span class="nc bnc" id="L6407" title="All 2 branches missed.">                if (range &gt; 100) break; // only to avoid hangs</span>
            }

            // Remove hexes that are not on the board or not in the arc
<span class="nc bnc" id="L6411" title="All 2 branches missed.">            fieldFire.get(bracket).removeIf(h -&gt; !game.getBoard().contains(h)</span>
<span class="nc bnc" id="L6412" title="All 2 branches missed.">                    || !Compute.isInArc(c, fac, h, fieldofFireWpArc));</span>
        }

        // create the sprites
        //
<span class="nc" id="L6417">        fieldofFireSprites.clear();</span>

        // for all available range brackets Min/S/M/L/E ...
<span class="nc bnc" id="L6420" title="All 2 branches missed.">        for (int bracket = 0; bracket &lt; fieldFire.size(); bracket++) {</span>
<span class="nc bnc" id="L6421" title="All 2 branches missed.">            if (fieldFire.get(bracket) == null) continue;</span>
<span class="nc bnc" id="L6422" title="All 2 branches missed.">            for (Coords loc : fieldFire.get(bracket)) {</span>
                // check surrounding hexes
<span class="nc" id="L6424">                int edgesToPaint = 0;</span>
<span class="nc bnc" id="L6425" title="All 2 branches missed.">                for (int dir = 0; dir &lt; 6; dir++) {</span>
<span class="nc" id="L6426">                    Coords adjacentHex = loc.translated(dir);</span>
<span class="nc bnc" id="L6427" title="All 2 branches missed.">                    if (!fieldFire.get(bracket).contains(adjacentHex)) edgesToPaint += (1 &lt;&lt; dir);</span>
                }
                // create sprite if there's a border to paint
<span class="nc bnc" id="L6430" title="All 2 branches missed.">                if (edgesToPaint &gt; 0) {</span>
<span class="nc" id="L6431">                    FieldofFireSprite ffSprite = new FieldofFireSprite(</span>
                            this, bracket, loc, edgesToPaint);
<span class="nc" id="L6433">                    fieldofFireSprites.add(ffSprite);</span>
                }
<span class="nc" id="L6435">            }</span>
            // Add range markers (m, S, M, L, E)
            // this looks for a hex in the middle of the range bracket;
            // if outside the board, nearer hexes will be tried until
            // the inner edge of the range bracket is reached
            // the directions tested are those that fall between the
            // hex facings because this makes for a better placement
            // ... most of the time...

            // The directions[][] is used to make the marker placement
            // fairly symmetrical to the unit facing which a simple for
            // loop over the hex facings doesn't do
<span class="nc" id="L6447">            int[][] directions = {{0, 1}, {0, 5}, {3, 2}, {3, 4}, {1, 2}, {5, 4}};</span>
            // don't paint too many &quot;min&quot; markers
<span class="nc" id="L6449">            int numMinMarkers = 0;</span>
<span class="nc bnc" id="L6450" title="All 2 branches missed.">            for (int[] dir : directions) {</span>
                // find the middle of the range bracket
<span class="nc" id="L6452">                int rangeend = Math.max(fieldofFireRanges[fieldofFireWpUnderwater][bracket], 0);</span>
<span class="nc" id="L6453">                int rangebegin = 1;</span>
<span class="nc bnc" id="L6454" title="All 2 branches missed.">                if (bracket &gt; 0)</span>
<span class="nc" id="L6455">                    rangebegin = Math.max(fieldofFireRanges[fieldofFireWpUnderwater][bracket - 1] + 1, 1);</span>
<span class="nc" id="L6456">                int dist = (rangeend + rangebegin) / 2;</span>
                // translate to the middle of the range bracket
<span class="nc" id="L6458">                Coords mark = c.translated((dir[0] + fac) % 6, (dist + 1) / 2)</span>
<span class="nc" id="L6459">                        .translated((dir[1] + fac) % 6, dist / 2);</span>
                // traverse back to the unit until a hex is onboard
<span class="nc bnc" id="L6461" title="All 2 branches missed.">                while (!game.getBoard().contains(mark))</span>
<span class="nc" id="L6462">                    mark = Coords.nextHex(mark, c);</span>

                // add a text range marker if the found position is good
<span class="nc bnc" id="L6465" title="All 8 branches missed.">                if (game.getBoard().contains(mark) &amp;&amp; fieldFire.get(bracket).contains(mark)</span>
                        &amp;&amp; ((bracket &gt; 0) || (numMinMarkers &lt; 2))) {
<span class="nc" id="L6467">                    TextMarkerSprite tS = new TextMarkerSprite(this, mark,</span>
                            rangeTexts[bracket], FieldofFireSprite.fieldofFireColors[bracket]);
<span class="nc" id="L6469">                    fieldofFireSprites.add(tS);</span>
<span class="nc bnc" id="L6470" title="All 2 branches missed.">                    if (bracket == 0) numMinMarkers++;</span>
                }
            }
        }

<span class="nc" id="L6475">        repaint();</span>
<span class="nc" id="L6476">    }</span>

    /**
     * Displays a dialog and changes the theme of all
     * board hexes to the user-chosen theme.
     */
    public void changeTheme() {
<span class="nc bnc" id="L6483" title="All 2 branches missed.">        if (game == null) return;</span>
<span class="nc" id="L6484">        IBoard board = game.getBoard();</span>
<span class="nc bnc" id="L6485" title="All 2 branches missed.">        if (board.inSpace()) return;</span>

<span class="nc" id="L6487">        Set&lt;String&gt; themes = tileManager.getThemes();</span>
<span class="nc bnc" id="L6488" title="All 2 branches missed.">        if (themes.remove(&quot;&quot;)) themes.add(&quot;(No Theme)&quot;);</span>
<span class="nc" id="L6489">        themes.add(&quot;(Original Theme)&quot;);</span>

<span class="nc" id="L6491">        setShouldIgnoreKeys(true);</span>
<span class="nc" id="L6492">        selectedTheme = (String) JOptionPane.showInputDialog(</span>
                null,
                &quot;Choose the desired theme:&quot;,
                &quot;Theme Selection&quot;,
                JOptionPane.PLAIN_MESSAGE,
                null,
<span class="nc" id="L6498">                themes.toArray(),</span>
                selectedTheme);
<span class="nc" id="L6500">        setShouldIgnoreKeys(false);</span>

<span class="nc bnc" id="L6502" title="All 2 branches missed.">        if (selectedTheme == null) {</span>
<span class="nc" id="L6503">            return;</span>
<span class="nc bnc" id="L6504" title="All 2 branches missed.">        } else if (selectedTheme.equals(&quot;(Original Theme)&quot;)) {</span>
<span class="nc" id="L6505">            selectedTheme = null;</span>
<span class="nc bnc" id="L6506" title="All 2 branches missed.">        } else if (selectedTheme.equals(&quot;(No Theme)&quot;)) {</span>
<span class="nc" id="L6507">            selectedTheme = &quot;&quot;;</span>
        }

<span class="nc" id="L6510">        board.setTheme(selectedTheme);</span>
<span class="nc" id="L6511">    }</span>

    private Image getBoardBackgroundHexImage(Coords c, IHex hex) {
<span class="nc" id="L6514">        IBoard board = game.getBoard();</span>
<span class="nc bnc" id="L6515" title="All 6 branches missed.">        if ((hex == null) || (board == null) || (hex.getTheme() == null)</span>
<span class="nc bnc" id="L6516" title="All 2 branches missed.">                || !hex.getTheme().equals(HexTileset.TRANSPARENT_THEME)</span>
<span class="nc bnc" id="L6517" title="All 2 branches missed.">                || !board.hasBoardBackground()) {</span>
<span class="nc" id="L6518">            return null;</span>
        }
        // Determine what sub-board the hex came from
<span class="nc" id="L6521">        int boardX = (int) ((c.getX() + 0.0) / board.getSubBoardWidth());</span>
<span class="nc" id="L6522">        int boardY = (int) ((c.getY() + 0.0) / board.getSubBoardHeight());</span>
<span class="nc" id="L6523">        int linIdx = boardY * board.getNumBoardsWidth() + boardX;</span>
<span class="nc bnc" id="L6524" title="All 4 branches missed.">        if (linIdx &lt; 0 || linIdx &gt; boardBackgrounds.size() - 1) {</span>
<span class="nc" id="L6525">            MegaMek.getLogger().error(&quot;Error computing linear index or missing background images in BoardView1.getBoardBackgroundHexImage!&quot;);</span>
<span class="nc" id="L6526">            return null;</span>
        }
<span class="nc" id="L6528">        Image bgImg = getScaledImage(boardBackgrounds.get(linIdx), true);</span>
<span class="nc" id="L6529">        int bgImgWidth = bgImg.getWidth(null);</span>
<span class="nc" id="L6530">        int bgImgHeight = bgImg.getHeight(null);</span>

<span class="nc" id="L6532">        Point p1SRC = getHexLocationLargeTile(</span>
<span class="nc" id="L6533">                c.getX() - (boardX * board.getSubBoardWidth()),</span>
<span class="nc" id="L6534">                c.getY() - (boardY * board.getSubBoardHeight()));</span>
<span class="nc" id="L6535">        p1SRC.x = p1SRC.x % bgImgWidth;</span>
<span class="nc" id="L6536">        p1SRC.y = p1SRC.y % bgImgHeight;</span>
<span class="nc" id="L6537">        Point p2SRC = new Point((int) (p1SRC.x + HEX_W * scale),</span>
                (int) (p1SRC.y + HEX_H * scale));
<span class="nc" id="L6539">        Point p2DST = new Point((int) (HEX_W * scale),</span>
                (int) (HEX_H * scale));

<span class="nc" id="L6542">        Image hexImage = new BufferedImage(HEX_W, HEX_H,</span>
                BufferedImage.TYPE_INT_ARGB);
<span class="nc" id="L6544">        Graphics2D g = (Graphics2D) hexImage.getGraphics();</span>

        // hex mask to limit drawing to the hex shape
        // TODO: this is not ideal yet but at least it draws
        // without leaving gaps at any zoom
<span class="nc" id="L6549">        Image hexMask = getScaledImage(tileManager.getHexMask(), true);</span>
<span class="nc" id="L6550">        g.drawImage(hexMask, 0, 0, this);</span>
<span class="nc" id="L6551">        Composite svComp = g.getComposite();</span>
<span class="nc" id="L6552">        g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_ATOP,</span>
                1f));

        // paint the right slice from the big pic
<span class="nc" id="L6556">        g.drawImage(bgImg, 0, 0, p2DST.x, p2DST.y, p1SRC.x, p1SRC.y,</span>
                p2SRC.x, p2SRC.y, null);

        // Handle wrapping of the image
<span class="nc bnc" id="L6560" title="All 4 branches missed.">        if (p2SRC.x &gt; bgImgWidth &amp;&amp; p2SRC.y &lt;= bgImgHeight) {</span>
<span class="nc" id="L6561">            g.drawImage(bgImg, bgImgWidth - p1SRC.x, 0, p2DST.x,</span>
                    p2DST.y, 0, p1SRC.y, p2SRC.x - bgImgWidth, p2SRC.y,
                    null); // paint addtl slice on the left side
<span class="nc bnc" id="L6564" title="All 4 branches missed.">        } else if (p2SRC.x &lt;= bgImgWidth &amp;&amp; p2SRC.y &gt; bgImgHeight) {</span>
<span class="nc" id="L6565">            g.drawImage(bgImg, 0, bgImgHeight - p1SRC.y, p2DST.x,</span>
                    p2DST.y, p1SRC.x, 0, p2SRC.x, p2SRC.y - bgImgHeight,
                    null); // paint addtl slice on the top
<span class="nc bnc" id="L6568" title="All 4 branches missed.">        } else if (p2SRC.x &gt; bgImgWidth &amp;&amp; p2SRC.y &gt; bgImgHeight) {</span>
<span class="nc" id="L6569">            g.drawImage(bgImg, bgImgWidth - p1SRC.x, 0, p2DST.x,</span>
                    p2DST.y, 0, p1SRC.y, p2SRC.x - bgImgWidth, p2SRC.y,
                    null); // paint addtl slice on the top
<span class="nc" id="L6572">            g.drawImage(bgImg, 0, bgImgHeight - p1SRC.y, p2DST.x,</span>
                    p2DST.y, p1SRC.x, 0, p2SRC.x, p2SRC.y - bgImgHeight,
                    null); // paint addtl slice on the left side
            // paint addtl slice on the top left side
<span class="nc" id="L6576">            g.drawImage(bgImg, bgImgWidth - p1SRC.x,</span>
                    bgImgHeight - p1SRC.y, p2DST.x, p2DST.y, 0, 0,
                    p2SRC.x - bgImgWidth, p2SRC.y - bgImgHeight, null);
        }
<span class="nc" id="L6580">        g.setComposite(svComp);</span>
<span class="nc" id="L6581">        return hexImage;</span>
    }

    public boolean getDisplayInvalidHexInfo() {
<span class="nc" id="L6585">        return displayInvalidHexInfo;</span>
    }

    public void setDisplayInvalidHexInfo(boolean v) {
<span class="nc" id="L6589">        displayInvalidHexInfo = v;</span>
<span class="nc" id="L6590">    }</span>

    public Rectangle getDisplayablesRect() {
<span class="nc" id="L6593">        return displayablesRect;</span>
    }

    public void toggleKeybindsOverlay() {
<span class="nc bnc" id="L6597" title="All 2 branches missed.">        keybindOverlay.setVisible(!keybindOverlay.isVisible());</span>
<span class="nc" id="L6598">        repaint();</span>
<span class="nc" id="L6599">    }</span>

    private class MovingUnit {
        public Entity entity;

        public ArrayList&lt;UnitLocation&gt; path;

<span class="nc" id="L6606">        MovingUnit(Entity entity, Vector&lt;UnitLocation&gt; path) {</span>
<span class="nc" id="L6607">            this.entity = entity;</span>
<span class="nc" id="L6608">            this.path = new ArrayList&lt;UnitLocation&gt;(path);</span>
<span class="nc" id="L6609">        }</span>
    }

    /**
     * the old redrawworker converted to a runnable which is called now and then
     * from the event thread
     */
<span class="fc" id="L6616">    protected class RedrawWorker implements Runnable {</span>

<span class="fc" id="L6618">        protected long lastTime = System.currentTimeMillis();</span>

<span class="fc" id="L6620">        protected long currentTime = System.currentTimeMillis();</span>

        public void run() {
<span class="fc" id="L6623">            currentTime = System.currentTimeMillis();</span>
<span class="pc bpc" id="L6624" title="1 of 2 branches missed.">            if (isShowing()) {</span>
<span class="nc" id="L6625">                boolean redraw = false;</span>
<span class="nc bnc" id="L6626" title="All 2 branches missed.">                for (int i = 0; i &lt; displayables.size(); i++) {</span>
<span class="nc" id="L6627">                    IDisplayable disp = displayables.get(i);</span>
<span class="nc bnc" id="L6628" title="All 2 branches missed.">                    if (!disp.isSliding()) {</span>
<span class="nc" id="L6629">                        disp.setIdleTime(currentTime - lastTime, true);</span>
                    } else {
<span class="nc bnc" id="L6631" title="All 4 branches missed.">                        redraw = redraw || disp.slide();</span>
                    }
                }
<span class="nc bnc" id="L6634" title="All 4 branches missed.">                redraw = redraw || doMoveUnits(currentTime - lastTime);</span>
<span class="nc bnc" id="L6635" title="All 2 branches missed.">                if (redraw) {</span>
<span class="nc" id="L6636">                    repaint();</span>
                }
<span class="nc" id="L6638">                centerOnHexSoftStep(currentTime - lastTime);</span>
            }
<span class="fc" id="L6640">            lastTime = currentTime;</span>
<span class="fc" id="L6641">        }</span>
    }

<span class="fc" id="L6644">    private class BoardViewMouseMotionAdapter extends MouseMotionAdapter {</span>
        @Override
        public void mouseMoved(MouseEvent e) {
<span class="nc" id="L6647">            Point point = e.getPoint();</span>

<span class="nc bnc" id="L6649" title="All 2 branches missed.">            for (IDisplayable disp : displayables) {</span>
<span class="nc bnc" id="L6650" title="All 2 branches missed.">                if (disp.isBeingDragged()) {</span>
<span class="nc" id="L6651">                    return;</span>
                }
<span class="nc" id="L6653">                double width = Math.min(boardSize.getWidth(), scrollpane</span>
<span class="nc" id="L6654">                        .getViewport().getSize().getWidth());</span>
<span class="nc" id="L6655">                double height = Math.min(boardSize.getHeight(), scrollpane</span>
<span class="nc" id="L6656">                        .getViewport().getSize().getHeight());</span>
<span class="nc" id="L6657">                Dimension drawDimension = new Dimension();</span>
<span class="nc" id="L6658">                drawDimension.setSize(width, height);</span>
<span class="nc" id="L6659">                disp.isMouseOver(point, drawDimension);</span>
<span class="nc" id="L6660">            }</span>
<span class="nc" id="L6661">        }</span>

        @Override
        public void mouseDragged(MouseEvent e) {
<span class="nc" id="L6665">            Point point = e.getPoint();</span>

<span class="nc bnc" id="L6667" title="All 2 branches missed.">            for (IDisplayable disp : displayables) {</span>
<span class="nc" id="L6668">                Point adjustPoint = new Point((int) Math.min(</span>
<span class="nc" id="L6669">                        boardSize.getWidth(), -getBounds().getX()),</span>
<span class="nc" id="L6670">                        (int) Math.min(boardSize.getHeight(), -getBounds()</span>
<span class="nc" id="L6671">                                .getY()));</span>
<span class="nc" id="L6672">                Point dispPoint = new Point();</span>
<span class="nc" id="L6673">                dispPoint.x = point.x - adjustPoint.x;</span>
<span class="nc" id="L6674">                dispPoint.y = point.y - adjustPoint.y;</span>
<span class="nc" id="L6675">                double width = Math.min(boardSize.getWidth(), scrollpane</span>
<span class="nc" id="L6676">                        .getViewport().getSize().getWidth());</span>
<span class="nc" id="L6677">                double height = Math.min(boardSize.getHeight(), scrollpane</span>
<span class="nc" id="L6678">                        .getViewport().getSize().getHeight());</span>
<span class="nc" id="L6679">                Dimension drawDimension = new Dimension();</span>
<span class="nc" id="L6680">                drawDimension.setSize(width, height);</span>
<span class="nc bnc" id="L6681" title="All 2 branches missed.">                if (disp.isDragged(dispPoint, drawDimension)) {</span>
<span class="nc" id="L6682">                    repaint();</span>
<span class="nc" id="L6683">                    return;</span>
                }
<span class="nc" id="L6685">            }</span>
            // only scroll when we should
<span class="nc bnc" id="L6687" title="All 2 branches missed.">            if (!shouldScroll) {</span>
<span class="nc" id="L6688">                mouseAction(getCoordsAt(point), BOARD_HEX_DRAG,</span>
<span class="nc" id="L6689">                        e.getModifiers());</span>
<span class="nc" id="L6690">                return;</span>
            }
            // if we have not yet been dragging, set the var so popups don't
            // appear when we stop scrolling
<span class="nc bnc" id="L6694" title="All 2 branches missed.">            if (!dragging) {</span>
<span class="nc" id="L6695">                dragging = true;</span>
<span class="nc" id="L6696">                setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));</span>
            }
<span class="nc" id="L6698">            Point p = scrollpane.getViewport().getViewPosition();</span>
<span class="nc" id="L6699">            int newX = p.x - (e.getX() - scrollXDifference);</span>
<span class="nc" id="L6700">            int newY = p.y - (e.getY() - scrollYDifference);</span>
<span class="nc" id="L6701">            int maxX = getWidth() - scrollpane.getViewport().getWidth();</span>
<span class="nc" id="L6702">            int maxY = getHeight() - scrollpane.getViewport().getHeight();</span>
<span class="nc bnc" id="L6703" title="All 2 branches missed.">            if (newX &lt; 0) {</span>
<span class="nc" id="L6704">                newX = 0;</span>
            }
<span class="nc bnc" id="L6706" title="All 2 branches missed.">            if (newX &gt; maxX) {</span>
<span class="nc" id="L6707">                newX = maxX;</span>
            }
<span class="nc bnc" id="L6709" title="All 2 branches missed.">            if (newY &lt; 0) {</span>
<span class="nc" id="L6710">                newY = 0;</span>
            }
<span class="nc bnc" id="L6712" title="All 2 branches missed.">            if (newY &gt; maxY) {</span>
<span class="nc" id="L6713">                newY = maxY;</span>
            }
            // don't scroll horizontally if the board fits into the window
<span class="nc bnc" id="L6716" title="All 2 branches missed.">            if (scrollpane.getViewport().getWidth() &gt;= getWidth()) {</span>
<span class="nc" id="L6717">                newX = scrollpane.getViewport().getViewPosition().x;</span>
            }
<span class="nc" id="L6719">            scrollpane.getViewport().setViewPosition(new Point(newX, newY));</span>
<span class="nc" id="L6720">        }</span>
    }

<span class="fc" id="L6723">    private class BoardViewMouseWheelListener implements MouseWheelListener {</span>
        public void mouseWheelMoved(MouseWheelEvent we) {
<span class="nc" id="L6725">            Point mousePoint = we.getPoint();</span>
<span class="nc" id="L6726">            Point dispPoint = new Point(mousePoint.x + getBounds().x, mousePoint.y + getBounds().y);</span>

            // If the mouse is over an IDisplayable, have it react instead of the board
            // Currently only implemented for the ChatterBox
<span class="nc bnc" id="L6730" title="All 2 branches missed.">            for (IDisplayable disp : displayables) {</span>
<span class="nc bnc" id="L6731" title="All 2 branches missed.">                if (!(disp instanceof ChatterBox2)) {</span>
<span class="nc" id="L6732">                    continue;</span>
                }
<span class="nc" id="L6734">                double width = scrollpane.getViewport().getSize().getWidth();</span>
<span class="nc" id="L6735">                double height = scrollpane.getViewport().getSize().getHeight();</span>
<span class="nc" id="L6736">                Dimension drawDimension = new Dimension();</span>
<span class="nc" id="L6737">                drawDimension.setSize(width, height);</span>
                // we need to adjust the point, because it should be against
                // the displayable dimension
<span class="nc bnc" id="L6740" title="All 2 branches missed.">                if (disp.isMouseOver(dispPoint, drawDimension)) {</span>
<span class="nc" id="L6741">                    ChatterBox2 cb2 = (ChatterBox2) disp;</span>
<span class="nc bnc" id="L6742" title="All 2 branches missed.">                    if (we.getWheelRotation() &gt; 0) {</span>
<span class="nc" id="L6743">                        cb2.scrollDown();</span>
                    } else {
<span class="nc" id="L6745">                        cb2.scrollUp();</span>
                    }
<span class="nc" id="L6747">                    refreshDisplayables();</span>
<span class="nc" id="L6748">                    return;</span>
                }
<span class="nc" id="L6750">            }</span>

            // calculate a few things to reposition the map
<span class="nc" id="L6753">            Coords zoomCenter = getCoordsAt(we.getPoint());</span>
<span class="nc" id="L6754">            Point hexL = getCentreHexLocation(zoomCenter);</span>
<span class="nc" id="L6755">            Point inhexDelta = new Point(we.getPoint());</span>
<span class="nc" id="L6756">            inhexDelta.translate(-HEX_W, -HEX_H);</span>
<span class="nc" id="L6757">            inhexDelta.translate(-hexL.x, -hexL.y);</span>
<span class="nc" id="L6758">            double ihdx = ((double) inhexDelta.x) / ((double) HEX_W) / scale;</span>
<span class="nc" id="L6759">            double ihdy = ((double) inhexDelta.y) / ((double) HEX_H) / scale;</span>
<span class="nc" id="L6760">            int oldzoomIndex = zoomIndex;</span>

<span class="nc" id="L6762">            boolean ZoomNoCtrl = GUIPreferences.getInstance().getMouseWheelZoom();</span>
<span class="nc" id="L6763">            boolean wheelFlip = GUIPreferences.getInstance().getMouseWheelZoomFlip();</span>
<span class="nc bnc" id="L6764" title="All 2 branches missed.">            boolean zoomIn = (we.getWheelRotation() &gt; 0) ^ wheelFlip; // = XOR</span>
<span class="nc" id="L6765">            boolean doZoom = ZoomNoCtrl ^ we.isControlDown(); // = XOR</span>
<span class="nc bnc" id="L6766" title="All 4 branches missed.">            boolean horizontalScroll = !doZoom &amp;&amp; we.isShiftDown();</span>

<span class="nc bnc" id="L6768" title="All 2 branches missed.">            if (doZoom) {</span>
<span class="nc bnc" id="L6769" title="All 2 branches missed.">                if (zoomIn) {</span>
<span class="nc" id="L6770">                    zoomIn();</span>
                } else {
<span class="nc" id="L6772">                    zoomOut();</span>
                }
<span class="nc bnc" id="L6774" title="All 2 branches missed.">                if (zoomIndex != oldzoomIndex) {</span>
<span class="nc" id="L6775">                    adjustVisiblePosition(zoomCenter, dispPoint, ihdx, ihdy);</span>
                }
            } else { // SCROLL
<span class="nc bnc" id="L6778" title="All 2 branches missed.">                if (horizontalScroll) {</span>
<span class="nc" id="L6779">                    hbar.setValue((int) (hbar.getValue() + (HEX_H * scale * (we.getWheelRotation()))));</span>
                } else {
<span class="nc" id="L6781">                    vbar.setValue((int) (vbar.getValue() + (HEX_H * scale * (we.getWheelRotation()))));</span>
                }
<span class="nc" id="L6783">                stopSoftCentering();</span>
            }

<span class="nc" id="L6786">            pingMinimap();</span>
<span class="nc" id="L6787">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.4.201905082037</span></div></body></html>