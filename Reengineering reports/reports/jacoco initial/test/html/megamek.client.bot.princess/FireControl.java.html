<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FireControl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">megamek</a> &gt; <a href="index.source.html" class="el_package">megamek.client.bot.princess</a> &gt; <span class="el_source">FireControl.java</span></div><h1>FireControl.java</h1><pre class="source lang-java linenums">/*
 * MegaMek - Copyright (C) 2000-2011 Ben Mazur (bmazur@sev.org)
 *
 *  This program is free software; you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by the Free
 *  Software Foundation; either version 2 of the License, or (at your option)
 *  any later version.
 *
 *  This program is distributed in the hope that it will be useful, but
 *  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 *  for more details.
 */
package megamek.client.bot.princess;

import java.text.DecimalFormat;
import java.text.NumberFormat;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Vector;

import megamek.common.AmmoType;
import megamek.common.BattleArmor;
import megamek.common.BombType;
import megamek.common.BuildingTarget;
import megamek.common.Compute;
import megamek.common.Coords;
import megamek.common.Dropship;
import megamek.common.Entity;
import megamek.common.EntityMovementType;
import megamek.common.EntityWeightClass;
import megamek.common.EquipmentType;
import megamek.common.FixedWingSupport;
import megamek.common.GunEmplacement;
import megamek.common.HexTarget;
import megamek.common.IAero;
import megamek.common.IGame;
import megamek.common.IHex;
import megamek.common.ILocationExposureStatus;
import megamek.common.INarcPod;
import megamek.common.IPlayer;
import megamek.common.Infantry;
import megamek.common.LargeSupportTank;
import megamek.common.LosEffects;
import megamek.common.Mech;
import megamek.common.MechWarrior;
import megamek.common.Mounted;
import megamek.common.MovePath;
import megamek.common.MoveStep;
import megamek.common.Protomech;
import megamek.common.RangeType;
import megamek.common.Tank;
import megamek.common.TargetRoll;
import megamek.common.TargetRollModifier;
import megamek.common.Targetable;
import megamek.common.Terrains;
import megamek.common.ToHitData;
import megamek.common.VTOL;
import megamek.common.WeaponType;
import megamek.common.actions.EntityAction;
import megamek.common.actions.FindClubAction;
import megamek.common.actions.RepairWeaponMalfunctionAction;
import megamek.common.actions.SearchlightAttackAction;
import megamek.common.actions.SpotAction;
import megamek.common.actions.UnjamTurretAction;
import megamek.common.actions.WeaponAttackAction;
import megamek.common.annotations.Nullable;
import megamek.common.annotations.StaticWrapper;
import megamek.common.logging.LogLevel;
import megamek.common.options.OptionsConstants;
import megamek.common.pathfinder.AeroGroundPathFinder;
import megamek.common.weapons.StopSwarmAttack;
import megamek.common.weapons.Weapon;
import megamek.common.weapons.infantry.InfantryWeapon;
import megamek.common.weapons.missiles.ATMWeapon;
import megamek.common.weapons.missiles.MMLWeapon;

/**
 * FireControl selects which weapons a unit wants to fire and at whom Pay
 * attention to the difference between &quot;guess&quot; and &quot;get&quot;. Guess will be much
 * faster, but inaccurate
 */
public class FireControl {

    protected static final double DAMAGE_UTILITY = 1.0;
    protected static final double CRITICAL_UTILITY = 10.0;
    protected static final double KILL_UTILITY = 50.0;
    protected static final double OVERHEAT_DISUTILITY = 5.0;
    protected static final double OVERHEAT_DISUTILITY_AERO = 50.0; // Aeros *really* don't want to overheat.
    protected static final double EJECTED_PILOT_DISUTILITY = 1000.0;
    protected static final double CIVILIAN_TARGET_DISUTILITY = 250.0;
    protected static final double TARGET_HP_FRACTION_DEALT_UTILITY = -30.0;

    private static final double TARGET_POTENTIAL_DAMAGE_UTILITY = 1.0;
    static final double COMMANDER_UTILITY = 0.5;
    static final double SUB_COMMANDER_UTILITY = 0.25;
    static final double STRATEGIC_TARGET_UTILITY = 0.5;
    static final double PRIORITY_TARGET_UTILITY = 0.25;

    static final String TH_WOODS = &quot;woods&quot;;
    static final String TH_SMOKE = &quot;smoke&quot;;
    static final String TH_PHY_BASE = &quot;base&quot;;
    static final String TH_GUNNERY = &quot;gunnery skill&quot;;
    static final String TH_SENSORS = &quot;attacker sensors damaged&quot;;
    static final String TH_MINIMUM_RANGE = &quot;Minimum Range&quot;;
    static final String TH_HEAT = &quot;heat&quot;;
    static final String TH_WEAPON_MOD = &quot;weapon to-hit&quot;;
    static final String TH_AMMO_MOD = &quot;ammunition to-hit modifier&quot;;
<span class="fc" id="L114">    static final TargetRollModifier TH_ATT_PRONE = new TargetRollModifier(2, &quot;attacker prone&quot;);</span>
<span class="fc" id="L115">    static final TargetRollModifier TH_TAR_IMMOBILE = new TargetRollModifier(-4, &quot;target immobile&quot;);</span>
<span class="fc" id="L116">    static final TargetRollModifier TH_TAR_SKID = new TargetRollModifier(2, &quot;target skidded&quot;);</span>
<span class="fc" id="L117">    static final TargetRollModifier TH_TAR_NO_MOVE = new TargetRollModifier(1, &quot;target didn't move&quot;);</span>
<span class="fc" id="L118">    static final TargetRollModifier TH_TAR_SPRINT = new TargetRollModifier(-1, &quot;target sprinted&quot;);</span>
<span class="fc" id="L119">    static final TargetRollModifier TH_TAR_AERO_NOE_ADJ = new TargetRollModifier(1,</span>
                                                                                           &quot;NOE aero adjacent flight &quot; +
                                                                                           &quot;path&quot;);
<span class="fc" id="L122">    static final TargetRollModifier TH_TAR_AERO_NOE = new TargetRollModifier(3,</span>
                                                                                       &quot;NOE aero non-adjacent flight &quot; +
                                                                                       &quot;path&quot;);
<span class="fc" id="L125">    static final TargetRollModifier TH_TAR_PRONE_RANGE = new TargetRollModifier(1,</span>
                                                                                &quot;target prone and at range&quot;);
<span class="fc" id="L127">    static final TargetRollModifier TH_TAR_PRONE_ADJ = new TargetRollModifier(-2,</span>
                                                                              &quot;target prone and adjacent&quot;);
<span class="fc" id="L129">    static final TargetRollModifier TH_TAR_BA = new TargetRollModifier(1, &quot;battle armor target&quot;);</span>
<span class="fc" id="L130">    static final TargetRollModifier TH_TAR_MW = new TargetRollModifier(2, &quot;ejected mechwarrior target&quot;);</span>
<span class="fc" id="L131">    static final TargetRollModifier TH_TAR_INF = new TargetRollModifier(1, &quot;infantry target&quot;);</span>
<span class="fc" id="L132">    static final TargetRollModifier TH_ANTI_AIR = new TargetRollModifier(-2, &quot;anti-aircraft quirk&quot;);</span>
<span class="fc" id="L133">    static final TargetRollModifier TH_INDUSTRIAL =</span>
            new TargetRollModifier(1, &quot;industrial cockpit without advanced fire control&quot;);
<span class="fc" id="L135">    static final TargetRollModifier TH_PRIMATIVE_INDUSTRIAL =</span>
            new TargetRollModifier(2, &quot;primitive industrial cockpit without advanced fire control&quot;);
<span class="fc" id="L137">    static final TargetRollModifier TH_TAR_SUPER = new TargetRollModifier(-1, &quot;superheavy target&quot;);</span>
<span class="fc" id="L138">    static final TargetRollModifier TH_TAR_GROUND_DS = new TargetRollModifier(-4, &quot;grounded dropship target&quot;);</span>
<span class="fc" id="L139">    static final TargetRollModifier TH_TAR_LOW_PROFILE = new TargetRollModifier(1,</span>
                                                                                          &quot;narrow/low profile target&quot;);
<span class="fc" id="L141">    static final TargetRollModifier TH_PHY_NOT_MECH =</span>
            new TargetRollModifier(TargetRoll.IMPOSSIBLE, &quot;non-mechs don't make physical attacks&quot;);
<span class="fc" id="L143">    static final TargetRollModifier TH_PHY_TOO_FAR = new TargetRollModifier(TargetRoll.IMPOSSIBLE,</span>
                                                                            &quot;target not adjacent&quot;);
<span class="fc" id="L145">    static final TargetRollModifier TH_NULL_POSITION = new TargetRollModifier(TargetRoll.AUTOMATIC_FAIL,</span>
                                                                              &quot;null position&quot;);
<span class="fc" id="L147">    static final TargetRollModifier TH_RNG_TOO_FAR = new TargetRollModifier(TargetRoll.IMPOSSIBLE,</span>
                                                                            &quot;target beyond max range&quot;);
<span class="fc" id="L149">    static final TargetRollModifier TH_PHY_NOT_IN_ARC = new TargetRollModifier(TargetRoll.IMPOSSIBLE,</span>
                                                                               &quot;target not in arc&quot;);
<span class="fc" id="L151">    static final TargetRollModifier TH_PHY_TOO_MUCH_ELEVATION =</span>
            new TargetRollModifier(TargetRoll.IMPOSSIBLE, &quot;target elevation not in range&quot;);
<span class="fc" id="L153">    static final TargetRollModifier TH_PHY_P_TAR_PRONE = new TargetRollModifier(TargetRoll.IMPOSSIBLE,</span>
                                                                                &quot;can't punch while prone&quot;);
<span class="fc" id="L155">    static final TargetRollModifier TH_PHY_P_TAR_INF = new TargetRollModifier(TargetRoll.IMPOSSIBLE,</span>
                                                                              &quot;can't punch infantry&quot;);
<span class="fc" id="L157">    static final TargetRollModifier TH_PHY_P_NO_ARM = new TargetRollModifier(TargetRoll.IMPOSSIBLE,</span>
                                                                             &quot;Your arm's off!&quot;);
<span class="fc" id="L159">    static final TargetRollModifier TH_PHY_P_NO_SHOULDER = new TargetRollModifier(TargetRoll.IMPOSSIBLE,</span>
                                                                                  &quot;shoulder destroyed&quot;);
<span class="fc" id="L161">    static final TargetRollModifier TH_PHY_P_UPPER_ARM = new TargetRollModifier(2,</span>
                                                                                          &quot;upper arm actuator &quot; +
                                                                                          &quot;destroyed&quot;);
<span class="fc" id="L164">    static final TargetRollModifier TH_PHY_P_LOWER_ARM = new TargetRollModifier(2,</span>
                                                                                          &quot;lower arm actuator missing&quot; +
                                                                                          &quot; or destroyed&quot;);
<span class="fc" id="L167">    static final TargetRollModifier TH_PHY_P_HAND = new TargetRollModifier(1,</span>
                                                                                     &quot;hand actuator missing or &quot; +
                                                                                     &quot;destroyed&quot;);
<span class="fc" id="L170">    static final TargetRollModifier TH_PHY_K_PRONE = new TargetRollModifier(TargetRoll.IMPOSSIBLE,</span>
                                                                            &quot;can't kick while prone&quot;);
<span class="fc" id="L172">    static final TargetRollModifier TH_PHY_K_INF = new TargetRollModifier(3, &quot;kicking infantry&quot;);</span>
<span class="fc" id="L173">    static final TargetRollModifier TH_PHY_K_INF_RNG = new TargetRollModifier(TargetRoll.IMPOSSIBLE,</span>
                                                                                        &quot;Infantry too far away&quot;);
<span class="fc" id="L175">    static final TargetRollModifier TH_PHY_K_HIP = new TargetRollModifier(TargetRoll.IMPOSSIBLE,</span>
                                                                          &quot;can't kick with broken hip&quot;);
<span class="fc" id="L177">    static final TargetRollModifier TH_PHY_K_UPPER_LEG = new TargetRollModifier(2,</span>
                                                                                          &quot;upper leg actuator &quot; +
                                                                                          &quot;destroyed&quot;);
<span class="fc" id="L180">    static final TargetRollModifier TH_PHY_K_LOWER_LEG = new TargetRollModifier(2,</span>
                                                                                          &quot;lower leg actuator &quot; +
                                                                                          &quot;destroyed&quot;);
<span class="fc" id="L183">    static final TargetRollModifier TH_PHY_K_FOOT = new TargetRollModifier(1, &quot;foot actuator destroyed&quot;);</span>
<span class="fc" id="L184">    static final TargetRollModifier TH_PHY_LIGHT = new TargetRollModifier(-2, &quot;weight class attack modifier&quot;);</span>
<span class="fc" id="L185">    static final TargetRollModifier TH_PHY_MEDIUM = new TargetRollModifier(-1,</span>
                                                                                     &quot;weight class attack modifier&quot;);
<span class="fc" id="L187">    static final TargetRollModifier TH_PHY_SUPER = new TargetRollModifier(1, &quot;superheavy attacker&quot;);</span>
<span class="fc" id="L188">    static final TargetRollModifier TH_PHY_EASY_PILOT = new TargetRollModifier(-1, &quot;easy to pilot quirk&quot;);</span>
<span class="fc" id="L189">    static final TargetRollModifier TH_PHY_P_NO_ARMS_QUIRK = new TargetRollModifier(TargetRoll.IMPOSSIBLE,</span>
                                                                                              &quot;no/minimal arms quirk&quot;);
<span class="fc" id="L191">    static final TargetRollModifier TH_WEAP_CANNOT_FIRE = new TargetRollModifier(TargetRoll.IMPOSSIBLE,</span>
                                                                                 &quot;weapon cannot fire&quot;);
<span class="fc" id="L193">    static final TargetRollModifier TH_WEAP_NO_AMMO = new TargetRollModifier(TargetRoll.IMPOSSIBLE,</span>
                                                                             &quot;ammo is gone&quot;);
<span class="fc" id="L195">    static final TargetRollModifier TH_WEAP_PRONE_ARMLESS =</span>
            new TargetRollModifier(TargetRoll.IMPOSSIBLE, &quot;prone and missing an arm&quot;);
<span class="fc" id="L197">    static final TargetRollModifier TH_WEAP_ARM_PROP = new TargetRollModifier(TargetRoll.IMPOSSIBLE,</span>
                                                                              &quot;using arm as prop&quot;);
<span class="fc" id="L199">    static final TargetRollModifier TH_WEAP_PRONE_LEG = new TargetRollModifier(TargetRoll.IMPOSSIBLE,</span>
                                                                               &quot;prone leg weapon&quot;);
<span class="fc" id="L201">    static final TargetRollModifier TH_WEAPON_NO_ARC = new TargetRollModifier(TargetRoll.IMPOSSIBLE,</span>
                                                                              &quot;not in arc&quot;);
<span class="fc" id="L203">    static final TargetRollModifier TH_INF_ZERO_RNG =</span>
            new TargetRollModifier(TargetRoll.AUTOMATIC_FAIL, &quot;noninfantry shooting with zero range&quot;);
<span class="fc" id="L205">    static final TargetRollModifier TH_STOP_SWARM_INVALID = new TargetRollModifier(TargetRoll.IMPOSSIBLE,</span>
                                                                                   &quot;not swarming a Mek&quot;);
<span class="fc" id="L207">    static final TargetRollModifier TH_SWARM_STOPPED = new TargetRollModifier(TargetRoll.AUTOMATIC_SUCCESS,</span>
                                                                              &quot;stops swarming&quot;);
<span class="fc" id="L209">    static final TargetRollModifier TH_OUT_OF_RANGE = new TargetRollModifier(TargetRoll.IMPOSSIBLE,</span>
                                                                             &quot;out of range&quot;);
<span class="fc" id="L211">    static final TargetRollModifier TH_SHORT_RANGE = new TargetRollModifier(0, &quot;Short Range&quot;);</span>
<span class="fc" id="L212">    static final TargetRollModifier TH_MEDIUM_RANGE = new TargetRollModifier(2, &quot;Medium Range&quot;);</span>
<span class="fc" id="L213">    static final TargetRollModifier TH_LONG_RANGE = new TargetRollModifier(4, &quot;Long Range&quot;);</span>
<span class="fc" id="L214">    static final TargetRollModifier TH_EXTREME_RANGE = new TargetRollModifier(6, &quot;Extreme Range&quot;);</span>
<span class="fc" id="L215">    static final TargetRollModifier TH_TARGETTING_COMP = new TargetRollModifier(-1, &quot;targeting computer&quot;);</span>
<span class="fc" id="L216">    static final TargetRollModifier TH_IMP_TARG_SHORT =</span>
            new TargetRollModifier(-1, &quot;improved targetting (short) quirk&quot;);
<span class="fc" id="L218">    static final TargetRollModifier TH_IMP_TARG_MEDIUM =</span>
            new TargetRollModifier(-1, &quot;improved targetting (medium) quirk&quot;);
<span class="fc" id="L220">    static final TargetRollModifier TH_IMP_TARG_LONG =</span>
            new TargetRollModifier(-1, &quot;improved targetting (long) quirk&quot;);
<span class="fc" id="L222">    static final TargetRollModifier TH_VAR_RNG_TARG_SHORT_AT_SHORT =</span>
            new TargetRollModifier(-1, &quot;variable range targetting (short) quirk&quot;);
<span class="fc" id="L224">    static final TargetRollModifier TH_VAR_RNG_TARG_SHORT_AT_LONG =</span>
            new TargetRollModifier(1, &quot;variable range targetting (short) quirk&quot;);
<span class="fc" id="L226">    static final TargetRollModifier TH_VAR_RNG_TARG_LONG_AT_LONG =</span>
            new TargetRollModifier(-1, &quot;variable range targetting (long) quirk&quot;);
<span class="fc" id="L228">    static final TargetRollModifier TH_VAR_RNG_TARG_LONG_AT_SHORT =</span>
            new TargetRollModifier(1, &quot;variable range targetting (long) quirk&quot;);
<span class="fc" id="L230">    static final TargetRollModifier TH_POOR_TARG_SHORT =</span>
            new TargetRollModifier(1, &quot;poor targetting (short) quirk&quot;);
<span class="fc" id="L232">    static final TargetRollModifier TH_POOR_TARG_MEDIUM =</span>
            new TargetRollModifier(1, &quot;poor targetting (medium) quirk&quot;);
<span class="fc" id="L234">    static final TargetRollModifier TH_POOR_TARG_LONG =</span>
            new TargetRollModifier(1, &quot;poor targetting (long) quirk&quot;);
<span class="fc" id="L236">    static final TargetRollModifier TH_ACCURATE_WEAP =</span>
            new TargetRollModifier(-1, &quot;accurate weapon quirk&quot;);
<span class="fc" id="L238">    static final TargetRollModifier TH_INACCURATE_WEAP =</span>
            new TargetRollModifier(1, &quot;inaccurate weapon quirk&quot;);
<span class="fc" id="L240">    static final TargetRollModifier TH_RNG_LARGE =</span>
            new TargetRollModifier(-1, &quot;target large vehicle or superheavy mech&quot;);
<span class="fc" id="L242">    static final TargetRollModifier TH_AIR_STRIKE_PATH =</span>
            new TargetRollModifier(TargetRoll.IMPOSSIBLE, &quot;target not under flight path&quot;);
<span class="fc" id="L244">    static final TargetRollModifier TH_AIR_STRIKE = new TargetRollModifier(2, &quot;strike attack&quot;);</span>
<span class="fc" id="L245">    private static final TargetRollModifier TH_STABLE_WEAP =</span>
            new TargetRollModifier(1, &quot;stabilized weapon quirk&quot;);
<span class="fc" id="L247">    private static final TargetRollModifier TH_PHY_LARGE = new TargetRollModifier(-2, &quot;target large vehicle&quot;);</span>

    /**
     * The possible fire control types.
     * If you're adding a new one, add it here then make sure to add it to Princess.InitializeFireControls
     */
<span class="fc" id="L253">    public enum FireControlType {</span>
<span class="fc" id="L254">        Basic, </span>
<span class="fc" id="L255">        Infantry,</span>
<span class="fc" id="L256">        MultiTarget</span>
    }
    
    protected final Princess owner;

    /**
     * Constructor
     *
     * @param owningPrincess The {@link Princess} bot that utilizes this this class for computing firing solutions.
     */
<span class="fc" id="L266">    public FireControl(final Princess owningPrincess) {</span>
<span class="fc" id="L267">        owner = owningPrincess;</span>
<span class="fc" id="L268">    }</span>

    /**
     * Returns the movement modifier calculated by {@link Compute#getAttackerMovementModifier(IGame, int,
     * EntityMovementType)}.
     *
     * @param game            The {@link IGame} being played.
     * @param shooterId       The ID of the unit doing the shooting.
     * @param shooterMoveType The {@link EntityMovementType} of the unit doing the shooting.
     * @return The attacker movement modifier as a {@link ToHitData} object.
     */
    @StaticWrapper()
    protected ToHitData getAttackerMovementModifier(final IGame game,
                                                    final int shooterId,
                                                    final EntityMovementType shooterMoveType) {
<span class="nc" id="L283">        return Compute.getAttackerMovementModifier(game, shooterId, shooterMoveType);</span>
    }

    /**
     * Returns the {@link Coords} computed by 
     * {@link Compute#getClosestFlightPath(int, Coords, Entity)}.
     *
     * @param shooterPosition The shooter's position.
     * @param targetAero      The aero unit being attacked.
     * @return The {@link Coords} from the target's flight path closest to the shooter.
     */
    @StaticWrapper
    Coords getNearestPointInFlightPath(final Coords shooterPosition,
                                       final IAero targetAero) {
<span class="nc" id="L297">        return Compute.getClosestFlightPath(-1, shooterPosition, (Entity)targetAero);</span>
    }

    /**
     * Returns the movement modifier calculated by {@link Compute#getTargetMovementModifier(int, boolean, boolean,
     * IGame)}
     *
     * @param hexesMoved The number of hexes the target unit moved.
     * @param jumping    Set TRUE if the target jumped.
     * @param vtol       Set TRUE if the target is a {@link VTOL}.
     * @param game       The {@link IGame} being played.
     * @return The target movement modifier as a {@link ToHitData} object.
     */
    @StaticWrapper()
    protected ToHitData getTargetMovementModifier(final int hexesMoved,
                                                  final boolean jumping,
                                                  final boolean vtol,
                                                  final IGame game) {
<span class="nc" id="L315">        return Compute.getTargetMovementModifier(hexesMoved, jumping, vtol, game);</span>
    }

    /**
     * Gets the toHit modifier common to both weapon and physical attacks
     *
     * @param shooter      The unit doing the shooting.
     * @param shooterState The state of the unit doing the shooting.
     * @param target       Who is being shot at.
     * @param targetState  The state of the target.
     * @param distance     Distance between shooter and target.
     * @param game         The game being played.  @return The estimated to hit modifiers.
     */
    ToHitData guessToHitModifierHelperForAnyAttack(final Entity shooter,
                                                   @Nullable EntityState shooterState,
                                                   final Targetable target,
                                                   @Nullable EntityState targetState,
                                                   final int distance,
                                                   final IGame game) {

<span class="pc bpc" id="L335" title="1 of 2 branches missed.">        if (null == shooterState) {</span>
<span class="nc" id="L336">            shooterState = new EntityState(shooter);</span>
        }
<span class="pc bpc" id="L338" title="1 of 2 branches missed.">        if (null == targetState) {</span>
<span class="nc" id="L339">            targetState = new EntityState(target);</span>
        }

        // Can't shoot if one of us is not on the board.
        // todo exception for off-board artillery.
<span class="fc bfc" id="L344" title="All 4 branches covered.">        if ((null == shooterState.getPosition()) || (null == targetState.getPosition())) {</span>
<span class="fc" id="L345">            return new ToHitData(TH_NULL_POSITION);</span>
        }

        // Is the target in range at all?
<span class="fc" id="L349">        final int maxRange = owner.getMaxWeaponRange(shooter, target.isAirborne());</span>
<span class="fc bfc" id="L350" title="All 2 branches covered.">        if (distance &gt; maxRange) {</span>
<span class="fc" id="L351">            return new ToHitData(TH_RNG_TOO_FAR);</span>
        }

<span class="fc" id="L354">        final ToHitData toHitData = new ToHitData();</span>

        // If people are moving or lying down, there are consequences
<span class="fc" id="L357">        toHitData.append(getAttackerMovementModifier(game, shooter.getId(), shooterState.getMovementType()));</span>

        // Ground units attacking airborne aeros.
<span class="pc bpc" id="L360" title="1 of 4 branches missed.">        if (!shooterState.isAero() &amp;&amp; targetState.isAirborneAero()) {</span>
<span class="fc" id="L361">            final IAero targetAero = (IAero) target;</span>
<span class="pc bpc" id="L362" title="1 of 2 branches missed.">            if (((Entity)targetAero).isNOE()) {</span>
<span class="fc" id="L363">                final Coords closestInFlightPath = getNearestPointInFlightPath(shooterState.getPosition(), targetAero);</span>
<span class="fc" id="L364">                final int aeroDistance = closestInFlightPath.distance(shooterState.getPosition());</span>
<span class="fc bfc" id="L365" title="All 2 branches covered.">                if (1 &gt;= aeroDistance) {</span>
<span class="fc" id="L366">                    toHitData.addModifier(TH_TAR_AERO_NOE_ADJ);</span>
                } else {
<span class="fc" id="L368">                    toHitData.addModifier(TH_TAR_AERO_NOE);</span>
                }
            }
<span class="fc" id="L371">        } else {</span>
<span class="fc" id="L372">            toHitData.append(getTargetMovementModifier(targetState.getHexesMoved(), targetState.isJumping(),</span>
                                                       target instanceof VTOL, game));
        }
<span class="fc bfc" id="L375" title="All 2 branches covered.">        if (shooterState.isProne()) {</span>
<span class="fc" id="L376">            toHitData.addModifier(TH_ATT_PRONE);</span>
        }
<span class="pc bpc" id="L378" title="1 of 4 branches missed.">        if (targetState.isImmobile() &amp;&amp; !target.isHexBeingBombed()) {</span>
<span class="fc" id="L379">            toHitData.addModifier(TH_TAR_IMMOBILE);</span>
        }
<span class="fc bfc" id="L381" title="All 2 branches covered.">        if (game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_TACOPS_STANDING_STILL)</span>
<span class="fc bfc" id="L382" title="All 2 branches covered.">            &amp;&amp; (EntityMovementType.MOVE_NONE == targetState.getMovementType())</span>
<span class="pc bpc" id="L383" title="4 of 8 branches missed.">            &amp;&amp; !targetState.isImmobile()</span>
            &amp;&amp; !((target instanceof Infantry) || (target instanceof VTOL) ||
                 (target instanceof GunEmplacement))) {
<span class="fc" id="L386">            toHitData.addModifier(TH_TAR_NO_MOVE);</span>
        }

        // did the target sprint?
<span class="fc bfc" id="L390" title="All 2 branches covered.">        if (EntityMovementType.MOVE_SPRINT == targetState.getMovementType()</span>
<span class="pc bpc" id="L391" title="1 of 2 branches missed.">            || EntityMovementType.MOVE_VTOL_SPRINT == targetState.getMovementType()) {</span>
<span class="fc" id="L392">            toHitData.addModifier(TH_TAR_SPRINT);</span>
        }

        // terrain modifiers, since &quot;compute&quot; won't let me do these remotely
<span class="fc" id="L396">        final IHex targetHex = game.getBoard().getHex(targetState.getPosition());</span>
<span class="fc" id="L397">        int woodsLevel = targetHex.terrainLevel(Terrains.WOODS);</span>
<span class="fc bfc" id="L398" title="All 2 branches covered.">        if (targetHex.terrainLevel(Terrains.JUNGLE) &gt; woodsLevel) {</span>
<span class="fc" id="L399">            woodsLevel = targetHex.terrainLevel(Terrains.JUNGLE);</span>
        }
<span class="fc bfc" id="L401" title="All 2 branches covered.">        if (1 &lt;= woodsLevel) {</span>
<span class="fc" id="L402">            toHitData.addModifier(woodsLevel, TH_WOODS);</span>
        }

<span class="fc" id="L405">        final int smokeLevel = targetHex.terrainLevel(Terrains.SMOKE);</span>
<span class="pc bpc" id="L406" title="1 of 2 branches missed.">        if (1 &lt;= smokeLevel) {</span>
            // Smoke level doesn't necessary correspond to the to-hit modifier
            // even levels are light smoke, odd are heavy smoke
<span class="nc" id="L409">            toHitData.addModifier((smokeLevel % 2) + 1, TH_SMOKE);</span>
        }

<span class="fc bfc" id="L412" title="All 4 branches covered.">        if (targetState.isProne() &amp;&amp; (1 &lt; distance)) {</span>
<span class="fc" id="L413">            toHitData.addModifier(TH_TAR_PRONE_RANGE);</span>
<span class="pc bpc" id="L414" title="1 of 4 branches missed.">        } else if (targetState.isProne() &amp;&amp; (1 == distance)) {</span>
<span class="fc" id="L415">            toHitData.addModifier(TH_TAR_PRONE_ADJ);</span>
        }

<span class="fc bfc" id="L418" title="All 2 branches covered.">        if (EntityMovementType.MOVE_SKID == targetState.getMovementType()) {</span>
<span class="fc" id="L419">            toHitData.addModifier(TH_TAR_SKID);</span>
        }

<span class="fc" id="L422">        final boolean isShooterInfantry = (shooter instanceof Infantry);</span>
<span class="pc bpc" id="L423" title="1 of 2 branches missed.">        if (!isShooterInfantry) {</span>
<span class="fc bfc" id="L424" title="All 2 branches covered.">            if (target instanceof BattleArmor) {</span>
<span class="fc" id="L425">                toHitData.addModifier(TH_TAR_BA);</span>
<span class="fc bfc" id="L426" title="All 2 branches covered.">            } else if (target instanceof MechWarrior) {</span>
<span class="fc" id="L427">                toHitData.addModifier(TH_TAR_MW);</span>
<span class="fc bfc" id="L428" title="All 2 branches covered.">            } else if (target instanceof Infantry) {</span>
<span class="fc" id="L429">                toHitData.addModifier(TH_TAR_INF);</span>
            }
        }

<span class="fc bfc" id="L433" title="All 2 branches covered.">        if (shooter.hasQuirk(OptionsConstants.QUIRK_POS_ANTI_AIR) &amp;&amp;</span>
<span class="pc bpc" id="L434" title="1 of 4 branches missed.">            (target.isAirborne() || target.isAirborneVTOLorWIGE())) {</span>
<span class="fc" id="L435">            toHitData.addModifier(TH_ANTI_AIR);</span>
        }

<span class="pc bpc" id="L438" title="1 of 2 branches missed.">        if (shooter instanceof Mech) {</span>
<span class="fc" id="L439">            final Mech shooterMech = (Mech) shooter;</span>
<span class="fc bfc" id="L440" title="All 2 branches covered.">            if (Mech.COCKPIT_INDUSTRIAL == shooterMech.getCockpitType()) {</span>
<span class="fc" id="L441">                toHitData.addModifier(TH_INDUSTRIAL);</span>
<span class="fc bfc" id="L442" title="All 2 branches covered.">            } else if (Mech.COCKPIT_PRIMITIVE_INDUSTRIAL == shooterMech.getCockpitType()) {</span>
<span class="fc" id="L443">                toHitData.addModifier(TH_PRIMATIVE_INDUSTRIAL);</span>
            }
        }

<span class="fc bfc" id="L447" title="All 2 branches covered.">        if (target instanceof Mech) {</span>
<span class="fc" id="L448">            final Mech targetMech = (Mech) target;</span>
<span class="fc bfc" id="L449" title="All 2 branches covered.">            if (Mech.COCKPIT_SUPERHEAVY == targetMech.getCockpitType() ||</span>
<span class="pc bpc" id="L450" title="1 of 2 branches missed.">                Mech.COCKPIT_SUPERHEAVY_TRIPOD == targetMech.getCockpitType()) {</span>
<span class="fc" id="L451">                toHitData.addModifier(TH_TAR_SUPER);</span>
            }
        }

<span class="pc bpc" id="L455" title="1 of 4 branches missed.">        if ((target instanceof Dropship) &amp;&amp; !target.isAirborne()) {</span>
<span class="fc" id="L456">            toHitData.addModifier(TH_TAR_GROUND_DS);</span>
        }

<span class="fc" id="L459">        return toHitData;</span>
    }

    /**
     * Makes a rather poor guess as to what the to hit modifier will be with a physical attack.
     *
     * @param shooter      The unit doing the attacking.
     * @param shooterState The state of the unit doing the attacking.
     * @param target       Who is being attacked.
     * @param targetState  The state of the target.
     * @param attackType   The tyep of physical attack being made.
     * @param game         The game being played.
     * @return The estimated to hit modifiers.
     */
    ToHitData guessToHitModifierPhysical(final Entity shooter,
                                         @Nullable EntityState shooterState,
                                         final Targetable target,
                                         @Nullable EntityState targetState,
                                         final PhysicalAttackType attackType,
                                         final IGame game) {

        // todo weapons, frenzy (pg 144) &amp; vehicle charges.
        // todo heat mods to piloting?

<span class="fc bfc" id="L483" title="All 2 branches covered.">        if (!(shooter instanceof Mech)) {</span>
<span class="fc" id="L484">            return new ToHitData(TH_PHY_NOT_MECH);</span>
        }

<span class="pc bpc" id="L487" title="1 of 2 branches missed.">        if (null == shooterState) {</span>
<span class="nc" id="L488">            shooterState = new EntityState(shooter);</span>
        }
<span class="pc bpc" id="L490" title="1 of 2 branches missed.">        if (null == targetState) {</span>
<span class="nc" id="L491">            targetState = new EntityState(target);</span>
        }

        // We can hit someone who isn't standing right next to us.
<span class="fc" id="L495">        final int distance = shooterState.getPosition().distance(targetState.getPosition());</span>
<span class="fc bfc" id="L496" title="All 2 branches covered.">        if (1 &lt; distance) {</span>
<span class="fc" id="L497">            return new ToHitData(TH_PHY_TOO_FAR);</span>
        }

        // Get the general to hit modifiers.
<span class="fc" id="L501">        final ToHitData toHitData = new ToHitData();</span>
<span class="fc" id="L502">        toHitData.append(guessToHitModifierHelperForAnyAttack(shooter, shooterState, target, targetState, distance,</span>
                                                              game));
<span class="pc bpc" id="L504" title="2 of 4 branches missed.">        if (TargetRoll.IMPOSSIBLE == toHitData.getValue() || TargetRoll.AUTOMATIC_FAIL == toHitData.getValue()) {</span>
<span class="nc" id="L505">            return toHitData;</span>
        }

        // Check if target is within arc
        final int arc;
<span class="fc bfc" id="L510" title="All 2 branches covered.">        if (PhysicalAttackType.LEFT_PUNCH == attackType) {</span>
<span class="fc" id="L511">            arc = Compute.ARC_LEFTARM;</span>
<span class="fc bfc" id="L512" title="All 2 branches covered.">        } else if (PhysicalAttackType.RIGHT_PUNCH == attackType) {</span>
<span class="fc" id="L513">            arc = Compute.ARC_RIGHTARM;</span>
        } else {
<span class="fc" id="L515">            arc = Compute.ARC_FORWARD; // assume kick</span>
        }
<span class="fc bfc" id="L517" title="All 2 branches covered.">        if (!isInArc(shooterState.getPosition(), shooterState.getSecondaryFacing(), targetState.getPosition(), arc)) {</span>
<span class="fc" id="L518">            return new ToHitData(TH_PHY_NOT_IN_ARC);</span>
        }

        // Check elevation difference.
<span class="fc" id="L522">        final IHex attackerHex = game.getBoard().getHex(shooterState.getPosition());</span>
<span class="fc" id="L523">        final IHex targetHex = game.getBoard().getHex(targetState.getPosition());</span>
<span class="fc" id="L524">        final int attackerElevation = shooter.getElevation() + attackerHex.getLevel();</span>
<span class="fc" id="L525">        final int attackerHeight = shooter.relHeight() + attackerHex.getLevel();</span>
<span class="fc" id="L526">        final int targetElevation = target.getElevation() + targetHex.getLevel();</span>
<span class="fc" id="L527">        final int targetHeight = targetElevation + target.getHeight();</span>
<span class="fc bfc" id="L528" title="All 2 branches covered.">        if (attackType.isPunch()) {</span>
<span class="fc bfc" id="L529" title="All 2 branches covered.">            if (shooter.hasQuirk(OptionsConstants.QUIRK_NEG_NO_ARMS)) {</span>
<span class="fc" id="L530">                return new ToHitData(TH_PHY_P_NO_ARMS_QUIRK);</span>
            }

<span class="pc bpc" id="L533" title="1 of 4 branches missed.">            if ((attackerHeight &lt; targetElevation) || (attackerHeight &gt; targetHeight)) {</span>
<span class="fc" id="L534">                return new ToHitData(TH_PHY_TOO_MUCH_ELEVATION);</span>
            }

<span class="fc bfc" id="L537" title="All 2 branches covered.">            if (shooterState.isProne()) {</span>
<span class="fc" id="L538">                return new ToHitData(TH_PHY_P_TAR_PRONE);</span>
            }
<span class="fc bfc" id="L540" title="All 2 branches covered.">            if (target instanceof Infantry) {</span>
<span class="fc" id="L541">                return new ToHitData(TH_PHY_P_TAR_INF);</span>
            }
<span class="fc bfc" id="L543" title="All 2 branches covered.">            final int armLocation = PhysicalAttackType.RIGHT_PUNCH == attackType ? Mech.LOC_RARM : Mech.LOC_LARM;</span>
<span class="fc bfc" id="L544" title="All 2 branches covered.">            if (shooter.isLocationBad(armLocation)) {</span>
<span class="fc" id="L545">                return new ToHitData(TH_PHY_P_NO_ARM);</span>
            }
<span class="fc bfc" id="L547" title="All 2 branches covered.">            if (!shooter.hasWorkingSystem(Mech.ACTUATOR_SHOULDER, armLocation)) {</span>
<span class="fc" id="L548">                return new ToHitData(TH_PHY_P_NO_SHOULDER);</span>
            }

            // Base to hit chance.
<span class="fc" id="L552">            toHitData.addModifier(shooter.getCrew().getPiloting(), TH_PHY_BASE);</span>
<span class="fc bfc" id="L553" title="All 2 branches covered.">            if (!shooter.hasWorkingSystem(Mech.ACTUATOR_UPPER_ARM, armLocation)) {</span>
<span class="fc" id="L554">                toHitData.addModifier(TH_PHY_P_UPPER_ARM);</span>
            }
<span class="fc bfc" id="L556" title="All 2 branches covered.">            if (!shooter.hasWorkingSystem(Mech.ACTUATOR_LOWER_ARM, armLocation)) {</span>
<span class="fc" id="L557">                toHitData.addModifier(TH_PHY_P_LOWER_ARM);</span>
            }
<span class="fc bfc" id="L559" title="All 2 branches covered.">            if (!shooter.hasWorkingSystem(Mech.ACTUATOR_HAND, armLocation)) {</span>
<span class="fc" id="L560">                toHitData.addModifier(TH_PHY_P_HAND);</span>
            }
<span class="fc" id="L562">        } else { // assuming kick</span>

<span class="fc bfc" id="L564" title="All 2 branches covered.">            if (shooterState.isProne()) {</span>
<span class="fc" id="L565">                return new ToHitData(TH_PHY_K_PRONE);</span>
            }
<span class="pc bpc" id="L567" title="2 of 4 branches missed.">            if ((attackerElevation &lt; targetElevation) || (attackerElevation &gt; targetHeight)) {</span>
<span class="nc" id="L568">                return new ToHitData(TH_PHY_TOO_MUCH_ELEVATION);</span>
            }
<span class="fc bfc" id="L570" title="All 2 branches covered.">            if ((shooter).hasHipCrit()) {</span>
<span class="fc" id="L571">                return new ToHitData(TH_PHY_K_HIP);</span>
            }
<span class="pc bpc" id="L573" title="1 of 2 branches missed.">            final int legLocation = PhysicalAttackType.RIGHT_KICK == attackType ? Mech.LOC_RLEG : Mech.LOC_LLEG;</span>

            // Base to hit chance.
<span class="fc" id="L576">            toHitData.addModifier(shooter.getCrew().getPiloting() - 2, TH_PHY_BASE);</span>
<span class="fc bfc" id="L577" title="All 2 branches covered.">            if (!shooter.hasWorkingSystem(Mech.ACTUATOR_UPPER_LEG, legLocation)) {</span>
<span class="fc" id="L578">                toHitData.addModifier(TH_PHY_K_UPPER_LEG);</span>
            }
<span class="fc bfc" id="L580" title="All 2 branches covered.">            if (!shooter.hasWorkingSystem(Mech.ACTUATOR_LOWER_LEG, legLocation)) {</span>
<span class="fc" id="L581">                toHitData.addModifier(TH_PHY_K_LOWER_LEG);</span>
            }
<span class="fc bfc" id="L583" title="All 2 branches covered.">            if (!shooter.hasWorkingSystem(Mech.ACTUATOR_FOOT, legLocation)) {</span>
<span class="fc" id="L584">                toHitData.addModifier(TH_PHY_K_FOOT);</span>
            }
<span class="fc bfc" id="L586" title="All 2 branches covered.">            if (target instanceof Infantry) {</span>
<span class="fc bfc" id="L587" title="All 2 branches covered.">                if (0 == distance) {</span>
<span class="fc" id="L588">                    toHitData.addModifier(TH_PHY_K_INF);</span>
                } else {
<span class="fc" id="L590">                    return new ToHitData(TH_PHY_K_INF_RNG);</span>
                }
            }
        }

<span class="fc bfc" id="L595" title="All 2 branches covered.">        if (game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_TACOPS_PHYSICAL_ATTACK_PSR)) {</span>
<span class="fc bfc" id="L596" title="All 2 branches covered.">            if (EntityWeightClass.WEIGHT_LIGHT == shooter.getWeightClass()) {</span>
<span class="fc" id="L597">                toHitData.addModifier(TH_PHY_LIGHT);</span>
<span class="fc bfc" id="L598" title="All 2 branches covered.">            } else if (EntityWeightClass.WEIGHT_MEDIUM == shooter.getWeightClass()) {</span>
<span class="fc" id="L599">                toHitData.addModifier(TH_PHY_MEDIUM);</span>
            }
        }

<span class="pc bpc" id="L603" title="3 of 6 branches missed.">        if ((target instanceof LargeSupportTank) || (target instanceof FixedWingSupport) ||</span>
<span class="nc bnc" id="L604" title="All 2 branches missed.">            (target instanceof Dropship &amp;&amp; target.isAirborne())) {</span>
<span class="nc" id="L605">            toHitData.addModifier(TH_PHY_LARGE);</span>
        }
<span class="fc" id="L607">        final Mech shooterMech = (Mech) shooter;</span>
<span class="fc bfc" id="L608" title="All 2 branches covered.">        if (Mech.COCKPIT_SUPERHEAVY == shooterMech.getCockpitType() ||</span>
<span class="pc bpc" id="L609" title="1 of 2 branches missed.">            Mech.COCKPIT_SUPERHEAVY_TRIPOD == shooterMech.getCockpitType()) {</span>
<span class="fc" id="L610">            toHitData.addModifier(TH_PHY_SUPER);</span>
        }

<span class="fc bfc" id="L613" title="All 4 branches covered.">        if (shooter.hasQuirk(OptionsConstants.QUIRK_POS_EASY_PILOT) &amp;&amp; (3 &lt; shooter.getCrew().getPiloting())) {</span>
<span class="fc" id="L614">            toHitData.addModifier(TH_PHY_EASY_PILOT);</span>
        }

<span class="fc" id="L617">        return toHitData;</span>
    }

    /**
     * Returns the value of {@link Compute#isInArc(Coords, int, Targetable, int)}.
     *
     * @param shooterPosition The current {@link Coords} of the shooter.
     * @param shooterFacing   The shooter's current facing.
     * @param targetPosition  The current {@link Coords} of the target.
     * @param weaponArc       The arc of the weapon being fired.
     * @return TRUE if the target falls within the weapon's firing arc.
     */
    @StaticWrapper
    protected boolean isInArc(final Coords shooterPosition,
                              final int shooterFacing,
                              final Coords targetPosition,
                              final int weaponArc) {
<span class="nc" id="L634">        return Compute.isInArc(shooterPosition, shooterFacing, targetPosition, weaponArc);</span>
    }

    /**
     * Returns the value of {@link LosEffects#calculateLos(IGame, int, Targetable, Coords, Coords, boolean)}.
     *
     * @param game            The {@link IGame} being played.
     * @param shooterId       The id of the shooting unit.
     * @param target          The unit being shot at as a {@link Targetable} object.
     * @param shooterPosition The current {@link Coords} of the shooter.
     * @param targetPosition  The current {@link Coords} of the target.
     * @param spotting        Set TRUE if the shooter is simply spotting for indrect fire.
     * @return The resulting {@link LosEffects}.
     */
    @StaticWrapper
    LosEffects getLosEffects(final IGame game,
                             final int shooterId,
                             final Targetable target,
                             final Coords shooterPosition,
                             final Coords targetPosition,
                             final boolean spotting) {
<span class="nc" id="L655">        return LosEffects.calculateLos(game, shooterId, target, shooterPosition, targetPosition, spotting);</span>
    }

    /**
     * Returns the value of {@link Compute#getSwarmMekBaseToHit(Entity, Entity, IGame)}.
     *
     * @param attacker The attacking {@link Entity}.
     * @param defender The target of the attack.
     * @param game     The game being played.
     * @return The to hit modifiers as a {@link ToHitData} object.
     */
    @StaticWrapper
    private ToHitData getSwarmMekBaseToHit(final Entity attacker,
                                           final Entity defender,
                                           final IGame game) {
<span class="nc" id="L670">        return Compute.getSwarmMekBaseToHit(attacker, defender, game);</span>
    }

    /**
     * Returns the value of {@link Compute#getLegAttackBaseToHit(Entity, Entity, IGame)}.
     *
     * @param attacker The attacking {@link Entity}.
     * @param defender The target of the attack.
     * @param game     The game being played.
     * @return The to hit modifiers as a {@link ToHitData} object.
     */
    @StaticWrapper
    private ToHitData getLegAttackBaseToHit(final Entity attacker,
                                            final Entity defender,
                                            final IGame game) {
<span class="nc" id="L685">        return Compute.getLegAttackBaseToHit(attacker, defender, game);</span>
    }

    /**
     * Returns the value of {@link Compute#getInfantryRangeMods(int, InfantryWeapon, InfantryWeapon, boolean)}.
     *
     * @param distance The distance to the target.
     * @param weapon   The {@link InfantryWeapon} being fired.
     * @return The to hit modifiers as a {@link ToHitData} object.
     */
    @StaticWrapper
    private ToHitData getInfantryRangeMods(final int distance,
                                           final InfantryWeapon weapon,
                                           final InfantryWeapon secondary,
                                           final boolean underwater) {
<span class="nc" id="L700">        return Compute.getInfantryRangeMods(distance, weapon, secondary, underwater);</span>
    }

    /**
     * Returns the value of {@link Compute#getDamageWeaponMods(Entity, Mounted)}.
     *
     * @param attacker The attacking {@link Entity}.
     * @param weapon   The {@link Mounted} weapon being fired.
     * @return The to hit modifiers as a {@link ToHitData} object.
     */
    @StaticWrapper
    private ToHitData getDamageWeaponMods(final Entity attacker,
                                          final Mounted weapon) {
<span class="fc" id="L713">        return Compute.getDamageWeaponMods(attacker, weapon);</span>
    }

    private boolean isLargeTarget(final Targetable target) {
<span class="pc bpc" id="L717" title="2 of 6 branches missed.">        if ((target instanceof LargeSupportTank) || (target instanceof FixedWingSupport) ||</span>
<span class="nc bnc" id="L718" title="All 2 branches missed.">            (target instanceof Dropship &amp;&amp; target.isAirborne())) {</span>
<span class="fc" id="L719">            return true;</span>
        }
<span class="fc bfc" id="L721" title="All 2 branches covered.">        if (!(target instanceof Mech)) {</span>
<span class="fc" id="L722">            return false;</span>
        }

<span class="fc" id="L725">        final Mech targetMech = (Mech) target;</span>
<span class="fc bfc" id="L726" title="All 2 branches covered.">        return (Mech.COCKPIT_SUPERHEAVY == targetMech.getCockpitType()) ||</span>
<span class="pc bpc" id="L727" title="1 of 2 branches missed.">               (Mech.COCKPIT_SUPERHEAVY_TRIPOD == targetMech.getCockpitType());</span>
    }

    /**
     * Makes an educated guess as to the to hit modifier with a weapon attack.
     * Does not actually place unit into desired position, because that is
     * exceptionally slow. Most of this is copied from WeaponAttack.
     *
     * @param shooter
     *            The {@link Entity} doing the shooting.
     * @param shooterState
     *            The {@link EntityState} of the unit doing the shooting.
     * @param target
     *            The {@link Targetable} being shot at.
     * @param targetState
     *            The {@link EntityState} of the unit being shot at.
     * @param weapon
     *            The weapon being fired as a {@link Mounted} object.
     * @param game
     *            The {@link IGame being played.}
     * @return The to hit modifiers for the given weapon firing at the given
     *         target as a {@link ToHitData} object.
     */
    ToHitData guessToHitModifierForWeapon(final Entity shooter,
                                          @Nullable EntityState shooterState,
                                          final Targetable target,
                                          @Nullable EntityState targetState,
                                          final Mounted weapon,
                                          final IGame game) {

<span class="pc bpc" id="L757" title="1 of 2 branches missed.">        if (null == shooterState) {</span>
<span class="nc" id="L758">            shooterState = new EntityState(shooter);</span>
        }
<span class="pc bpc" id="L760" title="1 of 2 branches missed.">        if (null == targetState) {</span>
<span class="nc" id="L761">            targetState = new EntityState(target);</span>
        }

        // First check if the shot is impossible
<span class="fc bfc" id="L765" title="All 2 branches covered.">        if (!weapon.canFire()) {</span>
<span class="fc" id="L766">            return new ToHitData(TH_WEAP_CANNOT_FIRE);</span>
        }

        // Make sure we have ammo.
<span class="fc" id="L770">        final WeaponType weaponType = (WeaponType) weapon.getType();</span>
<span class="pc bpc" id="L771" title="1 of 2 branches missed.">        if (AmmoType.T_NA != weaponType.getAmmoType()) {</span>
<span class="fc bfc" id="L772" title="All 2 branches covered.">            if (null == weapon.getLinked()) {</span>
<span class="fc" id="L773">                return new ToHitData(TH_WEAP_NO_AMMO);</span>
            }
<span class="fc bfc" id="L775" title="All 2 branches covered.">            if (0 == weapon.getLinked().getUsableShotsLeft()) {</span>
<span class="fc" id="L776">                return new ToHitData(TH_WEAP_NO_AMMO);</span>
            }
        }

<span class="fc bfc" id="L780" title="All 2 branches covered.">        if (shooterState.isProne()) {</span>
            // Cannot fire if we cannot at least prop ourselves up.
<span class="pc bpc" id="L782" title="1 of 4 branches missed.">            if (shooter.isLocationBad(Mech.LOC_LARM) &amp;&amp; shooter.isLocationBad(Mech.LOC_RARM)) {</span>
<span class="fc" id="L783">                return new ToHitData(TH_WEAP_PRONE_ARMLESS);</span>
            }
            // Cannot fire weapons mounted in the propping arm.
<span class="pc bpc" id="L786" title="1 of 4 branches missed.">            if ((Mech.LOC_LARM == weapon.getLocation() || Mech.LOC_RARM == weapon.getLocation())</span>
<span class="pc bpc" id="L787" title="1 of 2 branches missed.">                &amp;&amp; shooter.isLocationBad(weapon.getLocation())) {</span>
<span class="fc" id="L788">                return new ToHitData(TH_WEAP_ARM_PROP);</span>
            }
            // Cannot fire leg-mounted weapons while prone.)
<span class="pc bpc" id="L791" title="3 of 4 branches missed.">            if ((Mech.LOC_LLEG == weapon.getLocation()) || (Mech.LOC_RLEG == weapon.getLocation())) {</span>
<span class="fc" id="L792">                return new ToHitData(TH_WEAP_PRONE_LEG);</span>
            }
        }

        // Check if torso twists affect weapon
<span class="fc" id="L797">        int shooterFacing = shooterState.getFacing();</span>
<span class="pc bpc" id="L798" title="1 of 2 branches missed.">        if (shooter.isSecondaryArcWeapon(shooter.getEquipmentNum(weapon))) {</span>
<span class="nc" id="L799">            shooterFacing = shooterState.getSecondaryFacing();</span>
        }
<span class="fc" id="L801">        final boolean inArc = isInArc(shooterState.getPosition(), shooterFacing, targetState.getPosition(),</span>
<span class="fc" id="L802">                                      shooter.getWeaponArc(shooter.getEquipmentNum(weapon)));</span>
<span class="fc bfc" id="L803" title="All 2 branches covered.">        if (!inArc) {</span>
<span class="fc" id="L804">            return new ToHitData(TH_WEAPON_NO_ARC);</span>
        }

        // Check range.
<span class="fc" id="L808">        int distance = shooterState.getPosition().distance(targetState.getPosition());</span>

        // Ground units attacking airborne aero considerations.
<span class="pc bpc" id="L811" title="1 of 4 branches missed.">        if (targetState.isAirborneAero() &amp;&amp; !shooterState.isAero()) {</span>

            // If the aero is attacking me, there is no range.
<span class="fc bfc" id="L814" title="All 2 branches covered.">            if (target.getTargetId() == shooter.getId()) {</span>
<span class="fc" id="L815">                distance = 0;</span>
            } else {
                // Take into account altitude.
<span class="fc" id="L818">                distance += 2 * target.getAltitude();</span>
            }
        }
<span class="fc" id="L821">        int range = RangeType.rangeBracket(distance, weaponType.getRanges(weapon),</span>
<span class="fc" id="L822">                                           game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_RANGE),</span>
<span class="fc" id="L823">                                           game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_LOS_RANGE));</span>
<span class="fc bfc" id="L824" title="All 2 branches covered.">        if (RangeType.RANGE_OUT == range) {</span>
<span class="fc" id="L825">            return new ToHitData(TH_OUT_OF_RANGE);</span>
<span class="fc bfc" id="L826" title="All 4 branches covered.">        } else if ((RangeType.RANGE_MINIMUM == range) &amp;&amp; targetState.isAirborneAero()) {</span>
<span class="fc" id="L827">            range = RangeType.RANGE_SHORT;</span>
        }

        // Cannot shoot at 0 range infantry unless shooter is also infantry.
<span class="fc" id="L831">        final boolean isShooterInfantry = (shooter instanceof Infantry);</span>
<span class="pc bpc" id="L832" title="1 of 6 branches missed.">        if ((0 == distance) &amp;&amp; (!isShooterInfantry) &amp;&amp; !(weaponType instanceof StopSwarmAttack) &amp;&amp;</span>
<span class="fc bfc" id="L833" title="All 2 branches covered.">            !targetState.isAirborneAero()) {</span>
<span class="fc" id="L834">            return new ToHitData(TH_INF_ZERO_RNG);</span>
        }

        // Handle stopping a swarm attack.
<span class="fc bfc" id="L838" title="All 2 branches covered.">        if (weaponType instanceof StopSwarmAttack) {</span>
<span class="fc bfc" id="L839" title="All 2 branches covered.">            if (Entity.NONE == shooter.getSwarmTargetId()) {</span>
<span class="fc" id="L840">                return new ToHitData(TH_STOP_SWARM_INVALID);</span>
            } else {
<span class="fc" id="L842">                return new ToHitData(TH_SWARM_STOPPED);</span>
            }
        }

        // Get the mods that apply to all attacks.
<span class="fc" id="L847">        final ToHitData baseMods = guessToHitModifierHelperForAnyAttack(shooter,</span>
                                                                        shooterState,
                                                                        target,
                                                                        targetState,
                                                                        distance,
                                                                        game);
<span class="pc bpc" id="L853" title="2 of 4 branches missed.">        if (TargetRoll.IMPOSSIBLE == baseMods.getValue() || TargetRoll.AUTOMATIC_FAIL == baseMods.getValue()) {</span>
<span class="nc" id="L854">            return baseMods;</span>
        }

        // Base to hit is gunnery skill
<span class="fc" id="L858">        final ToHitData toHit = new ToHitData(shooter.getCrew().getGunnery(), TH_GUNNERY);</span>
<span class="fc" id="L859">        toHit.append(baseMods);</span>

        // There is kindly already a class that will calculate line of sight for me
        // todo take into account spotting for indirect fire.
<span class="fc" id="L863">        final LosEffects losEffects = getLosEffects(game, shooter.getId(), target, shooterState.getPosition(),</span>
<span class="fc" id="L864">                                                    targetState.getPosition(), false);</span>

        // water is a separate los effect
<span class="fc" id="L867">        final IHex targetHex = game.getBoard().getHex(targetState.getPosition());</span>
<span class="fc" id="L868">        Entity targetEntity = null;</span>
<span class="pc bpc" id="L869" title="1 of 2 branches missed.">        if (target instanceof Entity) {</span>
<span class="fc" id="L870">            targetEntity = (Entity) target;</span>
        }
<span class="pc bpc" id="L872" title="1 of 2 branches missed.">        if (null != targetEntity) {</span>
<span class="pc bpc" id="L873" title="1 of 2 branches missed.">            if (targetHex.containsTerrain(Terrains.WATER)</span>
<span class="nc bnc" id="L874" title="All 2 branches missed.">                &amp;&amp; (1 == targetHex.terrainLevel(Terrains.WATER))</span>
<span class="nc bnc" id="L875" title="All 2 branches missed.">                &amp;&amp; (0 &lt; targetEntity.height())) {</span>
<span class="nc" id="L876">                losEffects.setTargetCover(losEffects.getTargetCover() | LosEffects.COVER_HORIZONTAL);</span>
            }
        }

        // Can we still hit after taking into account LoS?
<span class="fc" id="L881">        toHit.append(losEffects.losModifiers(game));</span>
<span class="pc bpc" id="L882" title="2 of 4 branches missed.">        if ((TargetRoll.IMPOSSIBLE == toHit.getValue()) || (TargetRoll.AUTOMATIC_FAIL == toHit.getValue())) {</span>
<span class="nc" id="L883">            return toHit; // you can't hit what you can't see</span>
        }

        // Handle sensor damage.  Mek sensor damage is handled under general damage mods.
<span class="fc bfc" id="L887" title="All 2 branches covered.">        if (shooter instanceof Tank) {</span>
<span class="fc" id="L888">            final int sensors = ((Tank) shooter).getSensorHits();</span>
<span class="pc bpc" id="L889" title="1 of 2 branches missed.">            if (0 &lt; sensors) {</span>
<span class="fc" id="L890">                toHit.addModifier(sensors, TH_SENSORS);</span>
            }
        }

        // Handle mechs being swarmed.
<span class="fc bfc" id="L895" title="All 2 branches covered.">        if (targetEntity instanceof Mech) {</span>
<span class="pc bpc" id="L896" title="1 of 2 branches missed.">            if (Infantry.SWARM_MEK.equals(weaponType.getInternalName())) {</span>
<span class="nc" id="L897">                toHit.append(getSwarmMekBaseToHit(shooter, targetEntity, game));</span>
            }
<span class="pc bpc" id="L899" title="1 of 2 branches missed.">            if (Infantry.LEG_ATTACK.equals(weapon.getType().getInternalName())) {</span>
<span class="nc" id="L900">                toHit.append(getLegAttackBaseToHit(shooter, targetEntity, game));</span>
            }
        }
<span class="pc bpc" id="L903" title="2 of 4 branches missed.">        if ((TargetRoll.IMPOSSIBLE == toHit.getValue()) || (TargetRoll.AUTOMATIC_FAIL == toHit.getValue())) {</span>
<span class="nc" id="L904">            return toHit;</span>
        }

        // Now deal with range effects
<span class="pc bpc" id="L908" title="1 of 2 branches missed.">        if (!weaponType.hasFlag(WeaponType.F_INFANTRY)) {</span>
<span class="fc bfc" id="L909" title="All 2 branches covered.">            if (RangeType.RANGE_SHORT == range) {</span>
<span class="fc" id="L910">                toHit.addModifier(TH_SHORT_RANGE);</span>
<span class="fc bfc" id="L911" title="All 2 branches covered.">            } else if (RangeType.RANGE_MEDIUM == range) {</span>
<span class="fc" id="L912">                toHit.addModifier(TH_MEDIUM_RANGE);</span>
<span class="fc bfc" id="L913" title="All 2 branches covered.">            } else if (RangeType.RANGE_LONG == range) {</span>
<span class="fc" id="L914">                toHit.addModifier(TH_LONG_RANGE);</span>
<span class="fc bfc" id="L915" title="All 2 branches covered.">            } else if (RangeType.RANGE_EXTREME == range) {</span>
<span class="fc" id="L916">                toHit.addModifier(TH_EXTREME_RANGE);</span>
<span class="pc bpc" id="L917" title="1 of 2 branches missed.">            } else if (RangeType.RANGE_MINIMUM == range) {</span>
<span class="fc" id="L918">                toHit.addModifier((weaponType.getMinimumRange() - distance) + 1, TH_MINIMUM_RANGE);</span>
            }
        } else {
<span class="nc" id="L921">            toHit.append(getInfantryRangeMods(distance, (InfantryWeapon) weapon.getType(),</span>
<span class="nc bnc" id="L922" title="All 2 branches missed.">                                              isShooterInfantry ? ((Infantry) shooter).getSecondaryWeapon() : null,</span>
<span class="nc bnc" id="L923" title="All 2 branches missed.">                                              ILocationExposureStatus.WET == shooter.getLocationStatus(weapon.getLocation())));</span>
        }

        // let us not forget about heat
<span class="fc bfc" id="L927" title="All 2 branches covered.">        if (0 != shooter.getHeatFiringModifier()) {</span>
<span class="fc" id="L928">            toHit.addModifier(shooter.getHeatFiringModifier(), TH_HEAT);</span>
        }

        // and damage
<span class="fc" id="L932">        toHit.append(getDamageWeaponMods(shooter, weapon));</span>

        // weapon mods
<span class="fc bfc" id="L935" title="All 2 branches covered.">        if (0 != weaponType.getToHitModifier()) {</span>
<span class="fc" id="L936">            toHit.addModifier(weaponType.getToHitModifier(), TH_WEAPON_MOD);</span>
        }

        // Target size.
<span class="fc bfc" id="L940" title="All 2 branches covered.">        if (isLargeTarget(target)) {</span>
<span class="fc" id="L941">            toHit.addModifier(TH_RNG_LARGE);</span>
        }

        // ammo mods
<span class="pc bpc" id="L945" title="1 of 2 branches missed.">        if (AmmoType.T_NA != weaponType.getAmmoType()</span>
<span class="pc bpc" id="L946" title="1 of 2 branches missed.">            &amp;&amp; (null != weapon.getLinked())</span>
<span class="fc bfc" id="L947" title="All 2 branches covered.">            &amp;&amp; (weapon.getLinked().getType() instanceof AmmoType)) {</span>
<span class="fc" id="L948">            final AmmoType ammoType = (AmmoType) weapon.getLinked().getType();</span>
<span class="pc bpc" id="L949" title="1 of 4 branches missed.">            if ((null != ammoType) &amp;&amp; (0 != ammoType.getToHitModifier())) {</span>
<span class="fc" id="L950">                toHit.addModifier(ammoType.getToHitModifier(), TH_AMMO_MOD);</span>
            }
        }

        // targeting computer
<span class="fc bfc" id="L955" title="All 4 branches covered.">        if (shooter.hasTargComp() &amp;&amp; weaponType.hasFlag(WeaponType.F_DIRECT_FIRE)) {</span>
<span class="fc" id="L956">            toHit.addModifier(TH_TARGETTING_COMP);</span>
        }

        // shooter quirks
<span class="fc bfc" id="L960" title="All 2 branches covered.">        if (RangeType.RANGE_SHORT == range) {</span>
<span class="fc bfc" id="L961" title="All 2 branches covered.">            if (shooter.hasQuirk(OptionsConstants.QUIRK_POS_IMP_TARG_S)) {</span>
<span class="fc" id="L962">                toHit.addModifier(TH_IMP_TARG_SHORT);</span>
            }
<span class="fc bfc" id="L964" title="All 2 branches covered.">            if (shooter.hasQuirk(OptionsConstants.QUIRK_POS_VAR_RNG_TARG_S)) {</span>
<span class="fc" id="L965">                toHit.addModifier(TH_VAR_RNG_TARG_SHORT_AT_SHORT);</span>
            }
<span class="fc bfc" id="L967" title="All 2 branches covered.">            if (shooter.hasQuirk(OptionsConstants.QUIRK_POS_VAR_RNG_TARG_L)) {</span>
<span class="fc" id="L968">                toHit.addModifier(TH_VAR_RNG_TARG_LONG_AT_SHORT);</span>
            }
<span class="fc bfc" id="L970" title="All 2 branches covered.">            if (shooter.hasQuirk(OptionsConstants.QUIRK_NEG_POOR_TARG_S)) {</span>
<span class="fc" id="L971">                toHit.addModifier(TH_POOR_TARG_SHORT);</span>
            }
        }
<span class="fc bfc" id="L974" title="All 2 branches covered.">        if (RangeType.RANGE_MEDIUM == range) {</span>
<span class="fc bfc" id="L975" title="All 2 branches covered.">            if (shooter.hasQuirk(OptionsConstants.QUIRK_POS_IMP_TARG_M)) {</span>
<span class="fc" id="L976">                toHit.addModifier(TH_IMP_TARG_MEDIUM);</span>
            }
<span class="fc bfc" id="L978" title="All 2 branches covered.">            if (shooter.hasQuirk(OptionsConstants.QUIRK_NEG_POOR_TARG_M)) {</span>
<span class="fc" id="L979">                toHit.addModifier(TH_POOR_TARG_MEDIUM);</span>
            }
        }
<span class="fc bfc" id="L982" title="All 2 branches covered.">        if (RangeType.RANGE_LONG == range) {</span>
<span class="fc bfc" id="L983" title="All 2 branches covered.">            if (shooter.hasQuirk(OptionsConstants.QUIRK_POS_IMP_TARG_L)) {</span>
<span class="fc" id="L984">                toHit.addModifier(TH_IMP_TARG_LONG);</span>
            }
<span class="fc bfc" id="L986" title="All 2 branches covered.">            if (shooter.hasQuirk(OptionsConstants.QUIRK_POS_VAR_RNG_TARG_S)) {</span>
<span class="fc" id="L987">                toHit.addModifier(TH_VAR_RNG_TARG_SHORT_AT_LONG);</span>
            }
<span class="fc bfc" id="L989" title="All 2 branches covered.">            if (shooter.hasQuirk(OptionsConstants.QUIRK_POS_VAR_RNG_TARG_L)) {</span>
<span class="fc" id="L990">                toHit.addModifier(TH_VAR_RNG_TARG_LONG_AT_LONG);</span>
            }
<span class="fc bfc" id="L992" title="All 2 branches covered.">            if (shooter.hasQuirk(OptionsConstants.QUIRK_NEG_POOR_TARG_L)) {</span>
<span class="fc" id="L993">                toHit.addModifier(TH_POOR_TARG_LONG);</span>
            }
        }

        // weapon quirks
<span class="fc bfc" id="L998" title="All 2 branches covered.">        if (weapon.hasQuirk(OptionsConstants.QUIRK_WEAP_POS_ACCURATE)) {</span>
<span class="fc" id="L999">            toHit.addModifier(TH_ACCURATE_WEAP);</span>
        }
<span class="fc bfc" id="L1001" title="All 2 branches covered.">        if (weapon.hasQuirk(OptionsConstants.QUIRK_WEAP_NEG_INACCURATE)) {</span>
<span class="fc" id="L1002">            toHit.addModifier(TH_INACCURATE_WEAP);</span>
        }
<span class="pc bpc" id="L1004" title="3 of 4 branches missed.">        if (weapon.hasQuirk(OptionsConstants.QUIRK_WEAP_POS_STABLE_WEAPON) &amp;&amp; (EntityMovementType.MOVE_RUN == shooter.moved)) {</span>
<span class="nc" id="L1005">            toHit.addModifier(TH_STABLE_WEAP);</span>
        }

<span class="fc" id="L1008">        return toHit;</span>
    }

    /**
     * Makes an educated guess as to the to hit modifier by an aerospace unit
     * flying on a ground map doing a strike attack on a unit
     *
     * @param shooter
     *            The {@link Entity} doing the shooting.
     * @param shooterState
     *            The {@link EntityState} of the unit doing the shooting.
     * @param target
     *            The {@link megamek.common.Targetable} being shot at.
     * @param targetState
     *            The {@link megamek.client.bot.princess.EntityState} of the
     *            unit being shot at.
     * @param flightPath
     *            The path the shooter is taking.
     * @param weapon
     *            The weapon being fired as a {@link megamek.common.Mounted}
     *            object.
     * @param game
     *            The {@link megamek.common.IGame being played.}
     * @param assumeUnderFlightPlan
     *            Set TRUE to assume that the target falls under the given
     *            flight path.
     * @return The to hit modifiers for the given weapon firing at the given
     *         target as a {@link ToHitData} object.
     */
    ToHitData guessAirToGroundStrikeToHitModifier(final Entity shooter,
                                                  @Nullable EntityState shooterState,
                                                  final Targetable target,
                                                  @Nullable EntityState targetState,
                                                  final MovePath flightPath,
                                                  final Mounted weapon,
                                                  final IGame game,
                                                  final boolean assumeUnderFlightPlan) {

<span class="pc bpc" id="L1046" title="1 of 2 branches missed.">        if (null == targetState) {</span>
<span class="nc" id="L1047">            targetState = new EntityState(target);</span>
        }
<span class="pc bpc" id="L1049" title="1 of 2 branches missed.">        if (null == shooterState) {</span>
<span class="nc" id="L1050">            shooterState = new EntityState(shooter);</span>
        }

        // first check if the shot is impossible
<span class="fc bfc" id="L1054" title="All 2 branches covered.">        if (!weapon.canFire()) {</span>
<span class="fc" id="L1055">            return new ToHitData(TH_WEAP_CANNOT_FIRE);</span>
        }

        // Is the weapon loaded?
<span class="pc bpc" id="L1059" title="1 of 2 branches missed.">        if (AmmoType.T_NA != ((WeaponType) weapon.getType()).ammoType) {</span>
<span class="fc bfc" id="L1060" title="All 2 branches covered.">            if (null == weapon.getLinked()) {</span>
<span class="fc" id="L1061">                return new ToHitData(TH_WEAP_NO_AMMO);</span>
            }
<span class="fc bfc" id="L1063" title="All 2 branches covered.">            if (0 == weapon.getLinked().getUsableShotsLeft()) {</span>
<span class="fc" id="L1064">                return new ToHitData(TH_WEAP_NO_AMMO);</span>
            }
        }

        // check if target is even under our path
<span class="fc bfc" id="L1069" title="All 4 branches covered.">        if (!assumeUnderFlightPlan &amp;&amp; !isTargetUnderFlightPath(flightPath, targetState)) {</span>
<span class="fc" id="L1070">            return new ToHitData(TH_AIR_STRIKE_PATH);</span>
        }

        // Base to hit is gunnery skill
<span class="fc" id="L1074">        final ToHitData tohit = new ToHitData(shooter.getCrew().getGunnery(), TH_GUNNERY);</span>

        // Get general modifiers.
<span class="fc" id="L1077">        tohit.append(guessToHitModifierHelperForAnyAttack(shooter, shooterState, target, targetState, 0, game));</span>

        // Additional penalty due to strike attack
<span class="fc" id="L1080">        tohit.addModifier(TH_AIR_STRIKE);</span>

<span class="fc" id="L1082">        return tohit;</span>
    }

    /**
     * Checks if a target lies under a move path, to see if an aero unit can attack it.
     *
     * @param flightPath  move path to check
     * @param targetState used for targets position
     * @return TRUE if the target is under the path.
     */
    boolean isTargetUnderFlightPath(final MovePath flightPath,
                                    final EntityState targetState) {

<span class="fc" id="L1095">        final Coords targetCoords = targetState.getPosition();</span>
<span class="fc bfc" id="L1096" title="All 2 branches covered.">        for (final Enumeration&lt;MoveStep&gt; step = flightPath.getSteps(); step.hasMoreElements(); ) {</span>
<span class="fc" id="L1097">            final Coords stepCoords = step.nextElement().getPosition();</span>
<span class="fc bfc" id="L1098" title="All 2 branches covered.">            if (targetCoords.equals(stepCoords)) {</span>
<span class="fc" id="L1099">                return true;</span>
            }
<span class="fc" id="L1101">        }</span>
<span class="fc" id="L1102">        return false;</span>
    }

    /**
     * Mostly for debugging, this returns a non-null string that describes how
     * the guess has failed to be perfectly accurate. or null if perfectly
     * accurate
     *
     * @param shooter
     *            The unit doing the shooting.
     * @param target
     *            The unit being shot at.
     * @param weapon
     *            The weapon being fired.
     * @param game
     *            The game being played.
     * @return A description of the differences or NULL if there are none.
     */
    private String checkGuess(final Entity shooter,
                              final Targetable target,
                              final Mounted weapon,
                              final IGame game) {

        // This really should only be done for debugging purposes.  Regular play should avoid the overhead.
<span class="nc bnc" id="L1126" title="All 2 branches missed.">        if (!LogLevel.DEBUG.equals(owner.getVerbosity())) {</span>
<span class="nc" id="L1127">            return null;</span>
        }

        // Don't bother checking these as the guesses are minimal (or non-existant).
<span class="nc bnc" id="L1131" title="All 6 branches missed.">        if (shooter.isAero() || (null == shooter.getPosition()) || (null == target.getPosition())) {</span>
<span class="nc" id="L1132">            return null;</span>
        }

<span class="nc" id="L1135">        String ret = &quot;&quot;;</span>
<span class="nc" id="L1136">        final WeaponFireInfo guessInfo = new WeaponFireInfo(shooter,</span>
                                                            new EntityState(shooter),
                                                            target,
                                                            null,
                                                            weapon,
                                                            game,
                                                            true,
                                                            owner);
<span class="nc" id="L1144">        final WeaponFireInfo accurateInfo = new WeaponFireInfo(shooter, target, weapon, game, false, owner);</span>

<span class="nc bnc" id="L1146" title="All 2 branches missed.">        if (guessInfo.getToHit().getValue() != accurateInfo.getToHit().getValue()) {</span>
<span class="nc" id="L1147">            ret += &quot;Incorrect To Hit prediction, weapon &quot; + weapon.getName() + &quot; (&quot; + shooter.getChassis() + &quot; vs &quot; +</span>
<span class="nc" id="L1148">                   target.getDisplayName() + &quot;)&quot; + &quot;:\n&quot;;</span>
<span class="nc" id="L1149">            ret += &quot; Guess: &quot; + Integer.toString(guessInfo.getToHit().getValue()) + &quot; &quot; +</span>
<span class="nc" id="L1150">                   guessInfo.getToHit().getDesc() + &quot;\n&quot;;</span>
<span class="nc" id="L1151">            ret += &quot; Real:  &quot; + Integer.toString(accurateInfo.getToHit().getValue()) + &quot; &quot; +</span>
<span class="nc" id="L1152">                   accurateInfo.getToHit().getDesc() + &quot;\n&quot;;</span>
        }
<span class="nc" id="L1154">        return ret;</span>
    }

    /**
     * Mostly for debugging, this returns a non-null string that describes how
     * the guess on a physical attack failed to be perfectly accurate, or null
     * if accurate
     *
     * @param shooter
     *            The unit doing the shooting.
     * @param target
     *            The unit being shot at.
     * @param attackType
     *            The attack being made.
     * @param game
     *            The game being played.
     * @return A description of the differences or NULL if there are none.
     */
    private String checkGuessPhysical(final Entity shooter,
                                      final Targetable target,
                                      final PhysicalAttackType attackType,
                                      final IGame game) {

        // This really should only be done for debugging purposes. Regular play
        // should avoid the overhead.
<span class="nc bnc" id="L1179" title="All 2 branches missed.">        if (!LogLevel.DEBUG.equals(owner.getVerbosity())) {</span>
<span class="nc" id="L1180">            return null;</span>
        }

        // only mechs can do physicals
<span class="nc bnc" id="L1184" title="All 2 branches missed.">        if (!(shooter instanceof Mech)) {</span>
<span class="nc" id="L1185">            return null;</span>
        }

<span class="nc" id="L1188">        String ret = &quot;&quot;;</span>
<span class="nc bnc" id="L1189" title="All 2 branches missed.">        if (null == shooter.getPosition()) {</span>
<span class="nc" id="L1190">            return &quot;Shooter has NULL coordinates!&quot;;</span>
<span class="nc bnc" id="L1191" title="All 2 branches missed.">        } else if (null == target.getPosition()) {</span>
<span class="nc" id="L1192">            return &quot;Target has NULL coordinates!&quot;;</span>
        }

<span class="nc" id="L1195">        final PhysicalInfo guessInfo = new PhysicalInfo(shooter, null, target, null, attackType, game, owner, true);</span>
<span class="nc" id="L1196">        final PhysicalInfo accurateInfo = new PhysicalInfo(shooter, target, attackType, game, owner, false);</span>
<span class="nc bnc" id="L1197" title="All 2 branches missed.">        if (guessInfo.getHitData().getValue() != accurateInfo.getHitData().getValue()) {</span>
<span class="nc" id="L1198">            ret += &quot;Incorrect To Hit prediction, physical attack &quot; + attackType.name() + &quot;:\n&quot;;</span>
<span class="nc" id="L1199">            ret += &quot; Guess: &quot; + Integer.toString(guessInfo.getHitData().getValue()) + &quot; &quot; + guessInfo.getHitData()</span>
<span class="nc" id="L1200">                                                                                                     .getDesc() +</span>
                   &quot;\n&quot;;
<span class="nc" id="L1202">            ret += &quot; Real:  &quot; + Integer.toString(accurateInfo.getHitData().getValue()) + &quot; &quot; +</span>
<span class="nc" id="L1203">                   accurateInfo.getHitData().getDesc() + &quot;\n&quot;;</span>
        }
<span class="nc" id="L1205">        return ret;</span>
    }

    /**
     * Mostly for debugging, this returns a non-null string that describes how
     * any possible guess has failed to be perfectly accurate. or null if
     * perfect
     *
     * @param shooter
     *            The unit doing the shooting.
     * @param game
     *            The game being played.
     * @return A description of the differences or NULL if there are none.
     */
    String checkAllGuesses(final Entity shooter,
                           final IGame game) {

        // This really should only be done for debugging purposes.  Regular play should avoid the overhead.
<span class="nc bnc" id="L1223" title="All 2 branches missed.">        if (!LogLevel.DEBUG.equals(owner.getVerbosity())) {</span>
<span class="nc" id="L1224">            return null;</span>
        }

<span class="nc" id="L1227">        final StringBuilder ret = new StringBuilder();</span>
<span class="nc" id="L1228">        final List&lt;Targetable&gt; enemies = getTargetableEnemyEntities(shooter, game, owner.getFireControlState());</span>
<span class="nc bnc" id="L1229" title="All 2 branches missed.">        for (final Targetable enemy : enemies) {</span>
<span class="nc bnc" id="L1230" title="All 2 branches missed.">            for (final Mounted weapon : shooter.getWeaponList()) {</span>
<span class="nc" id="L1231">                final String shootingCheck = checkGuess(shooter, enemy, weapon, game);</span>
<span class="nc bnc" id="L1232" title="All 2 branches missed.">                if (null != shootingCheck) {</span>
<span class="nc" id="L1233">                    ret.append(shootingCheck);</span>
                }
<span class="nc" id="L1235">            }</span>
            String physicalCheck;
<span class="nc" id="L1237">            physicalCheck = checkGuessPhysical(shooter, enemy, PhysicalAttackType.RIGHT_KICK, game);</span>
<span class="nc bnc" id="L1238" title="All 2 branches missed.">            if (null != physicalCheck) {</span>
<span class="nc" id="L1239">                ret.append(physicalCheck);</span>
            }
<span class="nc" id="L1241">            physicalCheck = checkGuessPhysical(shooter, enemy, PhysicalAttackType.LEFT_KICK, game);</span>
<span class="nc bnc" id="L1242" title="All 2 branches missed.">            if (null != physicalCheck) {</span>
<span class="nc" id="L1243">                ret.append(physicalCheck);</span>
            }
<span class="nc" id="L1245">            physicalCheck = checkGuessPhysical(shooter, enemy, PhysicalAttackType.RIGHT_PUNCH, game);</span>
<span class="nc bnc" id="L1246" title="All 2 branches missed.">            if (null != physicalCheck) {</span>
<span class="nc" id="L1247">                ret.append(physicalCheck);</span>
            }
<span class="nc" id="L1249">            physicalCheck = checkGuessPhysical(shooter, enemy, PhysicalAttackType.LEFT_PUNCH, game);</span>
<span class="nc bnc" id="L1250" title="All 2 branches missed.">            if (null != physicalCheck) {</span>
<span class="nc" id="L1251">                ret.append(physicalCheck);</span>
            }

<span class="nc" id="L1254">        }</span>
<span class="nc" id="L1255">        return ret.toString();</span>
    }

    /**
     * calculates the 'utility' of a firing plan. override this function if you
     * have a better idea about what firing plans are good
     *
     * @param firingPlan
     *            The {@link FiringPlan} to be calculated.
     * @param overheatTolerance
     *            How much overheat we're willing to forgive.
     * @param shooterIsAero
     *            Set TRUE if the shooter is an Aero unit. Overheating Aeros
     *            take stiffer penalties.
     */
    void calculateUtility(final FiringPlan firingPlan,
                          final int overheatTolerance,
                          final boolean shooterIsAero) {
<span class="fc" id="L1273">        int overheat = 0;</span>
<span class="fc bfc" id="L1274" title="All 2 branches covered.">        if (firingPlan.getHeat() &gt; overheatTolerance) {</span>
<span class="fc" id="L1275">            overheat = firingPlan.getHeat() - overheatTolerance;</span>
        }

<span class="fc" id="L1278">        double modifier = 1;</span>
<span class="fc" id="L1279">        modifier += calcCommandUtility(firingPlan.getTarget());</span>
<span class="fc" id="L1280">        modifier += calcStrategicBuildingTargetUtility(firingPlan.getTarget());</span>
<span class="fc" id="L1281">        modifier += calcPriorityUnitTargetUtility(firingPlan.getTarget());</span>

<span class="fc" id="L1283">        double expectedDamage = firingPlan.getExpectedDamage();</span>
<span class="fc" id="L1284">        double utility = 0;</span>
<span class="fc" id="L1285">        utility += DAMAGE_UTILITY * expectedDamage;</span>
<span class="fc" id="L1286">        utility += CRITICAL_UTILITY * firingPlan.getExpectedCriticals();</span>
<span class="fc" id="L1287">        utility += KILL_UTILITY * firingPlan.getKillProbability();</span>
        // Multiply the combined damage/crit/kill utility for a target by a log-scaled factor based on the target's damage potential.
<span class="fc" id="L1289">        utility *= calcTargetPotentialDamageMultiplier(firingPlan.getTarget());</span>
<span class="fc" id="L1290">        utility += TARGET_HP_FRACTION_DEALT_UTILITY * calcDamageAllocationUtility(firingPlan.getTarget(), expectedDamage);</span>
<span class="fc" id="L1291">        utility -= calcCivilianTargetDisutility(firingPlan.getTarget());</span>
<span class="fc" id="L1292">        utility *= modifier;</span>
<span class="pc bpc" id="L1293" title="1 of 2 branches missed.">        utility -= (shooterIsAero ? OVERHEAT_DISUTILITY_AERO : OVERHEAT_DISUTILITY) * overheat;</span>
<span class="fc bfc" id="L1294" title="All 2 branches covered.">        utility -= (firingPlan.getTarget() instanceof MechWarrior) ? EJECTED_PILOT_DISUTILITY : 0;</span>
<span class="fc" id="L1295">        firingPlan.setUtility(utility);</span>
<span class="fc" id="L1296">    }</span>

    protected double calcStrategicBuildingTargetUtility(final Targetable target) {
<span class="fc bfc" id="L1299" title="All 2 branches covered.">        if (!(target instanceof BuildingTarget)) {</span>
<span class="fc" id="L1300">            return 0;</span>
        }

<span class="fc" id="L1303">        final DecimalFormat coordsFormat = new DecimalFormat(&quot;00&quot;);</span>
<span class="fc" id="L1304">        final Coords targetCoords = target.getPosition();</span>
<span class="fc" id="L1305">        final String coords = coordsFormat.format(targetCoords.getX() + 1) + coordsFormat.format(targetCoords.getY() + 1);</span>
<span class="fc bfc" id="L1306" title="All 2 branches covered.">        if (owner.getBehaviorSettings().getStrategicBuildingTargets().contains(coords)) {</span>
<span class="fc" id="L1307">            return STRATEGIC_TARGET_UTILITY;</span>
        }
<span class="fc" id="L1309">        return 0;</span>
    }

    protected double calcPriorityUnitTargetUtility(final Targetable target) {
<span class="fc bfc" id="L1313" title="All 2 branches covered.">        if (!(target instanceof Entity)) {</span>
<span class="fc" id="L1314">            return 0;</span>
        }

<span class="fc" id="L1317">        final int id = ((Entity) target).getId();</span>
<span class="fc bfc" id="L1318" title="All 2 branches covered.">        if (owner.getPriorityUnitTargets().contains(id)) {</span>
<span class="fc" id="L1319">            return PRIORITY_TARGET_UTILITY;</span>
        }
<span class="fc" id="L1321">        return 0;</span>
    }

    protected double calcCivilianTargetDisutility(final Targetable target) {
<span class="fc bfc" id="L1325" title="All 2 branches covered.">        if (!(target instanceof Entity)) {</span>
<span class="fc" id="L1326">            return 0;</span>
        }
<span class="fc" id="L1328">        final Entity entity = (Entity) target;</span>
<span class="fc bfc" id="L1329" title="All 2 branches covered.">        if (entity.isMilitary()) {</span>
<span class="fc" id="L1330">            return 0;</span>
        }
<span class="pc bpc" id="L1332" title="1 of 2 branches missed.">        if (owner.getPriorityUnitTargets().contains(entity.getId())) {</span>
<span class="nc" id="L1333">            return 0;</span>
        }
<span class="pc bpc" id="L1335" title="1 of 2 branches missed.">        if (owner.getHonorUtil().isEnemyDishonored(entity.getOwnerId())) {</span>
<span class="nc" id="L1336">            return 0;</span>
        }
<span class="fc" id="L1338">        return CIVILIAN_TARGET_DISUTILITY;</span>
    }

    protected double calcCommandUtility(final Targetable target) {
<span class="fc bfc" id="L1342" title="All 2 branches covered.">        if (!(target instanceof Entity)) {</span>
<span class="fc" id="L1343">            return 0;</span>
        }

<span class="fc" id="L1346">        final Entity entity = (Entity) target;</span>
<span class="fc bfc" id="L1347" title="All 2 branches covered.">        if (isCommander(entity)) {</span>
<span class="fc" id="L1348">            return COMMANDER_UTILITY;</span>
<span class="fc bfc" id="L1349" title="All 2 branches covered.">        } else if (isSubCommander(entity)) {</span>
<span class="fc" id="L1350">            return SUB_COMMANDER_UTILITY;</span>
        }
<span class="fc" id="L1352">        return 0;</span>
    }

    protected boolean isCommander(final Entity entity) {
<span class="nc bnc" id="L1356" title="All 2 branches missed.">        if (owner.getFireControlState().commanderCached(entity)) {</span>
<span class="nc" id="L1357">            return owner.getFireControlState().isCommander(entity);</span>
        } 

<span class="nc" id="L1360">        owner.getFireControlState().setCommander(entity, </span>
<span class="nc bnc" id="L1361" title="All 8 branches missed.">                entity.isCommander() || entity.hasC3M() || entity.hasC3i() || entity.hasC3MM() ||</span>
<span class="nc bnc" id="L1362" title="All 2 branches missed.">                (owner.getHighestEnemyInitiativeId() == entity.getId()));</span>
            
<span class="nc" id="L1364">        return owner.getFireControlState().isCommander(entity);</span>
    }

    protected boolean isSubCommander(final Entity entity) {
<span class="nc bnc" id="L1368" title="All 2 branches missed.">        if (owner.getFireControlState().subCommanderCached(entity)) {</span>
<span class="nc" id="L1369">            return owner.getFireControlState().isSubCommander(entity);</span>
        }

<span class="nc" id="L1372">        final int initBonus = entity.getHQIniBonus() + entity.getQuirkIniBonus();</span>
<span class="nc" id="L1373">        owner.getFireControlState().setSubCommander(entity, </span>
<span class="nc bnc" id="L1374" title="All 8 branches missed.">                entity.hasC3() || entity.hasTAG() || entity.hasBoostedC3() || entity.hasNovaCEWS() ||</span>
<span class="nc bnc" id="L1375" title="All 8 branches missed.">               entity.isUsingSpotlight() || entity.hasBAP() || entity.hasActiveECM() || entity.hasActiveECCM() ||</span>
<span class="nc bnc" id="L1376" title="All 6 branches missed.">               entity.hasQuirk(OptionsConstants.QUIRK_POS_IMPROVED_SENSORS) || entity.hasEiCockpit() ||</span>
               (0 &lt; initBonus));
            
<span class="nc" id="L1379">        return owner.getFireControlState().isSubCommander(entity);</span>
    }

    /**
     * Calculates the utility value for doing the given amount of damage to the
     * given target, taking into account damage already applied to this unit by
     * other units belonging to this player(not including allied players!) This
     * utility term is intended to function as a penalty for overkilling targets
     * with fire from multiple units. As such, below certain(high) thresholds,
     * the term does nothing. Only when doing &gt;50% of a target's HP this round
     * is a weight against this FiringPlan applied. In theory, since this term
     * scales linearly independently of the numeric damage dealt to a target,
     * this term will have a larger effect on low-damage units and a smaller
     * effect on high-damage units, which is probably okay for now(since really
     * high damage units tend to overkill as a matter of course more often). In
     * practice, this utility term results in Princess concentrating her fire
     * enough to reliably kill/cripple targets without falling into serious
     * overkill.
     */
    double calcDamageAllocationUtility(final Targetable target,
                                       final double expectedDamage) {

<span class="nc" id="L1401">        final double existingDamage = owner.getDamageAlreadyAssigned(target);</span>
<span class="nc" id="L1402">        final int targetHP = Compute.getTargetTotalHP(owner.getGame(), target);</span>
<span class="nc" id="L1403">        final double damageFraction = (existingDamage + expectedDamage) / ((double) targetHP);</span>
<span class="nc" id="L1404">        final double previousDamageFraction = existingDamage / ((double) targetHP);</span>

        //Do not shoot at units we already expect to deal more than their total HP of damage to!
<span class="nc bnc" id="L1407" title="All 2 branches missed.">        if (1.0 &lt;= previousDamageFraction) {</span>
<span class="nc" id="L1408">            return 100; </span>

            // In cases that are not generally overkill(less than 50% of the
            // target's total HP in damage), target as normal(don't want to
            // spread damage in these cases).
            // Also want to disregard damage allocation weighting if the target
            // is a building or infantry/BA(as they don't die until you do 100%
            // damage to them normally).
<span class="nc bnc" id="L1416" title="All 2 branches missed.">        } else if (0.5 &gt; damageFraction</span>
<span class="nc bnc" id="L1417" title="All 2 branches missed.">                   || Targetable.TYPE_BUILDING == target.getTargetType()</span>
<span class="nc bnc" id="L1418" title="All 2 branches missed.">                   || Targetable.TYPE_HEX_CLEAR == target.getTargetType()</span>
<span class="nc bnc" id="L1419" title="All 2 branches missed.">                   || owner.getGame().getEntity(target.getTargetId()) instanceof Infantry) {</span>
<span class="nc" id="L1420">            return 0;</span>
        }
        //In the remaining case(0.5&lt;=damage), return the fraction of target HP dealt as the penalty scaling factor(multiplied by the weight value to produce a penalty).
<span class="nc" id="L1423">        return damageFraction;</span>
    }

    /**
     * Calculates the potential damage that the target could theoretically
     * deliver as a measure of it's potential &quot;threat&quot; to any allied unit on the
     * board, thus prioritizing highly damaging enemies over less damaging ones.
     * For now, this works by simply getting the max damage of the target at
     * range=1, ignoring to-hit, heat, etc.
     */
    private double calcTargetPotentialDamage(final Targetable target) {
<span class="fc bfc" id="L1434" title="All 2 branches covered.">        if (!(target instanceof Entity)) {</span>
<span class="fc" id="L1435">            return 0;</span>
        }
<span class="fc" id="L1437">        final Entity entity = (Entity) target;</span>
<span class="fc" id="L1438">        return getMaxDamageAtRange(entity,1,false,false);</span>
    }

    /**
     * Calculates the logarithmic scaling factor for target damage potential in
     * the utility equation, using the target's potential damage, the weight
     * value TARGET_POTENTIAL_DAMAGE_UTILITY, and Princess's self-preservation
     * value. This is mostly here to not clutter up the utility calculation
     * method with all this extra math.
     */
    protected double calcTargetPotentialDamageMultiplier(final Targetable target) {
<span class="fc" id="L1449">        final double target_damage = calcTargetPotentialDamage(target);</span>
<span class="pc bpc" id="L1450" title="1 of 2 branches missed.">        if (0.0 == target_damage) { // Do not calculate for zero damage units.</span>
<span class="fc" id="L1451">            return 1.0;</span>
        }
<span class="nc" id="L1453">        final double self_preservation = owner.getBehaviorSettings().getSelfPreservationValue();</span>
<span class="nc" id="L1454">        final double max_self_preservation = owner.getBehaviorSettings()</span>
<span class="nc" id="L1455">                                                  .getSelfPreservationValue(10); // the preservation value of the highest index, i.e. the max value.</span>
<span class="nc" id="L1456">        final double preservation_scaling_factor = max_self_preservation / self_preservation; // Because the variance in log value for large numbers is smaller, we need to make a big self-preservation value become a small multiplicative factor, and vice versa.</span>
<span class="nc" id="L1457">        return Math.log10(TARGET_POTENTIAL_DAMAGE_UTILITY * preservation_scaling_factor * target_damage + 10); // Add 10 to make the multiplier scale from 1 upwards(1 being a target that does 0 damage)).</span>
    }
        
    /**
     * calculates the 'utility' of a physical action.
     *
     * @param physicalInfo The {@link PhysicalInfo} to be calculated.
     */
    void calculateUtility(final PhysicalInfo physicalInfo) {

        // If we can't hit, there's no point.
<span class="fc bfc" id="L1468" title="All 2 branches covered.">        if (0.0 &gt;= physicalInfo.getProbabilityToHit()) {</span>
<span class="fc" id="L1469">            physicalInfo.setUtility(-10000);</span>
<span class="fc" id="L1470">            return;</span>
        }

<span class="fc" id="L1473">        double utility = DAMAGE_UTILITY * physicalInfo.getExpectedDamage();</span>
<span class="fc" id="L1474">        utility += CRITICAL_UTILITY * physicalInfo.getExpectedCriticals();</span>
<span class="fc" id="L1475">        utility += KILL_UTILITY * physicalInfo.getKillProbability();</span>
<span class="fc" id="L1476">        utility *= calcTargetPotentialDamageMultiplier(physicalInfo.getTarget());</span>
<span class="fc bfc" id="L1477" title="All 2 branches covered.">        utility -= (physicalInfo.getTarget() instanceof MechWarrior) ? EJECTED_PILOT_DISUTILITY : 0;</span>
<span class="fc" id="L1478">        utility += calcCommandUtility(physicalInfo.getTarget());</span>
<span class="fc" id="L1479">        utility += calcStrategicBuildingTargetUtility(physicalInfo.getTarget());</span>
<span class="fc" id="L1480">        utility += calcPriorityUnitTargetUtility(physicalInfo.getTarget());</span>
<span class="fc" id="L1481">        utility -= calcCivilianTargetDisutility(physicalInfo.getTarget());</span>

<span class="fc" id="L1483">        physicalInfo.setUtility(utility);</span>
<span class="fc" id="L1484">    }</span>

    /**
     * Creates a new {@link WeaponFireInfo} object containing data about firing
     * the given weapon at the given target.
     *
     * @param shooter
     *            The unit doing the shooting.
     * @param shooterState
     *            The current state of the shooter.
     * @param target
     *            The target being fired on.
     * @param targetState
     *            The current state of the target.
     * @param weapon
     *            The weapon being fired.
     * @param game
     *            The game being played.
     * @param guessToHit
     *            Set TRUE to estimate the odds to hit rather than doing the
     *            full calculation.
     * @return The resulting {@link WeaponFireInfo}.
     */
    WeaponFireInfo buildWeaponFireInfo(final Entity shooter,
                                       final EntityState shooterState,
                                       final Targetable target,
                                       final EntityState targetState,
                                       final Mounted weapon,
                                       final IGame game,
                                       final boolean guessToHit) {
<span class="nc" id="L1514">        return new WeaponFireInfo(shooter, shooterState, target, targetState,</span>
                weapon, game, guessToHit, owner);
    }

    /**
     * Creates a new {@link WeaponFireInfo} object containing data about firing the given weapon at the given target.
     *
     * @param shooter               The unit doing the shooting.
     * @param flightPath            The path the unit flies over this turn.
     * @param target                The target being fired on.
     * @param targetState           The current state of the target.
     * @param weapon                The weapon being fired.
     * @param game                  The game being played.
     * @param assumeUnderFlightPath Set TRUE to assume the target is under the flight path and avoid doing the full
     *                              calculation.
     * @param guessToHit            Set TRUE to estimate the odds to hit rather than doing the full calculation.
     * @return The resulting {@link WeaponFireInfo}.
     */
    WeaponFireInfo buildWeaponFireInfo(final Entity shooter,
                                       final MovePath flightPath,
                                       final Targetable target,
                                       final EntityState targetState,
                                       final Mounted weapon,
                                       final IGame game,
                                       final boolean assumeUnderFlightPath,
                                       final boolean guessToHit) {
<span class="nc" id="L1540">        return new WeaponFireInfo(shooter, flightPath, target, targetState,</span>
                weapon, game, assumeUnderFlightPath, guessToHit, owner, new int[0]);
    }
    
    /**
     * Creates a new {@link WeaponFireInfo} object containing data about firing the given weapon at the given target.
     *
     * @param shooter               The unit doing the shooting.
     * @param flightPath            The path the unit flies over this turn.
     * @param target                The target being fired on.
     * @param targetState           The current state of the target.
     * @param weapon                The weapon being fired.
     * @param game                  The game being played.
     * @param assumeUnderFlightPath Set TRUE to assume the target is under the flight path and avoid doing the full
     *                              calculation.
     * @param guessToHit            Set TRUE to estimate the odds to hit rather than doing the full calculation.
     * @param bombPayload           The bomb payload, as described in WeaponAttackAction.setBombPayload
     * @return The resulting {@link WeaponFireInfo}.
     */
    private WeaponFireInfo buildWeaponFireInfo(final Entity shooter,
                                               final MovePath flightPath,
                                               final Targetable target,
                                               @SuppressWarnings(&quot;SameParameterValue&quot;) final EntityState targetState,
                                               final Mounted weapon,
                                               final IGame game,
                                               final boolean assumeUnderFlightPath,
                                               final boolean guessToHit,
                                               final int[] bombPayload) {
<span class="nc" id="L1568">        return new WeaponFireInfo(shooter, flightPath, target, targetState,</span>
                weapon, game, assumeUnderFlightPath, guessToHit, owner, bombPayload);
    }

    /**
     * Creates a new {@link WeaponFireInfo} object containing data about firing the given weapon at the given target.
     *
     * @param shooter    The unit doing the shooting.
     * @param target     The target being fired on.
     * @param weapon     The weapon being fired.
     * @param game       The game being played.
     * @param guessToHit Set TRUE to estimate the odds to hit rather than doing the full calculation.
     * @return The resulting {@link WeaponFireInfo}.
     */
    WeaponFireInfo buildWeaponFireInfo(final Entity shooter,
                                       final Targetable target,
                                       final Mounted weapon,
                                       final IGame game,
                                       final boolean guessToHit) {
<span class="nc" id="L1587">        return new WeaponFireInfo(shooter, target, weapon, game, guessToHit, owner);</span>
    }

    /**
     * Creates a firing plan that fires all weapons with nonzero to hit value at
     * a target ignoring heat, and using best guess from different states. Does
     * not change facing.
     *
     * @param shooter
     *            The unit doing the shooting.
     * @param shooterState
     *            The current state of the shooter.
     * @param target
     *            The unit being fired on.
     * @param targetState
     *            The current state of the target.
     * @param game
     *            The game being played.
     * @return The {@link FiringPlan} containing all weapons to be fired.
     */
    FiringPlan guessFullFiringPlan(final Entity shooter,
                                   @Nullable EntityState shooterState,
                                   final Targetable target,
                                   @Nullable EntityState targetState,
                                   final IGame game) {
<span class="pc bpc" id="L1612" title="1 of 2 branches missed.">        if (null == shooterState) {</span>
<span class="nc" id="L1613">            shooterState = new EntityState(shooter);</span>
        }
<span class="pc bpc" id="L1615" title="1 of 2 branches missed.">        if (null == targetState) {</span>
<span class="nc" id="L1616">            targetState = new EntityState(target);</span>
        }

<span class="fc" id="L1619">        final FiringPlan myPlan = new FiringPlan(target);</span>

        // Shooting isn't possible if one of us isn't on the board.
<span class="pc bpc" id="L1622" title="1 of 4 branches missed.">        if ((null == shooter.getPosition()) || shooter.isOffBoard() ||</span>
<span class="pc bpc" id="L1623" title="1 of 2 branches missed.">            !game.getBoard().contains(shooter.getPosition())) {</span>
<span class="fc" id="L1624">            owner.getLogger().error(&quot;Shooter's position is NULL/Off Board!&quot;);</span>
<span class="fc" id="L1625">            return myPlan;</span>
        }
<span class="pc bpc" id="L1627" title="2 of 6 branches missed.">        if ((null == target.getPosition()) || target.isOffBoard() || !game.getBoard().contains(target.getPosition())) {</span>
<span class="fc" id="L1628">            owner.getLogger().error(&quot;Target's position is NULL/Off Board!&quot;);</span>
<span class="fc" id="L1629">            return myPlan;</span>
        }

        // cycle through my weapons
<span class="fc bfc" id="L1633" title="All 2 branches covered.">        for (final Mounted weapon : shooter.getWeaponList()) {</span>
        	// respect restriction on manual AMS firing.
<span class="pc bpc" id="L1635" title="1 of 2 branches missed.">        	if(!game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_MANUAL_AMS) &amp;&amp;</span>
<span class="nc bnc" id="L1636" title="All 2 branches missed.">        			weapon.getType().hasFlag(WeaponType.F_AMS)) {</span>
<span class="nc" id="L1637">        		continue;</span>
        	}
        	
<span class="fc" id="L1640">            final WeaponFireInfo shoot = buildWeaponFireInfo(shooter,</span>
                                                             shooterState,
                                                             target,
                                                             targetState,
                                                             weapon,
                                                             game,
                                                             true);

<span class="fc bfc" id="L1648" title="All 2 branches covered.">            if (0 &lt; shoot.getProbabilityToHit()) {</span>
<span class="fc" id="L1649">                myPlan.add(shoot);</span>
            }
<span class="fc" id="L1651">        }</span>

        // Rank how useful this plan is.
<span class="fc" id="L1654">        calculateUtility(myPlan, calcHeatTolerance(shooter, null), shooterState.isAero());</span>
        
        // if we're in a position to drop bombs because we're an aircraft on a ground map, then
        // the &quot;alpha strike&quot; may be a bombing plan.
<span class="pc bpc" id="L1658" title="1 of 2 branches missed.">        if(shooter.isAirborneAeroOnGroundMap()) {</span>
<span class="nc" id="L1659">            final FiringPlan bombingPlan = this.getDiveBombPlan(shooter, null, target, game, shooter.passedOver(target), true);</span>
<span class="nc" id="L1660">            calculateUtility(bombingPlan, Entity.DOES_NOT_TRACK_HEAT, true); // bomb drops never cause heat</span>
            
<span class="nc bnc" id="L1662" title="All 2 branches missed.">            if(bombingPlan.getUtility() &gt; myPlan.getUtility()) {</span>
<span class="nc" id="L1663">                return bombingPlan;</span>
            }
        }
        
<span class="fc" id="L1667">        return myPlan;</span>
    }

    /**
     * Creates a firing plan that fires all weapons with nonzero to hit value in a air to ground strike
     *
     * @param shooter               The unit doing the shooting.
     * @param target                The unit being fired on.
     * @param targetState           The current state of the target.
     * @param flightPath            The path the shooter is flying over.
     * @param game                  The game being played.
     * @param assumeUnderFlightPath Set TRUE to automatically assume the target will be under the flight path rather
     *                              than going through the full calculation.
     * @return The {@link FiringPlan} containing all weapons to be fired.
     */
    FiringPlan guessFullAirToGroundPlan(final Entity shooter,
                                        final Targetable target,
                                        @Nullable EntityState targetState,
                                        final MovePath flightPath,
                                        final IGame game,
                                        final boolean assumeUnderFlightPath) {
<span class="pc bpc" id="L1688" title="1 of 2 branches missed.">        if (null == targetState) {</span>
<span class="nc" id="L1689">            targetState = new EntityState(target);</span>
        }

        // Must fly over the target to hit it.
<span class="pc bpc" id="L1693" title="3 of 4 branches missed.">        if (!assumeUnderFlightPath &amp;&amp; !isTargetUnderFlightPath(flightPath, targetState)) {</span>
<span class="nc" id="L1694">            return new FiringPlan(target);</span>
        }

<span class="fc" id="L1697">        final FiringPlan myPlan = new FiringPlan(target);</span>

        // Shooting isn't possible if one of us isn't on the board.
<span class="pc bpc" id="L1700" title="1 of 4 branches missed.">        if ((null == shooter.getPosition()) || shooter.isOffBoard() ||</span>
<span class="pc bpc" id="L1701" title="1 of 2 branches missed.">            !game.getBoard().contains(shooter.getPosition())) {</span>
<span class="fc" id="L1702">            owner.getLogger().error(&quot;Shooter's position is NULL/Off Board!&quot;);</span>
<span class="fc" id="L1703">            return myPlan;</span>
        }

<span class="pc bpc" id="L1706" title="2 of 6 branches missed.">        if ((null == target.getPosition()) || target.isOffBoard() || !game.getBoard().contains(target.getPosition())) {</span>
<span class="fc" id="L1707">            owner.getLogger().error(&quot;Target's position is NULL/Off Board!&quot;);</span>
<span class="fc" id="L1708">            return myPlan;</span>
        }
        
        // if we have no bombs on board, we can't attack from down here
<span class="pc bpc" id="L1712" title="1 of 2 branches missed.">        if (AeroGroundPathFinder.NAP_OF_THE_EARTH &gt;= flightPath.getFinalAltitude() &amp;&amp;</span>
<span class="nc bnc" id="L1713" title="All 2 branches missed.">            0 == shooter.getBombs(BombType.F_GROUND_BOMB).size()) {</span>
<span class="nc" id="L1714">            owner.getLogger().error(&quot;Shooter will crash if striking at altitude 1!&quot;);</span>
<span class="nc" id="L1715">            return myPlan;</span>
        }

<span class="pc bpc" id="L1718" title="1 of 2 branches missed.">        if (AeroGroundPathFinder.OPTIMAL_STRIKE_ALTITUDE &lt; flightPath.getFinalAltitude()) {</span>
<span class="nc" id="L1719">            owner.getLogger().error(&quot;Shooter's altitude is too high!&quot;);</span>
<span class="nc" id="L1720">            return myPlan;</span>
        }

        // cycle through my weapons
<span class="fc bfc" id="L1724" title="All 2 branches covered.">        for (final Mounted weapon : shooter.getWeaponList()) {</span>
            // bombing attacks have to be carried out separately from other weapon attacks, so we handle them in a special case
<span class="pc bpc" id="L1726" title="1 of 2 branches missed.">            if(weapon.isGroundBomb()) {</span>
<span class="nc" id="L1727">                continue;</span>
            }

<span class="fc" id="L1730">            final WeaponFireInfo shoot = buildWeaponFireInfo(shooter,</span>
                                                             flightPath,
                                                             target,
                                                             targetState,
                                                             weapon,
                                                             game,
                                                             true,
                                                             true);

            // for now, just fire weapons that will do damage until we get to heat capacity
<span class="fc bfc" id="L1740" title="All 2 branches covered.">            if (0 &lt; shoot.getProbabilityToHit() &amp;&amp;</span>
<span class="pc bpc" id="L1741" title="1 of 2 branches missed.">                myPlan.getHeat() + shoot.getHeat() + shooter.getHeat() &lt;= shooter.getHeatCapacity() &amp;&amp;</span>
<span class="pc bpc" id="L1742" title="1 of 2 branches missed.">                0 &lt; shoot.getExpectedDamage()) {</span>
<span class="fc" id="L1743">                myPlan.add(shoot);</span>
            }
<span class="fc" id="L1745">        }</span>
        
        // if we are here, we have already confirmed the target is under the flight path and are guessing
<span class="fc" id="L1748">        final FiringPlan bombPlan = getDiveBombPlan(shooter, flightPath, target, game, true, true);</span>
<span class="fc" id="L1749">        calculateUtility(bombPlan, Entity.DOES_NOT_TRACK_HEAT, shooter.isAero()); // bombs don't generate heat so don't bother with this calculation</span>
        
        // Rank how useful this plan is.
<span class="fc" id="L1752">        calculateUtility(myPlan, calcHeatTolerance(shooter, null), shooter.isAero());</span>
        
<span class="pc bpc" id="L1754" title="1 of 2 branches missed.">        if(myPlan.getUtility() &gt;= bombPlan.getUtility()) {</span>
<span class="fc" id="L1755">            return myPlan;</span>
        } else {
<span class="nc" id="L1757">            return bombPlan;</span>
        }
    }
   
    /**
     * Creates a firing plan that fires dive bombs, dropping all bombs on the given target
     *
     * @param shooter               The unit doing the shooting.
     * @param target                The unit being fired on.
     * @param game                  The game being played.
     * @param passedOverTarget      Set TRUE to automatically assume the target will be under the flight path rather
     *                              than going through the full calculation.
     * @param guess                 Whether we're just thinking about this firing plan or about to                              
     * @return The {@link FiringPlan} containing all bombs on target, if the shooter is capable of dropping bombs.
     */
    private FiringPlan getDiveBombPlan(final Entity shooter,
                                      final MovePath flighPath,
                                      final Targetable target,
                                       final IGame game,
                                      final boolean passedOverTarget,
                                      final boolean guess) {
<span class="fc" id="L1778">        final FiringPlan diveBombPlan = new FiringPlan(target);</span>
<span class="fc" id="L1779">        final HexTarget hexToBomb = new HexTarget(target.getPosition(), game.getBoard(), </span>
<span class="pc bpc" id="L1780" title="1 of 2 branches missed.">                shooter.isAero() ? Targetable.TYPE_HEX_AERO_BOMB : Targetable.TYPE_HEX_BOMB);</span>

        // things that cause us to avoid calculating a bomb plan:
        // not having any bombs (in the first place)
<span class="fc" id="L1784">        final Iterator&lt;Mounted&gt; weaponIter = shooter.getWeapons();</span>
<span class="pc bpc" id="L1785" title="1 of 2 branches missed.">        if (null == weaponIter) {</span>
<span class="fc" id="L1786">            return diveBombPlan;</span>
        }
        
        // not having any bombs (due to expenditure/damage)
<span class="nc bnc" id="L1790" title="All 2 branches missed.">        if(shooter.getBombs(BombType.F_GROUND_BOMB).size() == 0) {</span>
<span class="nc" id="L1791">            return diveBombPlan;</span>
        }

<span class="nc bnc" id="L1794" title="All 2 branches missed.">        while (weaponIter.hasNext()) {</span>
<span class="nc" id="L1795">            final Mounted weapon = weaponIter.next();</span>
<span class="nc bnc" id="L1796" title="All 2 branches missed.">            if(weapon.getType().hasFlag(WeaponType.F_DIVE_BOMB)) {</span>
<span class="nc" id="L1797">                final int[] bombPayload = new int[BombType.B_NUM];</span>
                // load up all droppable bombs, yeah baby! Mix thunder bombs and infernos 'cause why the hell not.
                // seriously, though, TODO: more intelligent bomb drops
<span class="nc bnc" id="L1800" title="All 2 branches missed.">                for (final Mounted bomb : shooter.getBombs(BombType.F_GROUND_BOMB)) {</span>
<span class="nc" id="L1801">                    bombPayload[((BombType) bomb.getType()).getBombType()]++;</span>
<span class="nc" id="L1802">                }</span>

<span class="nc" id="L1804">                final WeaponFireInfo diveBomb = buildWeaponFireInfo(shooter,</span>
                                                                    flighPath,
                                                                    hexToBomb,
                                                                    null,
                                                                    weapon,
                                                                    game,
                                                                    passedOverTarget,
                                                                    guess,
                                                                    bombPayload);
<span class="nc" id="L1813">                diveBombPlan.add(diveBomb);</span>
            }
<span class="nc" id="L1815">        }</span>
        
<span class="nc" id="L1817">        return diveBombPlan;</span>
    }

    /**
     * Creates a firing plan that fires all weapons with nonzero to hit value at a target ignoring heat, and using
     * actual game rules from different states
     *
     * @param shooter The unit doing the shooting.
     * @param target  The unit being fired on.
     * @param game    The game being played.
     * @return The {@link FiringPlan} containing all weapons to be fired.
     */
    FiringPlan getFullFiringPlan(final Entity shooter,
                                 final Targetable target,
                                 final Map&lt;Mounted, Double&gt; ammoConservation,
                                 final IGame game) {
<span class="fc" id="L1833">        final NumberFormat DECF = new DecimalFormat(&quot;0.000&quot;);</span>

<span class="fc" id="L1835">        final FiringPlan myPlan = new FiringPlan(target);</span>

        // Shooting isn't possible if one of us isn't on the board.
<span class="pc bpc" id="L1838" title="1 of 4 branches missed.">        if ((null == shooter.getPosition()) || shooter.isOffBoard() ||</span>
<span class="pc bpc" id="L1839" title="1 of 2 branches missed.">            !game.getBoard().contains(shooter.getPosition())) {</span>
<span class="fc" id="L1840">            owner.getLogger().error(&quot;Shooter's position is NULL/Off Board!&quot;);</span>
<span class="fc" id="L1841">            return myPlan;</span>
        }
<span class="pc bpc" id="L1843" title="2 of 6 branches missed.">        if ((null == target.getPosition()) || target.isOffBoard() || !game.getBoard().contains(target.getPosition())) {</span>
<span class="fc" id="L1844">            owner.getLogger().error(&quot;Target's position is NULL/Off Board!&quot;);</span>
<span class="fc" id="L1845">            return myPlan;</span>
        }

        // cycle through my weapons
<span class="fc bfc" id="L1849" title="All 2 branches covered.">        for (final Mounted weapon : shooter.getWeaponList()) {</span>
        	// respect restriction on manual AMS firing.
<span class="pc bpc" id="L1851" title="1 of 2 branches missed.">        	if(!game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_MANUAL_AMS) &amp;&amp;</span>
<span class="nc bnc" id="L1852" title="All 2 branches missed.">        			weapon.getType().hasFlag(WeaponType.F_AMS)) {</span>
<span class="nc" id="L1853">        		continue;</span>
        	}
        	
<span class="fc" id="L1856">        	final double toHitThreshold = ammoConservation.get(weapon);</span>
<span class="fc" id="L1857">            WeaponFireInfo shoot = buildWeaponFireInfo(shooter, target, weapon, game, false);</span>
            
            // if we're below the threshold, try switching missile modes
<span class="fc bfc" id="L1860" title="All 2 branches covered.">            if (shoot.getProbabilityToHit() &lt;= toHitThreshold) {</span>
                
<span class="fc" id="L1862">                int updatedMissileMode = switchMissileMode(weapon);</span>
                
<span class="pc bpc" id="L1864" title="1 of 2 branches missed.">                if (updatedMissileMode &gt; -1) {</span>
<span class="nc" id="L1865">                    shoot = buildWeaponFireInfo(shooter, target, weapon, game, false);</span>
<span class="nc" id="L1866">                    shoot.setUpdatedFiringMode(updatedMissileMode);</span>
                }
            }
            
<span class="fc bfc" id="L1870" title="All 2 branches covered.">            if ((shoot.getProbabilityToHit() &gt; toHitThreshold)) {</span>
<span class="fc" id="L1871">                myPlan.add(shoot);</span>
<span class="fc" id="L1872">                continue;</span>
            }            
            
<span class="fc" id="L1875">            owner.getLogger().debug(&quot;\nTo Hit Chance (&quot; + DECF.format(shoot.getProbabilityToHit()) </span>
<span class="fc" id="L1876">                      + &quot;) for &quot; + weapon.getName() +</span>
<span class="fc" id="L1877">                      &quot; is less than threshold (&quot; + DECF.format(toHitThreshold) + &quot;)&quot;);</span>
<span class="fc" id="L1878">        }</span>

        // Rank how useful this plan is.
<span class="fc" id="L1881">        calculateUtility(myPlan, calcHeatTolerance(shooter, null), shooter.isAero());</span>
        
<span class="pc bpc" id="L1883" title="1 of 2 branches missed.">        if(shooter.isAero()) {</span>
<span class="nc" id="L1884">            final FiringPlan bombingPlan = this.getDiveBombPlan(shooter, null, target, game, shooter.passedOver(target), false);</span>
<span class="nc" id="L1885">            calculateUtility(bombingPlan, Entity.DOES_NOT_TRACK_HEAT, true); // bomb drops never cause heat</span>
            
            // if the bombing plan actually involves doing something
<span class="nc bnc" id="L1888" title="All 2 branches missed.">            if((bombingPlan.size() &gt; 0) &amp;&amp; </span>
<span class="nc bnc" id="L1889" title="All 2 branches missed.">                    (bombingPlan.getUtility() &gt; myPlan.getUtility())) {</span>
<span class="nc" id="L1890">                return bombingPlan;</span>
            }
        }
        
<span class="fc" id="L1894">        return myPlan;</span>
    }
    
    protected int calcHeatTolerance(final Entity entity,
                                  @Nullable Boolean isAero) {

        // If the unit doesn't track heat, we won't worry about it.
<span class="pc bpc" id="L1901" title="1 of 2 branches missed.">        if (Entity.DOES_NOT_TRACK_HEAT == entity.getHeatCapacity()) {</span>
<span class="nc" id="L1902">            return Entity.DOES_NOT_TRACK_HEAT;</span>
        }

<span class="fc" id="L1905">        int baseTolerance = entity.getHeatCapacity() - entity.getHeat();</span>

        // if we've got a combat computer, we get an automatic
<span class="pc bpc" id="L1908" title="1 of 2 branches missed.">        if(entity.hasQuirk(OptionsConstants.QUIRK_POS_COMBAT_COMPUTER)) {</span>
<span class="nc" id="L1909">            baseTolerance += 4;</span>
        }
        
<span class="fc bfc" id="L1912" title="All 2 branches covered.">        if (null == isAero) {</span>
<span class="fc" id="L1913">            isAero = entity.isAero();</span>
        }

        // Aeros *really* don't want to overheat.
<span class="pc bpc" id="L1917" title="1 of 2 branches missed.">        if (isAero) {</span>
<span class="nc" id="L1918">            return baseTolerance;</span>
        }
        
<span class="fc" id="L1921">        return baseTolerance + 5; // todo add Heat Tolerance to Behavior Settings.</span>
    }

    /**
     * Creates an array that gives the 'best' firing plan (the maximum utility)
     * under the heat of the index
     *
     * @param shooter
     *            The unit doing the shooting.
     * @param alphaStrike
     *            The alpha strike plan.
     * @return An array of all the resulting firing plans.
     */
    FiringPlan[] calcFiringPlansUnderHeat(final Entity shooter,
                                          final FiringPlan alphaStrike) {

        // can't be lower than zero heat
<span class="fc" id="L1938">        int maxHeat = alphaStrike.getHeat();</span>
<span class="pc bpc" id="L1939" title="1 of 2 branches missed.">        if (0 &gt; maxHeat) {</span>
<span class="nc" id="L1940">            maxHeat = 0;</span>
        }

<span class="fc" id="L1943">        final Targetable target = alphaStrike.getTarget();</span>

<span class="fc" id="L1945">        final boolean isAero = shooter.isAero();</span>
<span class="fc" id="L1946">        final int heatTolerance = calcHeatTolerance(shooter, isAero);</span>

        // How many plans do I need to compute?
        final FiringPlan[] bestPlans;
<span class="pc bpc" id="L1950" title="1 of 2 branches missed.">        if (shooter instanceof Infantry) {</span>
<span class="nc" id="L1951">            bestPlans = new FiringPlan[maxHeat + 4];</span>
        } else {
<span class="fc" id="L1953">            bestPlans = new FiringPlan[maxHeat + 1];</span>
        }

        // First plan is a plan that fires only heatless weapons.
        // The remaining plans will build at least some heat.
        // we include arm flip information into the regular heat plans, but infantry don't flip arms so we don't bother.
<span class="fc" id="L1959">        bestPlans[0] = new FiringPlan(target, alphaStrike.getFlipArms());</span>
<span class="fc" id="L1960">        final FiringPlan nonZeroHeatOptions = new FiringPlan(target);</span>
<span class="fc" id="L1961">        final FiringPlan swarmAttack = new FiringPlan(target);</span>
<span class="fc" id="L1962">        final FiringPlan legAttack = new FiringPlan(target);</span>
<span class="fc" id="L1963">        final FiringPlan fieldGuns = new FiringPlan(target);</span>
<span class="fc" id="L1964">        double fieldGunMassAlreadyFired = 0.0; //We need to track the tonnage of field guns being fired, because trying to fire more than the current possible total(# of men left) results in nothing being fired.</span>
<span class="fc bfc" id="L1965" title="All 2 branches covered.">        for (final WeaponFireInfo weaponFireInfo : alphaStrike) {</span>

            //Leg and swarm attacks can't be mixed with any other attacks, so we have to consider each of those separately.
<span class="pc bpc" id="L1968" title="1 of 2 branches missed.">            if (shooter instanceof Infantry) {</span>
<span class="nc bnc" id="L1969" title="All 2 branches missed.">                if ((weaponFireInfo.getWeapon().getType()).getInternalName().equals(Infantry.LEG_ATTACK)) {</span>
<span class="nc" id="L1970">                    legAttack.add(weaponFireInfo);</span>
<span class="nc" id="L1971">                    continue;</span>
<span class="nc bnc" id="L1972" title="All 2 branches missed.">                } else if ((weaponFireInfo.getWeapon().getType()).getInternalName().equals(Infantry.SWARM_MEK)) {</span>
<span class="nc" id="L1973">                    swarmAttack.add(weaponFireInfo);</span>
<span class="nc" id="L1974">                    continue;</span>
                }
                // We probably shouldn't consider stopping swarm attacks, since Princess isn't smart enough to recognize the rare situations when this is a good idea(e.g. planning to put lots of allied fire on the swarm target next turn, target is likely to explode and ammo explosion splash damage is on, etc).
<span class="nc bnc" id="L1977" title="All 2 branches missed.">                else if ((weaponFireInfo.getWeapon().getType()) instanceof StopSwarmAttack) {</span>
<span class="nc" id="L1978">                    continue;</span>
<span class="nc bnc" id="L1979" title="All 2 branches missed.">                } else if (!(shooter instanceof BattleArmor) &amp;&amp; Infantry.LOC_FIELD_GUNS == weaponFireInfo.getWeapon()</span>
<span class="nc bnc" id="L1980" title="All 2 branches missed.">                                                                                                         .getLocation()) {</span>
<span class="nc" id="L1981">                    final double fieldGunMass = weaponFireInfo.getWeapon().getTonnage();</span>
                    //Only fire field guns up until we no longer have the men to fire more, since going over that limit results in nothing firing.
                    //In theory we could adapt the heat system to handle this(with tonnage as heat and shooting strength as heat capacity, no heat tolerance).
                    //This would behave much better for units with mixed type field guns, but given that those are rare, this should serve for now.
<span class="nc bnc" id="L1985" title="All 2 branches missed.">                    if(fieldGunMassAlreadyFired + fieldGunMass &lt;= ((Infantry)shooter).getShootingStrength()) {</span>
<span class="nc" id="L1986">                        fieldGuns.add(weaponFireInfo);</span>
<span class="nc" id="L1987">                        fieldGunMassAlreadyFired += fieldGunMass;</span>
                    }
                    continue;
                }
            }
<span class="fc bfc" id="L1992" title="All 2 branches covered.">            if (0 == weaponFireInfo.getHeat()) {</span>
<span class="fc" id="L1993">                bestPlans[0].add(weaponFireInfo);</span>
            } else {
<span class="fc" id="L1995">                nonZeroHeatOptions.add(weaponFireInfo);</span>
            }
<span class="fc" id="L1997">        }</span>
<span class="fc" id="L1998">        calculateUtility(bestPlans[0], heatTolerance, isAero);</span>
        
<span class="pc bpc" id="L2000" title="1 of 2 branches missed.">        if (shooter instanceof Infantry) {</span>
<span class="nc" id="L2001">            calculateUtility(swarmAttack, heatTolerance, isAero);</span>
<span class="nc" id="L2002">            calculateUtility(legAttack, heatTolerance, isAero);         </span>
<span class="nc" id="L2003">            calculateUtility(fieldGuns, heatTolerance, isAero);</span>
            //Add these plans to the end of the list.
<span class="nc" id="L2005">            bestPlans[maxHeat + 1] = swarmAttack;</span>
<span class="nc" id="L2006">            bestPlans[maxHeat + 2] = legAttack;</span>
<span class="nc" id="L2007">            bestPlans[maxHeat + 3] = fieldGuns;</span>
        }

        // build up heat table
<span class="fc bfc" id="L2011" title="All 2 branches covered.">        for (int heatLevel = 1; heatLevel &lt;= maxHeat; heatLevel++) {</span>
<span class="fc" id="L2012">            bestPlans[heatLevel] = new FiringPlan(target);</span>

            // Include all the firing options that exist at the last heat level.
<span class="fc" id="L2015">            bestPlans[heatLevel].addAll(bestPlans[heatLevel - 1]);</span>
<span class="fc" id="L2016">            calculateUtility(bestPlans[heatLevel], heatTolerance, isAero);</span>

<span class="fc bfc" id="L2018" title="All 2 branches covered.">            for (final WeaponFireInfo weaponFireInfo : nonZeroHeatOptions) {</span>

<span class="fc" id="L2020">                final int leftoverHeatCapacity = heatLevel - weaponFireInfo.getHeat();</span>

                // If this attack produces heat and is not already included in the plan, check its utility.
<span class="fc bfc" id="L2023" title="All 2 branches covered.">                if ((0 &lt;= leftoverHeatCapacity) &amp;&amp;</span>
<span class="fc bfc" id="L2024" title="All 2 branches covered.">                    !bestPlans[leftoverHeatCapacity].containsWeapon(weaponFireInfo.getWeapon())) {</span>

                    // make sure to pass along arm flip state from the alpha strike, if any
<span class="fc" id="L2027">                    final FiringPlan testPlan = new FiringPlan(target, alphaStrike.getFlipArms());</span>
<span class="fc" id="L2028">                    testPlan.addAll(bestPlans[heatLevel - weaponFireInfo.getHeat()]);</span>
<span class="fc" id="L2029">                    testPlan.add(weaponFireInfo);</span>
<span class="fc" id="L2030">                    calculateUtility(testPlan, heatTolerance, isAero);</span>

                    // If this plan has a higher utility, add it.
<span class="fc bfc" id="L2033" title="All 2 branches covered.">                    if (testPlan.getUtility() &gt; bestPlans[heatLevel].getUtility()) {</span>
<span class="fc" id="L2034">                        bestPlans[heatLevel] = testPlan;</span>
                    }
                }
<span class="fc" id="L2037">            }</span>
        }
        
        // if we are an aero blasting away at ground targets, another good option for a heatless plan is to bomb the crap out of the enemy
        //bombs cannot be mixed with other attack types, so we calculate it separately and overwrite the 0-heat plan if it's better
        //currently, this will probably result in the aero blowing its bomb load as soon as it passes over an enemy
        //dropping everything it has, including specialized munitions such as thunder bombs and infernos
<span class="pc bpc" id="L2044" title="3 of 4 branches missed.">        if (shooter.isAirborne() &amp;&amp; 0 &lt; shooter.getBombs(BombType.F_GROUND_BOMB).size()) {</span>
<span class="nc" id="L2045">            final FiringPlan diveBombPlan = this.getDiveBombPlan(shooter, null, target,</span>
<span class="nc" id="L2046">                                                                 shooter.getGame(), shooter.passedOver(target), false);</span>
            
<span class="nc" id="L2048">            calculateUtility(diveBombPlan, Entity.DOES_NOT_TRACK_HEAT, true);</span>
<span class="nc bnc" id="L2049" title="All 2 branches missed.">            if(diveBombPlan.getUtility() &gt; bestPlans[0].getUtility()) {</span>
<span class="nc" id="L2050">                bestPlans[0] = diveBombPlan;</span>
            }
        }
        
<span class="fc" id="L2054">        return bestPlans;</span>
    }

    /*
     * Gets the 'best' firing plan, using heat as a disutility. No twisting is
     * done
     * 
     * @param shooter The unit doing the shooting.
     * 
     * @param target The unit being shot at.
     * 
     * @param game The game currently being played.
     * 
     * @return the 'best' firing plan, using heat as a disutility.
     */
    FiringPlan getBestFiringPlan(final Entity shooter,
                                 final Targetable target,
                                 final IGame game,
                                 final Map&lt;Mounted, Double&gt; ammoConservation) {

        // Start with an alpha strike.
<span class="fc" id="L2075">        FiringPlan alphaStrike = getFullFiringPlan(shooter, target,</span>
                                                    ammoConservation, game);
        
<span class="pc bpc" id="L2078" title="1 of 2 branches missed.">        if(shooter.canFlipArms()) {</span>
<span class="nc" id="L2079">            shooter.setArmsFlipped(true, false);</span>
<span class="nc" id="L2080">            FiringPlan betaStrike = getFullFiringPlan(shooter, target, ammoConservation, game);</span>
<span class="nc" id="L2081">            betaStrike.setFlipArms(true);</span>
<span class="nc bnc" id="L2082" title="All 2 branches missed.">            if(betaStrike.getUtility() &gt; alphaStrike.getUtility()) {</span>
<span class="nc" id="L2083">                alphaStrike = betaStrike;</span>
            }
            
<span class="nc" id="L2086">            shooter.setArmsFlipped(false, false);</span>
        }
        
        // Although they don't track heat, infantry/BA do need to make tradeoffs
        // between firing different weapons, because swarm/leg attacks are
        // mutually exclusive with normal firing, so we treat them similarly to
        // heat-tracking units.
        
        // conventional fighters can drop bombs
<span class="pc bpc" id="L2095" title="1 of 2 branches missed.">        if (Entity.DOES_NOT_TRACK_HEAT == shooter.getHeatCapacity()</span>
<span class="nc bnc" id="L2096" title="All 2 branches missed.">            &amp;&amp; ((shooter.getEntityType() &amp; Entity.ETYPE_INFANTRY) == 0)) {</span>
<span class="nc" id="L2097">            return alphaStrike; // No need to worry about heat if the unit</span>
                                // doesn't track it.
        }

        // Get all the best plans that generate less heat than an alpha strike.
<span class="fc" id="L2102">        final FiringPlan[] allPlans = calcFiringPlansUnderHeat(shooter, alphaStrike);</span>

        // Determine the best plan taking into account our heat tolerance.
<span class="fc" id="L2105">        return getBestFiringPlanUnderHeat(target, shooter, allPlans);</span>
    }

    /**
     * Guesses the 'best' firing plan under a certain heat No twisting is done
     *
     * @param shooter
     *            The unit doing the shooting.
     * @param shooterState
     *            The current state of the shooting unit.
     * @param target
     *            The unit being shot at.
     * @param targetState
     *            The current state of the target unit.
     * @param maxHeat
     *            How much heat we're willing to tolerate.
     * @param game
     *            The game currently being played.
     * @return the 'best' firing plan under a certain heat.
     */
    protected FiringPlan guessBestFiringPlanUnderHeat(final Entity shooter,
                                                    @Nullable final EntityState shooterState,
                                                    final Targetable target,
                                                    @Nullable final EntityState targetState,
                                                    int maxHeat,
                                                    final IGame game) {

        // can't have less than zero heat
<span class="nc bnc" id="L2133" title="All 2 branches missed.">        if (0 &gt; maxHeat) {</span>
<span class="nc" id="L2134">            maxHeat = 0;</span>
        }

        // Start with an alpha strike. If it falls under our heat limit, use it.
<span class="nc" id="L2138">        FiringPlan alphaStrike = guessFullFiringPlan(shooter, shooterState,</span>
                                                       target, targetState, game);
        
<span class="nc bnc" id="L2141" title="All 2 branches missed.">        if(shooter.canFlipArms()) {</span>
<span class="nc" id="L2142">            shooter.setArmsFlipped(true, false);</span>
<span class="nc" id="L2143">            FiringPlan betaStrike = guessFullFiringPlan(shooter, shooterState,</span>
                                                        target, targetState, game);
<span class="nc" id="L2145">            betaStrike.setFlipArms(true);</span>
<span class="nc bnc" id="L2146" title="All 2 branches missed.">            if(betaStrike.getUtility() &gt; alphaStrike.getUtility()) {</span>
<span class="nc" id="L2147">                alphaStrike = betaStrike;</span>
            }
            
<span class="nc" id="L2150">            shooter.setArmsFlipped(false, false);</span>
        }
        
        // Infantry and BA may have alternative options, so we need to consider
        // different firing options.
<span class="nc bnc" id="L2155" title="All 4 branches missed.">        if (alphaStrike.getHeat() &lt;= maxHeat &amp;&amp; !(shooter instanceof Infantry)) {</span>
<span class="nc" id="L2156">            return alphaStrike;</span>
        }

        // Get the best firing plan that falls under our heat limit.
        // Now emulates the logic from getBestFiringPlanUnderHeat, rather than sorting the firing plans low to high then picking the lowest one
<span class="nc" id="L2161">        final FiringPlan[] heatPlans = calcFiringPlansUnderHeat(shooter, alphaStrike);</span>
<span class="nc" id="L2162">        FiringPlan bestPlan = new FiringPlan(target);</span>
        
<span class="nc bnc" id="L2164" title="All 2 branches missed.">        for (final FiringPlan firingPlan : heatPlans) {</span>
<span class="nc bnc" id="L2165" title="All 2 branches missed.">            if ((bestPlan.getUtility() &lt; firingPlan.getUtility())) {</span>
<span class="nc" id="L2166">                bestPlan = firingPlan;</span>
            }
        }
<span class="nc" id="L2169">        return bestPlan;</span>
    }

    private FiringPlan getBestFiringPlanUnderHeat(final Targetable target,
                                                  final Entity shooter,
                                                  final FiringPlan[] allPlans) {

        // Determine the best plan taking into account our heat tolerance.
<span class="fc" id="L2177">        FiringPlan bestPlan = new FiringPlan(target);</span>
<span class="fc" id="L2178">        final boolean isAero = shooter.isAero();</span>
<span class="fc" id="L2179">        final int heatTolerance = calcHeatTolerance(shooter, isAero);</span>
<span class="fc" id="L2180">        calculateUtility(bestPlan, heatTolerance, isAero);</span>
<span class="fc bfc" id="L2181" title="All 2 branches covered.">        for (final FiringPlan firingPlan : allPlans) {</span>
<span class="fc" id="L2182">            calculateUtility(firingPlan, heatTolerance, isAero);</span>
<span class="fc bfc" id="L2183" title="All 2 branches covered.">            if ((bestPlan.getUtility() &lt; firingPlan.getUtility())) {</span>
<span class="fc" id="L2184">                bestPlan = firingPlan;</span>
            }
        }
<span class="fc" id="L2187">        return bestPlan;</span>
    }

    /**
     * Figures out the best firing plan
     *
     * @param params - the appropriate firing plan calculation parameters
     * @return the 'best' firing plan - uses heat as disutility and includes the possibility of twisting
     */
    FiringPlan determineBestFiringPlan(final FiringPlanCalculationParameters params) {
        // unpack parameters for easier reference
<span class="nc" id="L2198">        final Entity shooter = params.getShooter();</span>
<span class="nc" id="L2199">        final Targetable target = params.getTarget();</span>
<span class="nc" id="L2200">        final EntityState shooterState = params.getShooterState();</span>
<span class="nc" id="L2201">        final EntityState targetState = params.getTargetState();</span>
<span class="nc" id="L2202">        final int maxHeat = params.getMaxHeat();</span>
<span class="nc" id="L2203">        final Map&lt;Mounted, Double&gt; ammoConservation = params.getAmmoConservation();</span>

        // Get the best plan without any twists.
<span class="nc" id="L2206">        FiringPlan noTwistPlan = null;</span>
        
<span class="nc bnc" id="L2208" title="All 3 branches missed.">        switch(params.getCalculationType()) {</span>
            case GET:
<span class="nc" id="L2210">                noTwistPlan = getBestFiringPlan(shooter, target, owner.getGame(), ammoConservation);</span>
<span class="nc" id="L2211">                break;</span>
            case GUESS:
<span class="nc" id="L2213">                noTwistPlan = guessBestFiringPlanUnderHeat(shooter,</span>
                                                           shooterState,
                                                           target,
                                                           targetState,
                                                           maxHeat,
<span class="nc" id="L2218">                                                           owner.getGame());</span>
                break;
        }
        
        // If we can't change facing, we're done.
<span class="nc bnc" id="L2223" title="All 2 branches missed.">        if (!params.getShooter().canChangeSecondaryFacing()) {</span>
<span class="nc" id="L2224">            return noTwistPlan;</span>
        }

        // Keep track of our original facing so we can go back to it.
<span class="nc" id="L2228">        final int originalFacing = shooter.getSecondaryFacing();</span>

<span class="nc" id="L2230">        final List&lt;Integer&gt; validFacingChanges = getValidFacingChanges(shooter);</span>
        
        // Now, we loop through all possible facings. If one facing produces a better plan 
        // than what we currently have as the best plan then use that. Start with &quot;no twist&quot; as default.
<span class="nc" id="L2234">        FiringPlan bestFiringPlan = noTwistPlan;</span>
<span class="nc bnc" id="L2235" title="All 2 branches missed.">        for (final int currentTwist : validFacingChanges) {</span>
<span class="nc" id="L2236">            shooter.setSecondaryFacing(correctFacing(originalFacing + currentTwist), false);</span>

<span class="nc" id="L2238">            FiringPlan twistPlan = null;</span>
<span class="nc bnc" id="L2239" title="All 3 branches missed.">            switch (params.getCalculationType()) {</span>
                case GET:
<span class="nc" id="L2241">                    twistPlan = getBestFiringPlan(shooter, target, owner.getGame(), ammoConservation);</span>
<span class="nc" id="L2242">                    break;</span>
                case GUESS:
<span class="nc" id="L2244">                    twistPlan = guessBestFiringPlanUnderHeat(shooter,</span>
                                                             shooterState,
                                                             target,
                                                             targetState,
                                                             maxHeat,
<span class="nc" id="L2249">                                                             owner.getGame());</span>
            }
<span class="nc" id="L2251">            twistPlan.setTwist(currentTwist);</span>

<span class="nc bnc" id="L2253" title="All 2 branches missed.">            if (twistPlan.getUtility() &gt; bestFiringPlan.getUtility()) {</span>
<span class="nc" id="L2254">                bestFiringPlan = twistPlan;</span>
            }
<span class="nc" id="L2256">        }</span>

        // Back to where we started.
<span class="nc" id="L2259">        shooter.setSecondaryFacing(originalFacing, false);</span>

<span class="nc" id="L2261">        return bestFiringPlan;</span>
    }

    /**
     * Determines if the given entity can use indirect fire as in LRMs.
     */
    public boolean entityCanIndirectFireMissile(FireControlState fireControlState, Entity shooter) {
    	// cache the results of our computation
<span class="nc bnc" id="L2269" title="All 2 branches missed.">    	if(fireControlState.getEntityIDFStates().containsKey(shooter.getId())) {</span>
<span class="nc" id="L2270">    		return fireControlState.getEntityIDFStates().get(shooter.getId());</span>
    	}
    	
    	// airborne aerospace units cannot use indirect fire
<span class="nc bnc" id="L2274" title="All 2 branches missed.">    	if(shooter.isAirborne()) {</span>
<span class="nc" id="L2275">    	    fireControlState.getEntityIDFStates().put(shooter.getId(), false);</span>
<span class="nc" id="L2276">    	    return false;</span>
    	}
    	
<span class="nc bnc" id="L2279" title="All 2 branches missed.">        for(Mounted weapon : shooter.getWeaponList()) {</span>
<span class="nc bnc" id="L2280" title="All 2 branches missed.">        	if(weapon.getType().hasModeType(Weapon.MODE_MISSILE_INDIRECT)) {</span>
<span class="nc" id="L2281">        		fireControlState.getEntityIDFStates().put(shooter.getId(), true);</span>
<span class="nc" id="L2282">        		return true;</span>
        	}
<span class="nc" id="L2284">        }</span>
        
<span class="nc" id="L2286">        fireControlState.getEntityIDFStates().put(shooter.getId(), false);</span>
<span class="nc" id="L2287">        return false;</span>
    }
    
    /**
     * Determines if the given entity (potentially employing a given firing plan)
     * can/should spot. If yes, then return a spot action.
     * @param plan
     * @param spotter
     * @return
     */
    public SpotAction getSpotAction(FiringPlan plan, Entity spotter, FireControlState fireControlState) {
    	// logic applies as follows:
    	// if I am disqualified from spotting, don't spot
    	// disqualifiers are:
    	// 		legally can't spot
    	//		am firing and don't have a command console to mitigate the spotting penalty
    	// otherwise, attempt to spot the closest enemy
<span class="nc bnc" id="L2304" title="All 8 branches missed.">    	if(spotter.isSpotting() || !spotter.canSpot() || spotter.isNarcedBy(INarcPod.HAYWIRE) || </span>
<span class="nc bnc" id="L2305" title="All 2 branches missed.">    			(plan != null) &amp;&amp; (plan.getExpectedDamage() &gt; 0) &amp;&amp; </span>
<span class="nc bnc" id="L2306" title="All 2 branches missed.">    			!spotter.getCrew().hasActiveCommandConsole()) {</span>
<span class="nc" id="L2307">    		return null;</span>
    	}
    	
<span class="nc" id="L2310">    	List&lt;Targetable&gt; enemyTargets = getAllTargetableEnemyEntities(</span>
<span class="nc" id="L2311">    			spotter.getOwner(), spotter.getGame(), fireControlState);</span>
<span class="nc" id="L2312">    	List&lt;Targetable&gt; closestTargets = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L2313">    	int shortestDistance = Integer.MAX_VALUE;</span>
    	
    	// loop through all enemy targets, pick a random one out of the closest.
    	// future revision: pick one that's the least evasive
<span class="nc bnc" id="L2317" title="All 2 branches missed.">    	for(Targetable target : enemyTargets) {</span>
<span class="nc" id="L2318">    		LosEffects effects = LosEffects.calculateLos(spotter.getGame(), spotter.getId(), target);</span>
            
            // if we're in LOS
<span class="nc bnc" id="L2321" title="All 2 branches missed.">    		if (effects.canSee()) {</span>
<span class="nc" id="L2322">    			int targetDistance = spotter.getPosition().distance(target.getPosition());</span>
<span class="nc bnc" id="L2323" title="All 2 branches missed.">    			if(targetDistance &lt; shortestDistance) {</span>
<span class="nc" id="L2324">    				shortestDistance = targetDistance;</span>
<span class="nc" id="L2325">    				closestTargets.clear();</span>
<span class="nc" id="L2326">    				closestTargets.add(target);</span>
<span class="nc bnc" id="L2327" title="All 2 branches missed.">    			} else if (targetDistance == shortestDistance) {</span>
<span class="nc" id="L2328">    				closestTargets.add(target);</span>
    			}
    		}
<span class="nc" id="L2331">    	}</span>
    	
    	// if we found one or more targets, pick at random from the closest ones.
    	// otherwise, we still can't spot
<span class="nc bnc" id="L2335" title="All 2 branches missed.">    	if(closestTargets.size() &gt; 0) {</span>
<span class="nc" id="L2336">	    	Targetable target = closestTargets.get(Compute.randomInt(closestTargets.size()));</span>
<span class="nc" id="L2337">	    	return new SpotAction(spotter.getId(), target.getTargetId());</span>
    	}
    	
<span class="nc" id="L2340">    	return null;</span>
    }
    
    /**
     * Gets all the entities that are potential targets
     *
     * @param shooter The unit doing the shooting.
     * @param game    The game being played.
     * @return A list of potential targets.
     */
    protected List&lt;Targetable&gt; getTargetableEnemyEntities(final Entity shooter,
                                                        final IGame game,
                                                        final FireControlState fireControlState) {
<span class="nc" id="L2353">        final List&lt;Targetable&gt; targetableEnemyList = new ArrayList&lt;&gt;();</span>

<span class="nc" id="L2355">        boolean shooterHasIDF = entityCanIndirectFireMissile(fireControlState, shooter);</span>
        
        // Go through every enemy unit 
<span class="nc bnc" id="L2358" title="All 2 branches missed.">        for (final Entity entity : owner.getEnemyEntities()) {</span>

            // If they are my enemy and we can either see them or have IDF capability
<span class="nc bnc" id="L2361" title="All 2 branches missed.">            if (entity.isTargetable()) {</span>

<span class="nc" id="L2363">                final LosEffects effects =</span>
<span class="nc" id="L2364">                        LosEffects.calculateLos(game, shooter.getId(), entity);</span>
                
                // if we're in LOS or we have IDF capability
<span class="nc bnc" id="L2367" title="All 4 branches missed.">                if (effects.canSee() || shooterHasIDF) {</span>
<span class="nc" id="L2368">                    targetableEnemyList.add(entity);</span>
                }
            }
<span class="nc" id="L2371">        }</span>

        // Add in potential building targets and the like.
<span class="nc" id="L2374">        targetableEnemyList.addAll(fireControlState.getAdditionalTargets());</span>

<span class="nc" id="L2376">        return targetableEnemyList;</span>
    }

    /**
     * Variation on getTargetableEnemyEntities.
     * Returns all possible enemy targets, regardless of LOS status.
     * @param player The player from whose perspective enemies are determined.
     * @param game    The game being played.
     * @return A list of potential targets.
     */
    static List&lt;Targetable&gt; getAllTargetableEnemyEntities(final IPlayer player, final IGame game, final FireControlState fireControlState) {
<span class="nc" id="L2387">        final List&lt;Targetable&gt; targetableEnemyList = new ArrayList&lt;&gt;();</span>

        // Go through every unit in the game.
<span class="nc bnc" id="L2390" title="All 2 branches missed.">        for (final Entity entity : game.getEntitiesVector()) {</span>

            // If they are my enemy and on the board, they're a target.
<span class="nc bnc" id="L2393" title="All 2 branches missed.">            if (entity.getOwner().isEnemyOf(player)</span>
<span class="nc bnc" id="L2394" title="All 2 branches missed.">                &amp;&amp; (null != entity.getPosition())</span>
<span class="nc bnc" id="L2395" title="All 2 branches missed.">                &amp;&amp; !entity.isOffBoard()</span>
<span class="nc bnc" id="L2396" title="All 2 branches missed.">                &amp;&amp; entity.isTargetable()</span>
<span class="nc bnc" id="L2397" title="All 4 branches missed.">                &amp;&amp; (null != entity.getCrew()) &amp;&amp; !entity.getCrew().isDead()) {</span>
<span class="nc" id="L2398">                targetableEnemyList.add(entity);</span>
            }
<span class="nc" id="L2400">        }</span>

        // Add in potential building targets and the like.
<span class="nc" id="L2403">        targetableEnemyList.addAll(fireControlState.getAdditionalTargets());</span>

<span class="nc" id="L2405">        return targetableEnemyList;</span>
    }

    /**
     * This is it. Calculate the 'best' possible firing plan for this entity.
     * Overload this function if you think you can do better.
     *
     * @param shooter The unit doing the shooting.
     * @param game    The game being played.
     * @return The best firing plan according to our calculations.
     */
    FiringPlan getBestFiringPlan(final Entity shooter,
                                 final IHonorUtil honorUtil,
                                 final IGame game,
                                 final Map&lt;Mounted, Double&gt; ammoConservation) {
<span class="nc" id="L2420">        FiringPlan bestPlan = null;</span>

        // Get a list of potential targets.
<span class="nc" id="L2423">        final List&lt;Targetable&gt; enemies = getTargetableEnemyEntities(shooter, game, owner.getFireControlState());</span>

        // Loop through each enemy and find the best plan for attacking them.
<span class="nc bnc" id="L2426" title="All 2 branches missed.">        for (final Targetable enemy : enemies) {</span>

<span class="nc" id="L2428">            final boolean priorityTarget = owner.getPriorityUnitTargets().contains(enemy.getTargetId());</span>

            // Skip retreating enemies so long as they haven't fired on me while retreating.
<span class="nc bnc" id="L2431" title="All 2 branches missed.">            final int playerId = (enemy instanceof Entity) ? ((Entity) enemy).getOwnerId() : -1;</span>
<span class="nc bnc" id="L2432" title="All 4 branches missed.">            if (!priorityTarget &amp;&amp; honorUtil.isEnemyBroken(enemy.getTargetId(), playerId,</span>
<span class="nc" id="L2433">                                                           owner.getForcedWithdrawal())) {</span>
<span class="nc" id="L2434">                owner.getLogger().info(enemy.getDisplayName() + &quot; is broken - ignoring&quot;);</span>
<span class="nc" id="L2435">                continue;</span>
            }

<span class="nc" id="L2438">            final FiringPlanCalculationParameters parameters =</span>
<span class="nc" id="L2439">                    new FiringPlanCalculationParameters.Builder().buildExact(shooter,</span>
                                                                             enemy,
                                                                             ammoConservation);
<span class="nc" id="L2442">            final FiringPlan plan = determineBestFiringPlan(parameters);</span>
            
<span class="nc" id="L2444">            owner.getLogger().info(shooter.getDisplayName() + &quot; at &quot; + enemy</span>
<span class="nc" id="L2445">                    .getDisplayName() + &quot; - Best Firing Plan: &quot; + plan.getDebugDescription(true));</span>
<span class="nc bnc" id="L2446" title="All 4 branches missed.">            if ((null == bestPlan) || (plan.getUtility() &gt; bestPlan.getUtility())) {</span>
<span class="nc" id="L2447">                bestPlan = plan;</span>
            }
<span class="nc" id="L2449">        }</span>
        
        // Return the best overall plan.
<span class="nc" id="L2452">        return bestPlan;</span>
    }

    /**
     * Calculates the maximum damage a unit can do at a given range.  Chance to hit is not a factor.
     *
     * @param shooter         The firing unit.
     * @param range           The range to be checked.
     * @param useExtremeRange Is the extreme range optional rule in effect?
     * @return The most damage done at that range.
     */
    // todo: cluster and other variable damage.
    public static double getMaxDamageAtRange(final Entity shooter,
                               final int range,
                               final boolean useExtremeRange,
                               final boolean useLOSRange) {
<span class="fc" id="L2468">        double maxDamage = 0;</span>

        // cycle through my weapons
<span class="pc bpc" id="L2471" title="1 of 2 branches missed.">        for (final Mounted weapon : shooter.getWeaponList()) {</span>
<span class="nc" id="L2472">            final WeaponType weaponType = (WeaponType) weapon.getType();</span>
<span class="nc" id="L2473">            final int bracket = RangeType.rangeBracket(range,</span>
<span class="nc" id="L2474">                                                       weaponType.getRanges(weapon),</span>
                                                       useExtremeRange,
                                                       useLOSRange);
            // if the weapon has been disabled or is out of ammo, don't count it
<span class="nc bnc" id="L2478" title="All 2 branches missed.">            if(weapon.isCrippled()) {</span>
<span class="nc" id="L2479">                continue;</span>
            }
            
<span class="nc" id="L2482">            int weaponDamage = weaponType.getDamage();</span>
            
            // just a ball park estimate of missile and/or other cluster damage
            // only a little over half of a cluster will generally hit
            // but some cluster munitions do more than 1 point of damage per individual hit
            // still better than just discounting them completely.
<span class="nc bnc" id="L2488" title="All 2 branches missed.">            if(weaponDamage == WeaponType.DAMAGE_BY_CLUSTERTABLE) {</span>
<span class="nc" id="L2489">                weaponDamage = weaponType.getRackSize();</span>
            }
            
<span class="nc bnc" id="L2492" title="All 4 branches missed.">            if ((RangeType.RANGE_OUT != bracket) &amp;&amp; (0 &lt; weaponDamage)) {</span>
<span class="nc" id="L2493">                maxDamage += weaponDamage;</span>
            }
<span class="nc" id="L2495">        }</span>

<span class="fc" id="L2497">        return maxDamage;</span>
    }

    /**
     * makes sure facing falls between 0 and 5 This function likely already exists somewhere else
     *
     * @param facing The facing to be corrected.
     * @return The properly adjusted facing.
     */
    public static int correctFacing(int facing) {
<span class="nc bnc" id="L2507" title="All 2 branches missed.">        while (0 &gt; facing) {</span>
<span class="nc" id="L2508">            facing += 6;</span>
        }
<span class="nc bnc" id="L2510" title="All 2 branches missed.">        if (5 &lt; facing) {</span>
<span class="nc" id="L2511">            facing = facing % 6;</span>
        }
<span class="nc" id="L2513">        return facing;</span>
    }

    /**
     * Makes sure ammo is loaded for each weapon
     */
    void loadAmmo(final Entity shooter,
                  final FiringPlan plan) {
<span class="nc bnc" id="L2521" title="All 2 branches missed.">        if (null == shooter) {</span>
<span class="nc" id="L2522">            return;</span>
        }
<span class="nc bnc" id="L2524" title="All 2 branches missed.">        if (null == plan) {</span>
<span class="nc" id="L2525">            return;</span>
        }
        
        // Loading ammo for all my weapons.
<span class="nc bnc" id="L2529" title="All 2 branches missed.">        for (final WeaponFireInfo info : plan) {</span>
<span class="nc" id="L2530">            final Mounted currentWeapon = info.getWeapon();</span>
<span class="nc bnc" id="L2531" title="All 2 branches missed.">            if (null == currentWeapon) {</span>
<span class="nc" id="L2532">                continue;</span>
            }
<span class="nc" id="L2534">            final WeaponType weaponType = (WeaponType) currentWeapon.getType();</span>

            // Skip weapons that don't use ammo.
<span class="nc bnc" id="L2537" title="All 2 branches missed.">            if (AmmoType.T_NA == weaponType.getAmmoType()) {</span>
<span class="nc" id="L2538">                continue;</span>
            }

<span class="nc" id="L2541">            final Mounted mountedAmmo = getPreferredAmmo(shooter, info.getTarget(), currentWeapon);</span>
            // if we found preferred ammo but can't apply it to the weapon, log it and continue.
<span class="nc bnc" id="L2543" title="All 4 branches missed.">            if ((null != mountedAmmo) &amp;&amp; !shooter.loadWeapon(currentWeapon, mountedAmmo)) {</span>
<span class="nc" id="L2544">                owner.getLogger().warning(shooter.getDisplayName() + &quot; tried to load &quot; </span>
<span class="nc" id="L2545">                          + currentWeapon.getName() + &quot; with ammo &quot; +</span>
<span class="nc" id="L2546">                          mountedAmmo.getDesc() + &quot; but failed somehow.&quot;);</span>
<span class="nc" id="L2547">                continue;</span>
            // if we didn't find preferred ammo after all, continue
<span class="nc bnc" id="L2549" title="All 2 branches missed.">            } else if (mountedAmmo == null) {</span>
<span class="nc" id="L2550">                continue;</span>
            }
<span class="nc" id="L2552">            final WeaponAttackAction action = info.getAction();</span>
<span class="nc" id="L2553">            action.setAmmoId(shooter.getEquipmentNum(mountedAmmo));</span>
<span class="nc" id="L2554">            action.setAmmoCarrier(mountedAmmo.getEntity().getId());</span>
<span class="nc" id="L2555">            info.setAction(action);</span>
<span class="nc" id="L2556">            owner.sendAmmoChange(info.getShooter().getId(), shooter.getEquipmentNum(currentWeapon),</span>
<span class="nc" id="L2557">                                 shooter.getEquipmentNum(mountedAmmo));</span>
<span class="nc" id="L2558">        }</span>
<span class="nc" id="L2559">    }</span>

    Mounted getClusterAmmo(final List&lt;Mounted&gt; ammoList,
                           final WeaponType weaponType,
                           final int range) {
<span class="fc" id="L2564">        Mounted returnAmmo = null;</span>
<span class="fc" id="L2565">        Mounted mmlLrm = null;</span>
<span class="fc" id="L2566">        Mounted mmlSrm = null;</span>

<span class="fc bfc" id="L2568" title="All 2 branches covered.">        for (final Mounted ammo : ammoList) {</span>
<span class="fc" id="L2569">            final AmmoType ammoType = (AmmoType) ammo.getType();</span>
<span class="fc bfc" id="L2570" title="All 2 branches covered.">            if (AmmoType.M_CLUSTER == ammoType.getMunitionType()) {</span>
                // MMLs have additional considerations.
                // There are no &quot;cluster&quot; missile munitions at this point in time.  Code is included in case
                // they are added to the game at some later date.
<span class="pc bpc" id="L2574" title="1 of 2 branches missed.">                if (!(weaponType instanceof MMLWeapon)) {</span>
<span class="fc" id="L2575">                    returnAmmo = ammo;</span>
<span class="fc" id="L2576">                    break;</span>
                }
<span class="nc bnc" id="L2578" title="All 4 branches missed.">                if ((null == mmlLrm) &amp;&amp; ammoType.hasFlag(AmmoType.F_MML_LRM)) {</span>
<span class="nc" id="L2579">                    mmlLrm = ammo;</span>
<span class="nc bnc" id="L2580" title="All 2 branches missed.">                } else if (null == mmlSrm) {</span>
<span class="nc" id="L2581">                    mmlSrm = ammo;</span>
<span class="nc bnc" id="L2582" title="All 2 branches missed.">                } else if (null != mmlLrm) {</span>
<span class="nc" id="L2583">                    break;</span>
                }
            }
<span class="fc" id="L2586">        }</span>

        // MML ammo depends on range.
<span class="pc bpc" id="L2589" title="1 of 2 branches missed.">        if (weaponType instanceof MMLWeapon) {</span>
<span class="nc bnc" id="L2590" title="All 2 branches missed.">            if (9 &lt; range) { // Out of SRM range</span>
<span class="nc" id="L2591">                returnAmmo = mmlLrm;</span>
<span class="nc bnc" id="L2592" title="All 2 branches missed.">            } else if (6 &lt; range) { // SRM long range.</span>
<span class="nc bnc" id="L2593" title="All 2 branches missed.">                returnAmmo = (null == mmlLrm ? mmlSrm : mmlLrm);</span>
            } else {
<span class="nc bnc" id="L2595" title="All 2 branches missed.">                returnAmmo = (null == mmlSrm ? mmlLrm : mmlSrm);</span>
            }
        }

<span class="fc" id="L2599">        return returnAmmo;</span>
    }

    Mounted getPreferredAmmo(final Entity shooter,
                             final Targetable target,
                             final Mounted weapon) {
<span class="fc" id="L2605">        final StringBuilder msg = new StringBuilder(&quot;Getting ammo for &quot;).append(weapon.getType().getShortName())</span>
<span class="fc" id="L2606">                                                                        .append(&quot; firing at &quot;)</span>
<span class="fc" id="L2607">                                                                        .append(target.getDisplayName</span>
<span class="fc" id="L2608">                        ());</span>
<span class="fc" id="L2609">        Entity targetEntity = null;</span>
<span class="fc" id="L2610">        Mounted preferredAmmo = null;</span>
<span class="fc" id="L2611">        WeaponType weaponType = (WeaponType) weapon.getType();</span>

        try {
<span class="fc" id="L2614">            boolean fireResistant = false;</span>
<span class="fc bfc" id="L2615" title="All 2 branches covered.">            if (target instanceof Entity) {</span>
<span class="fc" id="L2616">                targetEntity = (Entity) target;</span>
<span class="fc" id="L2617">                final int armorType = targetEntity.getArmorType(0);</span>
<span class="fc bfc" id="L2618" title="All 2 branches covered.">                if (targetEntity instanceof Mech) {</span>
<span class="fc" id="L2619">                    targetEntity.getArmorType(1);</span>
                }
<span class="pc bpc" id="L2621" title="1 of 4 branches missed.">                if (EquipmentType.T_ARMOR_BA_FIRE_RESIST == armorType</span>
                    || EquipmentType.T_ARMOR_HEAT_DISSIPATING == armorType) {
<span class="fc" id="L2623">                    fireResistant = true;</span>
                }
            }

            // Find the ammo that is valid for this weapon.
<span class="fc" id="L2628">            final List&lt;Mounted&gt; ammo = shooter.getAmmo();</span>
<span class="fc" id="L2629">            final List&lt;Mounted&gt; validAmmo = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L2630" title="All 2 branches covered.">            for (final Mounted a : ammo) {</span>
<span class="pc bpc" id="L2631" title="1 of 4 branches missed.">                if (AmmoType.isAmmoValid(a, weaponType) &amp;&amp; AmmoType.canSwitchToAmmo(weapon, (AmmoType) a.getType())) {</span>
<span class="fc" id="L2632">                    validAmmo.add(a);</span>
                }
<span class="fc" id="L2634">            }</span>

            // If no valid ammo was found, return nothing.
<span class="pc bpc" id="L2637" title="1 of 2 branches missed.">            if (validAmmo.isEmpty()) {</span>
<span class="nc" id="L2638">                return null;</span>
            }
<span class="fc" id="L2640">            msg.append(&quot;\n\tFound &quot;).append(validAmmo.size()).append(&quot; units of valid ammo.&quot;);</span>

<span class="fc" id="L2642">            final int range = shooter.getPosition().distance(target.getPosition());</span>
<span class="fc" id="L2643">            msg.append(&quot;\n\tRange to target is &quot;).append(range);</span>

            // AMS only uses 1 type of ammo.
<span class="pc bpc" id="L2646" title="1 of 2 branches missed.">            if (weaponType.hasFlag(WeaponType.F_AMS)) {</span>
<span class="nc" id="L2647">                return validAmmo.get(0);</span>
            }

            // ATMs
<span class="fc bfc" id="L2651" title="All 2 branches covered.">            if (weaponType instanceof ATMWeapon) {</span>
<span class="fc" id="L2652">                return getAtmAmmo(validAmmo, range, new EntityState(target), fireResistant);</span>
            }

            // Target is a building.
<span class="fc bfc" id="L2656" title="All 2 branches covered.">            if (target instanceof BuildingTarget) {</span>
<span class="fc" id="L2657">                msg.append(&quot;\n\tTarget is a building... &quot;);</span>
<span class="fc" id="L2658">                preferredAmmo = getIncendiaryAmmo(validAmmo, weaponType, range);</span>
<span class="pc bpc" id="L2659" title="1 of 2 branches missed.">                if (null != preferredAmmo) {</span>
<span class="fc" id="L2660">                    msg.append(&quot;Burn It Down!&quot;);</span>
<span class="fc" id="L2661">                    return preferredAmmo;</span>
                }

                // Entity targets.
<span class="pc bpc" id="L2665" title="1 of 2 branches missed.">            } else if (null != targetEntity) {</span>
                // Airborne targets
<span class="pc bpc" id="L2667" title="1 of 4 branches missed.">                if (targetEntity.isAirborne() || (targetEntity instanceof VTOL)) {</span>
<span class="fc" id="L2668">                    msg.append(&quot;\n\tTarget is airborne... &quot;);</span>
<span class="fc" id="L2669">                    preferredAmmo = getAntiAirAmmo(validAmmo, weaponType, range);</span>
<span class="pc bpc" id="L2670" title="1 of 2 branches missed.">                    if (null != preferredAmmo) {</span>
<span class="fc" id="L2671">                        msg.append(&quot;Shoot It Down!&quot;);</span>
<span class="fc" id="L2672">                        return preferredAmmo;</span>
                    }
                }
                // Battle Armor, Tanks and Protos, oh my!
<span class="pc bpc" id="L2676" title="2 of 6 branches missed.">                if ((targetEntity instanceof BattleArmor)</span>
                    || (targetEntity instanceof Tank)
                    || (targetEntity instanceof Protomech)) {
<span class="fc" id="L2679">                    msg.append(&quot;\n\tTarget is BA/Proto/Tank... &quot;);</span>
<span class="fc" id="L2680">                    preferredAmmo = getAntiVeeAmmo(validAmmo, weaponType, range, fireResistant);</span>
<span class="pc bpc" id="L2681" title="1 of 2 branches missed.">                    if (null != preferredAmmo) {</span>
<span class="fc" id="L2682">                        msg.append(&quot;We have ways of dealing with that.&quot;);</span>
<span class="fc" id="L2683">                        return preferredAmmo;</span>
                    }
                }
                // PBI
<span class="fc bfc" id="L2687" title="All 2 branches covered.">                if (targetEntity instanceof Infantry) {</span>
<span class="fc" id="L2688">                    msg.append(&quot;\n\tTarget is infantry... &quot;);</span>
<span class="fc" id="L2689">                    preferredAmmo = getAntiInfantryAmmo(validAmmo, weaponType, range);</span>
<span class="pc bpc" id="L2690" title="1 of 2 branches missed.">                    if (null != preferredAmmo) {</span>
<span class="fc" id="L2691">                        msg.append(&quot;They squish nicely.&quot;);</span>
<span class="fc" id="L2692">                        return preferredAmmo;</span>
                    }
                }
                // On his last legs
<span class="fc bfc" id="L2696" title="All 2 branches covered.">                if (Entity.DMG_HEAVY &lt;= targetEntity.getDamageLevel()) {</span>
<span class="fc" id="L2697">                    msg.append(&quot;\n\tTarget is heavily damaged... &quot;);</span>
<span class="fc" id="L2698">                    preferredAmmo = getClusterAmmo(validAmmo, weaponType, range);</span>
<span class="pc bpc" id="L2699" title="1 of 2 branches missed.">                    if (null != preferredAmmo) {</span>
<span class="fc" id="L2700">                        msg.append(&quot;Let's find a soft spot.&quot;);</span>
<span class="fc" id="L2701">                        return preferredAmmo;</span>
                    }
                }
                // He's running hot.
<span class="fc bfc" id="L2705" title="All 4 branches covered.">                if (9 &lt;= targetEntity.getHeat() &amp;&amp; !fireResistant) {</span>
<span class="fc" id="L2706">                    msg.append(&quot;\n\tTarget is at &quot;).append(targetEntity.getHeat()).append(&quot; heat... &quot;);</span>
<span class="fc" id="L2707">                    preferredAmmo = getHeatAmmo(validAmmo, weaponType, range);</span>
<span class="pc bpc" id="L2708" title="1 of 2 branches missed.">                    if (null != preferredAmmo) {</span>
<span class="fc" id="L2709">                        msg.append(&quot;Let's heat him up more.&quot;);</span>
<span class="fc" id="L2710">                        return preferredAmmo;</span>
                    }
                }
                // Everything else.
<span class="fc" id="L2714">                msg.append(&quot;\n\tTarget is a hard target... &quot;);</span>
<span class="fc" id="L2715">                preferredAmmo = getHardTargetAmmo(validAmmo, weaponType, range);</span>
<span class="pc bpc" id="L2716" title="1 of 2 branches missed.">                if (null != preferredAmmo) {</span>
<span class="fc" id="L2717">                    msg.append(&quot;Fill him with holes!&quot;);</span>
<span class="fc" id="L2718">                    return preferredAmmo;</span>
                }
            }

            // If we've gotten this far, no specialized ammo has been loaded
<span class="nc bnc" id="L2723" title="All 2 branches missed.">            if (weaponType instanceof MMLWeapon) {</span>
<span class="nc" id="L2724">                msg.append(&quot;\n\tLoading MML Ammo.&quot;);</span>
<span class="nc" id="L2725">                preferredAmmo = getGeneralMmlAmmo(validAmmo, range);</span>
            } else {
<span class="nc" id="L2727">                msg.append(&quot;\n\tLoading first available ammo.&quot;);</span>
<span class="nc" id="L2728">                preferredAmmo = validAmmo.get(0);</span>
            }
<span class="nc" id="L2730">            return preferredAmmo;</span>
        } finally {
<span class="fc bfc" id="L2732" title="All 2 branches covered.">            msg.append(&quot;\n\tReturning: &quot;).append(null == preferredAmmo ? &quot;null&quot; : preferredAmmo.getDesc());</span>
<span class="fc" id="L2733">            owner.getLogger().debug(msg.toString());</span>
        }
    }

    Mounted getGeneralMmlAmmo(final List&lt;Mounted&gt; ammoList,
                              final int range) {
        final Mounted returnAmmo;

        // Get the LRM and SRM bins if we have them.
<span class="fc" id="L2742">        Mounted mmlSrm = null;</span>
<span class="fc" id="L2743">        Mounted mmlLrm = null;</span>
<span class="fc bfc" id="L2744" title="All 2 branches covered.">        for (final Mounted ammo : ammoList) {</span>
<span class="fc" id="L2745">            final AmmoType type = (AmmoType) ammo.getType();</span>
<span class="fc bfc" id="L2746" title="All 4 branches covered.">            if ((null == mmlLrm) &amp;&amp; type.hasFlag(AmmoType.F_MML_LRM)) {</span>
<span class="fc" id="L2747">                mmlLrm = ammo;</span>
<span class="pc bpc" id="L2748" title="1 of 2 branches missed.">            } else if (null == mmlSrm) {</span>
<span class="fc" id="L2749">                mmlSrm = ammo;</span>
            } else //noinspection ConstantConditions
<span class="nc bnc" id="L2751" title="All 4 branches missed.">                if ((null != mmlSrm) &amp;&amp; (null != mmlLrm)) {</span>
<span class="nc" id="L2752">                    break;</span>
                }
<span class="fc" id="L2754">        }</span>

        // Out of SRM range.
<span class="fc bfc" id="L2757" title="All 2 branches covered.">        if (9 &lt; range) {</span>
<span class="fc" id="L2758">            returnAmmo = mmlLrm;</span>

            // LRMs have better chance to hit if we have them.
<span class="fc bfc" id="L2761" title="All 2 branches covered.">        } else if (5 &lt; range) {</span>
<span class="fc bfc" id="L2762" title="All 2 branches covered.">            returnAmmo = (null == mmlLrm ? mmlSrm : mmlLrm);</span>

            // If we only have LRMs left.
<span class="fc bfc" id="L2765" title="All 2 branches covered.">        } else if (null == mmlSrm) {</span>
<span class="fc" id="L2766">            returnAmmo = mmlLrm;</span>

            // Left with SRMS.
        } else {
<span class="fc" id="L2770">            returnAmmo = mmlSrm;</span>
        }
<span class="fc" id="L2772">        return returnAmmo;</span>
    }

    Mounted getAtmAmmo(final List&lt;Mounted&gt; ammoList,
                       final int range,
                       final EntityState target,
                       final boolean fireResistant) {
        Mounted returnAmmo;

        // Get the Hi-Ex, Ex-Range and Standard ammo bins if we have them.
<span class="fc" id="L2782">        Mounted heAmmo = null;</span>
<span class="fc" id="L2783">        Mounted erAmmo = null;</span>
<span class="fc" id="L2784">        Mounted stAmmo = null;</span>
<span class="fc" id="L2785">        Mounted infernoAmmo = null;</span>
<span class="fc bfc" id="L2786" title="All 2 branches covered.">        for (final Mounted ammo : ammoList) {</span>
<span class="fc" id="L2787">            final AmmoType type = (AmmoType) ammo.getType();</span>
<span class="fc bfc" id="L2788" title="All 4 branches covered.">            if ((null == heAmmo) &amp;&amp; (AmmoType.M_HIGH_EXPLOSIVE == type.getMunitionType())) {</span>
<span class="fc" id="L2789">                heAmmo = ammo;</span>
<span class="fc bfc" id="L2790" title="All 4 branches covered.">            } else if ((null == erAmmo) &amp;&amp; (AmmoType.M_EXTENDED_RANGE == type.getMunitionType())) {</span>
<span class="fc" id="L2791">                erAmmo = ammo;</span>
<span class="pc bpc" id="L2792" title="1 of 4 branches missed.">            } else if ((null == stAmmo) &amp;&amp; (AmmoType.M_STANDARD == type.getMunitionType())) {</span>
<span class="fc" id="L2793">                stAmmo = ammo;</span>
<span class="pc bpc" id="L2794" title="1 of 4 branches missed.">            } else if ((null == infernoAmmo) &amp;&amp; (AmmoType.M_IATM_IIW == type.getMunitionType())) {</span>
<span class="fc" id="L2795">                infernoAmmo = ammo;</span>
<span class="pc bpc" id="L2796" title="4 of 8 branches missed.">            } else if ((null != heAmmo) &amp;&amp; (null != erAmmo) &amp;&amp; (null != stAmmo) &amp;&amp; (null != infernoAmmo)) {</span>
<span class="nc" id="L2797">                break;</span>
            }
<span class="fc" id="L2799">        }</span>

        // Beyond 15 hexes is ER Ammo only range.
<span class="fc bfc" id="L2802" title="All 2 branches covered.">        if (15 &lt; range) {</span>
<span class="fc" id="L2803">            returnAmmo = erAmmo;</span>
            // ER Ammo has a better chance to hit past 10 hexes.
<span class="fc bfc" id="L2805" title="All 2 branches covered.">        } else if (10 &lt; range) {</span>
<span class="fc bfc" id="L2806" title="All 2 branches covered.">            returnAmmo = (null == erAmmo ? stAmmo : erAmmo);</span>
            // At 7-10 hexes, go with Standard, then ER then HE due to hit odds.
<span class="fc bfc" id="L2808" title="All 2 branches covered.">        } else if (6 &lt; range) {</span>
<span class="fc bfc" id="L2809" title="All 2 branches covered.">            if (null != stAmmo) {</span>
<span class="fc" id="L2810">                returnAmmo = stAmmo;</span>
<span class="pc bpc" id="L2811" title="1 of 2 branches missed.">            } else if (null != erAmmo) {</span>
<span class="fc" id="L2812">                returnAmmo = erAmmo;</span>
            } else {
<span class="nc" id="L2814">                returnAmmo = heAmmo;</span>
            }
            // Six hexes is at min for ER, and medium for both ST &amp; HE.
<span class="fc bfc" id="L2817" title="All 2 branches covered.">        } else if (6 == range) {</span>
<span class="fc bfc" id="L2818" title="All 2 branches covered.">            if (null != heAmmo) {</span>
<span class="fc" id="L2819">                returnAmmo = heAmmo;</span>
<span class="pc bpc" id="L2820" title="1 of 2 branches missed.">            } else if (null != stAmmo) {</span>
<span class="fc" id="L2821">                returnAmmo = stAmmo;</span>
            } else {
<span class="nc" id="L2823">                returnAmmo = erAmmo;</span>
            }
            // 4-5 hexes is medium for HE, short for ST and well within min for ER.
<span class="fc bfc" id="L2826" title="All 2 branches covered.">        } else if (3 &lt; range) {</span>
<span class="fc bfc" id="L2827" title="All 2 branches covered.">            if (null != stAmmo) {</span>
<span class="fc" id="L2828">                returnAmmo = stAmmo;</span>
<span class="fc bfc" id="L2829" title="All 2 branches covered.">            } else if (null != heAmmo) {</span>
<span class="fc" id="L2830">                returnAmmo = heAmmo;</span>
            } else {
<span class="fc" id="L2832">                returnAmmo = erAmmo;</span>
            }
            // Short range for HE.
        } else {
<span class="fc bfc" id="L2836" title="All 2 branches covered.">            if (null != heAmmo) {</span>
<span class="fc" id="L2837">                returnAmmo = heAmmo;</span>
<span class="pc bpc" id="L2838" title="1 of 2 branches missed.">            } else if (null != stAmmo) {</span>
<span class="fc" id="L2839">                returnAmmo = stAmmo;</span>
            } else {
<span class="nc" id="L2841">                returnAmmo = erAmmo;</span>
            }
        }

<span class="fc bfc" id="L2845" title="All 4 branches covered.">        if ((returnAmmo == stAmmo) &amp;&amp; (null != infernoAmmo)</span>
<span class="pc bpc" id="L2846" title="1 of 6 branches missed.">            &amp;&amp; ((9 &lt;= target.getHeat()) || target.isBuilding())</span>
            &amp;&amp; !fireResistant) {
<span class="fc" id="L2848">            returnAmmo = infernoAmmo;</span>
        }

<span class="fc" id="L2851">        return returnAmmo;</span>
    }

    Mounted getAntiVeeAmmo(final List&lt;Mounted&gt; ammoList,
                           final WeaponType weaponType,
                           final int range,
                           final boolean fireResistant) {
<span class="fc" id="L2858">        Mounted returnAmmo = null;</span>
<span class="fc" id="L2859">        Mounted mmlLrm = null;</span>
<span class="fc" id="L2860">        Mounted mmlSrm = null;</span>

<span class="fc bfc" id="L2862" title="All 2 branches covered.">        for (final Mounted ammo : ammoList) {</span>
<span class="fc" id="L2863">            final AmmoType ammoType = (AmmoType) ammo.getType();</span>
<span class="fc bfc" id="L2864" title="All 2 branches covered.">            if (AmmoType.M_CLUSTER == ammoType.getMunitionType()</span>
<span class="fc bfc" id="L2865" title="All 4 branches covered.">                || (AmmoType.M_INFERNO == ammoType.getMunitionType() &amp;&amp; !fireResistant)</span>
<span class="pc bpc" id="L2866" title="3 of 4 branches missed.">                || (AmmoType.M_INFERNO_IV == ammoType.getMunitionType() &amp;&amp; !fireResistant)) {</span>

                // MMLs have additional considerations.
<span class="fc bfc" id="L2869" title="All 2 branches covered.">                if (!(weaponType instanceof MMLWeapon)) {</span>
<span class="fc" id="L2870">                    returnAmmo = ammo;</span>
<span class="fc" id="L2871">                    break;</span>
                }
<span class="pc bpc" id="L2873" title="2 of 4 branches missed.">                if ((null == mmlLrm) &amp;&amp; ammoType.hasFlag(AmmoType.F_MML_LRM)) {</span>
<span class="nc" id="L2874">                    mmlLrm = ammo;</span>
<span class="pc bpc" id="L2875" title="1 of 2 branches missed.">                } else if (null == mmlSrm) {</span>
<span class="fc" id="L2876">                    mmlSrm = ammo;</span>
<span class="nc bnc" id="L2877" title="All 2 branches missed.">                } else if (null != mmlLrm) {</span>
<span class="nc" id="L2878">                    break;</span>
                }
            }
<span class="fc" id="L2881">        }</span>

        // MML ammo depends on range.
<span class="fc bfc" id="L2884" title="All 2 branches covered.">        if (weaponType instanceof MMLWeapon) {</span>
<span class="fc bfc" id="L2885" title="All 2 branches covered.">            if (9 &lt; range) { // Out of SRM range</span>
<span class="fc" id="L2886">                returnAmmo = mmlLrm;</span>
<span class="fc bfc" id="L2887" title="All 2 branches covered.">            } else if (6 &lt; range) { // SRM long range.</span>
<span class="pc bpc" id="L2888" title="1 of 2 branches missed.">                returnAmmo = (null == mmlLrm ? mmlSrm : mmlLrm);</span>
            } else {
<span class="fc bfc" id="L2890" title="All 2 branches covered.">                returnAmmo = (null == mmlSrm ? mmlLrm : mmlSrm);</span>
            }
        }

<span class="fc" id="L2894">        return returnAmmo;</span>
    }

    Mounted getAntiInfantryAmmo(final List&lt;Mounted&gt; ammoList,
                                final WeaponType weaponType,
                                final int range) {
<span class="fc" id="L2900">        Mounted returnAmmo = null;</span>
<span class="fc" id="L2901">        Mounted mmlLrm = null;</span>
<span class="fc" id="L2902">        Mounted mmlSrm = null;</span>

<span class="fc bfc" id="L2904" title="All 2 branches covered.">        for (final Mounted ammo : ammoList) {</span>
<span class="fc" id="L2905">            final AmmoType ammoType = (AmmoType) ammo.getType();</span>
<span class="fc bfc" id="L2906" title="All 2 branches covered.">            if (AmmoType.M_FLECHETTE == ammoType.getMunitionType()</span>
<span class="fc bfc" id="L2907" title="All 2 branches covered.">                || AmmoType.M_FRAGMENTATION == ammoType.getMunitionType()</span>
<span class="fc bfc" id="L2908" title="All 2 branches covered.">                || AmmoType.M_CLUSTER == ammoType.getMunitionType()</span>
<span class="fc bfc" id="L2909" title="All 2 branches covered.">                || AmmoType.M_INFERNO == ammoType.getMunitionType()</span>
<span class="pc bpc" id="L2910" title="1 of 2 branches missed.">                || AmmoType.M_INFERNO_IV == ammoType.getMunitionType()) {</span>

                // MMLs have additional considerations.
<span class="fc bfc" id="L2913" title="All 2 branches covered.">                if (!(weaponType instanceof MMLWeapon)) {</span>
<span class="fc" id="L2914">                    returnAmmo = ammo;</span>
<span class="fc" id="L2915">                    break;</span>
                }
<span class="pc bpc" id="L2917" title="1 of 4 branches missed.">                if ((null == mmlLrm) &amp;&amp; ammoType.hasFlag(AmmoType.F_MML_LRM)) {</span>
<span class="fc" id="L2918">                    mmlLrm = ammo;</span>
<span class="pc bpc" id="L2919" title="1 of 2 branches missed.">                } else if (null == mmlSrm) {</span>
<span class="fc" id="L2920">                    mmlSrm = ammo;</span>
                } else //noinspection ConstantConditions
<span class="nc bnc" id="L2922" title="All 4 branches missed.">                    if ((null != mmlLrm) &amp;&amp; (null != mmlSrm)) {</span>
<span class="nc" id="L2923">                        break;</span>
                    }
            }
<span class="fc" id="L2926">        }</span>

        // MML ammo depends on range.
<span class="fc bfc" id="L2929" title="All 2 branches covered.">        if (weaponType instanceof MMLWeapon) {</span>
<span class="fc bfc" id="L2930" title="All 2 branches covered.">            if (9 &lt; range) { // Out of SRM range</span>
<span class="fc" id="L2931">                returnAmmo = mmlLrm;</span>
<span class="fc bfc" id="L2932" title="All 2 branches covered.">            } else if (6 &lt; range) { // SRM long range.</span>
<span class="pc bpc" id="L2933" title="1 of 2 branches missed.">                returnAmmo = (null == mmlLrm ? mmlSrm : mmlLrm);</span>
            } else {
<span class="pc bpc" id="L2935" title="1 of 2 branches missed.">                returnAmmo = (null == mmlSrm ? mmlLrm : mmlSrm);</span>
            }
        }

<span class="fc" id="L2939">        return returnAmmo;</span>
    }

    private Mounted getHeatAmmo(final List&lt;Mounted&gt; ammoList,
                                final WeaponType weaponType,
                                final int range) {
<span class="fc" id="L2945">        Mounted returnAmmo = null;</span>
<span class="fc" id="L2946">        Mounted mmlLrm = null;</span>
<span class="fc" id="L2947">        Mounted mmlSrm = null;</span>

<span class="fc bfc" id="L2949" title="All 2 branches covered.">        for (final Mounted ammo : ammoList) {</span>
<span class="fc" id="L2950">            final AmmoType ammoType = (AmmoType) ammo.getType();</span>
<span class="fc bfc" id="L2951" title="All 2 branches covered.">            if (AmmoType.M_INFERNO == ammoType.getMunitionType()</span>
<span class="pc bpc" id="L2952" title="1 of 2 branches missed.">                || AmmoType.M_INFERNO_IV == ammoType.getMunitionType()) {</span>

                // MMLs have additional considerations.
<span class="pc bpc" id="L2955" title="1 of 2 branches missed.">                if (!(weaponType instanceof MMLWeapon)) {</span>
<span class="nc" id="L2956">                    returnAmmo = ammo;</span>
<span class="nc" id="L2957">                    break;</span>
                }
<span class="pc bpc" id="L2959" title="2 of 4 branches missed.">                if ((null == mmlLrm) &amp;&amp; ammoType.hasFlag(AmmoType.F_MML_LRM)) {</span>
<span class="nc" id="L2960">                    mmlLrm = ammo;</span>
<span class="pc bpc" id="L2961" title="1 of 2 branches missed.">                } else if (null == mmlSrm) {</span>
<span class="fc" id="L2962">                    mmlSrm = ammo;</span>
<span class="nc bnc" id="L2963" title="All 2 branches missed.">                } else if (null != mmlLrm) {</span>
<span class="nc" id="L2964">                    break;</span>
                }
            }
<span class="fc" id="L2967">        }</span>

        // MML ammo depends on range.
<span class="pc bpc" id="L2970" title="1 of 2 branches missed.">        if (weaponType instanceof MMLWeapon) {</span>
<span class="pc bpc" id="L2971" title="1 of 2 branches missed.">            if (9 &lt; range) { // Out of SRM range</span>
<span class="nc" id="L2972">                returnAmmo = mmlLrm;</span>
<span class="pc bpc" id="L2973" title="1 of 2 branches missed.">            } else if (6 &lt; range) { // SRM long range.</span>
<span class="nc bnc" id="L2974" title="All 2 branches missed.">                returnAmmo = (null == mmlLrm ? mmlSrm : mmlLrm);</span>
            } else {
<span class="pc bpc" id="L2976" title="1 of 2 branches missed.">                returnAmmo = (null == mmlSrm ? mmlLrm : mmlSrm);</span>
            }
        }

<span class="fc" id="L2980">        return returnAmmo;</span>
    }

    Mounted getIncendiaryAmmo(final List&lt;Mounted&gt; ammoList,
                              final WeaponType weaponType,
                              final int range) {
<span class="fc" id="L2986">        Mounted returnAmmo = null;</span>
<span class="fc" id="L2987">        Mounted mmlLrm = null;</span>
<span class="fc" id="L2988">        Mounted mmlSrm = null;</span>

<span class="fc bfc" id="L2990" title="All 2 branches covered.">        for (final Mounted ammo : ammoList) {</span>
<span class="fc" id="L2991">            final AmmoType ammoType = (AmmoType) ammo.getType();</span>
<span class="pc bpc" id="L2992" title="1 of 2 branches missed.">            if (AmmoType.M_INCENDIARY == ammoType.getMunitionType()</span>
<span class="pc bpc" id="L2993" title="1 of 2 branches missed.">                || AmmoType.M_INCENDIARY_LRM == ammoType.getMunitionType()</span>
<span class="fc bfc" id="L2994" title="All 2 branches covered.">                || AmmoType.M_INCENDIARY_AC == ammoType.getMunitionType()</span>
<span class="fc bfc" id="L2995" title="All 2 branches covered.">                || AmmoType.M_INFERNO == ammoType.getMunitionType()</span>
<span class="pc bpc" id="L2996" title="1 of 2 branches missed.">                || AmmoType.M_INFERNO_IV == ammoType.getMunitionType()) {</span>

                // MMLs have additional considerations.
<span class="fc bfc" id="L2999" title="All 2 branches covered.">                if (!(weaponType instanceof MMLWeapon)) {</span>
<span class="fc" id="L3000">                    returnAmmo = ammo;</span>
<span class="fc" id="L3001">                    break;</span>
                }
<span class="pc bpc" id="L3003" title="2 of 4 branches missed.">                if ((null == mmlLrm) &amp;&amp; ammoType.hasFlag(AmmoType.F_MML_LRM)) {</span>
<span class="nc" id="L3004">                    mmlLrm = ammo;</span>
<span class="pc bpc" id="L3005" title="1 of 2 branches missed.">                } else if (null == mmlSrm) {</span>
<span class="fc" id="L3006">                    mmlSrm = ammo;</span>
<span class="nc bnc" id="L3007" title="All 2 branches missed.">                } else if (null != mmlLrm) {</span>
<span class="nc" id="L3008">                    break;</span>
                }
            }
<span class="fc" id="L3011">        }</span>

        // MML ammo depends on range.
<span class="fc bfc" id="L3014" title="All 2 branches covered.">        if (weaponType instanceof MMLWeapon) {</span>
<span class="fc bfc" id="L3015" title="All 2 branches covered.">            if (9 &lt; range) { // Out of SRM range</span>
<span class="fc" id="L3016">                returnAmmo = mmlLrm;</span>
<span class="fc bfc" id="L3017" title="All 2 branches covered.">            } else if (6 &lt; range) { // SRM long range.</span>
<span class="pc bpc" id="L3018" title="1 of 2 branches missed.">                returnAmmo = (null == mmlLrm ? mmlSrm : mmlLrm);</span>
            } else {
<span class="pc bpc" id="L3020" title="1 of 2 branches missed.">                returnAmmo = (null == mmlSrm ? mmlLrm : mmlSrm);</span>
            }
        }

<span class="fc" id="L3024">        return returnAmmo;</span>
    }

    Mounted getHardTargetAmmo(final List&lt;Mounted&gt; ammoList,
                              final WeaponType weaponType,
                              final int range) {
<span class="fc" id="L3030">        Mounted returnAmmo = null;</span>
<span class="fc" id="L3031">        Mounted mmlLrm = null;</span>
<span class="fc" id="L3032">        Mounted mmlSrm = null;</span>

<span class="fc bfc" id="L3034" title="All 2 branches covered.">        for (final Mounted ammo : ammoList) {</span>
<span class="fc" id="L3035">            final AmmoType ammoType = (AmmoType) ammo.getType();</span>
<span class="fc bfc" id="L3036" title="All 2 branches covered.">            if (AmmoType.M_CLUSTER == ammoType.getMunitionType()</span>
<span class="pc bpc" id="L3037" title="1 of 2 branches missed.">                || AmmoType.M_ANTI_FLAME_FOAM == ammoType.getMunitionType()</span>
<span class="pc bpc" id="L3038" title="1 of 2 branches missed.">                || AmmoType.M_CHAFF == ammoType.getMunitionType()</span>
<span class="pc bpc" id="L3039" title="1 of 2 branches missed.">                || AmmoType.M_COOLANT == ammoType.getMunitionType()</span>
<span class="pc bpc" id="L3040" title="1 of 2 branches missed.">                || AmmoType.M_ECM == ammoType.getMunitionType()</span>
<span class="pc bpc" id="L3041" title="1 of 2 branches missed.">                || AmmoType.M_FASCAM == ammoType.getMunitionType()</span>
<span class="fc bfc" id="L3042" title="All 2 branches covered.">                || AmmoType.M_FLAK == ammoType.getMunitionType()</span>
<span class="pc bpc" id="L3043" title="1 of 2 branches missed.">                || AmmoType.M_FLARE == ammoType.getMunitionType()</span>
<span class="pc bpc" id="L3044" title="1 of 2 branches missed.">                || AmmoType.M_FLECHETTE == ammoType.getMunitionType()</span>
<span class="pc bpc" id="L3045" title="1 of 2 branches missed.">                || AmmoType.M_FRAGMENTATION == ammoType.getMunitionType()</span>
<span class="pc bpc" id="L3046" title="1 of 2 branches missed.">                || AmmoType.M_HAYWIRE == ammoType.getMunitionType()</span>
<span class="pc bpc" id="L3047" title="1 of 2 branches missed.">                || AmmoType.M_INCENDIARY == ammoType.getMunitionType()</span>
<span class="pc bpc" id="L3048" title="1 of 2 branches missed.">                || AmmoType.M_INCENDIARY_AC == ammoType.getMunitionType()</span>
<span class="pc bpc" id="L3049" title="1 of 2 branches missed.">                || AmmoType.M_INCENDIARY_LRM == ammoType.getMunitionType()</span>
<span class="fc bfc" id="L3050" title="All 2 branches covered.">                || AmmoType.M_INFERNO == ammoType.getMunitionType()</span>
<span class="pc bpc" id="L3051" title="1 of 2 branches missed.">                || AmmoType.M_INFERNO_IV == ammoType.getMunitionType()</span>
<span class="pc bpc" id="L3052" title="1 of 2 branches missed.">                || AmmoType.M_LASER_INHIB == ammoType.getMunitionType()</span>
<span class="pc bpc" id="L3053" title="1 of 2 branches missed.">                || AmmoType.M_OIL_SLICK == ammoType.getMunitionType()</span>
<span class="pc bpc" id="L3054" title="1 of 2 branches missed.">                || AmmoType.M_NEMESIS == ammoType.getMunitionType()</span>
<span class="pc bpc" id="L3055" title="1 of 2 branches missed.">                || AmmoType.M_PAINT_OBSCURANT == ammoType.getMunitionType()</span>
<span class="pc bpc" id="L3056" title="1 of 2 branches missed.">                || AmmoType.M_SMOKE == ammoType.getMunitionType()</span>
<span class="pc bpc" id="L3057" title="1 of 2 branches missed.">                || AmmoType.M_SMOKE_WARHEAD == ammoType.getMunitionType()</span>
<span class="pc bpc" id="L3058" title="1 of 2 branches missed.">                || AmmoType.M_THUNDER == ammoType.getMunitionType()</span>
<span class="pc bpc" id="L3059" title="1 of 2 branches missed.">                || AmmoType.M_THUNDER_ACTIVE == ammoType.getMunitionType()</span>
<span class="pc bpc" id="L3060" title="1 of 2 branches missed.">                || AmmoType.M_THUNDER_AUGMENTED == ammoType.getMunitionType()</span>
<span class="pc bpc" id="L3061" title="1 of 2 branches missed.">                || AmmoType.M_THUNDER_INFERNO == ammoType.getMunitionType()</span>
<span class="pc bpc" id="L3062" title="1 of 2 branches missed.">                || AmmoType.M_THUNDER_VIBRABOMB == ammoType.getMunitionType()</span>
<span class="pc bpc" id="L3063" title="1 of 2 branches missed.">                || AmmoType.M_TORPEDO == ammoType.getMunitionType()</span>
<span class="pc bpc" id="L3064" title="1 of 2 branches missed.">                || AmmoType.M_VIBRABOMB_IV == ammoType.getMunitionType()</span>
<span class="pc bpc" id="L3065" title="1 of 2 branches missed.">                || AmmoType.M_WATER == ammoType.getMunitionType()</span>
<span class="pc bpc" id="L3066" title="1 of 2 branches missed.">                || AmmoType.M_ANTI_TSM == ammoType.getMunitionType()</span>
<span class="pc bpc" id="L3067" title="1 of 2 branches missed.">                || AmmoType.M_CORROSIVE == ammoType.getMunitionType()) {</span>
<span class="nc" id="L3068">                continue;</span>
            }
            // MMLs have additional considerations.
<span class="fc bfc" id="L3071" title="All 2 branches covered.">            if (!(weaponType instanceof MMLWeapon)) {</span>
<span class="fc" id="L3072">                returnAmmo = ammo;</span>
<span class="fc" id="L3073">                break;</span>
            }
<span class="fc bfc" id="L3075" title="All 4 branches covered.">            if ((null == mmlLrm) &amp;&amp; ammoType.hasFlag(AmmoType.F_MML_LRM)) {</span>
<span class="fc" id="L3076">                mmlLrm = ammo;</span>
<span class="pc bpc" id="L3077" title="1 of 2 branches missed.">            } else if (null == mmlSrm) {</span>
<span class="fc" id="L3078">                mmlSrm = ammo;</span>
            } else //noinspection ConstantConditions
<span class="nc bnc" id="L3080" title="All 4 branches missed.">                if ((null != mmlLrm) &amp;&amp; (null != mmlSrm)) {</span>
<span class="nc" id="L3081">                    break;</span>
                }
<span class="fc" id="L3083">        }</span>

        // MML ammo depends on range.
<span class="fc bfc" id="L3086" title="All 2 branches covered.">        if (weaponType instanceof MMLWeapon) {</span>
<span class="fc bfc" id="L3087" title="All 2 branches covered.">            if (9 &lt; range) { // Out of SRM range</span>
<span class="fc" id="L3088">                returnAmmo = mmlLrm;</span>
<span class="fc bfc" id="L3089" title="All 2 branches covered.">            } else if (6 &lt; range) { // SRM long range.</span>
<span class="fc bfc" id="L3090" title="All 2 branches covered.">                returnAmmo = (null == mmlLrm ? mmlSrm : mmlLrm);</span>
            } else {
<span class="fc bfc" id="L3092" title="All 2 branches covered.">                returnAmmo = (null == mmlSrm ? mmlLrm : mmlSrm);</span>
            }
        }

<span class="fc" id="L3096">        return returnAmmo;</span>
    }

    Mounted getAntiAirAmmo(final List&lt;Mounted&gt; ammoList,
                           final WeaponType weaponType,
                           final int range) {
<span class="fc" id="L3102">        Mounted returnAmmo = null;</span>
<span class="fc" id="L3103">        Mounted mmlLrm = null;</span>
<span class="fc" id="L3104">        Mounted mmlSrm = null;</span>

<span class="fc bfc" id="L3106" title="All 2 branches covered.">        for (final Mounted ammo : ammoList) {</span>
<span class="fc" id="L3107">            final AmmoType ammoType = (AmmoType) ammo.getType();</span>
<span class="fc bfc" id="L3108" title="All 2 branches covered.">            if (AmmoType.M_CLUSTER == ammoType.getMunitionType()</span>
<span class="fc bfc" id="L3109" title="All 2 branches covered.">                || AmmoType.M_FLAK == ammoType.getMunitionType()) {</span>

                // MMLs have additional considerations.
                // There are no &quot;flak&quot; or &quot;cluster&quot; missile munitions at this point in time.  Code is included in case
                // they are added to the game at some later date.
<span class="pc bpc" id="L3114" title="1 of 2 branches missed.">                if (!(weaponType instanceof MMLWeapon)) {</span>
<span class="fc" id="L3115">                    returnAmmo = ammo;</span>
<span class="fc" id="L3116">                    break;</span>
                }
<span class="nc bnc" id="L3118" title="All 4 branches missed.">                if ((null == mmlLrm) &amp;&amp; ammoType.hasFlag(AmmoType.F_MML_LRM)) {</span>
<span class="nc" id="L3119">                    mmlLrm = ammo;</span>
<span class="nc bnc" id="L3120" title="All 2 branches missed.">                } else if (null == mmlSrm) {</span>
<span class="nc" id="L3121">                    mmlSrm = ammo;</span>
<span class="nc bnc" id="L3122" title="All 2 branches missed.">                } else if (null != mmlLrm) {</span>
<span class="nc" id="L3123">                    break;</span>
                }
            }
<span class="fc" id="L3126">        }</span>

        // MML ammo depends on range.
<span class="pc bpc" id="L3129" title="1 of 2 branches missed.">        if (weaponType instanceof MMLWeapon) {</span>
<span class="nc bnc" id="L3130" title="All 2 branches missed.">            if (9 &lt; range) { // Out of SRM range</span>
<span class="nc" id="L3131">                returnAmmo = mmlLrm;</span>
<span class="nc bnc" id="L3132" title="All 2 branches missed.">            } else if (6 &lt; range) { // SRM long range.</span>
<span class="nc bnc" id="L3133" title="All 2 branches missed.">                returnAmmo = (null == mmlLrm ? mmlSrm : mmlLrm);</span>
            } else {
<span class="nc bnc" id="L3135" title="All 2 branches missed.">                returnAmmo = (null == mmlSrm ? mmlLrm : mmlSrm);</span>
            }
        }

<span class="fc" id="L3139">        return returnAmmo;</span>
    }

    // Helper method that figures out the valid facing changes for the given shooter
    public static List&lt;Integer&gt; getValidFacingChanges(final Entity shooter) {
        // figure out all valid twists or turret turns
        // mechs can turn:
        //		one left, one right unless he has &quot;no torso twist&quot; quirk or is on the ground
        //		two left, two right if he has &quot;extended torso twist&quot; quirk
        // vehicles and turrets can turn any direction unless he has no turret
<span class="nc" id="L3149">        final List&lt;Integer&gt; validFacingChanges = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L3150" title="All 2 branches missed.">        if (((Entity.ETYPE_MECH &amp; shooter.getEntityType()) &gt; 0)</span>
<span class="nc bnc" id="L3151" title="All 2 branches missed.">            &amp;&amp; !shooter.hasQuirk(OptionsConstants.QUIRK_NEG_NO_TWIST)</span>
<span class="nc bnc" id="L3152" title="All 2 branches missed.">            &amp;&amp; !shooter.hasFallen()) {</span>
<span class="nc" id="L3153">            validFacingChanges.add(1);</span>
<span class="nc" id="L3154">            validFacingChanges.add(-1);</span>

<span class="nc bnc" id="L3156" title="All 2 branches missed.">            if (shooter.hasQuirk(OptionsConstants.QUIRK_POS_EXT_TWIST)) {</span>
<span class="nc" id="L3157">                validFacingChanges.add(2);</span>
<span class="nc" id="L3158">                validFacingChanges.add(-2);</span>
            }
<span class="nc bnc" id="L3160" title="All 2 branches missed.">        } else if ((shooter instanceof Tank</span>
<span class="nc bnc" id="L3161" title="All 4 branches missed.">                   &amp;&amp; !((Tank) shooter).hasNoTurret()) || (shooter instanceof Infantry)) {</span>
<span class="nc" id="L3162">            validFacingChanges.add(1);</span>
<span class="nc" id="L3163">            validFacingChanges.add(-1);</span>
<span class="nc" id="L3164">            validFacingChanges.add(2);</span>
<span class="nc" id="L3165">            validFacingChanges.add(-2);</span>
<span class="nc" id="L3166">            validFacingChanges.add(3);</span>
        }
        
<span class="nc" id="L3169">        return validFacingChanges;</span>
    }
    
    /**
     * This function evaluates whether or not a unit should spend its time
     * unjamming weapons instead of firing, and returns the appropriate firing plan if that's the case.
     * @param shooter Entity being considered.
     * @return Unjam action plan, if we conclude that we should spend time unjamming weapons.
     */
    public Vector&lt;EntityAction&gt; getUnjamWeaponPlan(Entity shooter) {
<span class="nc" id="L3179">        int maxJammedDamage = 0;</span>
<span class="nc" id="L3180">        int maxDamageWeaponID = -1;</span>
<span class="nc" id="L3181">        Vector&lt;EntityAction&gt; unjamVector = new Vector&lt;&gt;();</span>
        
        // apparently, only tank type units can unjam weapons/clear turrets
<span class="nc bnc" id="L3184" title="All 2 branches missed.">        if(!shooter.hasETypeFlag(Entity.ETYPE_TANK)) {</span>
<span class="nc" id="L3185">            return unjamVector;</span>
        }
        
<span class="nc" id="L3188">        Tank tankShooter = (Tank) shooter;</span>
        
        // can't unjam if crew is stunned. Skip the rest of the logic to save time. 
<span class="nc bnc" id="L3191" title="All 2 branches missed.">        if(tankShooter.getStunnedTurns() &gt; 0) {</span>
<span class="nc" id="L3192">            return unjamVector;</span>
        }
        
        // step 1: loop through all the unit's jammed weapons to determine the biggest one
<span class="nc bnc" id="L3196" title="All 2 branches missed.">        for(Mounted mounted : tankShooter.getJammedWeapons()) {</span>
<span class="nc" id="L3197">            int weaponDamage = ((WeaponType) mounted.getType()).getDamage();</span>
<span class="nc bnc" id="L3198" title="All 2 branches missed.">            if(weaponDamage == WeaponType.DAMAGE_BY_CLUSTERTABLE) {</span>
<span class="nc" id="L3199">                weaponDamage = ((WeaponType) mounted.getType()).getRackSize();</span>
            }
            
<span class="nc bnc" id="L3202" title="All 2 branches missed.">            if(weaponDamage &gt; maxJammedDamage) {</span>
<span class="nc" id="L3203">                    maxDamageWeaponID = shooter.getEquipmentNum(mounted);</span>
<span class="nc" id="L3204">                    maxJammedDamage = weaponDamage;</span>
            }
<span class="nc" id="L3206">        }</span>
                
        // if any of the unit's weapons are jammed, unjam the biggest one.
        // we can only unjam one per turn.
<span class="nc bnc" id="L3210" title="All 2 branches missed.">        if(maxDamageWeaponID &gt;= 0) {</span>
<span class="nc" id="L3211">            RepairWeaponMalfunctionAction rwma = new RepairWeaponMalfunctionAction(</span>
<span class="nc" id="L3212">                    shooter.getId(), maxDamageWeaponID);</span>
            
<span class="nc" id="L3214">            unjamVector.add(rwma);</span>
        // if the unit has a jammed turret, attempt to clear it
<span class="nc bnc" id="L3216" title="All 2 branches missed.">        } else if(tankShooter.canClearTurret()) {</span>
<span class="nc" id="L3217">            UnjamTurretAction uta = new UnjamTurretAction(shooter.getId());</span>
<span class="nc" id="L3218">            unjamVector.add(uta);</span>
        }
        
<span class="nc" id="L3221">        return unjamVector;</span>
    }

    /**
     * Return a &quot;Find Club&quot; action, if the unit in question can find a club.
     */
    @Nullable
    public FindClubAction getFindClubAction(Entity shooter) {
<span class="nc bnc" id="L3229" title="All 2 branches missed.">        if (FindClubAction.canMechFindClub(shooter.getGame(), shooter.getId())) {</span>
<span class="nc" id="L3230">            FindClubAction findClubAction = new FindClubAction(shooter.getId());</span>
<span class="nc" id="L3231">            return findClubAction;</span>
        }
        
<span class="nc" id="L3234">        return null;</span>
    }
    
    /**
     * Given a firing plan, calculate the best target to light up with a searchlight
     */
    public SearchlightAttackAction getSearchLightAction(Entity shooter, FiringPlan plan) {
        // no search light if it's not on, unit doesn't have one, or is hidden
<span class="nc bnc" id="L3242" title="All 6 branches missed.">        if(!shooter.isUsingSpotlight() || !shooter.hasSpotlight() || shooter.isHidden()) {</span>
<span class="nc" id="L3243">            return null;</span>
        }
        
        // assemble set of targets we're planning on shooting
<span class="nc" id="L3247">        Set&lt;Coords&gt; planTargets = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L3248" title="All 2 branches missed.">        if(plan != null) {</span>
<span class="nc bnc" id="L3249" title="All 2 branches missed.">            for(WeaponFireInfo wfi : plan) {</span>
<span class="nc" id="L3250">                planTargets.add(wfi.getTarget().getPosition());</span>
<span class="nc" id="L3251">            }</span>
        }
        
<span class="nc" id="L3254">        List&lt;SearchlightAttackAction&gt; searchlights = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L3255" title="All 2 branches missed.">        for (EntityAction action : shooter.getGame().getActionsVector()) {</span>
<span class="nc bnc" id="L3256" title="All 2 branches missed.">            if (action instanceof SearchlightAttackAction) {</span>
<span class="nc" id="L3257">                searchlights.add((SearchlightAttackAction) action);</span>
            }
<span class="nc" id="L3259">        }</span>
        
        // for each potential target on the board, draw a line between &quot;shooter&quot; and target
        // and assign it a score. Score is determined by:
        // # hostiles lit up - # friendlies lit up + # targets lit up
<span class="nc" id="L3264">        Targetable bestTarget = null;</span>
<span class="nc" id="L3265">        int bestTargetScore = 0;</span>

<span class="nc bnc" id="L3267" title="All 2 branches missed.">        for(Targetable target : getTargetableEnemyEntities(shooter, shooter.getGame(), owner.getFireControlState())) {</span>
<span class="nc" id="L3268">            int score = 0;</span>
            
<span class="nc bnc" id="L3270" title="All 2 branches missed.">            for(Coords intervening : Coords.intervening(shooter.getPosition(), target.getPosition())) {</span>
                // if it's already lit up, don't count it 
<span class="nc bnc" id="L3272" title="All 2 branches missed.">                if(shooter.getGame().isPositionIlluminated(intervening) &gt; 0) {</span>
<span class="nc" id="L3273">                    continue;</span>
                }
                
<span class="nc bnc" id="L3276" title="All 2 branches missed.">                for(Entity ent : shooter.getGame().getEntitiesVector(intervening, true)) {</span>
                    // don't count ourselves, or the target if it's already lit itself up
                    // or the target if it will be lit up by a previously declared search light
<span class="nc bnc" id="L3279" title="All 4 branches missed.">                    if((ent.getId() == shooter.getId()) || ent.isIlluminated()) {</span>
<span class="nc" id="L3280">                        continue;</span>
                    } else {
<span class="nc" id="L3282">                        boolean willbeIlluminated = false;</span>
                        
<span class="nc bnc" id="L3284" title="All 2 branches missed.">                        for(SearchlightAttackAction searchlight : searchlights) {</span>
<span class="nc bnc" id="L3285" title="All 2 branches missed.">                            if(searchlight.willIlluminate(shooter.getGame(), ent)) {</span>
<span class="nc" id="L3286">                                willbeIlluminated = true;</span>
<span class="nc" id="L3287">                                break;</span>
                            }
<span class="nc" id="L3289">                        }</span>
                        
<span class="nc bnc" id="L3291" title="All 2 branches missed.">                        if(willbeIlluminated) {</span>
<span class="nc" id="L3292">                            continue;</span>
                        }
                    }
                    
<span class="nc bnc" id="L3296" title="All 2 branches missed.">                    if(ent.isEnemyOf(shooter)) {</span>
<span class="nc" id="L3297">                        score++;</span>
                    } else {
<span class="nc" id="L3299">                        score--;</span>
                    }
                    
<span class="nc bnc" id="L3302" title="All 2 branches missed.">                    if(planTargets.contains(intervening)) {</span>
<span class="nc" id="L3303">                        score++;</span>
                    }
<span class="nc" id="L3305">                }</span>
<span class="nc" id="L3306">            }</span>
            
            // don't bother considering impossible searchlight actions
<span class="nc bnc" id="L3309" title="All 4 branches missed.">            if(score &gt; bestTargetScore &amp;&amp; SearchlightAttackAction.isPossible(shooter.getGame(), shooter.getId(), target, null)) {</span>
<span class="nc" id="L3310">                bestTargetScore = score;</span>
<span class="nc" id="L3311">                bestTarget = target;</span>
            }
<span class="nc" id="L3313">        }</span>
        
<span class="nc bnc" id="L3315" title="All 2 branches missed.">        if(bestTarget != null) {</span>
<span class="nc" id="L3316">            SearchlightAttackAction slaa = new SearchlightAttackAction(shooter.getId(), bestTarget.getTargetType(), bestTarget.getTargetId());</span>
<span class="nc" id="L3317">            return slaa;</span>
        }
        
<span class="nc" id="L3320">        return null;</span>
    }
    
    /**
     * Attempts to switch the current weapon's firing mode between direct and indirect
     * or vice versa. Returns -1 if the mode switch fails, or the weapon mode index if it succeeds.
     * @return Mode switch result.
     */
    private int switchMissileMode(Mounted weapon) {
        // check that we're operating a missile weapon that can switch direct/indirect modes
        // don't bother checking non-missile weapons
<span class="pc bpc" id="L3331" title="1 of 2 branches missed.">        if (weapon.getType().hasFlag(Weapon.F_MISSILE) &amp;&amp;</span>
<span class="nc bnc" id="L3332" title="All 2 branches missed.">                weapon.getType().hasModeType(Weapon.MODE_MISSILE_INDIRECT)) {</span>
            
            // if we are able to switch the weapon to indirect fire mode, do so and try again
<span class="nc bnc" id="L3335" title="All 2 branches missed.">            if (!weapon.curMode().equals(Weapon.MODE_MISSILE_INDIRECT)) {</span>
<span class="nc" id="L3336">                return weapon.setMode(Weapon.MODE_MISSILE_INDIRECT);</span>
            } else {
<span class="nc" id="L3338">                return weapon.setMode(&quot;&quot;);</span>
            }
        }       
        
<span class="fc" id="L3342">        return -1;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.4.201905082037</span></div></body></html>