<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BoardView1.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">megamek</a> &gt; <a href="index.source.html" class="el_package">megamek.client.ui.swing.boardview</a> &gt; <span class="el_source">BoardView1.java</span></div><h1>BoardView1.java</h1><pre class="source lang-java linenums">/*
* MegaMek -
* Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 Ben Mazur (bmazur@sev.org)
* Copyright (C) 2018-2021 - The MegaMek Team. All Rights Reserved.
*
* This program is free software; you can redistribute it and/or modify it under
* the terms of the GNU General Public License as published by the Free Software
* Foundation; either version 2 of the License, or (at your option) any later
* version.
*
* This program is distributed in the hope that it will be useful, but WITHOUT
* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
* details.
*/
package megamek.client.ui.swing.boardview;

import java.awt.AlphaComposite;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Component;
import java.awt.Composite;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.GradientPaint;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.GraphicsConfiguration;
import java.awt.GraphicsEnvironment;
import java.awt.Image;
import java.awt.MediaTracker;
import java.awt.Point;
import java.awt.Polygon;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.awt.Shape;
import java.awt.Toolkit;
import java.awt.Transparency;
import java.awt.event.ActionEvent;
import java.awt.event.KeyEvent;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionAdapter;
import java.awt.event.MouseMotionListener;
import java.awt.event.MouseWheelEvent;
import java.awt.event.MouseWheelListener;
import java.awt.font.GlyphVector;
import java.awt.geom.AffineTransform;
import java.awt.geom.Path2D;
import java.awt.geom.Point2D;
import java.awt.image.BufferedImage;
import java.awt.image.BufferedImageOp;
import java.awt.image.ConvolveOp;
import java.awt.image.ImageObserver;
import java.awt.image.ImageProducer;
import java.awt.image.Kernel;
import java.io.File;
import java.util.*;
import java.util.stream.Collectors;

import javax.imageio.ImageIO;
import javax.swing.AbstractAction;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JScrollBar;
import javax.swing.JScrollPane;
import javax.swing.JViewport;
import javax.swing.ScrollPaneLayout;
import javax.swing.Scrollable;
import javax.swing.SwingConstants;
import javax.swing.SwingUtilities;
import javax.swing.ToolTipManager;
import javax.swing.plaf.metal.DefaultMetalTheme;
import javax.swing.plaf.metal.MetalTheme;

import megamek.MegaMek;
import megamek.client.TimerSingleton;
import megamek.client.bot.princess.BotGeometry.ConvexBoardArea;
import megamek.client.bot.princess.PathEnumerator;
import megamek.client.bot.princess.Princess;
import megamek.client.event.BoardViewEvent;
import megamek.client.event.BoardViewListener;
import megamek.client.event.MechDisplayEvent;
import megamek.client.ui.IBoardView;
import megamek.client.ui.IDisplayable;
import megamek.client.ui.Messages;
import megamek.client.ui.SharedUtility;
import megamek.client.ui.swing.ChatterBox2;
import megamek.client.ui.swing.ClientGUI;
import megamek.client.ui.swing.GUIPreferences;
import megamek.client.ui.swing.MovementDisplay;
import megamek.client.ui.swing.tileset.HexTileset;
import megamek.client.ui.swing.tileset.TilesetManager;
import megamek.client.ui.swing.util.CommandAction;
import megamek.client.ui.swing.util.ImageCache;
import megamek.client.ui.swing.util.KeyCommandBind;
import megamek.client.ui.swing.util.MegaMekController;
import megamek.client.ui.swing.widget.MegamekBorder;
import megamek.client.ui.swing.widget.SkinSpecification;
import megamek.client.ui.swing.widget.SkinXMLHandler;
import megamek.common.ArtilleryTracker;
import megamek.common.Building;
import megamek.common.Building.BasementType;
import megamek.common.Compute;
import megamek.common.ComputeECM;
import megamek.common.Configuration;
import megamek.common.Coords;
import megamek.common.ECMInfo;
import megamek.common.Entity;
import megamek.common.EntityVisibilityUtils;
import megamek.common.Flare;
import megamek.common.GunEmplacement;
import megamek.common.IBoard;
import megamek.common.IGame;
import megamek.common.IGame.Phase;
import megamek.common.IHex;
import megamek.common.IPlayer;
import megamek.common.ITerrain;
import megamek.common.Infantry;
import megamek.common.LosEffects;
import megamek.common.Mech;
import megamek.common.Minefield;
import megamek.common.Mounted;
import megamek.common.MovePath;
import megamek.common.MovePath.MoveStepType;
import megamek.common.MoveStep;
import megamek.common.PlanetaryConditions;
import megamek.common.QuadMech;
import megamek.common.SpecialHexDisplay;
import megamek.common.TargetRoll;
import megamek.common.Targetable;
import megamek.common.Terrains;
import megamek.common.ToHitData;
import megamek.common.TripodMech;
import megamek.common.UnitLocation;
import megamek.common.WeaponType;
import megamek.common.actions.ArtilleryAttackAction;
import megamek.common.actions.AttackAction;
import megamek.common.actions.ChargeAttackAction;
import megamek.common.actions.ClubAttackAction;
import megamek.common.actions.DfaAttackAction;
import megamek.common.actions.EntityAction;
import megamek.common.actions.KickAttackAction;
import megamek.common.actions.PhysicalAttackAction;
import megamek.common.actions.ProtomechPhysicalAttackAction;
import megamek.common.actions.PunchAttackAction;
import megamek.common.actions.PushAttackAction;
import megamek.common.actions.SearchlightAttackAction;
import megamek.common.actions.WeaponAttackAction;
import megamek.common.event.BoardEvent;
import megamek.common.event.BoardListener;
import megamek.common.event.GameBoardChangeEvent;
import megamek.common.event.GameBoardNewEvent;
import megamek.common.event.GameEntityChangeEvent;
import megamek.common.event.GameEntityNewEvent;
import megamek.common.event.GameEntityRemoveEvent;
import megamek.common.event.GameListener;
import megamek.common.event.GameListenerAdapter;
import megamek.common.event.GameNewActionEvent;
import megamek.common.event.GamePhaseChangeEvent;
import megamek.common.logging.LogLevel;
import megamek.common.options.GameOptions;
import megamek.common.options.OptionsConstants;
import megamek.common.pathfinder.BoardClusterTracker;
import megamek.common.pathfinder.BoardClusterTracker.BoardCluster;
import megamek.common.preference.IClientPreferences;
import megamek.common.preference.IPreferenceChangeListener;
import megamek.common.preference.PreferenceChangeEvent;
import megamek.common.preference.PreferenceManager;
import megamek.common.util.FiringSolution;
import megamek.common.util.ImageUtil;
import megamek.common.util.fileUtils.MegaMekFile;

/**
 * Displays the board; lets the user scroll around and select points on it.
 */
public class BoardView1 extends JPanel implements IBoardView, Scrollable,
        BoardListener, MouseListener, IPreferenceChangeListener {

    private static final long serialVersionUID = -5582195884759007416L;

    private static final int BOARD_HEX_CLICK = 1;
    private static final int BOARD_HEX_DOUBLECLICK = 2;
    private static final int BOARD_HEX_DRAG = 3;
    private static final int BOARD_HEX_POPUP = 4;

    // the dimensions of megamek's hex images
    public static final int HEX_W = HexTileset.HEX_W;
    public static final int HEX_H = HexTileset.HEX_H;
<span class="fc" id="L193">    public static final int HEX_DIAG = (int) Math.round(Math.sqrt(HEX_W * HEX_W + HEX_H * HEX_H));</span>

    private static final int HEX_WC = HEX_W - (HEX_W / 4);
    static final int HEX_ELEV = 12;

<span class="fc" id="L198">    private static final float[] ZOOM_FACTORS = { 0.30f, 0.41f, 0.50f, 0.60f,</span>
            0.68f, 0.79f, 0.90f, 1.00f, 1.09f, 1.17f, 1.3f };

<span class="fc" id="L201">    private static final int[] ZOOM_SCALE_TYPES = {</span>
            ImageUtil.IMAGE_SCALE_AVG_FILTER, ImageUtil.IMAGE_SCALE_AVG_FILTER,
            ImageUtil.IMAGE_SCALE_BICUBIC, ImageUtil.IMAGE_SCALE_BICUBIC,
            ImageUtil.IMAGE_SCALE_BICUBIC, ImageUtil.IMAGE_SCALE_BICUBIC,
            ImageUtil.IMAGE_SCALE_BICUBIC, ImageUtil.IMAGE_SCALE_BICUBIC,
            ImageUtil.IMAGE_SCALE_BICUBIC, ImageUtil.IMAGE_SCALE_BICUBIC,
            ImageUtil.IMAGE_SCALE_BICUBIC };

<span class="fc" id="L209">    public static final int [] allDirections = {0,1,2,3,4,5};</span>

    // Set to TRUE to draw hexes with isometric elevation.
<span class="nc" id="L212">    private boolean drawIsometric = GUIPreferences.getInstance().getIsometricEnabled();</span>

<span class="nc" id="L214">    int DROPSHDW_DIST = 20;</span>

    // the index of zoom factor 1.00f
    static final int BASE_ZOOM_INDEX = 7;

    // Initial zoom index
<span class="nc" id="L220">    public int zoomIndex = BASE_ZOOM_INDEX;</span>

    // line width of the c3 network lines
    static final int C3_LINE_WIDTH = 1;

    // line width of the fly over lines
    static final int FLY_OVER_LINE_WIDTH = 3;

    // FIXME : Fonts shouldn't ever be handled like this for accessibility reasons
<span class="fc" id="L229">    private static Font FONT_7 = new Font(&quot;SansSerif&quot;, Font.PLAIN, 7);</span>
<span class="fc" id="L230">    private static Font FONT_8 = new Font(&quot;SansSerif&quot;, Font.PLAIN, 8);</span>
<span class="fc" id="L231">    private static Font FONT_9 = new Font(&quot;SansSerif&quot;, Font.PLAIN, 9);</span>
<span class="fc" id="L232">    private static Font FONT_10 = new Font(&quot;SansSerif&quot;, Font.PLAIN, 10);</span>
<span class="fc" id="L233">    private static Font FONT_12 = new Font(&quot;SansSerif&quot;, Font.PLAIN, 12);</span>

    Dimension hex_size;

<span class="nc" id="L237">    private Font font_note = FONT_10;</span>
<span class="nc" id="L238">    private Font font_hexnum = FONT_10;</span>
<span class="nc" id="L239">    private Font font_elev = FONT_9;</span>
<span class="nc" id="L240">    private Font font_minefield = FONT_12;</span>

    public final IGame game;
    ClientGUI clientgui;

    private Dimension boardSize;
<span class="nc" id="L246">    private Dimension preferredSize = new Dimension(0, 0);</span>

    // scrolly stuff:
<span class="nc" id="L249">    private JScrollPane scrollpane = null;</span>
    private JScrollBar vbar;
    private JScrollBar hbar;
<span class="nc" id="L252">    private int scrollXDifference = 0;</span>
<span class="nc" id="L253">    private int scrollYDifference = 0;</span>
    // are we drag-scrolling?
<span class="nc" id="L255">    private boolean dragging = false;</span>
    /** True when the right mouse button was pressed to start a drag */
<span class="nc" id="L257">    private boolean shouldScroll = false;</span>

    // entity sprites
<span class="nc" id="L260">    private Queue&lt;EntitySprite&gt; entitySprites = new PriorityQueue&lt;&gt;();</span>
<span class="nc" id="L261">    private Queue&lt;IsometricSprite&gt; isometricSprites = new PriorityQueue&lt;&gt;();</span>

<span class="nc" id="L263">    private ArrayList&lt;FlareSprite&gt; flareSprites = new ArrayList&lt;&gt;();</span>
    /**
     * A Map that maps an Entity ID and a secondary position to a Sprite. Note
     * that the key is a List where the first entry will be the Entity ID and
     * the second entry will be which secondary position the sprite belongs to;
     * if the Entity has no secondary positions, the first element will be the
     * ID and the second element will be -1.
     */
<span class="nc" id="L271">    private Map&lt;List&lt;Integer&gt;, EntitySprite&gt; entitySpriteIds = new HashMap&lt;&gt;();</span>
    /**
     * A Map that maps an Entity ID and a secondary position to a Sprite. Note
     * that the key is a List where the first entry will be the Entity ID and
     * the second entry will be which secondary position the sprite belongs to;
     * if the Entity has no secondary positions, the first element will be the
     * ID and the second element will be -1.
     */
<span class="nc" id="L279">    private Map&lt;List&lt;Integer&gt;, IsometricSprite&gt; isometricSpriteIds = new HashMap&lt;&gt;();</span>

    // sprites for the three selection cursors
    private CursorSprite cursorSprite;
    private CursorSprite highlightSprite;
    private CursorSprite selectedSprite;
    private CursorSprite firstLOSSprite;
    private CursorSprite secondLOSSprite;

    // sprite for current movement
<span class="nc" id="L289">    ArrayList&lt;StepSprite&gt; pathSprites = new ArrayList&lt;&gt;();</span>

<span class="nc" id="L291">    private ArrayList&lt;Coords&gt; strafingCoords = new ArrayList&lt;&gt;(5);</span>

<span class="nc" id="L293">    private ArrayList&lt;FiringSolutionSprite&gt; firingSprites = new ArrayList&lt;&gt;();</span>

<span class="nc" id="L295">    private ArrayList&lt;MovementEnvelopeSprite&gt; moveEnvSprites = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L296">    private ArrayList&lt;MovementModifierEnvelopeSprite&gt; moveModEnvSprites = new ArrayList&lt;&gt;();</span>

    // vector of sprites for all firing lines
<span class="nc" id="L299">    ArrayList&lt;AttackSprite&gt; attackSprites = new ArrayList&lt;&gt;();</span>

    // vector of sprites for all movement paths (using vectored movement)
<span class="nc" id="L302">    private ArrayList&lt;MovementSprite&gt; movementSprites = new ArrayList&lt;&gt;();</span>

    // vector of sprites for C3 network lines
<span class="nc" id="L305">    private ArrayList&lt;C3Sprite&gt; c3Sprites = new ArrayList&lt;&gt;();</span>

    // list of sprites for declared VTOL/airmech bombing/strafing targets
<span class="nc" id="L308">    private ArrayList&lt;VTOLAttackSprite&gt; vtolAttackSprites = new ArrayList&lt;&gt;();</span>

    // vector of sprites for aero flyover lines
<span class="nc" id="L311">    private ArrayList&lt;FlyOverSprite&gt; flyOverSprites = new ArrayList&lt;&gt;();</span>

    // List of sprites for the weapon field of fire
<span class="nc" id="L314">    private ArrayList&lt;HexSprite&gt; fieldofFireSprites = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L315">    public int[][] fieldofFireRanges = { new int[5], new int[5] };</span>
    public int fieldofFireWpArc;
    public Entity fieldofFireUnit;
    public int fieldofFireWpLoc;
    // int because it acts as an array index
<span class="nc" id="L320">    public int fieldofFireWpUnderwater = 0;</span>
<span class="fc" id="L321">    private static final String[] rangeTexts = { &quot;min&quot;, &quot;S&quot;, &quot;M&quot;, &quot;L&quot;, &quot;E&quot; };</span>

    TilesetManager tileManager;

    // polygons for a few things
    static Polygon hexPoly;
    static {
        // hex polygon
<span class="fc" id="L329">        hexPoly = new Polygon();</span>
<span class="fc" id="L330">        hexPoly.addPoint(21, 0);</span>
<span class="fc" id="L331">        hexPoly.addPoint(62, 0);</span>
<span class="fc" id="L332">        hexPoly.addPoint(83, 35);</span>
<span class="fc" id="L333">        hexPoly.addPoint(83, 36);</span>
<span class="fc" id="L334">        hexPoly.addPoint(62, 71);</span>
<span class="fc" id="L335">        hexPoly.addPoint(21, 71);</span>
<span class="fc" id="L336">        hexPoly.addPoint(0, 36);</span>
<span class="fc" id="L337">        hexPoly.addPoint(0, 35);</span>
    }

    Shape[] movementPolys;
    Shape[] facingPolys;
    Shape[] finalFacingPolys;
    Shape upArrow;
    Shape downArrow;

    // Image to hold the complete board shadow map
    BufferedImage shadowMap;
<span class="nc" id="L348">    double[] lightDirection = { -19, 7 };</span>
<span class="fc" id="L349">    private static Kernel kernel = new Kernel(5, 5,</span>
            new float[] {
                    1f/25f, 1f/25f, 1f/25f, 1f/25f, 1f/25f,
                    1f/25f, 1f/25f, 1f/25f, 1f/25f, 1f/25f,
                    1f/25f, 1f/25f, 1f/25f, 1f/25f, 1f/25f,
                    1f/25f, 1f/25f, 1f/25f, 1f/25f, 1f/25f,
                    1f/25f, 1f/25f, 1f/25f, 1f/25f, 1f/25f});
<span class="fc" id="L356">    private static BufferedImageOp blurOp = new ConvolveOp(kernel);</span>

    // the player who owns this BoardView's client
<span class="nc" id="L359">    private IPlayer localPlayer = null;</span>

    /**
     * Stores the currently deploying entity, used for highlighting deployment
     * hexes.
     */
<span class="nc" id="L365">    private Entity en_Deployer = null;</span>

    // should be able to turn it off(board editor)
<span class="nc" id="L368">    private boolean useLOSTool = true;</span>

    // Initial scale factor for sprites and map
<span class="nc" id="L371">    float scale = 1.00f;</span>
<span class="nc" id="L372">    private ImageCache&lt;Integer, Image&gt; scaledImageCache = new ImageCache&lt;&gt;();</span>
<span class="nc" id="L373">    private ImageCache&lt;Integer, BufferedImage&gt; shadowImageCache = new ImageCache&lt;&gt;();</span>

<span class="nc" id="L375">    private Set&lt;Integer&gt; animatedImages = new HashSet&lt;&gt;();</span>

    // Displayables (Chat box, etc.)
<span class="nc" id="L378">    ArrayList&lt;IDisplayable&gt; displayables = new ArrayList&lt;&gt;();</span>

    // Move units step by step
<span class="nc" id="L381">    private ArrayList&lt;MovingUnit&gt; movingUnits = new ArrayList&lt;&gt;();</span>

<span class="nc" id="L383">    private long moveWait = 0;</span>

    // moving entity sprites
<span class="nc" id="L386">    private List&lt;MovingEntitySprite&gt; movingEntitySprites = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L387">    private HashMap&lt;Integer, MovingEntitySprite&gt; movingEntitySpriteIds = new HashMap&lt;&gt;();</span>
<span class="nc" id="L388">    private ArrayList&lt;GhostEntitySprite&gt; ghostEntitySprites = new ArrayList&lt;&gt;();</span>

<span class="nc" id="L390">    protected transient ArrayList&lt;BoardViewListener&gt; boardListeners = new ArrayList&lt;&gt;();</span>

    // wreck sprites
<span class="nc" id="L393">    private ArrayList&lt;WreckSprite&gt; wreckSprites = new ArrayList&lt;WreckSprite&gt;();</span>
<span class="nc" id="L394">    private ArrayList&lt;IsometricWreckSprite&gt; isometricWreckSprites = new ArrayList&lt;&gt;();</span>

    private Coords rulerStart;
    private Coords rulerEnd;
    private Color rulerStartColor;
    private Color rulerEndColor;

    private Coords lastCursor;
    private Coords highlighted;
    Coords selected;
    private Coords firstLOS;

    /** stores the theme last selected to override all hex themes */
<span class="nc" id="L407">    private String selectedTheme = null;</span>

    // selected entity and weapon for artillery display
<span class="nc" id="L410">    Entity selectedEntity = null;</span>
<span class="nc" id="L411">    private Mounted selectedWeapon = null;</span>

    // hexes with ECM effect
<span class="nc" id="L414">    private Map&lt;Coords, Color&gt; ecmHexes = null;</span>
    // hexes that are teh centers of ECM effects
<span class="nc" id="L416">    private Map&lt;Coords, Color&gt; ecmCenters = null;</span>
    // hexes with ECM effect
<span class="nc" id="L418">    private Map&lt;Coords, Color&gt; eccmHexes = null;</span>
    // hexes that are teh centers of ECCM effects
<span class="nc" id="L420">    private Map&lt;Coords, Color&gt; eccmCenters = null;</span>

    // reference to our timertask for redraw
<span class="nc" id="L423">    private TimerTask ourTask = null;</span>

<span class="nc" id="L425">    BufferedImage bvBgImage = null;</span>
<span class="nc" id="L426">    boolean bvBgShouldTile = false;</span>
<span class="nc" id="L427">    BufferedImage scrollPaneBgBuffer = null;</span>
<span class="nc" id="L428">    Image scrollPaneBgImg = null;</span>

<span class="nc" id="L430">    List&lt;Image&gt; boardBackgrounds = new ArrayList&lt;&gt;();</span>

    private static final int FRAMES = 24;
    private long totalTime;
    private long averageTime;
    private int frameCount;
<span class="nc" id="L436">    private Font fpsFont = new Font(&quot;SansSerif&quot;, 0, 20); //$NON-NLS-1$</span>


    /**
     * Keeps track of whether we have an active ChatterBox2
     */
<span class="nc" id="L442">    private boolean chatterBoxActive = false;</span>

    /**
     * Keeps track of whether an outside source tells the BoardView that it
     * should ignore keyboard commands.
     */
<span class="nc" id="L448">    private boolean shouldIgnoreKeys = false;</span>

    FovHighlightingAndDarkening fovHighlightingAndDarkening;

<span class="nc" id="L452">    private String FILENAME_FLARE_IMAGE = &quot;flare.png&quot;;</span>

<span class="nc" id="L454">    private String FILENAME_RADAR_BLIP_IMAGE = &quot;radarBlip.png&quot;;</span>

    private Image flareImage;

    private Image radarBlipImage;

    /**
    * Cache that stores hex images for different coords
    */
    ImageCache&lt;Coords, HexImageCacheEntry&gt; hexImageCache;


    /**
     * Keeps track of whether all deployment zones should
     * be shown in the Arty Auto Hit Designation phase
     */
<span class="nc" id="L470">    public boolean showAllDeployment = false;</span>

    private long paintCompsStartTime;

<span class="nc" id="L474">    private Rectangle displayablesRect = new Rectangle();</span>

    // Soft Centering ---

    /** True when the board is in the process of centering to a spot. */
<span class="nc" id="L479">    private boolean isSoftCentering = false;</span>
    /** The final position of a soft centering relative to board size (x, y=0...1). */
<span class="nc" id="L481">    private Point2D softCenterTarget = new Point2D.Double();</span>
<span class="nc" id="L482">    private Point2D oldCenter = new Point2D.Double();</span>
    private long waitTimer;
    /** Speed of soft centering of the board, less is faster */
    private static final int SOFT_CENTER_SPEED = 8;

    // Tooltip Info ---
    /** Holds the final Coords for a planned movement. Set by MovementDisplay,
     *  used to display the distance in the board tooltip. */
    private Coords movementTarget;

    // Used to track the previous x/y for tooltip display
<span class="nc" id="L493">    int prevTipX = -1, prevTipY = -1;</span>

    /**
     * Flag to indicate if we should display informatin about illegal terrain in hexes.
     */
<span class="nc" id="L498">    boolean displayInvalidHexInfo = false;</span>

    /** Stores the correct tooltip dismiss delay so it can be restored when exiting the boardview */
<span class="nc" id="L501">    private int dismissDelay = ToolTipManager.sharedInstance().getDismissDelay();</span>
    
    /** A map overlay showing some important keybinds. */ 
    KeyBindingsOverlay keybindOverlay;


    /**
     * Construct a new board view for the specified game
     */
    public BoardView1(final IGame game, final MegaMekController controller, ClientGUI clientgui)
<span class="nc" id="L511">            throws java.io.IOException {</span>
<span class="nc" id="L512">        this.game = game;</span>
<span class="nc" id="L513">        this.clientgui = clientgui;</span>

<span class="nc" id="L515">        hexImageCache = new ImageCache&lt;Coords, HexImageCacheEntry&gt;();</span>

<span class="nc" id="L517">        tileManager = new TilesetManager(this);</span>
<span class="nc" id="L518">        ToolTipManager.sharedInstance().registerComponent(this);</span>

<span class="nc" id="L520">        game.addGameListener(gameListener);</span>
<span class="nc" id="L521">        game.getBoard().addBoardListener(this);</span>
        
<span class="nc" id="L523">        keybindOverlay = new KeyBindingsOverlay(game, clientgui);</span>
<span class="nc" id="L524">        addDisplayable(keybindOverlay);</span>
<span class="nc" id="L525">        ourTask = scheduleRedrawTimer();// call only once</span>
<span class="nc" id="L526">        clearSprites();</span>
<span class="nc" id="L527">        addMouseListener(this);</span>
<span class="nc" id="L528">        addMouseWheelListener(new MouseWheelListener() {</span>
            public void mouseWheelMoved(MouseWheelEvent we) {
<span class="nc" id="L530">                Point mousePoint = we.getPoint();</span>
<span class="nc" id="L531">                Point dispPoint = new Point(mousePoint.x + getBounds().x, mousePoint.y + getBounds().y);</span>
                
                // If the mouse is over an IDisplayable, have it react instead of the board
                // Currently only implemented for the ChatterBox
<span class="nc bnc" id="L535" title="All 2 branches missed.">                for (int i = 0; i &lt; displayables.size(); i++) {</span>
<span class="nc" id="L536">                    IDisplayable disp = displayables.get(i);</span>
<span class="nc bnc" id="L537" title="All 2 branches missed.">                    if (!(disp instanceof ChatterBox2)) {</span>
<span class="nc" id="L538">                        continue;</span>
                    }
<span class="nc" id="L540">                    double width = scrollpane.getViewport().getSize().getWidth();</span>
<span class="nc" id="L541">                    double height = scrollpane.getViewport().getSize().getHeight();</span>
<span class="nc" id="L542">                    Dimension drawDimension = new Dimension();</span>
<span class="nc" id="L543">                    drawDimension.setSize(width, height);</span>
                    // we need to adjust the point, because it should be against
                    // the displayable dimension
<span class="nc bnc" id="L546" title="All 2 branches missed.">                    if (disp.isMouseOver(dispPoint, drawDimension)) {</span>
<span class="nc" id="L547">                        ChatterBox2 cb2 = (ChatterBox2) disp;</span>
<span class="nc bnc" id="L548" title="All 2 branches missed.">                        if (we.getWheelRotation() &gt; 0) {</span>
<span class="nc" id="L549">                            cb2.scrollDown();</span>
                        } else {
<span class="nc" id="L551">                            cb2.scrollUp();</span>
                        }
<span class="nc" id="L553">                        refreshDisplayables();</span>
<span class="nc" id="L554">                        return;</span>
                    }
                }
                
                // calculate a few things to reposition the map
<span class="nc" id="L559">                Coords zoomCenter = getCoordsAt(we.getPoint());</span>
<span class="nc" id="L560">                Point hexL = getCentreHexLocation(zoomCenter);</span>
<span class="nc" id="L561">                Point inhexDelta = new Point(we.getPoint());</span>
<span class="nc" id="L562">                inhexDelta.translate(-HEX_W, -HEX_H);</span>
<span class="nc" id="L563">                inhexDelta.translate(-hexL.x, -hexL.y);</span>
<span class="nc" id="L564">                double ihdx = ((double)inhexDelta.x)/((double)HEX_W)/scale;</span>
<span class="nc" id="L565">                double ihdy = ((double)inhexDelta.y)/((double)HEX_H)/scale;</span>
<span class="nc" id="L566">                int oldzoomIndex = zoomIndex;</span>
                
<span class="nc" id="L568">                boolean ZoomNoCtrl = GUIPreferences.getInstance().getMouseWheelZoom();</span>
<span class="nc" id="L569">                boolean wheelFlip = GUIPreferences.getInstance().getMouseWheelZoomFlip();</span>
<span class="nc bnc" id="L570" title="All 2 branches missed.">                boolean zoomIn = (we.getWheelRotation() &gt; 0) ^ wheelFlip; // = XOR</span>
<span class="nc" id="L571">                boolean doZoom = ZoomNoCtrl ^ we.isControlDown(); // = XOR</span>
<span class="nc bnc" id="L572" title="All 4 branches missed.">                boolean horizontalScroll = !doZoom &amp;&amp; we.isShiftDown();</span>

<span class="nc bnc" id="L574" title="All 2 branches missed.">                if (doZoom) {</span>
<span class="nc bnc" id="L575" title="All 2 branches missed.">                    if (zoomIn) {</span>
<span class="nc" id="L576">                        zoomIn();</span>
                    } else {
<span class="nc" id="L578">                        zoomOut();</span>
                    }
<span class="nc bnc" id="L580" title="All 2 branches missed.">                    if (zoomIndex != oldzoomIndex) {</span>
<span class="nc" id="L581">                        adjustVisiblePosition(zoomCenter, dispPoint, ihdx, ihdy);</span>
                    }
                } else { // SCROLL
<span class="nc bnc" id="L584" title="All 2 branches missed.">                    if (horizontalScroll) {</span>
<span class="nc" id="L585">                        hbar.setValue((int) (hbar.getValue() + (HEX_H * scale * (we.getWheelRotation()))));</span>
                    } else {
<span class="nc" id="L587">                        vbar.setValue((int) (vbar.getValue() + (HEX_H * scale * (we.getWheelRotation()))));</span>
                    }
<span class="nc" id="L589">                    stopSoftCentering();</span>
                }
                
<span class="nc" id="L592">                pingMinimap();</span>
<span class="nc" id="L593">            }</span>
        });

<span class="nc" id="L596">        MouseMotionListener mouseMotionListener = new MouseMotionAdapter() {</span>
            @Override
            public void mouseMoved(MouseEvent e) {
<span class="nc" id="L599">                Point point = e.getPoint();</span>
<span class="nc bnc" id="L600" title="All 2 branches missed.">                if (null == point) {</span>
<span class="nc" id="L601">                    return;</span>
                }

<span class="nc bnc" id="L604" title="All 2 branches missed.">                for (IDisplayable disp: displayables) {</span>
<span class="nc bnc" id="L605" title="All 2 branches missed.">                    if (disp.isBeingDragged()) {</span>
<span class="nc" id="L606">                        return;</span>
                    }
<span class="nc" id="L608">                    double width = Math.min(boardSize.getWidth(), scrollpane</span>
<span class="nc" id="L609">                            .getViewport().getSize().getWidth());</span>
<span class="nc" id="L610">                    double height = Math.min(boardSize.getHeight(), scrollpane</span>
<span class="nc" id="L611">                            .getViewport().getSize().getHeight());</span>
<span class="nc" id="L612">                    Dimension drawDimension = new Dimension();</span>
<span class="nc" id="L613">                    drawDimension.setSize(width, height);</span>
<span class="nc" id="L614">                    disp.isMouseOver(point, drawDimension);</span>
<span class="nc" id="L615">                }</span>
<span class="nc" id="L616">            }</span>

            @Override
            public void mouseDragged(MouseEvent e) {
<span class="nc" id="L620">                Point point = e.getPoint();</span>
<span class="nc bnc" id="L621" title="All 2 branches missed.">                if (null == point) {</span>
<span class="nc" id="L622">                    return;</span>
                }
<span class="nc bnc" id="L624" title="All 2 branches missed.">                for (int i = 0; i &lt; displayables.size(); i++) {</span>
<span class="nc" id="L625">                    IDisplayable disp = displayables.get(i);</span>
<span class="nc" id="L626">                    Point adjustPoint = new Point((int) Math.min(</span>
<span class="nc" id="L627">                            boardSize.getWidth(), -getBounds().getX()),</span>
<span class="nc" id="L628">                                                  (int) Math.min(boardSize.getHeight(), -getBounds()</span>
<span class="nc" id="L629">                                                          .getY()));</span>
<span class="nc" id="L630">                    Point dispPoint = new Point();</span>
<span class="nc" id="L631">                    dispPoint.x = point.x - adjustPoint.x;</span>
<span class="nc" id="L632">                    dispPoint.y = point.y - adjustPoint.y;</span>
<span class="nc" id="L633">                    double width = Math.min(boardSize.getWidth(), scrollpane</span>
<span class="nc" id="L634">                            .getViewport().getSize().getWidth());</span>
<span class="nc" id="L635">                    double height = Math.min(boardSize.getHeight(), scrollpane</span>
<span class="nc" id="L636">                            .getViewport().getSize().getHeight());</span>
<span class="nc" id="L637">                    Dimension drawDimension = new Dimension();</span>
<span class="nc" id="L638">                    drawDimension.setSize(width, height);</span>
<span class="nc bnc" id="L639" title="All 2 branches missed.">                    if (disp.isDragged(dispPoint, drawDimension)) {</span>
<span class="nc" id="L640">                        repaint();</span>
<span class="nc" id="L641">                        return;</span>
                    }
                }
                // only scroll when we should
<span class="nc bnc" id="L645" title="All 2 branches missed.">                if (!shouldScroll) {</span>
<span class="nc" id="L646">                    mouseAction(getCoordsAt(point), BOARD_HEX_DRAG,</span>
<span class="nc" id="L647">                                e.getModifiers());</span>
<span class="nc" id="L648">                    return;</span>
                }
                // if we have not yet been dragging, set the var so popups don't
                // appear when we stop scrolling
<span class="nc bnc" id="L652" title="All 2 branches missed.">                if (!dragging) {</span>
<span class="nc" id="L653">                    dragging = true;</span>
<span class="nc" id="L654">                    setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));</span>
                }
<span class="nc" id="L656">                Point p = scrollpane.getViewport().getViewPosition();</span>
<span class="nc" id="L657">                int newX = p.x - (e.getX() - scrollXDifference);</span>
<span class="nc" id="L658">                int newY = p.y - (e.getY() - scrollYDifference);</span>
<span class="nc" id="L659">                int maxX = getWidth() - scrollpane.getViewport().getWidth();</span>
<span class="nc" id="L660">                int maxY = getHeight() - scrollpane.getViewport().getHeight();</span>
<span class="nc bnc" id="L661" title="All 2 branches missed.">                if (newX &lt; 0) {</span>
<span class="nc" id="L662">                    newX = 0;</span>
                }
<span class="nc bnc" id="L664" title="All 2 branches missed.">                if (newX &gt; maxX) {</span>
<span class="nc" id="L665">                    newX = maxX;</span>
                }
<span class="nc bnc" id="L667" title="All 2 branches missed.">                if (newY &lt; 0) {</span>
<span class="nc" id="L668">                    newY = 0;</span>
                }
<span class="nc bnc" id="L670" title="All 2 branches missed.">                if (newY &gt; maxY) {</span>
<span class="nc" id="L671">                    newY = maxY;</span>
                }
                // don't scroll horizontally if the board fits into the window
<span class="nc bnc" id="L674" title="All 2 branches missed.">                if (scrollpane.getViewport().getWidth() &gt;= getWidth()) {</span>
<span class="nc" id="L675">                    newX = scrollpane.getViewport().getViewPosition().x;</span>
                }
<span class="nc" id="L677">                scrollpane.getViewport().setViewPosition(new Point(newX, newY));</span>
<span class="nc" id="L678">            }</span>
        };
<span class="nc" id="L680">        addMouseMotionListener(mouseMotionListener);</span>

<span class="nc bnc" id="L682" title="All 2 branches missed.">        if (controller != null) {</span>
<span class="nc" id="L683">            registerKeyboardCommands(this, controller);</span>
        }

        // setAutoscrolls(true);

<span class="nc" id="L688">        updateBoardSize();</span>

<span class="nc" id="L690">        hex_size = new Dimension((int) (HEX_W * scale), (int) (HEX_H * scale));</span>

<span class="nc" id="L692">        initPolys();</span>

<span class="nc" id="L694">        cursorSprite = new CursorSprite(this, Color.cyan);</span>
<span class="nc" id="L695">        highlightSprite = new CursorSprite(this, Color.white);</span>
<span class="nc" id="L696">        selectedSprite = new CursorSprite(this, Color.blue);</span>
<span class="nc" id="L697">        firstLOSSprite = new CursorSprite(this, Color.red);</span>
<span class="nc" id="L698">        secondLOSSprite = new CursorSprite(this, Color.red);</span>

<span class="nc" id="L700">        PreferenceManager.getClientPreferences().addPreferenceChangeListener(this);</span>
<span class="nc" id="L701">        GUIPreferences.getInstance().addPreferenceChangeListener(this);</span>

<span class="nc" id="L703">        SpecialHexDisplay.Type.ARTILLERY_HIT.init();</span>
<span class="nc" id="L704">        SpecialHexDisplay.Type.ARTILLERY_INCOMING.init();</span>
<span class="nc" id="L705">        SpecialHexDisplay.Type.ARTILLERY_TARGET.init();</span>
<span class="nc" id="L706">        SpecialHexDisplay.Type.ARTILLERY_ADJUSTED.init();</span>
<span class="nc" id="L707">        SpecialHexDisplay.Type.ARTILLERY_AUTOHIT.init();</span>
<span class="nc" id="L708">        SpecialHexDisplay.Type.PLAYER_NOTE.init();</span>

<span class="nc" id="L710">        fovHighlightingAndDarkening = new FovHighlightingAndDarkening(this);</span>

<span class="nc" id="L712">        flareImage = ImageUtil.loadImageFromFile(</span>
<span class="nc" id="L713">                new MegaMekFile(Configuration.miscImagesDir(), FILENAME_FLARE_IMAGE)</span>
<span class="nc" id="L714">                        .toString());</span>
<span class="nc" id="L715">        radarBlipImage = ImageUtil.loadImageFromFile(</span>
<span class="nc" id="L716">                new MegaMekFile(Configuration.miscImagesDir(),</span>
<span class="nc" id="L717">                        FILENAME_RADAR_BLIP_IMAGE).toString());</span>
<span class="nc" id="L718">    }</span>

    private void registerKeyboardCommands(final BoardView1 bv,
            final MegaMekController controller) {
        // Register the action for TOGGLE_ISO
<span class="nc" id="L723">        controller.registerCommandAction(KeyCommandBind.TOGGLE_ISO.cmd,</span>
<span class="nc" id="L724">                new CommandAction() {</span>

                    @Override
                    public boolean shouldPerformAction() {
<span class="nc bnc" id="L728" title="All 2 branches missed.">                        return !shouldIgnoreKeyCommands();</span>
                    }

                    @Override
                    public void performAction() {
<span class="nc" id="L733">                        GUIPreferences guip = GUIPreferences.getInstance();</span>
<span class="nc" id="L734">                        guip.setIsometricEnabled(toggleIsometric());</span>
<span class="nc" id="L735">                    }</span>

                });

        // Register the action for TOGGLE_CHAT
<span class="nc" id="L740">        controller.registerCommandAction(KeyCommandBind.TOGGLE_CHAT.cmd,</span>
<span class="nc" id="L741">                new CommandAction() {</span>

                    @Override
                    public boolean shouldPerformAction() {
<span class="nc bnc" id="L745" title="All 2 branches missed.">                        return !shouldIgnoreKeyCommands();</span>
                    }

                    @Override
                    public void performAction() {
<span class="nc bnc" id="L750" title="All 2 branches missed.">                        if (!getChatterBoxActive()) {</span>
<span class="nc" id="L751">                            setChatterBoxActive(true);</span>
<span class="nc bnc" id="L752" title="All 2 branches missed.">                            for (IDisplayable disp : displayables) {</span>
<span class="nc bnc" id="L753" title="All 2 branches missed.">                                if (disp instanceof ChatterBox2) {</span>
<span class="nc" id="L754">                                    ((ChatterBox2) disp).slideUp();</span>
                                }
<span class="nc" id="L756">                            }</span>
<span class="nc" id="L757">                            requestFocus();</span>
                        }
<span class="nc" id="L759">                    }</span>

                });

        // Register the action for TOGGLE_CHAT
<span class="nc" id="L764">        controller.registerCommandAction(KeyCommandBind.TOGGLE_CHAT_CMD.cmd,</span>
<span class="nc" id="L765">                new CommandAction() {</span>

                    @Override
                    public boolean shouldPerformAction() {
<span class="nc bnc" id="L769" title="All 2 branches missed.">                        return !shouldIgnoreKeyCommands();</span>
                    }

                    @Override
                    public void performAction() {
<span class="nc bnc" id="L774" title="All 2 branches missed.">                        if (!getChatterBoxActive()) {</span>
<span class="nc" id="L775">                            setChatterBoxActive(true);</span>
<span class="nc bnc" id="L776" title="All 2 branches missed.">                            for (IDisplayable disp : displayables) {</span>
<span class="nc bnc" id="L777" title="All 2 branches missed.">                                if (disp instanceof ChatterBox2) {</span>
<span class="nc" id="L778">                                    ((ChatterBox2) disp).slideUp();</span>
<span class="nc" id="L779">                                    ((ChatterBox2) disp).setMessage(&quot;/&quot;);</span>
                                }
<span class="nc" id="L781">                            }</span>
<span class="nc" id="L782">                            requestFocus();</span>
                        }
<span class="nc" id="L784">                    }</span>

                });

        // Register the action for CENTER_ON_SELECTED
<span class="nc" id="L789">        controller.registerCommandAction(KeyCommandBind.CENTER_ON_SELECTED.cmd,</span>
<span class="nc" id="L790">                new CommandAction() {</span>

                    @Override
                    public boolean shouldPerformAction() {
<span class="nc bnc" id="L794" title="All 4 branches missed.">                        if (shouldIgnoreKeyCommands() || (selectedEntity == null)) {</span>
<span class="nc" id="L795">                            return false;</span>
                        } else {
<span class="nc" id="L797">                            return true;</span>
                        }
                    }

                    @Override
                    public void performAction() {
<span class="nc bnc" id="L803" title="All 2 branches missed.">                        if (selectedEntity != null) {</span>
<span class="nc" id="L804">                            centerOnHex(selectedEntity.getPosition());</span>
                        }
<span class="nc" id="L806">                    }</span>

                });

        // Register the action for SCROLL_NORTH
<span class="nc" id="L811">        controller.registerCommandAction(KeyCommandBind.SCROLL_NORTH.cmd,</span>
<span class="nc" id="L812">                new CommandAction() {</span>

                    @Override
                    public boolean shouldPerformAction() {
<span class="nc bnc" id="L816" title="All 2 branches missed.">                        return !shouldIgnoreKeyCommands();</span>
                    }

                    @Override
                    public void performAction() {
<span class="nc" id="L821">                        controller.stopRepeating(KeyCommandBind.SCROLL_SOUTH);</span>
<span class="nc" id="L822">                        vbar.setValue((int) (vbar.getValue() - (HEX_H * scale)));</span>
<span class="nc" id="L823">                        stopSoftCentering();</span>
<span class="nc" id="L824">                    }</span>

                    @Override
                    public void releaseAction() {
<span class="nc" id="L828">                        pingMinimap();</span>
<span class="nc" id="L829">                    }</span>

                    @Override
                    public boolean hasReleaseAction() {
<span class="nc" id="L833">                        return true;</span>
                    }

                });

        // Register the action for SCROLL_SOUTH
<span class="nc" id="L839">        controller.registerCommandAction(KeyCommandBind.SCROLL_SOUTH.cmd,</span>
<span class="nc" id="L840">                new CommandAction() {</span>

                    @Override
                    public boolean shouldPerformAction() {
<span class="nc bnc" id="L844" title="All 2 branches missed.">                        return !shouldIgnoreKeyCommands();</span>
                    }

                    @Override
                    public void performAction() {
<span class="nc" id="L849">                        controller.stopRepeating(KeyCommandBind.SCROLL_NORTH);</span>
<span class="nc" id="L850">                        vbar.setValue((int) (vbar.getValue() + (HEX_H * scale)));</span>
<span class="nc" id="L851">                        stopSoftCentering();</span>
<span class="nc" id="L852">                    }</span>

                    @Override
                    public void releaseAction() {
<span class="nc" id="L856">                        pingMinimap();</span>
<span class="nc" id="L857">                    }</span>

                    @Override
                    public boolean hasReleaseAction() {
<span class="nc" id="L861">                        return true;</span>
                    }

                });

        // Register the action for SCROLL_EAST
<span class="nc" id="L867">        controller.registerCommandAction(KeyCommandBind.SCROLL_EAST.cmd,</span>
<span class="nc" id="L868">                new CommandAction() {</span>

                    @Override
                    public boolean shouldPerformAction() {
<span class="nc bnc" id="L872" title="All 2 branches missed.">                        return !shouldIgnoreKeyCommands();</span>
                    }

                    @Override
                    public void performAction() {
<span class="nc" id="L877">                        controller.stopRepeating(KeyCommandBind.SCROLL_WEST);</span>
<span class="nc" id="L878">                        hbar.setValue((int) (hbar.getValue() + (HEX_W * scale)));</span>
<span class="nc" id="L879">                        stopSoftCentering();</span>
<span class="nc" id="L880">                    }</span>

                    @Override
                    public void releaseAction() {
<span class="nc" id="L884">                        pingMinimap();</span>
<span class="nc" id="L885">                    }</span>

                    @Override
                    public boolean hasReleaseAction() {
<span class="nc" id="L889">                        return true;</span>
                    }

                });

        // Register the action for SCROLL_WEST
<span class="nc" id="L895">        controller.registerCommandAction(KeyCommandBind.SCROLL_WEST.cmd,</span>
<span class="nc" id="L896">                new CommandAction() {</span>

                    @Override
                    public boolean shouldPerformAction() {
<span class="nc bnc" id="L900" title="All 2 branches missed.">                        return !shouldIgnoreKeyCommands();</span>
                    }

                    @Override
                    public void performAction() {
<span class="nc" id="L905">                        controller.stopRepeating(KeyCommandBind.SCROLL_EAST);</span>
<span class="nc" id="L906">                        hbar.setValue((int) (hbar.getValue() - (HEX_W * scale)));</span>
<span class="nc" id="L907">                        stopSoftCentering();</span>
<span class="nc" id="L908">                    }</span>

                    @Override
                    public void releaseAction() {
<span class="nc" id="L912">                        pingMinimap();</span>
<span class="nc" id="L913">                    }</span>

                    @Override
                    public boolean hasReleaseAction() {
<span class="nc" id="L917">                        return true;</span>
                    }

                });

        // Register the action for Showing the Field of Fire
<span class="nc" id="L923">        controller.registerCommandAction(KeyCommandBind.FIELD_FIRE.cmd,</span>
<span class="nc" id="L924">                new CommandAction() {</span>

                    @Override
                    public boolean shouldPerformAction() {
<span class="nc bnc" id="L928" title="All 2 branches missed.">                        return !shouldIgnoreKeyCommands();</span>
                    }

                    @Override
                    public void performAction() {
<span class="nc" id="L933">                        GUIPreferences guip = GUIPreferences.getInstance();</span>
<span class="nc bnc" id="L934" title="All 2 branches missed.">                        guip.setShowFieldOfFire(!guip.getShowFieldOfFire());</span>
<span class="nc" id="L935">                        repaint();</span>
<span class="nc" id="L936">                    }</span>

                });

        // Register the action for Toggling drawing unit labels
<span class="nc" id="L941">        controller.registerCommandAction(KeyCommandBind.TOGGLE_DRAW_LABELS.cmd,</span>
<span class="nc" id="L942">                new CommandAction() {</span>

                    @Override
                    public boolean shouldPerformAction() {
<span class="nc bnc" id="L946" title="All 2 branches missed.">                        return !shouldIgnoreKeyCommands();</span>
                    }

                    @Override
                    public void performAction() {
<span class="nc" id="L951">                        GUIPreferences guip = GUIPreferences.getInstance();</span>
<span class="nc" id="L952">                        boolean drawLabels = guip.getBoolean(</span>
                                GUIPreferences.ADVANCED_DRAW_ENTITY_LABEL);
<span class="nc bnc" id="L954" title="All 2 branches missed.">                        guip.setValue(GUIPreferences.ADVANCED_DRAW_ENTITY_LABEL,</span>
                                !drawLabels);
<span class="nc" id="L956">                        updateEntityLabels();</span>
<span class="nc bnc" id="L957" title="All 2 branches missed.">                        for (Sprite s: wreckSprites) {</span>
<span class="nc" id="L958">                            s.prepare();</span>
<span class="nc" id="L959">                        }</span>
<span class="nc bnc" id="L960" title="All 2 branches missed.">                        for (Sprite s: isometricWreckSprites) {</span>
<span class="nc" id="L961">                            s.prepare();</span>
<span class="nc" id="L962">                        }</span>
<span class="nc" id="L963">                    }</span>

                });
        
        // Register the action for TOGGLE_KEYBIND_DISPLAY
<span class="nc" id="L968">        controller.registerCommandAction(KeyCommandBind.TOGGLE_KEYBIND_DISPLAY.cmd,</span>
<span class="nc" id="L969">                new CommandAction() {</span>

                    @Override
                    public boolean shouldPerformAction() {
<span class="nc bnc" id="L973" title="All 2 branches missed.">                        return !shouldIgnoreKeyCommands();</span>
                    }

                    @Override
                    public void performAction() {
<span class="nc" id="L978">                        toggleKeybindsOverlay();</span>
<span class="nc" id="L979">                    }</span>
                });
        
        // Register the action for TOGGLE_HEX_COORDS
<span class="nc" id="L983">        controller.registerCommandAction(KeyCommandBind.TOGGLE_HEX_COORDS.cmd,</span>
<span class="nc" id="L984">                new CommandAction() {</span>

                    @Override
                    public boolean shouldPerformAction() {
<span class="nc bnc" id="L988" title="All 2 branches missed.">                        return !shouldIgnoreKeyCommands();</span>
                    }

                    @Override
                    public void performAction() {
<span class="nc" id="L993">                        boolean coordsShown = GUIPreferences.getInstance().getBoolean(GUIPreferences.ADVANCED_SHOW_COORDS);</span>
<span class="nc bnc" id="L994" title="All 2 branches missed.">                        GUIPreferences.getInstance().setValue(GUIPreferences.ADVANCED_SHOW_COORDS, !coordsShown);</span>
<span class="nc" id="L995">                    }</span>

                });

<span class="nc" id="L999">    }</span>

    private boolean shouldIgnoreKeyCommands() {
<span class="nc bnc" id="L1002" title="All 4 branches missed.">        return getChatterBoxActive() || !isVisible()</span>
<span class="nc bnc" id="L1003" title="All 2 branches missed.">               || (game.getPhase() == Phase.PHASE_LOUNGE)</span>
<span class="nc bnc" id="L1004" title="All 2 branches missed.">               || (game.getPhase() == Phase.PHASE_END_REPORT)</span>
<span class="nc bnc" id="L1005" title="All 2 branches missed.">               || (game.getPhase() == Phase.PHASE_MOVEMENT_REPORT)</span>
<span class="nc bnc" id="L1006" title="All 2 branches missed.">               || (game.getPhase() == Phase.PHASE_TARGETING_REPORT)</span>
<span class="nc bnc" id="L1007" title="All 2 branches missed.">               || (game.getPhase() == Phase.PHASE_FIRING_REPORT)</span>
<span class="nc bnc" id="L1008" title="All 2 branches missed.">               || (game.getPhase() == Phase.PHASE_PHYSICAL_REPORT)</span>
<span class="nc bnc" id="L1009" title="All 2 branches missed.">               || (game.getPhase() == Phase.PHASE_OFFBOARD_REPORT)</span>
<span class="nc bnc" id="L1010" title="All 4 branches missed.">               || (game.getPhase() == Phase.PHASE_INITIATIVE_REPORT)</span>
               || shouldIgnoreKeys;
    }

<span class="nc" id="L1014">    protected final RedrawWorker redrawWorker = new RedrawWorker();</span>

    /**
     * this should only be called once!! this will cause a timer to schedule
     * constant screen updates every 20 milliseconds!
     */
    protected TimerTask scheduleRedrawTimer() {
<span class="nc" id="L1021">        final TimerTask redraw = new TimerTask() {</span>
            @Override
            public void run() {
                try {
<span class="nc" id="L1025">                    SwingUtilities.invokeLater(redrawWorker);</span>
<span class="nc" id="L1026">                } catch (Exception ie) {</span>
<span class="nc" id="L1027">                    MegaMek.getLogger().error(&quot;Ignoring error: &quot; + ie.getMessage());</span>
<span class="nc" id="L1028">                }</span>
<span class="nc" id="L1029">            }</span>
        };
<span class="nc" id="L1031">        TimerSingleton.getInstance().schedule(redraw, 20, 20);</span>
<span class="nc" id="L1032">        return redraw;</span>
    }

    protected void scheduleRedraw() {
        try {
<span class="nc" id="L1037">            SwingUtilities.invokeLater(redrawWorker);</span>
<span class="nc" id="L1038">        } catch (Exception ie) {</span>
<span class="nc" id="L1039">            MegaMek.getLogger().error(&quot;Ignoring error: &quot; + ie.getMessage());</span>
<span class="nc" id="L1040">        }</span>
<span class="nc" id="L1041">    }</span>

    public void preferenceChange(PreferenceChangeEvent e) {
<span class="nc bnc" id="L1044" title="All 2 branches missed.">        if (e.getName().equals(IClientPreferences.MAP_TILESET)) {</span>
<span class="nc" id="L1045">            updateBoard();</span>
        }
<span class="nc bnc" id="L1047" title="All 2 branches missed.">        if (e.getName().equals(GUIPreferences.ADVANCED_DRAW_ENTITY_LABEL)</span>
<span class="nc bnc" id="L1048" title="All 2 branches missed.">                || e.getName().equals(GUIPreferences.UNIT_LABEL_BORDER)</span>
<span class="nc bnc" id="L1049" title="All 2 branches missed.">                || e.getName().equals(GUIPreferences.TEAM_COLORING)</span>
<span class="nc bnc" id="L1050" title="All 2 branches missed.">                || e.getName().equals(GUIPreferences.SHOW_DAMAGE_DECAL)</span>
<span class="nc bnc" id="L1051" title="All 2 branches missed.">                || e.getName().equals(GUIPreferences.SHOW_DAMAGE_LEVEL)) {</span>
<span class="nc" id="L1052">            updateEntityLabels();</span>
<span class="nc bnc" id="L1053" title="All 2 branches missed.">            for (Sprite s: wreckSprites) {</span>
<span class="nc" id="L1054">                s.prepare();</span>
<span class="nc" id="L1055">            }</span>
<span class="nc bnc" id="L1056" title="All 2 branches missed.">            for (Sprite s: isometricWreckSprites) {</span>
<span class="nc" id="L1057">                s.prepare();</span>
<span class="nc" id="L1058">            }</span>
        }
<span class="nc bnc" id="L1060" title="All 2 branches missed.">        if (e.getName().equals(GUIPreferences.AOHEXSHADOWS)</span>
<span class="nc bnc" id="L1061" title="All 2 branches missed.">                || e.getName().equals(GUIPreferences.FLOATINGISO)</span>
<span class="nc bnc" id="L1062" title="All 2 branches missed.">                || e.getName().equals(GUIPreferences.LEVELHIGHLIGHT)</span>
<span class="nc bnc" id="L1063" title="All 2 branches missed.">                || e.getName().equals(GUIPreferences.ADVANCED_SHOW_COORDS)</span>
<span class="nc bnc" id="L1064" title="All 2 branches missed.">                || e.getName().equals(GUIPreferences.FOV_DARKEN)</span>
<span class="nc bnc" id="L1065" title="All 2 branches missed.">                || e.getName().equals(GUIPreferences.FOV_DARKEN_ALPHA)</span>
<span class="nc bnc" id="L1066" title="All 2 branches missed.">                || e.getName().equals(GUIPreferences.FOV_GRAYSCALE)</span>
<span class="nc bnc" id="L1067" title="All 2 branches missed.">                || e.getName().equals(GUIPreferences.FOV_HIGHLIGHT)</span>
<span class="nc bnc" id="L1068" title="All 2 branches missed.">                || e.getName().equals(GUIPreferences.FOV_HIGHLIGHT_ALPHA)</span>
<span class="nc bnc" id="L1069" title="All 2 branches missed.">                || e.getName().equals(GUIPreferences.FOV_STRIPES)</span>
<span class="nc bnc" id="L1070" title="All 2 branches missed.">                || e.getName().equals(GUIPreferences.FOV_HIGHLIGHT_RINGS_COLORS_HSB)</span>
<span class="nc bnc" id="L1071" title="All 2 branches missed.">                || e.getName().equals(GUIPreferences.FOV_HIGHLIGHT_RINGS_RADII)</span>
<span class="nc bnc" id="L1072" title="All 2 branches missed.">                || e.getName().equals(GUIPreferences.SHADOWMAP)) {</span>
<span class="nc" id="L1073">            clearHexImageCache();</span>
<span class="nc" id="L1074">            repaint();</span>
        }
<span class="nc bnc" id="L1076" title="All 2 branches missed.">        if (e.getName().equals(GUIPreferences.INCLINES)) {</span>
<span class="nc" id="L1077">            game.getBoard().initializeAllAutomaticTerrain();</span>
<span class="nc" id="L1078">            clearHexImageCache();</span>
<span class="nc" id="L1079">            repaint();</span>
        }
<span class="nc" id="L1081">    }</span>

    /**
     * Adds the specified board listener to receive board events from this
     * board.
     *
     * @param listener the board listener.
     */
    public void addBoardViewListener(BoardViewListener listener) {
<span class="nc bnc" id="L1090" title="All 2 branches missed.">        if (!boardListeners.contains(listener)) {</span>
<span class="nc" id="L1091">            boardListeners.add(listener);</span>
        }
<span class="nc" id="L1093">    }</span>

    /**
     * Removes the specified board listener.
     *
     * @param listener the board listener.
     */
    public void removeBoardViewListener(BoardViewListener listener) {
<span class="nc" id="L1101">        boardListeners.remove(listener);</span>
<span class="nc" id="L1102">    }</span>

    /**
     * Notifies attached board listeners of the event.
     *
     * @param event the board event.
     */
    public void processBoardViewEvent(BoardViewEvent event) {
<span class="nc bnc" id="L1110" title="All 2 branches missed.">        if (boardListeners == null) {</span>
<span class="nc" id="L1111">            return;</span>
        }
<span class="nc bnc" id="L1113" title="All 2 branches missed.">        for (BoardViewListener l : boardListeners) {</span>
<span class="nc bnc" id="L1114" title="All 9 branches missed.">            switch (event.getType()) {</span>
                case BoardViewEvent.BOARD_HEX_CLICKED:
                case BoardViewEvent.BOARD_HEX_DOUBLECLICKED:
                case BoardViewEvent.BOARD_HEX_DRAGGED:
                case BoardViewEvent.BOARD_HEX_POPUP:
<span class="nc" id="L1119">                    l.hexMoused(event);</span>
<span class="nc" id="L1120">                    break;</span>
                case BoardViewEvent.BOARD_HEX_CURSOR:
<span class="nc" id="L1122">                    l.hexCursor(event);</span>
<span class="nc" id="L1123">                    break;</span>
                case BoardViewEvent.BOARD_HEX_HIGHLIGHTED:
<span class="nc" id="L1125">                    l.boardHexHighlighted(event);</span>
<span class="nc" id="L1126">                    break;</span>
                case BoardViewEvent.BOARD_HEX_SELECTED:
<span class="nc" id="L1128">                    l.hexSelected(event);</span>
<span class="nc" id="L1129">                    break;</span>
                case BoardViewEvent.BOARD_FIRST_LOS_HEX:
<span class="nc" id="L1131">                    l.firstLOSHex(event);</span>
<span class="nc" id="L1132">                    break;</span>
                case BoardViewEvent.BOARD_SECOND_LOS_HEX:
<span class="nc" id="L1134">                    l.secondLOSHex(event, getFirstLOS());</span>
<span class="nc" id="L1135">                    break;</span>
                case BoardViewEvent.FINISHED_MOVING_UNITS:
<span class="nc" id="L1137">                    l.finishedMovingUnits(event);</span>
<span class="nc" id="L1138">                    break;</span>
                case BoardViewEvent.SELECT_UNIT:
<span class="nc" id="L1140">                    l.unitSelected(event);</span>
                    break;
            }
<span class="nc" id="L1143">        }</span>
<span class="nc" id="L1144">    }</span>

    void addMovingUnit(Entity entity, Vector&lt;UnitLocation&gt; movePath) {
<span class="nc bnc" id="L1147" title="All 2 branches missed.">        if (!movePath.isEmpty()) {</span>
<span class="nc" id="L1148">            MovingUnit m = new MovingUnit(entity, movePath);</span>
<span class="nc" id="L1149">            movingUnits.add(m);</span>

<span class="nc" id="L1151">            GhostEntitySprite ghostSprite = new GhostEntitySprite(this, entity);</span>
<span class="nc" id="L1152">            ghostEntitySprites.add(ghostSprite);</span>

            // Center on the starting hex of the moving unit.
<span class="nc" id="L1155">            UnitLocation loc = movePath.get(0);</span>
<span class="nc" id="L1156">            centerOnHex(loc.getCoords());</span>
        }
<span class="nc" id="L1158">    }</span>

    public void addDisplayable(IDisplayable disp) {
<span class="nc" id="L1161">        displayables.add(disp);</span>
<span class="nc" id="L1162">    }</span>

    public void removeDisplayable(IDisplayable disp) {
<span class="nc" id="L1165">        displayables.remove(disp);</span>
<span class="nc" id="L1166">    }</span>

    /**
     * Draw the screen!
     */
    @Override
    public synchronized void paintComponent(Graphics g) {
<span class="nc" id="L1173">        GUIPreferences guip = GUIPreferences.getInstance();</span>

<span class="nc bnc" id="L1175" title="All 2 branches missed.">        if (guip.getBoolean(GUIPreferences.ADVANCED_SHOW_FPS)) {</span>
<span class="nc" id="L1176">            paintCompsStartTime = System.nanoTime();</span>
        }

<span class="nc bnc" id="L1179" title="All 2 branches missed.">        if (guip.getAntiAliasing()) {</span>
<span class="nc" id="L1180">            ((Graphics2D) g).setRenderingHint(RenderingHints.KEY_ANTIALIASING,</span>
                    RenderingHints.VALUE_ANTIALIAS_ON);
        }

<span class="nc bnc" id="L1184" title="All 2 branches missed.">        if (!isTileImagesLoaded()) {</span>
<span class="nc" id="L1185">            g.drawString(Messages.getString(&quot;BoardView1.loadingImages&quot;), 20, 50);</span>
<span class="nc bnc" id="L1186" title="All 2 branches missed.">            if (!tileManager.isStarted()) {</span>
<span class="nc" id="L1187">                MegaMek.getLogger().info(&quot;Loading images for board&quot;);</span>
<span class="nc" id="L1188">                tileManager.loadNeededImages(game);</span>
            }
            // wait 1 second, then repaint
<span class="nc" id="L1191">            repaint(1000);</span>
<span class="nc" id="L1192">            return;</span>
        }

<span class="nc" id="L1195">        Rectangle viewRect = scrollpane.getVisibleRect();</span>
<span class="nc bnc" id="L1196" title="All 4 branches missed.">        if (bvBgShouldTile &amp;&amp; (bvBgImage != null)) {</span>
<span class="nc" id="L1197">            Rectangle clipping = g.getClipBounds();</span>
<span class="nc" id="L1198">            int x = 0;</span>
<span class="nc" id="L1199">            int y = 0;</span>
<span class="nc" id="L1200">            int w = bvBgImage.getWidth();</span>
<span class="nc" id="L1201">            int h = bvBgImage.getHeight();</span>
<span class="nc bnc" id="L1202" title="All 2 branches missed.">            while (y &lt; clipping.getHeight()) {</span>
<span class="nc" id="L1203">                int yRem = 0;</span>
<span class="nc bnc" id="L1204" title="All 2 branches missed.">                if (y == 0) {</span>
<span class="nc" id="L1205">                    yRem = clipping.y % h;</span>
                }
<span class="nc" id="L1207">                x = 0;</span>
<span class="nc bnc" id="L1208" title="All 2 branches missed.">                while (x &lt; clipping.getWidth()) {</span>
<span class="nc" id="L1209">                    int xRem = 0;</span>
<span class="nc bnc" id="L1210" title="All 2 branches missed.">                    if (x == 0) {</span>
<span class="nc" id="L1211">                        xRem = clipping.x % w;</span>
                    }
<span class="nc bnc" id="L1213" title="All 4 branches missed.">                    if ((xRem &gt; 0) || (yRem &gt; 0)) {</span>
                        try {
<span class="nc" id="L1215">                            g.drawImage(bvBgImage.getSubimage(xRem, yRem, w - xRem, h - yRem),</span>
                                    clipping.x + x, clipping.y + y, this);
<span class="nc" id="L1217">                        } catch (Exception e) {</span>
                            // if we somehow messed up the math, log the error and simply act as if we have no background image.
<span class="nc" id="L1219">                            Rectangle rasterBounds = bvBgImage.getRaster().getBounds();</span>
                            
<span class="nc" id="L1221">                            String errorData = String.format(&quot;Error drawing background image. Raster Bounds: %.2f, %.2f, width:%.2f, height:%.2f, Attempted Draw Coordinates: %d, %d, width:%d, height:%d&quot;,</span>
<span class="nc" id="L1222">                                    rasterBounds.getMinX(), rasterBounds.getMinY(), rasterBounds.getWidth(), rasterBounds.getHeight(),</span>
<span class="nc" id="L1223">                                    xRem, yRem, w - xRem, h - yRem);</span>
<span class="nc" id="L1224">                            MegaMek.getLogger().error(errorData);</span>
<span class="nc" id="L1225">                        }</span>
                    } else {
<span class="nc" id="L1227">                        g.drawImage(bvBgImage, clipping.x + x, clipping.y + y,</span>
                                this);
                    }
<span class="nc" id="L1230">                    x += w - xRem;</span>
<span class="nc" id="L1231">                }</span>
<span class="nc" id="L1232">                y += h - yRem;</span>
<span class="nc" id="L1233">            }</span>
<span class="nc bnc" id="L1234" title="All 2 branches missed.">        } else if (bvBgImage != null) {</span>
<span class="nc" id="L1235">            g.drawImage(bvBgImage, -getX(), -getY(), (int) viewRect.getWidth(),</span>
<span class="nc" id="L1236">                    (int) viewRect.getHeight(), this);</span>
        } else {
<span class="nc" id="L1238">            MetalTheme theme = new DefaultMetalTheme();</span>
<span class="nc" id="L1239">            g.setColor(theme.getControl());</span>
<span class="nc" id="L1240">            g.fillRect(-getX(), -getY(), (int) viewRect.getWidth(),</span>
<span class="nc" id="L1241">                    (int) viewRect.getHeight());</span>
        }

        // Used to pad the board edge
<span class="nc" id="L1245">        g.translate(HEX_W, HEX_H);</span>

        // Initialize the shadow map when its not yet present
<span class="nc bnc" id="L1248" title="All 2 branches missed.">        if (shadowMap == null) {</span>
<span class="nc" id="L1249">            updateShadowMap();</span>
        }

<span class="nc" id="L1252">        drawHexes(g, g.getClipBounds());</span>

        // draw wrecks
<span class="nc bnc" id="L1255" title="All 4 branches missed.">        if (guip.getShowWrecks() &amp;&amp; !useIsometric()) {</span>
<span class="nc" id="L1256">            drawSprites(g, wreckSprites);</span>
        }

        // Field of Fire
<span class="nc bnc" id="L1260" title="All 4 branches missed.">        if (!useIsometric() &amp;&amp; GUIPreferences.getInstance().getShowFieldOfFire()) {</span>
<span class="nc" id="L1261">            drawSprites(g, fieldofFireSprites);</span>
        }

<span class="nc bnc" id="L1264" title="All 4 branches missed.">        if ((game.getPhase() == Phase.PHASE_MOVEMENT) &amp;&amp; !useIsometric()) {</span>
<span class="nc" id="L1265">            drawSprites(g, moveEnvSprites);</span>
<span class="nc" id="L1266">            drawSprites(g, moveModEnvSprites);</span>
        }

        // Minefield signs all over the place!
<span class="nc" id="L1270">        drawMinefields(g);</span>

        // Artillery targets
<span class="nc" id="L1273">        drawArtilleryHexes(g);</span>

        // draw highlight border
<span class="nc" id="L1276">        drawSprite(g, highlightSprite);</span>

        // draw cursors
<span class="nc" id="L1279">        drawSprite(g, cursorSprite);</span>
<span class="nc" id="L1280">        drawSprite(g, selectedSprite);</span>
<span class="nc" id="L1281">        drawSprite(g, firstLOSSprite);</span>
<span class="nc" id="L1282">        drawSprite(g, secondLOSSprite);</span>

        // draw deployment indicators.
        // For Isometric rendering, this is done during drawHexes
<span class="nc bnc" id="L1286" title="All 4 branches missed.">        if ((en_Deployer != null) &amp;&amp; !useIsometric()) {</span>
<span class="nc" id="L1287">            drawDeployment(g);</span>
        }

<span class="nc bnc" id="L1290" title="All 4 branches missed.">        if ((game.getPhase() == IGame.Phase.PHASE_SET_ARTYAUTOHITHEXES) &amp;&amp; showAllDeployment) {</span>
<span class="nc" id="L1291">            drawAllDeployment(g);</span>
        }

        // draw Flare Sprites
<span class="nc" id="L1295">        drawSprites(g, flareSprites);</span>

        // draw C3 links
<span class="nc" id="L1298">        drawSprites(g, c3Sprites);</span>

        // draw flyover routes
<span class="nc bnc" id="L1301" title="All 2 branches missed.">        if (game.getBoard().onGround()) {</span>
<span class="nc" id="L1302">            drawSprites(g, vtolAttackSprites);</span>
<span class="nc" id="L1303">            drawSprites(g, flyOverSprites);</span>
        }

        // draw onscreen entities
<span class="nc" id="L1307">        drawSprites(g, entitySprites);</span>

        // draw moving onscreen entities
<span class="nc" id="L1310">        drawSprites(g, movingEntitySprites);</span>

        // draw ghost onscreen entities
<span class="nc" id="L1313">        drawSprites(g, ghostEntitySprites);</span>

        // draw onscreen attacks
<span class="nc" id="L1316">        drawSprites(g, attackSprites);</span>

        // draw movement vectors.
<span class="nc bnc" id="L1319" title="All 4 branches missed.">        if (game.useVectorMove() &amp;&amp; (game.getPhase() == IGame.Phase.PHASE_MOVEMENT)) {</span>
<span class="nc" id="L1320">            drawSprites(g, movementSprites);</span>
        }

        // draw movement, if valid
<span class="nc" id="L1324">        drawSprites(g, pathSprites);</span>

        // draw firing solution sprites, but only during the firing phase
<span class="nc bnc" id="L1327" title="All 4 branches missed.">        if ((game.getPhase() == Phase.PHASE_FIRING) || (game.getPhase() == Phase.PHASE_OFFBOARD)) {</span>
<span class="nc" id="L1328">            drawSprites(g, firingSprites);</span>
        }

<span class="nc bnc" id="L1331" title="All 2 branches missed.">        if (game.getPhase() == Phase.PHASE_FIRING) {</span>
<span class="nc bnc" id="L1332" title="All 2 branches missed.">            for (Coords c : strafingCoords) {</span>
<span class="nc" id="L1333">                drawHexBorder(g, getHexLocation(c), Color.yellow, 0, 3);</span>
<span class="nc" id="L1334">            }</span>
        }


        // draw the ruler line
<span class="nc bnc" id="L1339" title="All 2 branches missed.">        if (rulerStart != null) {</span>
<span class="nc" id="L1340">            Point start = getCentreHexLocation(rulerStart);</span>
<span class="nc bnc" id="L1341" title="All 2 branches missed.">            if (rulerEnd != null) {</span>
<span class="nc" id="L1342">                Point end = getCentreHexLocation(rulerEnd);</span>
<span class="nc" id="L1343">                g.setColor(Color.yellow);</span>
<span class="nc" id="L1344">                g.drawLine(start.x, start.y, end.x, end.y);</span>

<span class="nc" id="L1346">                g.setColor(rulerEndColor);</span>
<span class="nc" id="L1347">                g.fillRect(end.x - 1, end.y - 1, 2, 2);</span>
            }

<span class="nc" id="L1350">            g.setColor(rulerStartColor);</span>
<span class="nc" id="L1351">            g.fillRect(start.x - 1, start.y - 1, 2, 2);</span>
        }

        // Undo the previous translation
<span class="nc" id="L1355">        g.translate(-HEX_W, -HEX_H);</span>


        // draw all the &quot;displayables&quot;
<span class="nc bnc" id="L1359" title="All 2 branches missed.">        if (displayablesRect == null) {</span>
<span class="nc" id="L1360">            displayablesRect = new Rectangle();</span>
        }
<span class="nc" id="L1362">        displayablesRect.x = -getX();</span>
<span class="nc" id="L1363">        displayablesRect.y = -getY();</span>
<span class="nc" id="L1364">        displayablesRect.width = scrollpane.getViewport().getViewRect().width;</span>
<span class="nc" id="L1365">        displayablesRect.height = scrollpane.getViewport().getViewRect().height;</span>
<span class="nc bnc" id="L1366" title="All 2 branches missed.">        for (IDisplayable disp: displayables) {</span>
<span class="nc" id="L1367">            disp.draw(g, displayablesRect);</span>
<span class="nc" id="L1368">        }</span>

<span class="nc bnc" id="L1370" title="All 2 branches missed.">        if (guip.getBoolean(GUIPreferences.ADVANCED_SHOW_FPS)) {</span>
<span class="nc bnc" id="L1371" title="All 2 branches missed.">            if (frameCount == FRAMES) {</span>
<span class="nc" id="L1372">                averageTime = totalTime / FRAMES;</span>
<span class="nc" id="L1373">                totalTime = 0;</span>
<span class="nc" id="L1374">                frameCount = 0;</span>
            } else {
<span class="nc" id="L1376">                totalTime += System.nanoTime() - paintCompsStartTime;</span>
<span class="nc" id="L1377">                frameCount++;</span>
            }
<span class="nc" id="L1379">            String s = String.format(&quot;%1$5.3f&quot;, averageTime / 1000000d);</span>
<span class="nc" id="L1380">            g.setFont(fpsFont);</span>
<span class="nc" id="L1381">            g.setColor(Color.YELLOW);</span>
<span class="nc" id="L1382">            g.drawString(s, -getX() + 5, -getY() + 20);</span>
        }

        // debugging method that renders the bounding box of a unit's movement envelope.
        //renderClusters((Graphics2D) g);
        //renderMovementBoundingBox((Graphics2D) g);
        //renderDonut(g, new Coords(10, 10), 2);
        //renderApproxHexDirection((Graphics2D) g);
<span class="nc" id="L1390">    }</span>

    /**
     * Debugging method that renders a hex in the approximate direction 
     * from the selected entity to the selected hex, of both exist.
     * @param g Graphics object on which to draw.
     */
    @SuppressWarnings(&quot;unused&quot;)
    private void renderApproxHexDirection(Graphics2D g) {
<span class="nc bnc" id="L1399" title="All 4 branches missed.">        if(selectedEntity == null || selected == null) {</span>
<span class="nc" id="L1400">            return;</span>
        }
        
<span class="nc" id="L1403">        int direction = selectedEntity.getPosition().approximateDirection(selected, 0, 0);</span>
        
<span class="nc" id="L1405">        Coords donutCoords = selectedEntity.getPosition().translated(direction);</span>
        
<span class="nc" id="L1407">        Point p = getCentreHexLocation(donutCoords.getX(), donutCoords.getY(), true);</span>
<span class="nc" id="L1408">        p.translate(HEX_W  / 2, HEX_H  / 2);</span>
<span class="nc" id="L1409">        drawHexBorder(g, p, Color.BLUE, 0, 6);</span>
<span class="nc" id="L1410">    }</span>
    
    /**
     * Debugging method that renders the bounding hex of a unit's movement envelope.
     * Warning: very slow when rendering the bounding hex for really fast units.
     * @param g Graphics object on which to draw.
     */
    @SuppressWarnings(&quot;unused&quot;)
    private void renderMovementBoundingBox(Graphics2D g) {
<span class="nc bnc" id="L1419" title="All 2 branches missed.">        if(selectedEntity != null) {</span>
<span class="nc" id="L1420">            Princess princess = new Princess(&quot;test&quot;, &quot;localhost&quot;, 2020, LogLevel.DEBUG);</span>
<span class="nc" id="L1421">            princess.getGame().setBoard(this.game.getBoard());</span>
<span class="nc" id="L1422">            PathEnumerator pathEnum = new PathEnumerator(princess, this.game);</span>
<span class="nc" id="L1423">            pathEnum.recalculateMovesFor(this.selectedEntity);</span>

<span class="nc" id="L1425">            ConvexBoardArea cba = pathEnum.getUnitMovableAreas().get(this.selectedEntity.getId());</span>
<span class="nc bnc" id="L1426" title="All 2 branches missed.">            for(int x = 0; x &lt; game.getBoard().getWidth(); x++) {</span>
<span class="nc bnc" id="L1427" title="All 2 branches missed.">                for(int y = 0; y &lt; game.getBoard().getHeight(); y++) {</span>
<span class="nc" id="L1428">                    Point p = getCentreHexLocation(x, y, true);</span>
<span class="nc" id="L1429">                    p.translate(HEX_W  / 2, HEX_H  / 2);</span>
<span class="nc" id="L1430">                    Coords c = new Coords(x, y);</span>

<span class="nc bnc" id="L1432" title="All 2 branches missed.">                    if(cba.contains(c)) {</span>

<span class="nc" id="L1434">                        drawHexBorder(g, p, Color.PINK, 0, 6);</span>
                    }
                }
            }

<span class="nc bnc" id="L1439" title="All 2 branches missed.">            for(Integer x = 0; x &lt; 6; x++) {</span>
<span class="nc" id="L1440">                Coords c = cba.getVertexNum(x);</span>
<span class="nc bnc" id="L1441" title="All 2 branches missed.">                if(c == null) {</span>
<span class="nc" id="L1442">                    continue;</span>
                }

<span class="nc" id="L1445">                Point p = getCentreHexLocation(c.getX(), c.getY(), true);</span>
<span class="nc" id="L1446">                p.translate(HEX_W / 2, HEX_H  / 2);</span>

<span class="nc" id="L1448">                drawHexBorder(g, p, Color.yellow, 0, 3);</span>
<span class="nc" id="L1449">                String s = x.toString();</span>
<span class="nc" id="L1450">                this.drawCenteredText((Graphics2D) g, s, p, Color.yellow, false);</span>
            }
        }
<span class="nc" id="L1453">    }</span>

    /**
     * Debugging method that renders a hex donut around the given coordinates, with the given radius.
     * @param g Graphics object on which to draw.
     */
    @SuppressWarnings(&quot;unused&quot;)
    private void renderDonut(Graphics2D g, Coords coords, int radius) {
<span class="nc" id="L1461">        List&lt;Coords&gt; donut = coords.allAtDistance(radius);</span>

<span class="nc bnc" id="L1463" title="All 2 branches missed.">        for(Coords donutCoords : donut) {</span>
<span class="nc" id="L1464">            Point p = getCentreHexLocation(donutCoords.getX(), donutCoords.getY(), true);</span>
<span class="nc" id="L1465">            p.translate(HEX_W  / 2, HEX_H  / 2);</span>
<span class="nc" id="L1466">            drawHexBorder(g, p, Color.PINK, 0, 6);</span>
<span class="nc" id="L1467">        }</span>
<span class="nc" id="L1468">    }</span>
    
    /**
     * Debugging method that renders a obnoxious pink lines around hexes in &quot;Board Clusters&quot;
     * @param g Graphics object on which to draw.
     */
    @SuppressWarnings(&quot;unused&quot;)
    private void renderClusters(Graphics2D g) {
<span class="nc" id="L1476">        BoardClusterTracker bct = new BoardClusterTracker();</span>
<span class="nc" id="L1477">        Map&lt;Coords, BoardCluster&gt; clusterMap = bct.generateClusters(selectedEntity, false, true);</span>
        
<span class="nc bnc" id="L1479" title="All 2 branches missed.">        for(BoardCluster cluster : clusterMap.values().stream().distinct().collect(Collectors.toList())) {</span>
<span class="nc bnc" id="L1480" title="All 2 branches missed.">            for (Coords coords : cluster.contents.keySet()) {</span>
<span class="nc" id="L1481">                Point p = getCentreHexLocation(coords.getX(), coords.getY(), true);</span>
<span class="nc" id="L1482">                p.translate(HEX_W  / 2, HEX_H  / 2);</span>
<span class="nc" id="L1483">                drawHexBorder(g, p, new Color(0, 0, (20 * cluster.id) % 255), 0, 6);</span>
<span class="nc" id="L1484">            }</span>
<span class="nc" id="L1485">        }</span>
<span class="nc" id="L1486">    }</span>

    /**
     *  @return a list of {@link Coords} of all hexes on the board.
     *          Returns ONLY hexes where board.getHex != null.
     */
    private List&lt;Coords&gt; allBoardHexes() {
<span class="nc" id="L1493">        IBoard board = game.getBoard();</span>
<span class="nc bnc" id="L1494" title="All 2 branches missed.">        if (board == null) {</span>
<span class="nc" id="L1495">            return Collections.emptyList();</span>
        }

<span class="nc" id="L1498">        List&lt;Coords&gt; coordList = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1499" title="All 2 branches missed.">        for (int i = 0; i &lt; board.getWidth(); i++) {</span>
<span class="nc bnc" id="L1500" title="All 2 branches missed.">            for (int j = 0; j &lt; board.getHeight(); j++) {</span>
<span class="nc bnc" id="L1501" title="All 2 branches missed.">                if (board.getHex(i, j) != null) {</span>
<span class="nc" id="L1502">                    coordList.add(new Coords(i, j));</span>
                }
            }
        }

<span class="nc" id="L1507">        return coordList;</span>
    }

    private Image createBlurredShadow(Image orig) {
<span class="nc bnc" id="L1511" title="All 2 branches missed.">        if ((orig == null) ||</span>
<span class="nc bnc" id="L1512" title="All 2 branches missed.">                orig.getWidth(this) &lt; 0 ||</span>
<span class="nc bnc" id="L1513" title="All 2 branches missed.">                orig.getHeight(this) &lt; 0) {</span>
<span class="nc" id="L1514">            return null;</span>
        }
<span class="nc" id="L1516">        BufferedImage mask = shadowImageCache.get(orig.hashCode());</span>
<span class="nc bnc" id="L1517" title="All 2 branches missed.">        if (mask == null) {</span>
            GraphicsConfiguration config = GraphicsEnvironment
<span class="nc" id="L1519">                    .getLocalGraphicsEnvironment().getDefaultScreenDevice()</span>
<span class="nc" id="L1520">                    .getDefaultConfiguration();</span>

            // a slightly bigger image to give room for blurring
<span class="nc" id="L1523">            mask = config.createCompatibleImage(orig.getWidth(this)+4, orig.getHeight(this)+4,</span>
                    Transparency.TRANSLUCENT);
<span class="nc" id="L1525">            Graphics g = mask.getGraphics();</span>
<span class="nc" id="L1526">            g.drawImage(orig,2,2,null);</span>
<span class="nc" id="L1527">            g.dispose();</span>
<span class="nc" id="L1528">            mask = createShadowMask(mask);</span>
<span class="nc" id="L1529">            mask = blurOp.filter(mask, null);</span>
<span class="nc bnc" id="L1530" title="All 2 branches missed.">            if (game.getPlanetaryConditions().getLight() != PlanetaryConditions.L_DAY) {</span>
<span class="nc" id="L1531">                mask = blurOp.filter(mask, null);</span>
            }
<span class="nc" id="L1533">            shadowImageCache.put(orig.hashCode(), mask);</span>
        }
<span class="nc" id="L1535">        return mask;</span>
    }

    /**
     *  Prepares a shadow map for the board, drawing shadows for hills/trees/buildings.
     *  The shadow map is an image the size of the whole board.
     */
    private void updateShadowMap() {
        // Issues:
        // Bridge shadows show a gap towards connected hexes. I don't know why.
        // More than one super image on a hex (building+road) doesnt work. how do I get
        //   the super for a hex for a specific terrain? This would also help
        //   with building shadowing other buildings.
        // AO shadows might be handled by this too. But:
        // this seems to need a lot of additional copying (paint shadow on a clean map for this level alone; soften up; copy to real shadow
        // map with clipping area active; get new clean shadow map for next shadowed level;
        // too much hassle currently; it works so beautifully
<span class="nc bnc" id="L1552" title="All 2 branches missed.">        if (!GUIPreferences.getInstance().getShadowMap()) return;</span>

<span class="nc" id="L1554">        IBoard board = game.getBoard();</span>
<span class="nc bnc" id="L1555" title="All 2 branches missed.">        if (board == null) return;</span>
<span class="nc bnc" id="L1556" title="All 2 branches missed.">        if (board.inSpace()) return;</span>
<span class="nc bnc" id="L1557" title="All 2 branches missed.">        if (boardSize == null) updateBoardSize();</span>
<span class="nc bnc" id="L1558" title="All 2 branches missed.">        if (!isTileImagesLoaded()) return;</span>
        // Map editor? No shadows
<span class="nc bnc" id="L1560" title="All 2 branches missed.">        if (game.getPhase() == IGame.Phase.PHASE_UNKNOWN) return;</span>

<span class="nc" id="L1562">        long stT = System.nanoTime();</span>

        // 1) create or get the hex shadow
<span class="nc" id="L1565">        Image hexShadow = createBlurredShadow(tileManager.getHexMask());</span>
<span class="nc bnc" id="L1566" title="All 2 branches missed.">        if (hexShadow == null) {</span>
<span class="nc" id="L1567">            repaint(1000);</span>
<span class="nc" id="L1568">            return;</span>
        }


        // the shadowmap needs to be painted as if scale == 1
        // therefore some of the methods of boardview1 cannot be used
<span class="nc" id="L1574">        int width = game.getBoard().getWidth() * HEX_WC + (int) (HEX_W / 4);</span>
<span class="nc" id="L1575">        int height = game.getBoard().getHeight() * (int) (HEX_H) + (int) (HEX_H / 2);</span>

        GraphicsConfiguration config = GraphicsEnvironment
<span class="nc" id="L1578">                .getLocalGraphicsEnvironment().getDefaultScreenDevice()</span>
<span class="nc" id="L1579">                .getDefaultConfiguration();</span>

<span class="nc" id="L1581">        shadowMap = config.createCompatibleImage(width, height,</span>
                Transparency.TRANSLUCENT);

<span class="nc" id="L1584">        Graphics2D g = (Graphics2D)(shadowMap.createGraphics());</span>

<span class="nc bnc" id="L1586" title="All 2 branches missed.">        if ((game.getPlanetaryConditions().getLight() == PlanetaryConditions.L_MOONLESS) ||</span>
<span class="nc bnc" id="L1587" title="All 2 branches missed.">        (game.getPlanetaryConditions().getLight() == PlanetaryConditions.L_PITCH_BLACK)) {</span>
<span class="nc" id="L1588">            lightDirection = new double[] { 0, 0 };</span>
<span class="nc bnc" id="L1589" title="All 2 branches missed.">        } else if (game.getPlanetaryConditions().getLight() == PlanetaryConditions.L_DUSK) {</span>
            // TODO: replace when made user controlled
<span class="nc" id="L1591">            lightDirection = new double[] { -38, 14 };</span>
        } else {
<span class="nc" id="L1593">            lightDirection = new double[] { -19, 7 };</span>
        }

        // Shadows for elevation
        // 1a) Sort the board hexes by elevation
        // 1b) Create a reduced list of shadowcasting hexes
<span class="nc" id="L1599">        double angle = Math.atan2(-lightDirection[1], lightDirection[0]);</span>
<span class="nc" id="L1600">        int mDir = (int)(0.5+1.5-angle/Math.PI*3); // +0.5 to counter the (int)</span>
<span class="nc" id="L1601">        int[] sDirs = { mDir%6, (mDir+1)%6, (mDir+5)%6 };</span>
<span class="nc" id="L1602">        HashMap&lt;Integer,Set&lt;Coords&gt;&gt; sortedHexes = new HashMap&lt;Integer,Set&lt;Coords&gt;&gt;();</span>
<span class="nc" id="L1603">        HashMap&lt;Integer,Set&lt;Coords&gt;&gt; shadowCastingHexes = new HashMap&lt;Integer,Set&lt;Coords&gt;&gt;();</span>
<span class="nc bnc" id="L1604" title="All 2 branches missed.">        for (Coords c: allBoardHexes()) {</span>
<span class="nc" id="L1605">            IHex hex = board.getHex(c);</span>
<span class="nc" id="L1606">            int level = hex.getLevel();</span>
<span class="nc bnc" id="L1607" title="All 2 branches missed.">            if (!sortedHexes.containsKey(level)) { // no hexes yet for this height</span>
<span class="nc" id="L1608">                sortedHexes.put(level, new HashSet&lt;Coords&gt;());</span>
            }
<span class="nc bnc" id="L1610" title="All 2 branches missed.">            if (!shadowCastingHexes.containsKey(level)) { // no hexes yet for this height</span>
<span class="nc" id="L1611">                shadowCastingHexes.put(level, new HashSet&lt;Coords&gt;());</span>
            }
<span class="nc" id="L1613">            sortedHexes.get(level).add(c);</span>
            // add a hex to the shadowcasting hexes only
            // if it is nor surrounded by same height hexes
<span class="nc" id="L1616">            boolean surrounded = true;</span>
<span class="nc bnc" id="L1617" title="All 2 branches missed.">            for (int dir: sDirs) {</span>
<span class="nc bnc" id="L1618" title="All 2 branches missed.">                if (!board.contains(c.translated(dir))) {</span>
<span class="nc" id="L1619">                    surrounded = false;</span>
                } else {
<span class="nc" id="L1621">                    IHex nhex = board.getHex(c.translated(dir));</span>
<span class="nc" id="L1622">                    int lv = nhex.getLevel();</span>
<span class="nc bnc" id="L1623" title="All 2 branches missed.">                    if (lv &lt; level)</span>
<span class="nc" id="L1624">                        surrounded = false;</span>
                }
            }
<span class="nc bnc" id="L1627" title="All 2 branches missed.">            if (!surrounded) shadowCastingHexes.get(level).add(c);</span>
<span class="nc" id="L1628">        }</span>

        // 2) Create clipping areas
<span class="nc" id="L1631">        HashMap&lt;Integer,Shape&gt; levelClips = new HashMap&lt;Integer,Shape&gt;();</span>
<span class="nc bnc" id="L1632" title="All 2 branches missed.">        for (Integer h: sortedHexes.keySet()) {</span>
<span class="nc" id="L1633">            Path2D path = new Path2D.Float();</span>
<span class="nc bnc" id="L1634" title="All 2 branches missed.">            for (Coords c: sortedHexes.get(h)) {</span>
<span class="nc" id="L1635">                Point p = getHexLocationLargeTile(c.getX(), c.getY(), 1);</span>
<span class="nc" id="L1636">                AffineTransform t = AffineTransform.getTranslateInstance(p.x+HEX_W/2, p.y+HEX_H/2);</span>
<span class="nc" id="L1637">                t.scale(1.02, 1.02);</span>
<span class="nc" id="L1638">                t.translate(-HEX_W/2, -HEX_H/2);</span>
<span class="nc" id="L1639">                path.append(t.createTransformedShape(hexPoly), false);</span>
<span class="nc" id="L1640">            }</span>
<span class="nc" id="L1641">            levelClips.put(h, path);</span>
<span class="nc" id="L1642">        }</span>


        // 3) Find all level differences
<span class="nc" id="L1646">        final int maxDiff = 35; // limit all diffs to this value</span>
<span class="nc" id="L1647">        Set&lt;Integer&gt; lDiffs = new TreeSet&lt;Integer&gt;();</span>
<span class="nc" id="L1648">        for (int shadowed = board.getMinElevation();</span>
<span class="nc bnc" id="L1649" title="All 2 branches missed.">                shadowed &lt; board.getMaxElevation();</span>
<span class="nc" id="L1650">                shadowed++) {</span>
<span class="nc bnc" id="L1651" title="All 2 branches missed.">            if (levelClips.get(shadowed) == null) continue;</span>

<span class="nc" id="L1653">            for (int shadowcaster = shadowed+1;</span>
<span class="nc bnc" id="L1654" title="All 2 branches missed.">                    shadowcaster &lt;= board.getMaxElevation();</span>
<span class="nc" id="L1655">                    shadowcaster++) {</span>
<span class="nc bnc" id="L1656" title="All 2 branches missed.">                if (levelClips.get(shadowcaster) == null) continue;</span>

<span class="nc" id="L1658">                lDiffs.add(Math.min(shadowcaster-shadowed, maxDiff));</span>
            }
        }

        // 4) Elevation Shadow images for all level differences present
<span class="nc" id="L1663">        int n = 10;</span>
<span class="nc" id="L1664">        double deltaX = lightDirection[0]/n;</span>
<span class="nc" id="L1665">        double deltaY = lightDirection[1]/n;</span>
<span class="nc" id="L1666">        Map&lt;Integer,BufferedImage&gt; hS = new HashMap&lt;Integer,BufferedImage&gt;();</span>
<span class="nc bnc" id="L1667" title="All 2 branches missed.">        for (int lDiff: lDiffs) {</span>
<span class="nc" id="L1668">            Dimension eSize = new Dimension(</span>
<span class="nc" id="L1669">                    (int)(Math.abs(lightDirection[0])*lDiff+HEX_W)*2,</span>
<span class="nc" id="L1670">                    (int)(Math.abs(lightDirection[1])*lDiff+HEX_H)*2);</span>

<span class="nc" id="L1672">            BufferedImage elevShadow = config.createCompatibleImage(eSize.width, eSize.height,</span>
                    Transparency.TRANSLUCENT);
<span class="nc" id="L1674">            Graphics gS = elevShadow.getGraphics();</span>
<span class="nc" id="L1675">            Point2D p1 = new Point2D.Double(eSize.width/2, eSize.height/2);</span>
<span class="nc bnc" id="L1676" title="All 2 branches missed.">            if (GUIPreferences.getInstance().getHexInclines()) {</span>
                // With inclines, the level 1 shadows are only very slight
<span class="nc" id="L1678">                int beg = 4;</span>
<span class="nc" id="L1679">                p1.setLocation(p1.getX()+deltaX*beg, p1.getY()+deltaY*beg);</span>
<span class="nc bnc" id="L1680" title="All 2 branches missed.">                for (int i = beg; i&lt;n*(lDiff-0.4); i++) {</span>
<span class="nc" id="L1681">                    gS.drawImage(hexShadow, (int)p1.getX(), (int)p1.getY(), null);</span>
<span class="nc" id="L1682">                    p1.setLocation(p1.getX()+deltaX, p1.getY()+deltaY);</span>
                }   
<span class="nc" id="L1684">            } else {</span>
<span class="nc bnc" id="L1685" title="All 2 branches missed.">                for (int i = 0; i&lt;n*lDiff; i++) {</span>
<span class="nc" id="L1686">                    gS.drawImage(hexShadow, (int)p1.getX(), (int)p1.getY(), null);</span>
<span class="nc" id="L1687">                    p1.setLocation(p1.getX()+deltaX, p1.getY()+deltaY);</span>
                }
                
            }
<span class="nc" id="L1691">            gS.dispose();</span>
<span class="nc" id="L1692">            hS.put(lDiff, elevShadow);</span>
<span class="nc" id="L1693">        }</span>

        // 5) Actually draw the elevation shadows
<span class="nc" id="L1696">        for (int shadowed = board.getMinElevation();</span>
<span class="nc bnc" id="L1697" title="All 2 branches missed.">                shadowed &lt; board.getMaxElevation();</span>
<span class="nc" id="L1698">                shadowed++) {</span>
<span class="nc bnc" id="L1699" title="All 2 branches missed.">            if (levelClips.get(shadowed) == null) continue;</span>

<span class="nc" id="L1701">            Shape saveClip = g.getClip();</span>
<span class="nc" id="L1702">            g.setClip(levelClips.get(shadowed));</span>

<span class="nc" id="L1704">            for (int shadowcaster = shadowed+1;</span>
<span class="nc bnc" id="L1705" title="All 2 branches missed.">                    shadowcaster &lt;= board.getMaxElevation();</span>
<span class="nc" id="L1706">                    shadowcaster++) {</span>
<span class="nc bnc" id="L1707" title="All 2 branches missed.">                if (levelClips.get(shadowcaster) == null) continue;</span>
<span class="nc" id="L1708">                int lDiff = shadowcaster - shadowed;</span>

<span class="nc bnc" id="L1710" title="All 2 branches missed.">                for (Coords c: shadowCastingHexes.get(shadowcaster)) {</span>
<span class="nc" id="L1711">                    Point2D p0 = getHexLocationLargeTile(c.getX(), c.getY(), 1);</span>
<span class="nc" id="L1712">                    g.drawImage(hS.get(Math.min(lDiff, maxDiff)),</span>
<span class="nc" id="L1713">                            (int)p0.getX()-(int)(Math.abs(lightDirection[0])*Math.min(lDiff, maxDiff)+HEX_W),</span>
<span class="nc" id="L1714">                            (int)p0.getY()-(int)(Math.abs(lightDirection[1])*Math.min(lDiff, maxDiff)+HEX_H), null);</span>
<span class="nc" id="L1715">                }</span>
            }
<span class="nc" id="L1717">            g.setClip(saveClip);</span>
        }

<span class="nc" id="L1720">        n = 5;</span>
<span class="nc" id="L1721">        deltaX = lightDirection[0]/n;</span>
<span class="nc" id="L1722">        deltaY = lightDirection[1]/n;</span>

        // 4) woods and bulding shadows
<span class="nc" id="L1725">        for (int shadowed = board.getMinElevation();</span>
<span class="nc bnc" id="L1726" title="All 2 branches missed.">                shadowed &lt;= board.getMaxElevation();</span>
<span class="nc" id="L1727">                shadowed++) {</span>
<span class="nc bnc" id="L1728" title="All 2 branches missed.">            if (levelClips.get(shadowed) == null) continue;</span>

<span class="nc" id="L1730">            Shape saveClip = g.getClip();</span>
<span class="nc" id="L1731">            g.setClip(levelClips.get(shadowed));</span>

<span class="nc" id="L1733">            for (int shadowcaster = board.getMinElevation();</span>
<span class="nc bnc" id="L1734" title="All 2 branches missed.">                    shadowcaster &lt;= board.getMaxElevation();</span>
<span class="nc" id="L1735">                    shadowcaster++) {</span>
<span class="nc bnc" id="L1736" title="All 2 branches missed.">                if (levelClips.get(shadowcaster) == null) continue;</span>

<span class="nc bnc" id="L1738" title="All 2 branches missed.">                for (Coords c: sortedHexes.get(shadowcaster)) {</span>
<span class="nc" id="L1739">                    Point2D p0 = getHexLocationLargeTile(c.getX(), c.getY(), 1);</span>
<span class="nc" id="L1740">                    Point2D p1 = new Point2D.Double();</span>

                    // Woods Shadow
<span class="nc" id="L1743">                    IHex hex = board.getHex(c);</span>
<span class="nc" id="L1744">                    List&lt;Image&gt; supers = tileManager.supersFor(hex);</span>

<span class="nc bnc" id="L1746" title="All 2 branches missed.">                    if (!supers.isEmpty()) {</span>
<span class="nc" id="L1747">                        Image lastSuper = createBlurredShadow(supers.get(supers.size()-1));</span>
<span class="nc bnc" id="L1748" title="All 2 branches missed.">                        if (lastSuper == null) {</span>
<span class="nc" id="L1749">                            clearShadowMap();</span>
<span class="nc" id="L1750">                            return;</span>
                        }
<span class="nc bnc" id="L1752" title="All 2 branches missed.">                        if (hex.containsTerrain(Terrains.WOODS) ||</span>
<span class="nc bnc" id="L1753" title="All 2 branches missed.">                                hex.containsTerrain(Terrains.JUNGLE)) {</span>
                            // Woods are 2 levels high, but then shadows
                            // appear very extreme, therefore only
                            // 1.5 levels: (shadowcaster+1.5-shadowed)
<span class="nc" id="L1757">                            double shadowHeight = .75 * hex.terrainLevel(Terrains.FOLIAGE_ELEV);</span>
<span class="nc" id="L1758">                            p1.setLocation(p0);</span>
<span class="nc bnc" id="L1759" title="All 2 branches missed.">                            if ((shadowcaster + shadowHeight - shadowed) &gt; 0) {</span>
<span class="nc bnc" id="L1760" title="All 2 branches missed.">                                for (int i = 0; i &lt; n * (shadowcaster + shadowHeight - shadowed); i++) {</span>
<span class="nc" id="L1761">                                    g.drawImage(lastSuper, (int)p1.getX(), (int)p1.getY(), null);</span>
<span class="nc" id="L1762">                                    p1.setLocation(p1.getX()+deltaX, p1.getY()+deltaY);</span>
                                }
                            }
                        }


                        // Buildings Shadow
<span class="nc bnc" id="L1769" title="All 2 branches missed.">                        if (hex.containsTerrain(Terrains.BUILDING)) {</span>
<span class="nc" id="L1770">                            int h = hex.terrainLevel(Terrains.BLDG_ELEV);</span>
<span class="nc bnc" id="L1771" title="All 2 branches missed.">                            if ((shadowcaster+h-shadowed) &gt; 0) {</span>
<span class="nc" id="L1772">                                p1.setLocation(p0);</span>
<span class="nc bnc" id="L1773" title="All 2 branches missed.">                                for (int i = 0; i &lt; (n * (shadowcaster + h - shadowed)); i++) {</span>
<span class="nc" id="L1774">                                    g.drawImage(lastSuper, (int) p1.getX(), (int) p1.getY(), null);</span>
<span class="nc" id="L1775">                                    p1.setLocation(p1.getX() + deltaX, p1.getY() + deltaY);</span>
                                }
                            }
                        }
                    }
                    // Bridge Shadow
<span class="nc bnc" id="L1781" title="All 2 branches missed.">                    if (hex.containsTerrain(Terrains.BRIDGE)) {</span>
<span class="nc" id="L1782">                        supers = tileManager.orthoFor(hex);</span>
<span class="nc bnc" id="L1783" title="All 2 branches missed.">                        if (supers.isEmpty()) break;</span>
<span class="nc" id="L1784">                        Image maskB = createBlurredShadow(supers.get(supers.size() - 1));</span>
<span class="nc bnc" id="L1785" title="All 2 branches missed.">                        if (maskB == null) {</span>
<span class="nc" id="L1786">                            clearShadowMap();</span>
<span class="nc" id="L1787">                            return;</span>
                        }
<span class="nc" id="L1789">                        int h = hex.terrainLevel(Terrains.BRIDGE_ELEV);</span>
<span class="nc" id="L1790">                        p1.setLocation(p0.getX() + deltaX * n * (shadowcaster + h - shadowed),</span>
<span class="nc" id="L1791">                                p0.getY() + deltaY * n * (shadowcaster + h - shadowed));</span>
                        // the shadowmask is translucent, therefore draw n times
                        // stupid hack
<span class="nc bnc" id="L1794" title="All 2 branches missed.">                        for (int i = 0; i &lt; n; i++)</span>
<span class="nc" id="L1795">                            g.drawImage(maskB, (int) p1.getX(), (int) p1.getY(), null);</span>
                    }
<span class="nc" id="L1797">                }</span>
            }
<span class="nc" id="L1799">            g.setClip(saveClip);</span>
        }

<span class="nc" id="L1802">        long tT5 = System.nanoTime() - stT;</span>
<span class="nc" id="L1803">        MegaMek.getLogger().info(&quot;Time to prepare the shadow map: &quot; + tT5 / 1e6 + &quot; ms&quot;);</span>
<span class="nc" id="L1804">    }</span>

    public void clearShadowMap() {
<span class="nc" id="L1807">        shadowMap = null;</span>
<span class="nc" id="L1808">    }</span>

    /**
     * Updates the boardSize variable with the proper values for this board.
     */
    private void updateBoardSize() {
<span class="nc" id="L1814">        int width = (game.getBoard().getWidth() * (int) (HEX_WC * scale))</span>
                    + (int) ((HEX_W / 4) * scale);
<span class="nc" id="L1816">        int height = (game.getBoard().getHeight() * (int) (HEX_H * scale))</span>
                     + (int) ((HEX_H / 2) * scale);
<span class="nc" id="L1818">        boardSize = new Dimension(width, height);</span>
<span class="nc" id="L1819">    }</span>

    /**
     * Looks through a vector of buffered images and draws them if they're
     * onscreen.
     */
    private synchronized void drawSprites(Graphics g,
            Collection&lt;? extends Sprite&gt; spriteArrayList) {
<span class="nc bnc" id="L1827" title="All 2 branches missed.">        for (Sprite sprite : spriteArrayList) {</span>
<span class="nc" id="L1828">            drawSprite(g, sprite);</span>
<span class="nc" id="L1829">        }</span>
<span class="nc" id="L1830">    }</span>

    private synchronized void drawHexSpritesForHex(Coords c, Graphics g,
            ArrayList&lt;? extends HexSprite&gt; spriteArrayList) {
<span class="nc" id="L1834">        Rectangle view = g.getClipBounds();</span>

<span class="nc bnc" id="L1836" title="All 2 branches missed.">        for (HexSprite sprite : spriteArrayList) {</span>
<span class="nc" id="L1837">            Coords cp = sprite.getPosition();</span>
            // This can potentially be an expensive operation
<span class="nc" id="L1839">            Rectangle spriteBounds = sprite.getBounds();</span>
<span class="nc bnc" id="L1840" title="All 6 branches missed.">            if (cp.equals(c) &amp;&amp; view.intersects(spriteBounds) &amp;&amp; !sprite.isHidden()) {</span>
<span class="nc bnc" id="L1841" title="All 2 branches missed.">                if (!sprite.isReady()) {</span>
<span class="nc" id="L1842">                    sprite.prepare();</span>
                }
<span class="nc" id="L1844">                sprite.drawOnto(g, spriteBounds.x, spriteBounds.y,</span>
                        this, false);
            }
<span class="nc" id="L1847">        }</span>
<span class="nc" id="L1848">    }</span>

    /**
     * Draws the Entity for the given hex. This function is used by the
     * isometric rendering process so that sprites are drawn in the order that
     * hills are rendered to create the appearance that the sprite is behind the
     * hill.
     *
     * @param c               The Coordinates of the hex that the sprites should be drawn
     *                        for.
     * @param g               The Graphics object for this board.
     * @param spriteArrayList The complete list of all IsometricSprite on the board.
     */
    private synchronized void drawIsometricSpritesForHex(Coords c, Graphics g,
            Collection&lt;IsometricSprite&gt; spriteArrayList) {
<span class="nc" id="L1863">        Rectangle view = g.getClipBounds();</span>
<span class="nc bnc" id="L1864" title="All 2 branches missed.">        for (IsometricSprite sprite : spriteArrayList) {</span>
<span class="nc" id="L1865">            Coords cp = sprite.getPosition();</span>
            // This can potentially be an expensive operation
<span class="nc" id="L1867">            Rectangle spriteBounds = sprite.getBounds();</span>
<span class="nc bnc" id="L1868" title="All 4 branches missed.">            if (cp.equals(c) &amp;&amp; view.intersects(spriteBounds)</span>
<span class="nc bnc" id="L1869" title="All 2 branches missed.">                &amp;&amp; !sprite.isHidden()) {</span>
<span class="nc bnc" id="L1870" title="All 2 branches missed.">                if (!sprite.isReady()) {</span>
<span class="nc" id="L1871">                    sprite.prepare();</span>
                }
<span class="nc" id="L1873">                sprite.drawOnto(g, spriteBounds.x, spriteBounds.y, this, false);</span>
            }
<span class="nc" id="L1875">        }</span>
<span class="nc" id="L1876">    }</span>

    /**
     * Draws the wrecksprites for the given hex. This function is used by the
     * isometric rendering process so that sprites are drawn in the order that
     * hills are rendered to create the appearance that the sprite is behind the
     * hill.
     *
     * @param c               The Coordinates of the hex that the sprites should be drawn
     *                        for.
     * @param g               The Graphics object for this board.
     * @param spriteArrayList The complete list of all IsometricSprite on the board.
     */
    private synchronized void drawIsometricWreckSpritesForHex(Coords c,
            Graphics g, ArrayList&lt;IsometricWreckSprite&gt; spriteArrayList) {
<span class="nc" id="L1891">        Rectangle view = g.getClipBounds();</span>
<span class="nc bnc" id="L1892" title="All 2 branches missed.">        for (IsometricWreckSprite sprite : spriteArrayList) {</span>
<span class="nc" id="L1893">            Coords cp = sprite.getPosition();</span>
<span class="nc bnc" id="L1894" title="All 4 branches missed.">            if (cp.equals(c) &amp;&amp; view.intersects(sprite.getBounds())</span>
<span class="nc bnc" id="L1895" title="All 2 branches missed.">                &amp;&amp; !sprite.isHidden()) {</span>
<span class="nc bnc" id="L1896" title="All 2 branches missed.">                if (!sprite.isReady()) {</span>
<span class="nc" id="L1897">                    sprite.prepare();</span>
                }
<span class="nc" id="L1899">                sprite.drawOnto(g, sprite.getBounds().x, sprite.getBounds().y,</span>
                                this, false);
            }
<span class="nc" id="L1902">        }</span>
<span class="nc" id="L1903">    }</span>

    /**
     * Draws a translucent sprite without any of the companion graphics, if it
     * is in the current view. This is used only when performing isometric
     * rending. This function is used to show units (with 50% transparency) that
     * are hidden behind a hill.
     * &lt;p/&gt;
     * TODO: Optimize this function so that it is only applied to sprites that
     * are actually hidden. This implementation performs the second rendering
     * for all sprites.
     */
    private final void drawIsometricSprites(Graphics g,
            Collection&lt;IsometricSprite&gt; spriteArrayList) {
<span class="nc" id="L1917">        Rectangle view = g.getClipBounds();</span>
<span class="nc bnc" id="L1918" title="All 2 branches missed.">        for (IsometricSprite sprite : spriteArrayList) {</span>
            // This can potentially be an expensive operation
<span class="nc" id="L1920">            Rectangle spriteBounds = sprite.getBounds();</span>
<span class="nc bnc" id="L1921" title="All 4 branches missed.">            if (view.intersects(spriteBounds) &amp;&amp; !sprite.isHidden()) {</span>
<span class="nc bnc" id="L1922" title="All 2 branches missed.">                if (!sprite.isReady()) {</span>
<span class="nc" id="L1923">                    sprite.prepare();</span>
                }
<span class="nc" id="L1925">                sprite.drawOnto(g, spriteBounds.x, spriteBounds.y,</span>
                                this, true);
            }
<span class="nc" id="L1928">        }</span>
<span class="nc" id="L1929">    }</span>

    /**
     * Draws a sprite, if it is in the current view
     */
    private final void drawSprite(Graphics g, Sprite sprite) {
<span class="nc" id="L1935">        Rectangle view = g.getClipBounds();</span>
        // This can potentially be an expensive operation
<span class="nc" id="L1937">        Rectangle spriteBounds = sprite.getBounds();</span>
<span class="nc bnc" id="L1938" title="All 4 branches missed.">        if (view.intersects(spriteBounds) &amp;&amp; !sprite.isHidden()) {</span>
<span class="nc bnc" id="L1939" title="All 2 branches missed.">            if (!sprite.isReady()) {</span>
<span class="nc" id="L1940">                sprite.prepare();</span>
            }
<span class="nc" id="L1942">            sprite.drawOnto(g, spriteBounds.x, spriteBounds.y, this);</span>
        }
<span class="nc" id="L1944">    }</span>

    /**
     * Draw an outline around legal deployment hexes
     */
    private void drawDeployment(Graphics g) {
<span class="nc" id="L1950">        Rectangle view = g.getClipBounds();</span>
        // only update visible hexes
<span class="nc" id="L1952">        int drawX = (view.x / (int) (HEX_WC * scale)) - 1;</span>
<span class="nc" id="L1953">        int drawY = (view.y / (int) (HEX_H * scale)) - 1;</span>

<span class="nc" id="L1955">        int drawWidth = (view.width / (int) (HEX_WC * scale)) + 3;</span>
<span class="nc" id="L1956">        int drawHeight = (view.height / (int) (HEX_H * scale)) + 3;</span>

<span class="nc" id="L1958">        IBoard board = game.getBoard();</span>
        // loop through the hexes
<span class="nc bnc" id="L1960" title="All 2 branches missed.">        for (int i = 0; i &lt; drawHeight; i++) {</span>
<span class="nc bnc" id="L1961" title="All 2 branches missed.">            for (int j = 0; j &lt; drawWidth; j++) {</span>
<span class="nc" id="L1962">                Coords c = new Coords(j + drawX, i + drawY);</span>
<span class="nc bnc" id="L1963" title="All 2 branches missed.">                if (board.isLegalDeployment(c, en_Deployer.getStartingPos())) {</span>
<span class="nc" id="L1964">                    drawHexBorder(g, getHexLocation(c), Color.yellow);</span>
                }
            }
        }
<span class="nc" id="L1968">    }</span>

    /**
     * Draw indicators for the deployment zones of all players
     */
    private void drawAllDeployment(Graphics g) {
<span class="nc" id="L1974">        Rectangle view = g.getClipBounds();</span>
        // only update visible hexes
<span class="nc" id="L1976">        int drawX = (view.x / (int) (HEX_WC * scale)) - 1;</span>
<span class="nc" id="L1977">        int drawY = (view.y / (int) (HEX_H * scale)) - 1;</span>

<span class="nc" id="L1979">        int drawWidth = (view.width / (int) (HEX_WC * scale)) + 3;</span>
<span class="nc" id="L1980">        int drawHeight = (view.height / (int) (HEX_H * scale)) + 3;</span>

<span class="nc" id="L1982">        IBoard board = game.getBoard();</span>
        // loop through the hexes
<span class="nc bnc" id="L1984" title="All 2 branches missed.">        for (int i = 0; i &lt; drawHeight; i++) {</span>
<span class="nc bnc" id="L1985" title="All 2 branches missed.">            for (int j = 0; j &lt; drawWidth; j++) {</span>
<span class="nc" id="L1986">                Coords c = new Coords(j + drawX, i + drawY);</span>
<span class="nc" id="L1987">                Enumeration&lt;IPlayer&gt; allP = game.getPlayers();</span>
                IPlayer cp;
<span class="nc" id="L1989">                int pCount = 0;</span>
<span class="nc" id="L1990">                int bThickness = 1 + 10 / game.getNoOfPlayers();</span>
                // loop through all players
<span class="nc bnc" id="L1992" title="All 2 branches missed.">                while (allP.hasMoreElements()) {</span>
<span class="nc" id="L1993">                    cp = allP.nextElement();</span>
<span class="nc bnc" id="L1994" title="All 2 branches missed.">                    if (board.isLegalDeployment(c, cp.getStartingPos())) {</span>
<span class="nc" id="L1995">                        Color bC = cp.getColour().getColour();</span>
<span class="nc" id="L1996">                        drawHexBorder(g, getHexLocation(c), bC, (bThickness+2)</span>
                                * pCount, bThickness);
<span class="nc" id="L1998">                        pCount++;</span>
<span class="nc" id="L1999">                    }</span>
                }
            }
        }
<span class="nc" id="L2003">    }</span>

    /**
     * Darkens a hexes in the viewing area if there is no line of sight between
     * them and the supplied source hex. Used in non-isometric view.
     *
     * @param p
     *            The source hex for which line of sight originates
     * @param g
     *            The graphics object to draw on.
     * @param col
     *            The what color to use.
     * @param outOfFOV
     *            The destination hex for computing the line of sight
     */

    /**
     * Draw a layer of a solid color (alpha possible) on the hex at Point p no
     * padding by default
     */
    void drawHexLayer(Point p, Graphics g, Color col, boolean outOfFOV) {
<span class="nc" id="L2024">        drawHexLayer(p, g, col, outOfFOV, 0);</span>
<span class="nc" id="L2025">    }</span>

    /**
     * Draw a layer of a solid color (alpha possible) on the hex at Point p with
     * some padding around the border
     */
    private void drawHexLayer(Point p, Graphics g, Color col, boolean outOfFOV,
            double pad) {
<span class="nc" id="L2033">        Graphics2D g2D = (Graphics2D)g;</span>
<span class="nc" id="L2034">        g.setColor(col);</span>

        // create stripe effect for FOV darkening but not for colored weapon
        // ranges
<span class="nc" id="L2038">        int fogStripes = GUIPreferences.getInstance().getFovStripes();</span>
<span class="nc bnc" id="L2039" title="All 6 branches missed.">        if (outOfFOV &amp;&amp; (fogStripes &gt; 0) &amp;&amp; (g instanceof Graphics2D)) {</span>
<span class="nc" id="L2040">            float lineSpacing = fogStripes;</span>
            // totally transparent here hurts the eyes
<span class="nc" id="L2042">            Color c2 = new Color(col.getRed() / 2, col.getGreen() / 2,</span>
<span class="nc" id="L2043">                    col.getBlue() / 2, col.getAlpha() / 2);</span>

            // the numbers make the lines align across hexes
<span class="nc" id="L2046">            GradientPaint gp = new GradientPaint(42.0f / lineSpacing, 0.0f,</span>
                    col, 104.0f / lineSpacing, 106.0f / lineSpacing, c2, true);
<span class="nc" id="L2048">            g2D.setPaint(gp);</span>
        }
<span class="nc" id="L2050">        Composite svComposite = g2D.getComposite();</span>
<span class="nc" id="L2051">        g2D.setComposite(AlphaComposite.SrcAtop);</span>
<span class="nc" id="L2052">        g2D.fillRect(0, 0, hex_size.width, hex_size.height);</span>
<span class="nc" id="L2053">        g2D.setComposite(svComposite);</span>
<span class="nc" id="L2054">    }</span>

    private void drawHexBorder(Graphics g, Color col, double pad,
            double linewidth) {
<span class="nc" id="L2058">        drawHexBorder(g, new Point(0,0), col, pad, linewidth);</span>
<span class="nc" id="L2059">    }</span>

    public void drawHexBorder(Graphics g, Point p, Color col, double pad,
            double linewidth) {
<span class="nc" id="L2063">        g.setColor(col);</span>
<span class="nc" id="L2064">        ((Graphics2D)g).fill(</span>
<span class="nc" id="L2065">                AffineTransform.getTranslateInstance(p.x, p.y).createTransformedShape(</span>
<span class="nc" id="L2066">                AffineTransform.getScaleInstance(scale, scale).createTransformedShape(</span>
<span class="nc" id="L2067">                HexDrawUtilities.getHexFullBorderArea(linewidth, pad))));</span>
<span class="nc" id="L2068">    }</span>

    /**
     * Draw an outline around the hex at Point p no padding and a width of 1
     */
    private void drawHexBorder(Graphics g, Point p, Color col) {
<span class="nc" id="L2074">        drawHexBorder(g, p, col, 0);</span>
<span class="nc" id="L2075">    }</span>

    /**
     * Draw an outline around the hex at Point p padded around the border by pad
     * and a line-width of 1
     */
    private void drawHexBorder(Graphics g, Point p, Color col, double pad) {
<span class="nc" id="L2082">        drawHexBorder(g, p, col, pad, 1);</span>
<span class="nc" id="L2083">    }</span>

    /**
     * returns the weapon selected in the mech display, or null if none selected
     * or it is not artillery or null if the selected entity is not owned
     */
    public Mounted getSelectedArtilleryWeapon() {
        // We don't want to display artillery auto-hit/adjusted fire hexes
        // during
        // the artyautohithexes phase. These could be displayed if the player
        // uses the /reset command in some situations
<span class="nc bnc" id="L2094" title="All 2 branches missed.">        if (game.getPhase() == IGame.Phase.PHASE_SET_ARTYAUTOHITHEXES) {</span>
<span class="nc" id="L2095">            return null;</span>
        }

<span class="nc bnc" id="L2098" title="All 4 branches missed.">        if ((selectedEntity == null) || (selectedWeapon == null)) {</span>
<span class="nc" id="L2099">            return null;</span>
        }

<span class="nc bnc" id="L2102" title="All 2 branches missed.">        if (!selectedEntity.getOwner().equals(localPlayer)) {</span>
<span class="nc" id="L2103">            return null; // Not my business to see this</span>
        }

<span class="nc bnc" id="L2106" title="All 2 branches missed.">        if (selectedEntity.getEquipmentNum(selectedWeapon) == -1) {</span>
<span class="nc" id="L2107">            return null; // inconsistent state - weapon not on entity</span>
        }

<span class="nc bnc" id="L2110" title="All 2 branches missed.">        if (!((selectedWeapon.getType() instanceof WeaponType) &amp;&amp; selectedWeapon</span>
<span class="nc bnc" id="L2111" title="All 2 branches missed.">                .getType().hasFlag(WeaponType.F_ARTILLERY))) {</span>
<span class="nc" id="L2112">            return null; // not artillery</span>
        }

        // otherwise, a weapon is selected, and it is artillery
<span class="nc" id="L2116">        return selectedWeapon;</span>
    }

    /**
     * Display artillery modifier in pretargeted hexes
     */
    private void drawArtilleryHexes(Graphics g) {
<span class="nc" id="L2123">        Mounted weapon = getSelectedArtilleryWeapon();</span>
<span class="nc" id="L2124">        Rectangle view = g.getClipBounds();</span>

        // Compute the origin of the viewing area
<span class="nc" id="L2127">        int drawX = (view.x / (int) (HEX_WC * scale)) - 1;</span>
<span class="nc" id="L2128">        int drawY = (view.y / (int) (HEX_H * scale)) - 1;</span>

        // Compute size of viewing area
<span class="nc" id="L2131">        int drawWidth = (view.width / (int) (HEX_WC * scale)) + 3;</span>
<span class="nc" id="L2132">        int drawHeight = (view.height / (int) (HEX_H * scale)) + 3;</span>

        Image artyIconImage;

        // Draw incoming artillery sprites - requires server to update client's
        // view of game
<span class="nc" id="L2138">        for (Enumeration&lt;ArtilleryAttackAction&gt; attacks = game.getArtilleryAttacks();</span>
<span class="nc bnc" id="L2139" title="All 2 branches missed.">             attacks.hasMoreElements(); ) {</span>
<span class="nc" id="L2140">            final ArtilleryAttackAction attack = attacks.nextElement();</span>
<span class="nc" id="L2141">            final Targetable target = attack.getTarget(game);</span>
<span class="nc bnc" id="L2142" title="All 2 branches missed.">            if (target == null) {</span>
<span class="nc" id="L2143">                continue;</span>
            }
<span class="nc" id="L2145">            final Coords c = target.getPosition();</span>
            // Is the Coord within the viewing area?
<span class="nc bnc" id="L2147" title="All 4 branches missed.">            if ((c.getX() &gt;= drawX) &amp;&amp; (c.getX() &lt;= (drawX + drawWidth))</span>
<span class="nc bnc" id="L2148" title="All 4 branches missed.">                    &amp;&amp; (c.getY() &gt;= drawY) &amp;&amp; (c.getY() &lt;= (drawY + drawHeight))) {</span>
<span class="nc" id="L2149">                Point p = getHexLocation(c);</span>
<span class="nc" id="L2150">                artyIconImage = tileManager.getArtilleryTarget(TilesetManager.ARTILLERY_INCOMING);</span>
<span class="nc" id="L2151">                g.drawImage(getScaledImage(artyIconImage, true), p.x, p.y, this);</span>
            }
<span class="nc" id="L2153">        }</span>

        // Draw pre-designated auto-hit hexes
<span class="nc bnc" id="L2156" title="All 2 branches missed.">        if (localPlayer != null) { // Could be null, like in map-editor</span>
<span class="nc bnc" id="L2157" title="All 2 branches missed.">            for (Coords c : localPlayer.getArtyAutoHitHexes()) {</span>
                // Is the Coord within the viewing area?
<span class="nc bnc" id="L2159" title="All 4 branches missed.">                if ((c.getX() &gt;= drawX) &amp;&amp; (c.getX() &lt;= (drawX + drawWidth))</span>
<span class="nc bnc" id="L2160" title="All 4 branches missed.">                    &amp;&amp; (c.getY() &gt;= drawY) &amp;&amp; (c.getY() &lt;= (drawY + drawHeight))) {</span>

<span class="nc" id="L2162">                    Point p = getHexLocation(c);</span>
<span class="nc" id="L2163">                    artyIconImage = tileManager.getArtilleryTarget(TilesetManager.ARTILLERY_AUTOHIT);</span>
<span class="nc" id="L2164">                    g.drawImage(getScaledImage(artyIconImage, true), p.x, p.y, this);</span>
                }
<span class="nc" id="L2166">            }</span>
        }

        // Draw modifiers for selected entity and weapon
<span class="nc bnc" id="L2170" title="All 2 branches missed.">        if (weapon != null) {</span>
            // Loop through all of the attack modifiers for this weapon
<span class="nc bnc" id="L2172" title="All 2 branches missed.">            for (ArtilleryTracker.ArtilleryModifier attackMod : selectedEntity.aTracker</span>
<span class="nc" id="L2173">                    .getWeaponModifiers(weapon)) {</span>
<span class="nc" id="L2174">                Coords c = attackMod.getCoords();</span>
                // Is the Coord within the viewing area?
<span class="nc bnc" id="L2176" title="All 4 branches missed.">                if ((c.getX() &gt;= drawX) &amp;&amp; (c.getX() &lt;= (drawX + drawWidth))</span>
<span class="nc bnc" id="L2177" title="All 4 branches missed.">                    &amp;&amp; (c.getY() &gt;= drawY) &amp;&amp; (c.getY() &lt;= (drawY + drawHeight))) {</span>

<span class="nc" id="L2179">                    Point p = getHexLocation(c);</span>
                    // draw the crosshairs
<span class="nc bnc" id="L2181" title="All 2 branches missed.">                    if (attackMod.getModifier() == TargetRoll.AUTOMATIC_SUCCESS) {</span>
                        // predesignated or already hit
<span class="nc" id="L2183">                        artyIconImage = tileManager</span>
<span class="nc" id="L2184">                                .getArtilleryTarget(TilesetManager.ARTILLERY_AUTOHIT);</span>
                    } else {
<span class="nc" id="L2186">                        artyIconImage = tileManager</span>
<span class="nc" id="L2187">                                .getArtilleryTarget(TilesetManager.ARTILLERY_ADJUSTED);</span>
                    }
<span class="nc" id="L2189">                    g.drawImage(getScaledImage(artyIconImage, true), p.x, p.y, this);</span>
                }
<span class="nc" id="L2191">            }</span>
        }
<span class="nc" id="L2193">    }</span>

    /*
     * NOTENOTENOTE: (itmo) wouldnt this be simpler with two arrays. One with
     * the strings {&quot;BoardView1.thunderblaablaa&quot;,&quot;BoardView1.Conventi..&quot;} one
     * with the offsets {51,51,42} etc Preferably indexed by an enum: enum{
     * Conventional, Thunder; } or something?
     */

    /**
     * Writes &quot;MINEFIELD&quot; in minefield hexes...
     */
    private void drawMinefields(Graphics g) {
<span class="nc" id="L2206">        Rectangle view = g.getClipBounds();</span>
        // only update visible hexes
<span class="nc" id="L2208">        int drawX = (view.x / (int) (HEX_WC * scale)) - 1;</span>
<span class="nc" id="L2209">        int drawY = (view.y / (int) (HEX_H * scale)) - 1;</span>

<span class="nc" id="L2211">        int drawWidth = (view.width / (int) (HEX_WC * scale)) + 3;</span>
<span class="nc" id="L2212">        int drawHeight = (view.height / (int) (HEX_H * scale)) + 3;</span>

<span class="nc" id="L2214">        int maxX = drawX + drawWidth;</span>
<span class="nc" id="L2215">        int maxY = drawY + drawHeight;</span>

<span class="nc" id="L2217">        IBoard board = game.getBoard();</span>
<span class="nc" id="L2218">        for (Enumeration&lt;Coords&gt; minedCoords = game.getMinedCoords();</span>
<span class="nc bnc" id="L2219" title="All 2 branches missed.">             minedCoords.hasMoreElements(); ) {</span>
<span class="nc" id="L2220">            Coords c = minedCoords.nextElement();</span>
            // If the coords aren't visible, skip
<span class="nc bnc" id="L2222" title="All 8 branches missed.">            if ((c.getX() &lt; drawX) || (c.getX() &gt; maxX) || (c.getY() &lt; drawY) || (c.getY() &gt; maxY)</span>
<span class="nc bnc" id="L2223" title="All 2 branches missed.">                || !board.contains(c)) {</span>
<span class="nc" id="L2224">                continue;</span>
            }

<span class="nc" id="L2227">            Point p = getHexLocation(c);</span>
<span class="nc" id="L2228">            Image mineImg = getScaledImage(tileManager.getMinefieldSign(), true);</span>
<span class="nc" id="L2229">            g.drawImage(mineImg, p.x + (int) (13 * scale), p.y</span>
                                                           + (int) (13 * scale), this);

<span class="nc" id="L2232">            g.setColor(Color.black);</span>
<span class="nc" id="L2233">            int nbrMfs = game.getNbrMinefields(c);</span>
<span class="nc bnc" id="L2234" title="All 2 branches missed.">            if (nbrMfs &gt; 1) {</span>
<span class="nc" id="L2235">                drawCenteredString(</span>
<span class="nc" id="L2236">                        Messages.getString(&quot;BoardView1.Multiple&quot;), //$NON-NLS-1$</span>
                        p.x, p.y + (int) (51 * scale), font_minefield, g);
<span class="nc bnc" id="L2238" title="All 2 branches missed.">            } else if (nbrMfs == 1) {</span>
<span class="nc" id="L2239">                Minefield mf = game.getMinefields(c).get(0);</span>

<span class="nc bnc" id="L2241" title="All 6 branches missed.">                switch (mf.getType()) {</span>
                    case (Minefield.TYPE_CONVENTIONAL):
<span class="nc" id="L2243">                        drawCenteredString(</span>
<span class="nc" id="L2244">                                Messages.getString(&quot;BoardView1.Conventional&quot;) //$NON-NLS-1$</span>
<span class="nc" id="L2245">                                + mf.getDensity() + &quot;)&quot;, //$NON-NLS-1$</span>
                                p.x, p.y + (int) (51 * scale),
                                font_minefield, g);
<span class="nc" id="L2248">                        break;</span>
                    case (Minefield.TYPE_INFERNO):
<span class="nc" id="L2250">                        drawCenteredString(</span>
<span class="nc" id="L2251">                                Messages.getString(&quot;BoardView1.Inferno&quot;) //$NON-NLS-1$</span>
<span class="nc" id="L2252">                                + mf.getDensity() + &quot;)&quot;, //$NON-NLS-1$</span>
                                p.x, p.y + (int) (51 * scale),
                                font_minefield, g);
<span class="nc" id="L2255">                        break;</span>
                    case (Minefield.TYPE_ACTIVE):
<span class="nc" id="L2257">                        drawCenteredString(</span>
<span class="nc" id="L2258">                                Messages.getString(&quot;BoardView1.Active&quot;) //$NON-NLS-1$</span>
<span class="nc" id="L2259">                                + mf.getDensity() + &quot;)&quot;,  //$NON-NLS-2$</span>
                                p.x, p.y + (int) (51 * scale),
                                font_minefield, g);
<span class="nc" id="L2262">                        break;</span>
                    case (Minefield.TYPE_COMMAND_DETONATED):
<span class="nc" id="L2264">                        drawCenteredString(</span>
<span class="nc" id="L2265">                                Messages.getString(&quot;BoardView1.Command-&quot;), //$NON-NLS-1$</span>
                                p.x, p.y + (int) (51 * scale),
                                font_minefield, g);
<span class="nc" id="L2268">                        drawCenteredString(</span>
<span class="nc" id="L2269">                                Messages.getString(&quot;BoardView1.detonated&quot; //$NON-NLS-1$</span>
<span class="nc" id="L2270">                                                   + mf.getDensity() + &quot;)&quot;), //$NON-NLS-1$</span>
                                p.x, p.y + (int) (60 * scale),
                                font_minefield, g);
<span class="nc" id="L2273">                        break;</span>
                    case (Minefield.TYPE_VIBRABOMB):
<span class="nc" id="L2275">                        drawCenteredString(</span>
<span class="nc" id="L2276">                                Messages.getString(&quot;BoardView1.Vibrabomb&quot;), //$NON-NLS-1$</span>
                                p.x, p.y + (int) (51 * scale),
                                font_minefield, g);
<span class="nc bnc" id="L2279" title="All 2 branches missed.">                        if (mf.getPlayerId() == localPlayer.getId()) {</span>
<span class="nc" id="L2280">                            drawCenteredString(&quot;(&quot; //$NON-NLS-1$</span>
<span class="nc" id="L2281">                                               + mf.getSetting() + &quot;)&quot;, //$NON-NLS-1$</span>
                                               p.x, p.y + (int) (60 * scale),
                                               font_minefield, g);
                        }
                        break;
                }
            }
<span class="nc" id="L2288">        }</span>
<span class="nc" id="L2289">    }</span>

    private void drawCenteredString(String string, int x, int y, Font font,
                                    Graphics graph) {
<span class="nc" id="L2293">        FontMetrics currentMetrics = getFontMetrics(font);</span>
<span class="nc" id="L2294">        int stringWidth = currentMetrics.stringWidth(string);</span>

<span class="nc" id="L2296">        x += ((hex_size.width - stringWidth) / 2);</span>

<span class="nc" id="L2298">        graph.setFont(font);</span>
<span class="nc" id="L2299">        graph.drawString(string, x, y);</span>
<span class="nc" id="L2300">    }</span>

    /**
     * This method creates an image the size of the entire board (all
     * mapsheets), draws the hexes onto it, and returns that image.
     */
    public BufferedImage getEntireBoardImage(boolean ignoreUnits) {
        // Set zoom to base, so we get a consist board image

<span class="nc" id="L2309">        int oldZoom = zoomIndex;</span>
<span class="nc" id="L2310">        zoomIndex = BASE_ZOOM_INDEX;</span>
<span class="nc" id="L2311">        zoom();</span>

<span class="nc" id="L2313">        Image entireBoard = createImage(boardSize.width, boardSize.height);</span>
<span class="nc" id="L2314">        Graphics2D boardGraph = (Graphics2D) entireBoard.getGraphics();</span>
<span class="nc" id="L2315">        boardGraph.setClip(0, 0, boardSize.width, boardSize.height);</span>
<span class="nc bnc" id="L2316" title="All 2 branches missed.">        if (GUIPreferences.getInstance().getAntiAliasing()) {</span>
<span class="nc" id="L2317">            boardGraph.setRenderingHint(RenderingHints.KEY_ANTIALIASING,</span>
                                        RenderingHints.VALUE_ANTIALIAS_ON);
        }

<span class="nc bnc" id="L2321" title="All 2 branches missed.">        if (shadowMap == null) {</span>
<span class="nc" id="L2322">            updateShadowMap();</span>
        }

        // Draw hexes
<span class="nc" id="L2326">        drawHexes(boardGraph, new Rectangle(boardSize), ignoreUnits);</span>

        // If we aren't ignoring units, draw everything else
<span class="nc bnc" id="L2329" title="All 2 branches missed.">        if (!ignoreUnits) {</span>
            // draw wrecks
<span class="nc bnc" id="L2331" title="All 2 branches missed.">            if (GUIPreferences.getInstance().getShowWrecks()</span>
<span class="nc bnc" id="L2332" title="All 2 branches missed.">                    &amp;&amp; !useIsometric()) {</span>
<span class="nc" id="L2333">                drawSprites(boardGraph, wreckSprites);</span>
            }

            // Field of Fire
<span class="nc bnc" id="L2337" title="All 2 branches missed.">            if (!useIsometric()</span>
<span class="nc bnc" id="L2338" title="All 2 branches missed.">                    &amp;&amp; GUIPreferences.getInstance().getShowFieldOfFire()) {</span>
<span class="nc" id="L2339">                drawSprites(boardGraph, fieldofFireSprites);</span>
            }

<span class="nc bnc" id="L2342" title="All 4 branches missed.">            if ((game.getPhase() == Phase.PHASE_MOVEMENT) &amp;&amp; !useIsometric()) {</span>
<span class="nc" id="L2343">                drawSprites(boardGraph, moveEnvSprites);</span>
<span class="nc" id="L2344">                drawSprites(boardGraph, moveModEnvSprites);</span>
            }

            // Minefield signs all over the place!
<span class="nc" id="L2348">            drawMinefields(boardGraph);</span>

            // Artillery targets
<span class="nc" id="L2351">            drawArtilleryHexes(boardGraph);</span>

            // draw highlight border
<span class="nc" id="L2354">            drawSprite(boardGraph, highlightSprite);</span>

            // draw cursors
<span class="nc" id="L2357">            drawSprite(boardGraph, cursorSprite);</span>
<span class="nc" id="L2358">            drawSprite(boardGraph, selectedSprite);</span>
<span class="nc" id="L2359">            drawSprite(boardGraph, firstLOSSprite);</span>
<span class="nc" id="L2360">            drawSprite(boardGraph, secondLOSSprite);</span>

            // draw deployment indicators.
            // For Isometric rendering, this is done during drawHexes
<span class="nc bnc" id="L2364" title="All 4 branches missed.">            if ((en_Deployer != null) &amp;&amp; !useIsometric()) {</span>
<span class="nc" id="L2365">                drawDeployment(boardGraph);</span>
            }

<span class="nc bnc" id="L2368" title="All 4 branches missed.">            if ((game.getPhase() == IGame.Phase.PHASE_SET_ARTYAUTOHITHEXES)</span>
                    &amp;&amp; (showAllDeployment)) {
<span class="nc" id="L2370">                drawAllDeployment(boardGraph);</span>
            }

            // draw Flare Sprites
<span class="nc" id="L2374">            drawSprites(boardGraph, flareSprites);</span>

            // draw C3 links
<span class="nc" id="L2377">            drawSprites(boardGraph, c3Sprites);</span>

            // draw flyover routes
<span class="nc bnc" id="L2380" title="All 2 branches missed.">            if (game.getBoard().onGround()) {</span>
<span class="nc" id="L2381">                drawSprites(boardGraph, vtolAttackSprites);</span>
<span class="nc" id="L2382">                drawSprites(boardGraph, flyOverSprites);</span>
            }

            // draw onscreen entities
<span class="nc" id="L2386">            drawSprites(boardGraph, entitySprites);</span>

            // draw moving onscreen entities
<span class="nc" id="L2389">            drawSprites(boardGraph, movingEntitySprites);</span>

            // draw ghost onscreen entities
<span class="nc" id="L2392">            drawSprites(boardGraph, ghostEntitySprites);</span>

            // draw onscreen attacks
<span class="nc" id="L2395">            drawSprites(boardGraph, attackSprites);</span>

            // draw movement vectors.
<span class="nc bnc" id="L2398" title="All 2 branches missed.">            if (game.useVectorMove()</span>
<span class="nc bnc" id="L2399" title="All 2 branches missed.">                &amp;&amp; (game.getPhase() == IGame.Phase.PHASE_MOVEMENT)) {</span>
<span class="nc" id="L2400">                drawSprites(boardGraph, movementSprites);</span>
            }

            // draw movement, if valid
<span class="nc" id="L2404">            drawSprites(boardGraph, pathSprites);</span>

            // draw firing solution sprites, but only during the firing phase
<span class="nc bnc" id="L2407" title="All 2 branches missed.">            if ((game.getPhase() == Phase.PHASE_FIRING) ||</span>
<span class="nc bnc" id="L2408" title="All 2 branches missed.">                (game.getPhase() == Phase.PHASE_OFFBOARD)) {</span>
<span class="nc" id="L2409">                drawSprites(boardGraph, firingSprites);</span>
            }

<span class="nc bnc" id="L2412" title="All 2 branches missed.">            if (game.getPhase() == Phase.PHASE_FIRING) {</span>
<span class="nc bnc" id="L2413" title="All 2 branches missed.">                for (Coords c : strafingCoords) {</span>
<span class="nc" id="L2414">                    drawHexBorder(boardGraph, getHexLocation(c), Color.yellow, 0, 3);</span>
<span class="nc" id="L2415">                }</span>
            }
        }
<span class="nc" id="L2418">        boardGraph.dispose();</span>

        // Restore the zoom setting
<span class="nc" id="L2421">        zoomIndex = oldZoom;</span>
<span class="nc" id="L2422">        zoom();</span>

<span class="nc" id="L2424">        return (BufferedImage) entireBoard;</span>
    }

    private void drawHexes(Graphics g, Rectangle view) {
<span class="nc" id="L2428">        drawHexes(g, view, false);</span>
<span class="nc" id="L2429">    }</span>

    /**
     * Redraws all hexes in the specified rectangle
     */
    private void drawHexes(Graphics g, Rectangle view, boolean saveBoardImage) {
        // only update visible hexes
<span class="nc" id="L2436">        double xs = (int) (HEX_WC*scale);</span>
<span class="nc" id="L2437">        double ys = (int) (HEX_H*scale);</span>

<span class="nc" id="L2439">        int drawX = (int) (view.x / xs) - 1;</span>
<span class="nc" id="L2440">        int drawY = (int) (view.y / ys) - 1;</span>

<span class="nc" id="L2442">        int drawWidth = (int) (view.width / xs) + 3;</span>
<span class="nc" id="L2443">        int drawHeight = (int) (view.height / ys) + 3;</span>

        // draw some hexes.
<span class="nc bnc" id="L2446" title="All 2 branches missed.">        if (useIsometric()) {</span>
<span class="nc" id="L2447">            IBoard board = game.getBoard();</span>
<span class="nc bnc" id="L2448" title="All 2 branches missed.">            for (int y = 0; y &lt; drawHeight; y++) {</span>
                // Half of each row is one-half hex
                // farther back (above) the other; draw those first
<span class="nc bnc" id="L2451" title="All 2 branches missed.">                for (int s = 0; s &lt;= 1; s++) {</span>
<span class="nc bnc" id="L2452" title="All 2 branches missed.">                    for (int x = s; x &lt; drawWidth+s+1; x=x+2) {</span>
                        // For s == 0 the x coordinate MUST be an even number
                        // to get correct occlusion; drawX may be any int though
<span class="nc" id="L2455">                        Coords c = new Coords(x + drawX/2*2, y + drawY);</span>
<span class="nc" id="L2456">                        IHex hex = board.getHex(c);</span>
<span class="nc bnc" id="L2457" title="All 2 branches missed.">                        if ((hex != null)) {</span>
<span class="nc" id="L2458">                            drawHex(c, g, saveBoardImage);</span>
<span class="nc" id="L2459">                            if (GUIPreferences.getInstance()</span>
<span class="nc bnc" id="L2460" title="All 2 branches missed.">                                    .getShowFieldOfFire()) {</span>
<span class="nc" id="L2461">                                drawHexSpritesForHex(c, g, fieldofFireSprites);</span>
                            }
<span class="nc" id="L2463">                            drawHexSpritesForHex(c, g, moveEnvSprites);</span>
<span class="nc" id="L2464">                            drawHexSpritesForHex(c, g, moveModEnvSprites);</span>
<span class="nc bnc" id="L2465" title="All 2 branches missed.">                            if ((en_Deployer != null)</span>
<span class="nc bnc" id="L2466" title="All 2 branches missed.">                                    &amp;&amp; board.isLegalDeployment(c,</span>
<span class="nc" id="L2467">                                            en_Deployer.getStartingPos())) {</span>
<span class="nc" id="L2468">                                drawHexBorder(g, getHexLocation(c),</span>
                                        Color.yellow);
                            }
<span class="nc" id="L2471">                            drawOrthograph(c, g);</span>
                        }
                    }
                }
<span class="nc bnc" id="L2475" title="All 2 branches missed.">                for (int x = 0; x &lt; drawWidth; x++) {</span>
<span class="nc" id="L2476">                    Coords c = new Coords(x + drawX, y + drawY);</span>
<span class="nc" id="L2477">                    IHex hex = board.getHex(c);</span>
<span class="nc bnc" id="L2478" title="All 2 branches missed.">                    if (hex != null) {</span>
<span class="nc bnc" id="L2479" title="All 2 branches missed.">                        if (!saveBoardImage) {</span>
<span class="nc bnc" id="L2480" title="All 2 branches missed.">                            if (GUIPreferences.getInstance().getShowWrecks()) {</span>
<span class="nc" id="L2481">                                drawIsometricWreckSpritesForHex(c, g,</span>
                                        isometricWreckSprites);
                            }
<span class="nc" id="L2484">                            drawIsometricSpritesForHex(c, g, isometricSprites);</span>
                        }
                    }
                }
            }
<span class="nc bnc" id="L2489" title="All 2 branches missed.">            if (!saveBoardImage) {</span>
                // If we are using Isometric rendering, redraw the entity
                // sprites at 50% transparent so sprites hidden behind hills can
                // still be seen by the user.
<span class="nc" id="L2493">                drawIsometricSprites(g, isometricSprites);</span>
            }
<span class="nc" id="L2495">        } else {</span>
            // Draw hexes without regard to elevation when
            // not using Isometric, since it does not matter.
<span class="nc bnc" id="L2498" title="All 2 branches missed.">            for (int i = 0; i &lt; drawHeight; i++) {</span>
<span class="nc bnc" id="L2499" title="All 2 branches missed.">                for (int j = 0; j &lt; drawWidth; j++) {</span>
<span class="nc" id="L2500">                    Coords c = new Coords(j + drawX, i + drawY);</span>
<span class="nc" id="L2501">                    drawHex(c, g, saveBoardImage);</span>
                }
            }
        }
<span class="nc" id="L2505">    }</span>

    /**
     * Draws a hex onto the board buffer. This assumes that drawRect is current,
     * and does not check if the hex is visible.
     */
    private void drawHex(Coords c, Graphics boardGraph,
                         boolean saveBoardImage) {
<span class="nc bnc" id="L2513" title="All 2 branches missed.">        if (!game.getBoard().contains(c)) {</span>
<span class="nc" id="L2514">            return;</span>
        }

<span class="nc" id="L2517">        final GUIPreferences guip = GUIPreferences.getInstance();</span>
<span class="nc" id="L2518">        final IHex hex = game.getBoard().getHex(c);</span>
<span class="nc" id="L2519">        final Point hexLoc = getHexLocation(c);</span>

        // Check the cache to see if we already have the image
<span class="nc" id="L2522">        HexImageCacheEntry cacheEntry = hexImageCache.get(c);</span>
<span class="nc bnc" id="L2523" title="All 4 branches missed.">        if ((cacheEntry != null) &amp;&amp; !cacheEntry.needsUpdating) {</span>
<span class="nc" id="L2524">            boardGraph.drawImage(cacheEntry.hexImage, hexLoc.x, hexLoc.y, this);</span>
<span class="nc" id="L2525">            return;</span>
        }

<span class="nc" id="L2528">        int level = hex.getLevel();</span>
<span class="nc" id="L2529">        int depth = hex.depth(false);</span>

<span class="nc" id="L2531">        ITerrain basement = hex.getTerrain(Terrains.BLDG_BASEMENT_TYPE);</span>
<span class="nc bnc" id="L2532" title="All 2 branches missed.">        if (basement != null) {</span>
<span class="nc" id="L2533">            depth = 0;</span>
        }

<span class="nc" id="L2536">        int height = Math.max(hex.terrainLevel(Terrains.BLDG_ELEV),</span>
<span class="nc" id="L2537">                              hex.terrainLevel(Terrains.BRIDGE_ELEV));</span>
<span class="nc" id="L2538">        height = Math.max(height, hex.terrainLevel(Terrains.INDUSTRIAL));</span>

<span class="nc" id="L2540">        Image boardBgHexImg = getBoardBackgroundHexImage(c, hex);</span>
        // get the base tile image
        Image baseImage, scaledImage;
<span class="nc bnc" id="L2543" title="All 2 branches missed.">        if (boardBgHexImg != null) {</span>
<span class="nc" id="L2544">            baseImage = boardBgHexImg;</span>
<span class="nc" id="L2545">            scaledImage = boardBgHexImg;</span>
        } else {
<span class="nc" id="L2547">            baseImage = tileManager.baseFor(hex);</span>
<span class="nc" id="L2548">            scaledImage = getScaledImage(baseImage, true);</span>
        }

        // Some hex images shouldn't be cached, like if they are animated
<span class="nc" id="L2552">        boolean dontCache = animatedImages.contains(baseImage.hashCode());</span>

        // check if this is a standard tile image 84x72 or something different
<span class="nc bnc" id="L2555" title="All 2 branches missed.">        boolean standardTile = (baseImage.getHeight(null) == HEX_H)</span>
<span class="nc bnc" id="L2556" title="All 2 branches missed.">                &amp;&amp; (baseImage.getWidth(null) == HEX_W);</span>

        int imgHeight, imgWidth;
<span class="nc" id="L2559">        imgWidth = scaledImage.getWidth(null);</span>
<span class="nc" id="L2560">        imgHeight = scaledImage.getHeight(null);</span>

        // do not make larger than hex images even when the input image is big
<span class="nc" id="L2563">        int origImgWidth = imgWidth; // save for later, needed for large tiles</span>
<span class="nc" id="L2564">        int origImgHeight = imgHeight;</span>

<span class="nc" id="L2566">        imgWidth = Math.min(imgWidth,(int)(HEX_W*scale));</span>
<span class="nc" id="L2567">        imgHeight = Math.min(imgHeight,(int)(HEX_H*scale));</span>

<span class="nc bnc" id="L2569" title="All 2 branches missed.">        if (useIsometric()) {</span>
<span class="nc" id="L2570">            int largestLevelDiff = 0;</span>
<span class="nc bnc" id="L2571" title="All 2 branches missed.">            for (int dir: allDirections) {</span>
<span class="nc" id="L2572">                IHex adjHex = game.getBoard().getHexInDir(c, dir);</span>
<span class="nc bnc" id="L2573" title="All 2 branches missed.">                if (adjHex == null) {</span>
<span class="nc" id="L2574">                    continue;</span>
                }
<span class="nc" id="L2576">                int levelDiff = Math.abs(level - adjHex.getLevel());</span>
<span class="nc bnc" id="L2577" title="All 2 branches missed.">                if (levelDiff &gt; largestLevelDiff) {</span>
<span class="nc" id="L2578">                    largestLevelDiff = levelDiff;</span>
                }
            }
<span class="nc" id="L2581">            imgHeight += HEX_ELEV * scale * largestLevelDiff;</span>
        }
        // If the base image isn't ready, we should signal a repaint and stop
<span class="nc bnc" id="L2584" title="All 4 branches missed.">        if ((imgWidth &lt; 0) || (imgHeight &lt; 0)) {</span>
<span class="nc" id="L2585">            repaint();</span>
<span class="nc" id="L2586">            return;</span>
        }

<span class="nc" id="L2589">        BufferedImage hexImage = new BufferedImage(imgWidth, imgHeight,</span>
                BufferedImage.TYPE_INT_ARGB);

<span class="nc" id="L2592">        Graphics2D g = (Graphics2D)(hexImage.getGraphics());</span>
<span class="nc" id="L2593">        GUIPreferences.AntiAliasifSet(g);</span>

<span class="nc bnc" id="L2595" title="All 2 branches missed.">        if (standardTile) { // is the image hex-sized, 84*72?</span>
<span class="nc" id="L2596">            g.drawImage(scaledImage, 0, 0, this);</span>
        } else { // Draw image for a texture larger than a hex
<span class="nc" id="L2598">            Point p1SRC = getHexLocationLargeTile(c.getX(), c.getY());</span>
<span class="nc" id="L2599">            p1SRC.x = p1SRC.x % origImgWidth;</span>
<span class="nc" id="L2600">            p1SRC.y = p1SRC.y % origImgHeight;</span>
<span class="nc" id="L2601">            Point p2SRC = new Point((int) (p1SRC.x + HEX_W * scale),</span>
                    (int) (p1SRC.y + HEX_H * scale));
<span class="nc" id="L2603">            Point p2DST = new Point((int) (HEX_W * scale),</span>
                    (int) (HEX_H * scale));

            // hex mask to limit drawing to the hex shape
            // TODO: this is not ideal yet but at least it draws
            // without leaving gaps at any zoom
<span class="nc" id="L2609">            Image hexMask = getScaledImage(tileManager.getHexMask(), true);</span>
<span class="nc" id="L2610">            g.drawImage(hexMask, 0, 0, this);</span>
<span class="nc" id="L2611">            Composite svComp = g.getComposite();</span>
<span class="nc" id="L2612">            g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_ATOP,</span>
                    1f));

            // paint the right slice from the big pic
<span class="nc" id="L2616">            g.drawImage(scaledImage, 0, 0, p2DST.x, p2DST.y, p1SRC.x, p1SRC.y,</span>
                    p2SRC.x, p2SRC.y, null);

            // Handle wrapping of the image
<span class="nc bnc" id="L2620" title="All 4 branches missed.">            if (p2SRC.x &gt; origImgWidth &amp;&amp; p2SRC.y &lt;= origImgHeight) {</span>
<span class="nc" id="L2621">                g.drawImage(scaledImage, origImgWidth - p1SRC.x, 0, p2DST.x,</span>
                        p2DST.y, 0, p1SRC.y, p2SRC.x - origImgWidth, p2SRC.y,
                        null); // paint addtl slice on the left side
<span class="nc bnc" id="L2624" title="All 4 branches missed.">            } else if (p2SRC.x &lt;= origImgWidth &amp;&amp; p2SRC.y &gt; origImgHeight) {</span>
<span class="nc" id="L2625">                g.drawImage(scaledImage, 0, origImgHeight - p1SRC.y, p2DST.x,</span>
                        p2DST.y, p1SRC.x, 0, p2SRC.x, p2SRC.y - origImgHeight,
                        null); // paint addtl slice on the top
<span class="nc bnc" id="L2628" title="All 4 branches missed.">            } else if (p2SRC.x &gt; origImgWidth &amp;&amp; p2SRC.y &gt; origImgHeight) {</span>
<span class="nc" id="L2629">                g.drawImage(scaledImage, origImgWidth - p1SRC.x, 0, p2DST.x,</span>
                        p2DST.y, 0, p1SRC.y, p2SRC.x - origImgWidth, p2SRC.y,
                        null); // paint addtl slice on the top
<span class="nc" id="L2632">                g.drawImage(scaledImage, 0, origImgHeight - p1SRC.y, p2DST.x,</span>
                        p2DST.y, p1SRC.x, 0, p2SRC.x, p2SRC.y - origImgHeight,
                        null); // paint addtl slice on the left side
                // paint addtl slice on the top left side
<span class="nc" id="L2636">                g.drawImage(scaledImage, origImgWidth - p1SRC.x, origImgHeight</span>
                        - p1SRC.y, p2DST.x, p2DST.y, 0, 0, p2SRC.x
                        - origImgWidth, p2SRC.y - origImgHeight, null);
            }

<span class="nc" id="L2641">            g.setComposite(svComp);</span>
        }

        // To place roads under the shadow map, supers for hexes with roads
        // have to be drawn before the shadow map, otherwise the supers are
        // drawn after.  Unfortunately I dont think the supers images
        // themselves can be checked for roads.
<span class="nc" id="L2648">        List&lt;Image&gt; supers = tileManager.supersFor(hex);</span>
<span class="nc" id="L2649">        boolean supersUnderShadow = false;</span>
<span class="nc bnc" id="L2650" title="All 2 branches missed.">        if (hex.containsTerrain(Terrains.ROAD) ||</span>
<span class="nc bnc" id="L2651" title="All 2 branches missed.">                hex.containsTerrain(Terrains.WATER)) {</span>
<span class="nc" id="L2652">            supersUnderShadow = true;</span>
<span class="nc bnc" id="L2653" title="All 2 branches missed.">            if (supers != null) {</span>
<span class="nc bnc" id="L2654" title="All 2 branches missed.">                for (Image image : supers) {</span>
<span class="nc bnc" id="L2655" title="All 2 branches missed.">                    if (animatedImages.contains(image.hashCode())) {</span>
<span class="nc" id="L2656">                        dontCache = true;</span>
                    }
<span class="nc" id="L2658">                    scaledImage = getScaledImage(image, true);</span>
<span class="nc" id="L2659">                    g.drawImage(scaledImage, 0, 0, this);</span>
<span class="nc" id="L2660">                }</span>
            }
        }

        // Add the terrain &amp; building shadows
<span class="nc bnc" id="L2665" title="All 4 branches missed.">        if (guip.getBoolean(GUIPreferences.SHADOWMAP) &amp;&amp;</span>
            (shadowMap != null)) {
<span class="nc" id="L2667">            Point p1SRC = getHexLocationLargeTile(c.getX(), c.getY(), 1);</span>
<span class="nc" id="L2668">            Point p2SRC = new Point(p1SRC.x + HEX_W, p1SRC.y + HEX_H);</span>
<span class="nc" id="L2669">            Point p2DST = new Point(hex_size.width, hex_size.height);</span>

<span class="nc" id="L2671">            Composite svComp = g.getComposite();</span>
<span class="nc bnc" id="L2672" title="All 2 branches missed.">            if (game.getPlanetaryConditions().getLight() == PlanetaryConditions.L_DAY) {</span>
<span class="nc" id="L2673">                g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_ATOP, 0.55f));</span>
            } else {
<span class="nc" id="L2675">                g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_ATOP, 0.45f));</span>
            }

            // paint the right slice from the big pic
<span class="nc" id="L2679">            g.drawImage(shadowMap, 0, 0, p2DST.x, p2DST.y, p1SRC.x, p1SRC.y,</span>
                    p2SRC.x, p2SRC.y, null);
<span class="nc" id="L2681">            g.setComposite(svComp);</span>
        }

<span class="nc bnc" id="L2684" title="All 2 branches missed.">        if (!supersUnderShadow) {</span>
<span class="nc bnc" id="L2685" title="All 2 branches missed.">            if (supers != null) {</span>
<span class="nc bnc" id="L2686" title="All 2 branches missed.">                for (Image image : supers) {</span>
<span class="nc bnc" id="L2687" title="All 2 branches missed.">                    if (null != image) {</span>
<span class="nc bnc" id="L2688" title="All 2 branches missed.">                        if (animatedImages.contains(image.hashCode())) {</span>
<span class="nc" id="L2689">                            dontCache = true;</span>
                        }
<span class="nc" id="L2691">                        scaledImage = getScaledImage(image, true);</span>
<span class="nc" id="L2692">                        g.drawImage(scaledImage, 0, 0, this);</span>
                    }
<span class="nc" id="L2694">                }</span>
            }
        }

        // AO Hex Shadow in this hex when a higher one is adjacent
<span class="nc bnc" id="L2699" title="All 2 branches missed.">        if (guip.getBoolean(GUIPreferences.AOHEXSHADOWS)</span>
               ) {
<span class="nc bnc" id="L2701" title="All 2 branches missed.">            for (int dir : allDirections) {</span>
<span class="nc" id="L2702">                Shape ShadowShape = getElevationShadowArea(c, dir);</span>
<span class="nc" id="L2703">                GradientPaint gpl = getElevationShadowGP(c, dir);</span>
<span class="nc bnc" id="L2704" title="All 4 branches missed.">                if (ShadowShape != null &amp;&amp; gpl != null) {</span>
<span class="nc" id="L2705">                    g.setPaint(gpl);</span>
<span class="nc" id="L2706">                    g.fill(getElevationShadowArea(c, dir));</span>
                }
            }
        }

        // Orthos (bridges)
<span class="nc" id="L2712">        List&lt;Image&gt; orthos = tileManager.orthoFor(hex);</span>
<span class="nc bnc" id="L2713" title="All 2 branches missed.">        if (orthos != null) {</span>
<span class="nc bnc" id="L2714" title="All 2 branches missed.">            for (Image image : orthos) {</span>
<span class="nc bnc" id="L2715" title="All 2 branches missed.">                if (animatedImages.contains(image.hashCode())) {</span>
<span class="nc" id="L2716">                    dontCache = true;</span>
                }
<span class="nc" id="L2718">                scaledImage = getScaledImage(image, true);</span>
<span class="nc bnc" id="L2719" title="All 2 branches missed.">                if (!useIsometric()) {</span>
<span class="nc" id="L2720">                    g.drawImage(scaledImage, 0, 0, this);</span>
                }
                // draw a shadow for bridge hex.
<span class="nc bnc" id="L2723" title="All 2 branches missed.">                if (useIsometric()</span>
<span class="nc bnc" id="L2724" title="All 2 branches missed.">                        &amp;&amp; !guip.getBoolean(GUIPreferences.SHADOWMAP)</span>
<span class="nc bnc" id="L2725" title="All 2 branches missed.">                        &amp;&amp; (hex.terrainLevel(Terrains.BRIDGE_ELEV) &gt; 0)) {</span>
<span class="nc" id="L2726">                    Image shadow = createShadowMask(scaledImage);</span>
<span class="nc" id="L2727">                    g.drawImage(shadow, 0, 0, this);</span>
                }
<span class="nc" id="L2729">            }</span>
        }

        // Shade and add static noise to hexes that are in an ECM field
<span class="nc bnc" id="L2733" title="All 2 branches missed.">        if (ecmHexes != null) {</span>
<span class="nc" id="L2734">            Color tint = ecmHexes.get(c);</span>
<span class="nc bnc" id="L2735" title="All 2 branches missed.">            if (tint != null) {</span>
<span class="nc" id="L2736">                Color origColor = g.getColor();</span>
<span class="nc" id="L2737">                g.setColor(tint);</span>
<span class="nc" id="L2738">                AffineTransform sc = new AffineTransform();</span>
<span class="nc" id="L2739">                sc.scale(scale, scale);</span>
<span class="nc" id="L2740">                g.fill(sc.createTransformedShape(hexPoly));</span>
<span class="nc" id="L2741">                g.setColor(origColor);</span>
<span class="nc" id="L2742">                Image staticImage = getScaledImage(</span>
<span class="nc" id="L2743">                        tileManager.getEcmStaticImage(tint), false);</span>
<span class="nc" id="L2744">                g.drawImage(staticImage, 0, 0, staticImage.getWidth(null),</span>
<span class="nc" id="L2745">                        staticImage.getHeight(null), this);</span>
            }
        }
        // Shade hexes that are in an ECCM field
<span class="nc bnc" id="L2749" title="All 2 branches missed.">        if (eccmHexes != null) {</span>
<span class="nc" id="L2750">            Color tint = eccmHexes.get(c);</span>
<span class="nc bnc" id="L2751" title="All 2 branches missed.">            if (tint != null) {</span>
<span class="nc" id="L2752">                Color origColor = g.getColor();</span>
<span class="nc" id="L2753">                g.setColor(tint);</span>
<span class="nc" id="L2754">                AffineTransform sc = new AffineTransform();</span>
<span class="nc" id="L2755">                sc.scale(scale, scale);</span>
<span class="nc" id="L2756">                g.fill(sc.createTransformedShape(hexPoly));</span>
<span class="nc" id="L2757">                g.setColor(origColor);</span>
            }
        }
        // Highlight hexes that contain the source of an ECM field
<span class="nc bnc" id="L2761" title="All 2 branches missed.">        if (ecmCenters != null) {</span>
<span class="nc" id="L2762">            Color tint = ecmCenters.get(c);</span>
<span class="nc bnc" id="L2763" title="All 2 branches missed.">            if (tint != null) {</span>
<span class="nc" id="L2764">                drawHexBorder(g, tint.darker(), 5, 10);</span>
            }
        }

        // Highlight hexes that contain the source of an ECCM field
<span class="nc bnc" id="L2769" title="All 2 branches missed.">        if (eccmCenters != null) {</span>
<span class="nc" id="L2770">            Color tint = eccmCenters.get(c);</span>
<span class="nc bnc" id="L2771" title="All 2 branches missed.">            if (tint != null) {</span>
<span class="nc" id="L2772">                drawHexBorder(g, tint.darker(), 5, 10);</span>
            }
        }

        // Darken the hex for night-time, if applicable
<span class="nc bnc" id="L2777" title="All 2 branches missed.">        if (guip.getBoolean(GUIPreferences.ADVANCED_DARKEN_MAP_AT_NIGHT)</span>
<span class="nc bnc" id="L2778" title="All 2 branches missed.">                &amp;&amp; (game.isPositionIlluminated(c) == IGame.ILLUMINATED_NONE)</span>
<span class="nc bnc" id="L2779" title="All 2 branches missed.">                &amp;&amp; (game.getPlanetaryConditions().getLight() &gt; PlanetaryConditions.L_DAY)) {</span>
<span class="nc bnc" id="L2780" title="All 2 branches missed.">            for (int x = 0; x &lt; hexImage.getWidth(); ++x) {</span>
<span class="nc bnc" id="L2781" title="All 2 branches missed.">                for (int y = 0; y &lt; hexImage.getHeight(); ++y) {</span>
<span class="nc" id="L2782">                    hexImage.setRGB(x, y, getNightDarkenedColor(hexImage.getRGB(x, y)));</span>
                }
            }
        }

        // Set the text color according to Preferences or Light Gray in space
<span class="nc" id="L2788">        g.setColor(guip.getMapTextColor());</span>
<span class="nc bnc" id="L2789" title="All 2 branches missed.">        if (game.getBoard().inSpace()) {</span>
<span class="nc" id="L2790">            g.setColor(Color.LIGHT_GRAY);</span>
        }

        // draw special stuff for the hex
<span class="nc" id="L2794">        final Collection&lt;SpecialHexDisplay&gt; shdList = game.getBoard().getSpecialHexDisplay(c);</span>
        try {
<span class="nc bnc" id="L2796" title="All 2 branches missed.">            if (shdList != null) {</span>
<span class="nc bnc" id="L2797" title="All 2 branches missed.">                for (SpecialHexDisplay shd : shdList) {</span>
<span class="nc bnc" id="L2798" title="All 2 branches missed.">                    if (shd.drawNow(game.getPhase(), game.getRoundCount(), localPlayer)) {</span>
<span class="nc" id="L2799">                        scaledImage = getScaledImage(shd.getType().getDefaultImage(), true);</span>
<span class="nc" id="L2800">                        g.drawImage(scaledImage, 0, 0, this);</span>
                    }
<span class="nc" id="L2802">                }</span>
            }
<span class="nc" id="L2804">        } catch (Exception e) {</span>
<span class="nc" id="L2805">            MegaMek.getLogger().error(&quot;Exception, probably can't load file.&quot;, e);</span>
<span class="nc" id="L2806">            drawCenteredString(&quot;Loading Error&quot;, 0, (int) (50 * scale), font_note, g);</span>
<span class="nc" id="L2807">            return;</span>
<span class="nc" id="L2808">        }</span>

        // write hex coordinate unless deactivated or scale factor too small
<span class="nc bnc" id="L2811" title="All 4 branches missed.">        if (guip.getBoolean(GUIPreferences.ADVANCED_SHOW_COORDS) &amp;&amp; (scale &gt;= 0.5)) {</span>
<span class="nc" id="L2812">            drawCenteredString(c.getBoardNum(), 0, (int) (12 * scale), font_hexnum, g);</span>
        }

<span class="nc bnc" id="L2815" title="All 4 branches missed.">        if (getDisplayInvalidHexInfo() &amp;&amp; !hex.isValid(null)) {</span>
<span class="nc" id="L2816">            Point hexCenter = new Point((int) (HEX_W / 2 * scale), (int) (HEX_H / 2 * scale));</span>
<span class="nc" id="L2817">            drawCenteredText(g, Messages.getString(&quot;BoardEditor.INVALID&quot;), hexCenter, Color.RED,</span>
                    false, new Font(&quot;SansSerif&quot;, Font.BOLD, 14));
        }

        // write terrain level / water depth / building height
<span class="nc bnc" id="L2822" title="All 2 branches missed.">        if (scale &gt; 0.5f) {</span>
<span class="nc" id="L2823">            int ypos = HEX_H-2;</span>
<span class="nc bnc" id="L2824" title="All 2 branches missed.">            if (level != 0) {</span>
<span class="nc" id="L2825">                drawCenteredString(</span>
<span class="nc" id="L2826">                        Messages.getString(&quot;BoardView1.LEVEL&quot;) + level, //$NON-NLS-1$</span>
                        0, (int) (ypos * scale), font_elev, g);
<span class="nc" id="L2828">                ypos -= 10;</span>
            }
<span class="nc bnc" id="L2830" title="All 2 branches missed.">            if (depth != 0) {</span>
<span class="nc" id="L2831">                drawCenteredString(</span>
<span class="nc" id="L2832">                        Messages.getString(&quot;BoardView1.DEPTH&quot;) + depth, //$NON-NLS-1$</span>
                        0, (int) (ypos * scale), font_elev, g);
<span class="nc" id="L2834">                ypos -= 10;</span>
            }
<span class="nc bnc" id="L2836" title="All 2 branches missed.">            if (height &gt; 0) {</span>
<span class="nc" id="L2837">                g.setColor(GUIPreferences.getInstance().getColor(</span>
                        &quot;AdvancedBuildingTextColor&quot;));                 //$NON-NLS-1$
<span class="nc" id="L2839">                drawCenteredString(</span>
<span class="nc" id="L2840">                        Messages.getString(&quot;BoardView1.HEIGHT&quot;) + height, //$NON-NLS-1$</span>
                        0, (int) (ypos * scale), font_elev, g);
<span class="nc" id="L2842">                ypos -= 10;</span>
            }
<span class="nc bnc" id="L2844" title="All 2 branches missed.">            if (hex.terrainLevel(Terrains.FOLIAGE_ELEV) == 1) {</span>
<span class="nc" id="L2845">                g.setColor(GUIPreferences.getInstance().getColor(</span>
                        GUIPreferences.ADVANCED_LOW_FOLIAGE_COLOR));  
<span class="nc" id="L2847">                drawCenteredString(Messages.getString(&quot;BoardView1.LowFoliage&quot;), </span>
                        0, (int) (ypos * scale), font_elev, g);
<span class="nc" id="L2849">                ypos -= 10;</span>
            }
        }

        // Used to make the following draw calls shorter
<span class="nc" id="L2854">        int s21 = (int)(21*scale);</span>
<span class="nc" id="L2855">        int s71 = (int)(71*scale);</span>
<span class="nc" id="L2856">        int s35 = (int)(35*scale);</span>
<span class="nc" id="L2857">        int s36 = (int)(36*scale);</span>
<span class="nc" id="L2858">        int s62 = (int)(62*scale);</span>
<span class="nc" id="L2859">        int s83 = (int)(83*scale);</span>

<span class="nc" id="L2861">        Point p1 = new Point(s62, 0);</span>
<span class="nc" id="L2862">        Point p2 = new Point(s21, 0);</span>
<span class="nc" id="L2863">        Point p3 = new Point(s83, s35);</span>
<span class="nc" id="L2864">        Point p4 = new Point(s83, s36);</span>
<span class="nc" id="L2865">        Point p5 = new Point(s62, s71);</span>
<span class="nc" id="L2866">        Point p6 = new Point(s21, s71);</span>
<span class="nc" id="L2867">        Point p7 = new Point(0, s36);</span>
<span class="nc" id="L2868">        Point p8 = new Point(0, s35);</span>

<span class="nc" id="L2870">        g.setColor(Color.black);</span>
<span class="nc" id="L2871">        g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,</span>
                1f));

        // draw elevation borders
<span class="nc bnc" id="L2875" title="All 2 branches missed.">        if (drawElevationLine(c, 0)) {</span>
<span class="nc" id="L2876">            drawIsometricElevation(c, Color.GRAY, p1, p2, 0, g);</span>
<span class="nc bnc" id="L2877" title="All 2 branches missed.">            if (guip.getBoolean(GUIPreferences.LEVELHIGHLIGHT)) {</span>
<span class="nc" id="L2878">                g.drawLine(s21, 0, s62, 0);</span>
            }
        }

<span class="nc bnc" id="L2882" title="All 2 branches missed.">        if (drawElevationLine(c, 1)) {</span>
<span class="nc" id="L2883">            drawIsometricElevation(c, Color.DARK_GRAY, p3, p1, 1, g);</span>
<span class="nc bnc" id="L2884" title="All 2 branches missed.">            if (guip.getBoolean(GUIPreferences.LEVELHIGHLIGHT)) {</span>
<span class="nc" id="L2885">                g.drawLine(s62, 0, s83, s35);</span>
            }
        }

<span class="nc bnc" id="L2889" title="All 2 branches missed.">        if (drawElevationLine(c, 2)) {</span>
<span class="nc" id="L2890">            drawIsometricElevation(c, Color.LIGHT_GRAY, p4, p5, 2, g);</span>
<span class="nc bnc" id="L2891" title="All 2 branches missed.">            if (guip.getBoolean(GUIPreferences.LEVELHIGHLIGHT)) {</span>
<span class="nc" id="L2892">                g.drawLine(s83, s36, s62, s71);</span>
            }
        }

<span class="nc bnc" id="L2896" title="All 2 branches missed.">        if (drawElevationLine(c, 3)) {</span>
<span class="nc" id="L2897">            drawIsometricElevation(c, Color.GRAY, p6, p5, 3, g);</span>
<span class="nc bnc" id="L2898" title="All 2 branches missed.">            if (guip.getBoolean(GUIPreferences.LEVELHIGHLIGHT)) {</span>
<span class="nc" id="L2899">                g.drawLine(s62, s71, s21, s71);</span>
            }
        }

<span class="nc bnc" id="L2903" title="All 2 branches missed.">        if (drawElevationLine(c, 4)) {</span>
<span class="nc" id="L2904">            drawIsometricElevation(c, Color.DARK_GRAY, p7, p6, 4, g);</span>
<span class="nc bnc" id="L2905" title="All 2 branches missed.">            if (guip.getBoolean(GUIPreferences.LEVELHIGHLIGHT)) {</span>
<span class="nc" id="L2906">                g.drawLine(s21, s71, 0, s36);</span>
            }
        }

<span class="nc bnc" id="L2910" title="All 2 branches missed.">        if (drawElevationLine(c, 5)) {</span>
<span class="nc" id="L2911">            drawIsometricElevation(c, Color.LIGHT_GRAY, p8, p2, 5, g);</span>
<span class="nc bnc" id="L2912" title="All 2 branches missed.">            if (guip.getBoolean(GUIPreferences.LEVELHIGHLIGHT)) {</span>
<span class="nc" id="L2913">                g.drawLine(0, s35, s21, 0);</span>
            }

        }

<span class="nc" id="L2918">        boolean hasLoS = fovHighlightingAndDarkening.draw(g, c, 0, 0,</span>
                saveBoardImage);

        // draw mapsheet borders
<span class="nc bnc" id="L2922" title="All 2 branches missed.">        if (GUIPreferences.getInstance().getShowMapsheets()) {</span>
<span class="nc" id="L2923">            g.setColor(GUIPreferences.getInstance().getColor(</span>
                    GUIPreferences.ADVANCED_MAPSHEET_COLOR));
<span class="nc bnc" id="L2925" title="All 2 branches missed.">            if ((c.getX() % 16) == 0) {</span>
                // left edge of sheet (edge 4 &amp; 5)
<span class="nc" id="L2927">                g.drawLine(s21, s71, 0, s36);</span>
<span class="nc" id="L2928">                g.drawLine(0, s35, s21, 0);</span>
<span class="nc bnc" id="L2929" title="All 2 branches missed.">            } else if ((c.getX() % 16) == 15) {</span>
                // right edge of sheet (edge 1 &amp; 2)
<span class="nc" id="L2931">                g.drawLine(s62, 0, s83, s35);</span>
<span class="nc" id="L2932">                g.drawLine(s83, s36, s62, s71);</span>
            }
<span class="nc bnc" id="L2934" title="All 2 branches missed.">            if ((c.getY() % 17) == 0) {</span>
                // top edge of sheet (edge 0 and possible 1 &amp; 5)
<span class="nc" id="L2936">                g.drawLine(s21, 0, s62, 0);</span>
<span class="nc bnc" id="L2937" title="All 2 branches missed.">                if ((c.getX() % 2) == 0) {</span>
<span class="nc" id="L2938">                    g.drawLine(s62, 0, s83, s35);</span>
<span class="nc" id="L2939">                    g.drawLine(0, s35, s21, 0);</span>
                }
<span class="nc bnc" id="L2941" title="All 2 branches missed.">            } else if ((c.getY() % 17) == 16) {</span>
                // bottom edge of sheet (edge 3 and possible 2 &amp; 4)
<span class="nc" id="L2943">                g.drawLine(s62, s71, s21, s71);</span>
<span class="nc bnc" id="L2944" title="All 2 branches missed.">                if ((c.getX() % 2) == 1) {</span>
<span class="nc" id="L2945">                    g.drawLine(s83, s36, s62, s71);</span>
<span class="nc" id="L2946">                    g.drawLine(s21, s71, 0, s36);</span>
                }
            }
        }

<span class="nc bnc" id="L2951" title="All 4 branches missed.">        if (!hasLoS &amp;&amp; guip.getFovGrayscale()) {</span>
            // rework the pixels to grayscale
<span class="nc bnc" id="L2953" title="All 2 branches missed.">            for (int x = 0; x &lt; hexImage.getWidth(); ++x) {</span>
<span class="nc bnc" id="L2954" title="All 2 branches missed.">                for (int y = 0; y &lt; hexImage.getHeight(); ++y) {</span>
<span class="nc" id="L2955">                    int rgb = hexImage.getRGB(x, y);</span>
<span class="nc" id="L2956">                    int rd = (rgb &gt;&gt; 16) &amp; 0xFF;</span>
<span class="nc" id="L2957">                    int gr = (rgb &gt;&gt; 8) &amp; 0xFF;</span>
<span class="nc" id="L2958">                    int bl = (rgb &amp; 0xFF);</span>
<span class="nc" id="L2959">                    int al = (rgb &gt;&gt; 24);</span>

<span class="nc" id="L2961">                    int grayLevel = (rd + gr + bl) / 3;</span>
<span class="nc" id="L2962">                    int gray = (al &lt;&lt; 24) + (grayLevel &lt;&lt; 16) + (grayLevel &lt;&lt; 8) + grayLevel;</span>
<span class="nc" id="L2963">                    hexImage.setRGB(x, y, gray);</span>
                }
            }
        }

<span class="nc" id="L2968">        cacheEntry = new HexImageCacheEntry(hexImage);</span>
<span class="nc bnc" id="L2969" title="All 2 branches missed.">        if (!dontCache) {</span>
<span class="nc" id="L2970">            hexImageCache.put(c, cacheEntry);</span>
        }
<span class="nc" id="L2972">        boardGraph.drawImage(cacheEntry.hexImage, hexLoc.x, hexLoc.y, this);</span>
<span class="nc" id="L2973">    }</span>

    /**
     * Draws a orthographic hex onto the board buffer. This assumes that
     * drawRect is current, and does not check if the hex is visible.
     */
    private void drawOrthograph(Coords c, Graphics boardGraph) {
<span class="nc bnc" id="L2980" title="All 2 branches missed.">        if (!game.getBoard().contains(c)) {</span>
<span class="nc" id="L2981">            return;</span>
        }

<span class="nc" id="L2984">        final IHex oHex = game.getBoard().getHex(c);</span>
<span class="nc" id="L2985">        final Point oHexLoc = getHexLocation(c);</span>

        // We need to adjust the height based on several cases
<span class="nc" id="L2988">        int elevOffset = oHex.terrainLevel(Terrains.BRIDGE_ELEV);</span>

<span class="nc" id="L2990">        int orthX = oHexLoc.x;</span>
<span class="nc" id="L2991">        int orthY = oHexLoc.y - (int) (HEX_ELEV * scale * elevOffset);</span>
<span class="nc bnc" id="L2992" title="All 2 branches missed.">        if (!useIsometric()) {</span>
<span class="nc" id="L2993">            orthY = oHexLoc.y;</span>
        }
<span class="nc bnc" id="L2995" title="All 2 branches missed.">        if (tileManager.orthoFor(oHex) != null) {</span>
<span class="nc bnc" id="L2996" title="All 2 branches missed.">            for (Image image : tileManager.orthoFor(oHex)) {</span>
<span class="nc" id="L2997">                BufferedImage scaledImage = ImageUtil.createAcceleratedImage(getScaledImage(image, true));</span>

                // Darken the hex for night-time, if applicable
<span class="nc bnc" id="L3000" title="All 2 branches missed.">                if (GUIPreferences.getInstance().getBoolean(GUIPreferences.ADVANCED_DARKEN_MAP_AT_NIGHT)</span>
<span class="nc bnc" id="L3001" title="All 2 branches missed.">                        &amp;&amp; (game.isPositionIlluminated(c) == IGame.ILLUMINATED_NONE)</span>
<span class="nc bnc" id="L3002" title="All 2 branches missed.">                        &amp;&amp; (game.getPlanetaryConditions().getLight() &gt; PlanetaryConditions.L_DAY)) {</span>
<span class="nc bnc" id="L3003" title="All 2 branches missed.">                    for (int x = 0; x &lt; scaledImage.getWidth(null); ++x) {</span>
<span class="nc bnc" id="L3004" title="All 2 branches missed.">                        for (int y = 0; y &lt; scaledImage.getHeight(); ++y) {</span>
<span class="nc" id="L3005">                            scaledImage.setRGB(x, y, getNightDarkenedColor(scaledImage.getRGB(x, y)));</span>
                        }
                    }
                }

                // draw orthogonal
<span class="nc" id="L3011">                boardGraph.drawImage(scaledImage, orthX, orthY, this);</span>
<span class="nc" id="L3012">            }</span>
        }
<span class="nc" id="L3014">    }</span>

    final boolean useIsometric() {
<span class="nc" id="L3017">        return drawIsometric;</span>
    }

    /**
     * Draws the Isometric elevation for the hex at the given coordinates (c) on
     * the side indicated by the direction (dir). This method only draws a
     * triangle for the elevation, the companion triangle representing the
     * adjacent hex is also needed. The two triangles when drawn together make a
     * complete rectangle representing the complete elevated hex side.
     * &lt;p/&gt;
     * By drawing the elevated hex as two separate triangles we avoid clipping
     * problems with other hexes because the lower elevation is rendered before
     * the higher elevation. Thus any hexes that have a higher elevation than
     * the lower hex will overwrite the lower hex.
     * &lt;p/&gt;
     * The Triangle for each hex side is formed by points p1, p2, and p3. Where
     * p1 and p2 are the original hex edges, and p3 has the same X value as p1,
     * but the y value has been increased (or decreased) based on the difference
     * in elevation between the given hex and the adjacent hex.
     *
     * @param c          Coordinates of the source hex.
     * @param color      Color to use for the elevation polygons.
     * @param p1         The First point on the edge of the hex.
     * @param p2         The second point on the edge of the hex.
     * @param dir        The side of the hex to have the elevation drawn on.
     * @param g
     */
    private final void drawIsometricElevation(Coords c, Color color, Point p1,
            Point p2, int dir, Graphics g) {
<span class="nc" id="L3046">        final IHex dest = game.getBoard().getHexInDir(c, dir);</span>
<span class="nc" id="L3047">        final IHex src = game.getBoard().getHex(c);</span>

<span class="nc bnc" id="L3049" title="All 2 branches missed.">        if (!useIsometric() ||</span>
<span class="nc bnc" id="L3050" title="All 2 branches missed.">                GUIPreferences.getInstance().getBoolean(GUIPreferences.FLOATINGISO)) {</span>
<span class="nc" id="L3051">            return;</span>
        }

        // Pad polygon size slightly to avoid rounding errors from scale float.
<span class="nc" id="L3055">        int fudge = -1;</span>
<span class="nc bnc" id="L3056" title="All 6 branches missed.">        if ((dir == 2) || (dir == 4) || (dir == 3)) {</span>
<span class="nc" id="L3057">            fudge = 1;</span>
        }

<span class="nc" id="L3060">        final int elev = src.getLevel();</span>
        // If the Destination is null, draw the complete elevation side.
<span class="nc bnc" id="L3062" title="All 10 branches missed.">        if ((dest == null) &amp;&amp; (elev &gt; 0)</span>
            &amp;&amp; ((dir == 2) || (dir == 3) || (dir == 4))) {

            // Determine the depth of the edge that needs to be drawn.
<span class="nc" id="L3066">            int height = elev;</span>
<span class="nc" id="L3067">            IHex southHex = game.getBoard().getHexInDir(c, 3);</span>
<span class="nc bnc" id="L3068" title="All 4 branches missed.">            if ((dir != 3) &amp;&amp; (southHex != null)</span>
<span class="nc bnc" id="L3069" title="All 2 branches missed.">                &amp;&amp; (elev &gt; southHex.getLevel())) {</span>
<span class="nc" id="L3070">                height = elev - southHex.getLevel();</span>
            }
<span class="nc" id="L3072">            int scaledHeight = (int) (HEX_ELEV * scale * height);</span>

<span class="nc" id="L3074">            Polygon p = new Polygon(new int[] { p1.x, p2.x, p2.x, p1.x },</span>
                    new int[] { p1.y + fudge, p2.y + fudge,
                            p2.y + scaledHeight, p1.y + scaledHeight }, 4);
<span class="nc" id="L3077">            g.setColor(color);</span>
<span class="nc" id="L3078">            g.drawPolygon(p);</span>
<span class="nc" id="L3079">            g.fillPolygon(p);</span>

<span class="nc" id="L3081">            g.setColor(Color.BLACK);</span>
<span class="nc bnc" id="L3082" title="All 4 branches missed.">            if ((dir == 2) || (dir == 4)) {</span>
<span class="nc" id="L3083">                g.drawLine(p1.x, p1.y, p1.x, p1.y + scaledHeight);</span>
            }
<span class="nc" id="L3085">            return;</span>
<span class="nc bnc" id="L3086" title="All 2 branches missed.">        } else if (dest == null) {</span>
<span class="nc" id="L3087">            return;</span>
        }

<span class="nc" id="L3090">        int delta = elev - dest.getLevel();</span>
        // Don't draw the elevation if there is no exposed edge for the player
        // to see.
<span class="nc bnc" id="L3093" title="All 18 branches missed.">        if ((delta == 0)</span>
            || (((dir == 0) || (dir == 1) || (dir == 5)) &amp;&amp; (delta &gt; 0))
            || (((dir == 2) || (dir == 3) || (dir == 4)) &amp;&amp; (delta &lt; 0))) {
<span class="nc" id="L3096">            return;</span>
        }

<span class="nc bnc" id="L3099" title="All 2 branches missed.">        if (dir == 1) {</span>
            /*
            // Draw a little bit of shadow to improve the 3d isometric effect.
            Polygon shadow1 = new Polygon(new int[] { p1.x, p2.x,
                    p2.x - (int) (HEX_ELEV * scale) }, new int[] { p1.y, p2.y,
                    p2.y }, 3);
            if ((p2.x - (int) (HEX_ELEV * scale)) &lt; 0) {
                MegaMek.getLogger().info(&quot;Negative X value!: &quot; + (p2.x - (int) (HEX_ELEV * scale)));
            }
            g.setColor(new Color(0, 0, 0, 0.4f));
            g.fillPolygon(shadow1);*/
            // not necessary with the shadowmap
            // people not using the shadowmap will probably not need this shadow either
        }

<span class="nc bnc" id="L3114" title="All 6 branches missed.">        if ((dir == 2) || (dir == 3) || (dir == 4)) {</span>
<span class="nc" id="L3115">            int scaledDelta = (int) (HEX_ELEV * scale * delta);</span>
<span class="nc" id="L3116">            Point p3 = new Point(p1.x, p1.y + scaledDelta + fudge);</span>

<span class="nc" id="L3118">            Polygon p = new Polygon(new int[] { p1.x, p2.x, p2.x, p1.x },</span>
                    new int[] { p1.y + fudge, p2.y + fudge,
                            p2.y + fudge + scaledDelta,
                            p1.y + fudge + scaledDelta }, 4);

<span class="nc bnc" id="L3123" title="All 2 branches missed.">            if ((p1.y + fudge) &lt; 0) {</span>
<span class="nc" id="L3124">                MegaMek.getLogger().info(&quot;Negative Y value (Fudge)!: &quot; + (p1.y + fudge));</span>
            }
<span class="nc bnc" id="L3126" title="All 2 branches missed.">            if ((p2.y + fudge) &lt; 0) {</span>
<span class="nc" id="L3127">                MegaMek.getLogger().info(&quot;Negative Y value (Fudge)!: &quot; + (p2.y + fudge));</span>
            }

<span class="nc bnc" id="L3130" title="All 2 branches missed.">            if ((p2.y + fudge + scaledDelta) &lt; 0) {</span>
<span class="nc" id="L3131">                MegaMek.getLogger().info(&quot;Negative Y value!: &quot; + (p2.y + fudge + scaledDelta));</span>
            }
<span class="nc bnc" id="L3133" title="All 2 branches missed.">            if (( p1.y + fudge + scaledDelta) &lt; 0) {</span>
<span class="nc" id="L3134">                MegaMek.getLogger().info(&quot;Negative Y value!: &quot; + ( p1.y + fudge + scaledDelta));</span>
            }
<span class="nc" id="L3136">            g.setColor(color);</span>
<span class="nc" id="L3137">            g.drawPolygon(p);</span>
<span class="nc" id="L3138">            g.fillPolygon(p);</span>

<span class="nc" id="L3140">            g.setColor(Color.BLACK);</span>
<span class="nc bnc" id="L3141" title="All 8 branches missed.">            if ((dir == 1) || (dir == 2) || (dir == 5) || (dir == 4)) {</span>
<span class="nc" id="L3142">                g.drawLine(p1.x, p1.y, p3.x, p3.y);</span>
            }
        }
<span class="nc" id="L3145">    }</span>

    /**
     * Returns true if an elevation line should be drawn between the starting
     * hex and the hex in the direction specified. Results should be transitive,
     * that is, if a line is drawn in one direction, it should be drawn in the
     * opposite direction as well.
     */
    private final boolean drawElevationLine(Coords src, int direction) {
<span class="nc" id="L3154">        final IHex srcHex = game.getBoard().getHex(src);</span>
<span class="nc" id="L3155">        final IHex destHex = game.getBoard().getHexInDir(src, direction);</span>
<span class="nc bnc" id="L3156" title="All 4 branches missed.">        if ((destHex == null) &amp;&amp; (srcHex.getLevel() != 0)) {</span>
<span class="nc" id="L3157">            return true;</span>
<span class="nc bnc" id="L3158" title="All 2 branches missed.">        } else if (destHex == null) {</span>
<span class="nc" id="L3159">            return false;</span>
<span class="nc bnc" id="L3160" title="All 2 branches missed.">        } else if (srcHex.getLevel() != destHex.getLevel()) {</span>
<span class="nc" id="L3161">            return true;</span>
        } else {
<span class="nc bnc" id="L3163" title="All 2 branches missed.">            return (srcHex.floor() != destHex.floor());</span>
        }
    }

    /**
     * Given an int-packed RGB value, apply a modifier for the light level and return the result.
     *
     * @param rgb int-packed ARGB value.
     * @return An int-packed ARGB value, which is an adjusted value of the input, based on the light level
     */
    public int getNightDarkenedColor(int rgb) {
<span class="nc" id="L3174">        int rd = (rgb &gt;&gt; 16) &amp; 0xFF;</span>
<span class="nc" id="L3175">        int gr = (rgb &gt;&gt; 8) &amp; 0xFF;</span>
<span class="nc" id="L3176">        int bl = rgb &amp; 0xFF;</span>
<span class="nc" id="L3177">        int al = (rgb &gt;&gt; 24);</span>

<span class="nc bnc" id="L3179" title="All 5 branches missed.">        switch (game.getPlanetaryConditions().getLight()) {</span>
        case PlanetaryConditions.L_FULL_MOON:
<span class="nc" id="L3181">            rd = rd / 4; // 1/4 red</span>
<span class="nc" id="L3182">            gr = gr / 4; // 1/4 green</span>
<span class="nc" id="L3183">            bl = bl / 2; // half blue</span>
<span class="nc" id="L3184">            break;</span>
        case PlanetaryConditions.L_PITCH_BLACK:
<span class="nc" id="L3186">            int gy = (rd + gr + bl) / 16;</span>
<span class="nc bnc" id="L3187" title="All 2 branches missed.">            if (Math.random() &lt; 0.3) {</span>
<span class="nc" id="L3188">                gy = gy * 4 / 5;</span>
            }
<span class="nc bnc" id="L3190" title="All 2 branches missed.">            if (Math.random() &lt; 0.3) {</span>
<span class="nc" id="L3191">                gy = gy * 5 / 4;</span>
            }
<span class="nc" id="L3193">            rd = gy + rd / 5;</span>
<span class="nc" id="L3194">            gr = gy + gr / 5;</span>
<span class="nc" id="L3195">            bl = gy + bl / 5;</span>
<span class="nc" id="L3196">            break;</span>
        case PlanetaryConditions.L_MOONLESS:
<span class="nc" id="L3198">            rd = rd / 4;</span>
<span class="nc" id="L3199">            gr = gr / 4;</span>
<span class="nc" id="L3200">            bl = bl / 2;</span>
<span class="nc" id="L3201">            break;</span>
        case PlanetaryConditions.L_DUSK:
<span class="nc" id="L3203">            bl = bl * 3 / 4;</span>
<span class="nc" id="L3204">            break;</span>
        default:
        }

<span class="nc" id="L3208">        return (al &lt;&lt; 24) + (rd &lt;&lt; 16) + (gr &lt;&lt; 8) + bl;</span>
    }

    /**
     * Generates a Shape drawing area for the hex shadow effect in a lower hex
     * when a higher hex is found in direction.
     */
    private final Shape getElevationShadowArea(Coords src, int direction) {
<span class="nc" id="L3216">        final IHex srcHex = game.getBoard().getHex(src);</span>
<span class="nc" id="L3217">        final IHex destHex = game.getBoard().getHexInDir(src, direction);</span>

        // When at the board edge, create a shadow in hexes of level &lt; 0
<span class="nc bnc" id="L3220" title="All 2 branches missed.">        if (destHex == null)</span>
        {
<span class="nc bnc" id="L3222" title="All 2 branches missed.">            if (srcHex.getLevel() &gt;= 0) return null;</span>
        }
        else
        {
            // no shadow area when the current hex is not lower than the next hex in direction
<span class="nc bnc" id="L3227" title="All 2 branches missed.">            if (srcHex.getLevel() &gt;= destHex.getLevel()) return null;</span>
<span class="nc bnc" id="L3228" title="All 2 branches missed.">            if (GUIPreferences.getInstance().getHexInclines()</span>
<span class="nc bnc" id="L3229" title="All 2 branches missed.">                    &amp;&amp; (destHex.getLevel() - srcHex.getLevel() &lt; 2)</span>
<span class="nc bnc" id="L3230" title="All 2 branches missed.">                    &amp;&amp; !destHex.hasCliffTopTowards(srcHex)) {</span>
<span class="nc" id="L3231">                return null;</span>
            }
        }

<span class="nc" id="L3235">        return(AffineTransform.getScaleInstance(scale, scale).createTransformedShape(</span>
<span class="nc" id="L3236">                HexDrawUtilities.getHexBorderArea(direction, HexDrawUtilities.CUT_BORDER, 36)));</span>
    }

    /**
     * Generates a fill gradient which is rotated and aligned properly for
     * the drawing area for a hex shadow effect in a lower hex.
     */
    private final GradientPaint getElevationShadowGP(Coords src, int direction) {
<span class="nc" id="L3244">        final IHex srcHex = game.getBoard().getHex(src);</span>
<span class="nc" id="L3245">        final IHex destHex = game.getBoard().getHexInDir(src, direction);</span>

<span class="nc bnc" id="L3247" title="All 2 branches missed.">        if (destHex == null) return null;</span>

<span class="nc" id="L3249">        int ldiff = destHex.getLevel()-srcHex.getLevel();</span>
        // the shadow strength depends on the level difference,
        // but only to a maximum difference of 3 levels
<span class="nc" id="L3252">        ldiff = Math.min(ldiff*5,15);</span>

<span class="nc" id="L3254">        Color c1 = new Color(30,30,50,255); // dark end of shadow</span>
<span class="nc" id="L3255">        Color c2 = new Color(50,50,70,0);   // light end of shadow</span>

<span class="nc" id="L3257">        Point2D p1 = new Point2D.Double(41.5,-25+ldiff);</span>
<span class="nc" id="L3258">        Point2D p2 = new Point2D.Double(41.5,8.0+ldiff);</span>

<span class="nc" id="L3260">        AffineTransform t = new AffineTransform();</span>
<span class="nc" id="L3261">        t.scale(scale,scale);</span>
<span class="nc" id="L3262">        t.rotate(Math.toRadians(direction*60),41.5,35.5);</span>
<span class="nc" id="L3263">        t.transform(p1,p1);</span>
<span class="nc" id="L3264">        t.transform(p2,p2);</span>

<span class="nc" id="L3266">        return(new GradientPaint(p1,c1,p2,c2));</span>
    }

    /**
     * Returns the absolute position of the upper-left hand corner of the hex
     * graphic
     */
    private Point getHexLocation(int x, int y, boolean ignoreElevation) {
<span class="nc" id="L3274">        float elevationAdjust = 0.0f;</span>

<span class="nc" id="L3276">        IHex hex = game.getBoard().getHex(x, y);</span>
<span class="nc bnc" id="L3277" title="All 6 branches missed.">        if ((hex != null) &amp;&amp; useIsometric() &amp;&amp; !ignoreElevation) {</span>
<span class="nc" id="L3278">            elevationAdjust = hex.getLevel() * HEX_ELEV * scale * -1.0f;</span>
        }
<span class="nc" id="L3280">        int ypos = (y * (int) (HEX_H * scale))</span>
<span class="nc bnc" id="L3281" title="All 2 branches missed.">                   + ((x &amp; 1) == 1 ? (int) ((HEX_H / 2) * scale) : 0);</span>
<span class="nc" id="L3282">        return new Point(x * (int) (HEX_WC * scale), ypos + (int) elevationAdjust);</span>
    }

    /**
     * For large tile texture: Returns the absolute position of the upper-left
     * hand corner of the hex graphic When using large tiles multiplying the
     * rounding errors from the (int) cast must be avoided however this cannot
     * be used for small tiles as it will make gaps appear between hexes This
     * will not factor in Isometric as this would be incorrect for large tiles
     */
    private Point getHexLocationLargeTile(int x, int y, float tscale) {
<span class="nc" id="L3293">        int ypos = (int) (y * HEX_H * tscale)</span>
<span class="nc bnc" id="L3294" title="All 2 branches missed.">                + ((x &amp; 1) == 1 ? (int) ((HEX_H / 2) * tscale) : 0);</span>
<span class="nc" id="L3295">        return new Point((int) (x * HEX_WC * tscale), ypos);</span>
    }

    private Point getHexLocationLargeTile(int x, int y) {
<span class="nc" id="L3299">        return getHexLocationLargeTile(x, y, scale);</span>
    }

    Point getHexLocation(Coords c) {
<span class="nc" id="L3303">        return getHexLocation(c.getX(), c.getY(), false);</span>
    }

     /**
     * Returns the absolute position of the centre of the hex graphic
     */
    private Point getCentreHexLocation(int x, int y, boolean ignoreElevation) {
<span class="nc" id="L3310">        Point p = getHexLocation(x, y, ignoreElevation);</span>
<span class="nc" id="L3311">        p.x += ((HEX_W / 2) * scale);</span>
<span class="nc" id="L3312">        p.y += ((HEX_H / 2) * scale);</span>
<span class="nc" id="L3313">        return p;</span>
    }

    public Point getCentreHexLocation(Coords c) {
<span class="nc" id="L3317">        return getCentreHexLocation(c.getX(), c.getY(), false);</span>
    }

    public Point getCentreHexLocation(Coords c, boolean ignoreElevation) {
<span class="nc" id="L3321">        return getCentreHexLocation(c.getX(), c.getY(), ignoreElevation);</span>
    }

    public void drawRuler(Coords s, Coords e, Color sc, Color ec) {
<span class="nc" id="L3325">        rulerStart = s;</span>
<span class="nc" id="L3326">        rulerEnd = e;</span>
<span class="nc" id="L3327">        rulerStartColor = sc;</span>
<span class="nc" id="L3328">        rulerEndColor = ec;</span>

<span class="nc" id="L3330">        repaint();</span>
<span class="nc" id="L3331">    }</span>

    /**
     * Returns the coords at the specified point
     */
    Coords getCoordsAt(Point p) {
        // We must account for the board translation to add padding
<span class="nc" id="L3338">        p.x -= HEX_W;</span>
<span class="nc" id="L3339">        p.y -= HEX_H;</span>

        // base values
<span class="nc" id="L3342">        int x = p.x / (int) (HEX_WC * scale);</span>
<span class="nc" id="L3343">        int y = p.y / (int) (HEX_H * scale);</span>
        // correction for the displaced odd columns
<span class="nc bnc" id="L3345" title="All 2 branches missed.">        if ((float) p.y / (scale * HEX_H) - y &lt; 0.5)</span>
<span class="nc" id="L3346">            y -= x % 2;</span>

        // check the surrounding hexes if they contain p
        // checking at most 3 hexes would be sufficient
        // but which ones? This is failsafer.
<span class="nc" id="L3351">        Coords cc = new Coords(x, y);</span>
<span class="nc bnc" id="L3352" title="All 2 branches missed.">        if (!HexDrawUtilities.getHexFull(getHexLocation(cc),scale).contains(p)) {</span>
<span class="nc" id="L3353">            boolean hasMatch = false;</span>
<span class="nc bnc" id="L3354" title="All 4 branches missed.">            for (int dir = 0; dir &lt; 6 &amp;&amp; !hasMatch; dir++) {</span>
<span class="nc" id="L3355">                Coords cn = cc.translated(dir);</span>
<span class="nc bnc" id="L3356" title="All 2 branches missed.">                if (HexDrawUtilities.getHexFull(getHexLocation(cn),scale).contains(p)) {</span>
<span class="nc" id="L3357">                    cc = cn;</span>
<span class="nc" id="L3358">                    hasMatch = true;</span>
                }
            }
        }

<span class="nc bnc" id="L3363" title="All 2 branches missed.">        if (useIsometric()) {</span>
            // When using isometric rendering, a lower hex can obscure the
            // normal hex. Iterate over all hexes from highest to lowest,
            // looking for a hex that contains the selected mouse click point.
<span class="nc" id="L3367">            final int minElev = Math.min(0, game.getBoard().getMinElevation());</span>
<span class="nc" id="L3368">            final int maxElev = Math.max(0, game.getBoard().getMaxElevation());</span>
<span class="nc" id="L3369">            final int delta = (int) Math</span>
<span class="nc" id="L3370">                    .ceil(((double) maxElev - minElev) / 3.0f);</span>
<span class="nc" id="L3371">            final int minHexSpan = Math.max(y - delta, 0);</span>
<span class="nc" id="L3372">            final int maxHexSpan = Math.min(y + delta, game.getBoard()</span>
<span class="nc" id="L3373">                                                           .getHeight());</span>
<span class="nc bnc" id="L3374" title="All 2 branches missed.">            for (int elev = maxElev; elev &gt;= minElev; elev--) {</span>
<span class="nc bnc" id="L3375" title="All 2 branches missed.">                for (int i = minHexSpan; i &lt;= maxHexSpan; i++) {</span>
<span class="nc bnc" id="L3376" title="All 2 branches missed.">                    for (int dx = -1; dx &lt; 2; dx++) {</span>
<span class="nc" id="L3377">                        Coords c1 = new Coords(x + dx, i);</span>
<span class="nc" id="L3378">                        IHex hexAlt = game.getBoard().getHex(c1);</span>
<span class="nc bnc" id="L3379" title="All 4 branches missed.">                        if (HexDrawUtilities.getHexFull(getHexLocation(c1),scale).contains(p)</span>
                                &amp;&amp; (hexAlt != null)
<span class="nc bnc" id="L3381" title="All 2 branches missed.">                                &amp;&amp; (hexAlt.getLevel() == elev)) {</span>
                            // Return immediately with highest hex found.
<span class="nc" id="L3383">                            return c1;</span>
                        }
                    }
                }
            }
            // nothing found
<span class="nc" id="L3389">            return new Coords(-1,-1);</span>
        }
        else {
            // not Isometric
<span class="nc" id="L3393">            return cc;</span>
        }
    }

    public void redrawMovingEntity(Entity entity, Coords position, int facing,
            int elevation) {
<span class="nc" id="L3399">        Integer entityId = Integer.valueOf(entity.getId());</span>
<span class="nc" id="L3400">        List&lt;Integer&gt; spriteKey = getIdAndLoc(entityId, -1);</span>
<span class="nc" id="L3401">        EntitySprite sprite = entitySpriteIds.get(spriteKey);</span>
<span class="nc" id="L3402">        IsometricSprite isoSprite = isometricSpriteIds.get(spriteKey);</span>
        // We can ignore secondary locations for now, as we don't have moving
        // multi-location entitys (will need to change for mobile structures)

        PriorityQueue&lt;EntitySprite&gt; newSprites;
        PriorityQueue&lt;IsometricSprite&gt; isoSprites;
        HashMap&lt;List&lt;Integer&gt;, EntitySprite&gt; newSpriteIds;
        HashMap&lt;List&lt;Integer&gt;, IsometricSprite&gt; newIsoSpriteIds;

        // Remove sprite for Entity, so it's not displayed while moving
<span class="nc bnc" id="L3412" title="All 2 branches missed.">        if (sprite != null) {</span>
<span class="nc" id="L3413">            newSprites = new PriorityQueue&lt;EntitySprite&gt;(entitySprites);</span>
<span class="nc" id="L3414">            newSpriteIds = new HashMap&lt;&gt;(entitySpriteIds);</span>

<span class="nc" id="L3416">            newSprites.remove(sprite);</span>
<span class="nc" id="L3417">            newSpriteIds.remove(spriteKey);</span>

<span class="nc" id="L3419">            entitySprites = newSprites;</span>
<span class="nc" id="L3420">            entitySpriteIds = newSpriteIds;</span>
        }
        // Remove iso sprite for Entity, so it's not displayed while moving
<span class="nc bnc" id="L3423" title="All 2 branches missed.">        if (isoSprite != null) {</span>
<span class="nc" id="L3424">            isoSprites = new PriorityQueue&lt;IsometricSprite&gt;(isometricSprites);</span>
<span class="nc" id="L3425">            newIsoSpriteIds = new HashMap&lt;&gt;(isometricSpriteIds);</span>

<span class="nc" id="L3427">            isoSprites.remove(isoSprite);</span>
<span class="nc" id="L3428">            newIsoSpriteIds.remove(spriteKey);</span>

<span class="nc" id="L3430">            isometricSprites = isoSprites;</span>
<span class="nc" id="L3431">            isometricSpriteIds = newIsoSpriteIds;</span>
        }

<span class="nc" id="L3434">        MovingEntitySprite mSprite = movingEntitySpriteIds.get(entityId);</span>
<span class="nc" id="L3435">        List&lt;MovingEntitySprite&gt; newMovingSprites = new ArrayList&lt;&gt;(</span>
                movingEntitySprites);
<span class="nc" id="L3437">        HashMap&lt;Integer, MovingEntitySprite&gt; newMovingSpriteIds = new HashMap&lt;&gt;(</span>
                movingEntitySpriteIds);
        // Remove any old movement sprite
<span class="nc bnc" id="L3440" title="All 2 branches missed.">        if (mSprite != null) {</span>
<span class="nc" id="L3441">            newMovingSprites.remove(mSprite);</span>
        }
        // Create new movement sprite
<span class="nc bnc" id="L3444" title="All 2 branches missed.">        if (entity.getPosition() != null) {</span>
<span class="nc" id="L3445">            mSprite = new MovingEntitySprite(this, entity, position, facing,</span>
                    elevation);
<span class="nc" id="L3447">            newMovingSprites.add(mSprite);</span>
<span class="nc" id="L3448">            newMovingSpriteIds.put(entityId, mSprite);</span>
        }

<span class="nc" id="L3451">        movingEntitySprites = newMovingSprites;</span>
<span class="nc" id="L3452">        movingEntitySpriteIds = newMovingSpriteIds;</span>
<span class="nc" id="L3453">    }</span>

    public boolean isMovingUnits() {
<span class="nc bnc" id="L3456" title="All 2 branches missed.">        return movingUnits.size() &gt; 0;</span>
    }

    /**
     * Clears the sprite for an entity and prepares it to be re-drawn. Replaces
     * the old sprite with the new! Try to prevent annoying
     * ConcurrentModificationExceptions
     */
    public void redrawEntity(Entity entity) {
<span class="nc" id="L3465">        redrawEntity(entity, null);</span>
<span class="nc" id="L3466">    }</span>

    /**
     * Convenience method for returning a Key value for the entitySpriteIds and
     * isometricSprite maps. The List contains as the first element the Entity
     * ID and as the second element it's location ID: either -1 if the Entity
     * has no secondary locations, or the index of its secondary location.
     *
     * @param entityId
     *            The Entity ID
     * @param secondaryLoc
     *            the secondary loc index, or -1 for Entitys without secondary
     *            positions
     * @return
     */
    private List&lt;Integer&gt; getIdAndLoc(Integer entityId, int secondaryLoc) {
<span class="nc" id="L3482">        List&lt;Integer&gt; idLoc = new ArrayList&lt;Integer&gt;(2);</span>
<span class="nc" id="L3483">        idLoc.add(entityId);</span>
<span class="nc" id="L3484">        idLoc.add(secondaryLoc);</span>
<span class="nc" id="L3485">        return idLoc;</span>
    }

    /**
     * Clears the sprite for an entity and prepares it to be re-drawn. Replaces
     * the old sprite with the new! Takes a reference to the Entity object
     * before changes, in case it contained important state information, like
     * Dropships taking off (airborne dropships lose their secondary hexes). Try
     * to prevent annoying ConcurrentModificationExceptions
     */
    public void redrawEntity(Entity entity, Entity oldEntity) {
<span class="nc" id="L3496">        Integer entityId = Integer.valueOf(entity.getId());</span>
<span class="nc bnc" id="L3497" title="All 2 branches missed.">        if (oldEntity == null) {</span>
<span class="nc" id="L3498">            oldEntity = entity;</span>
        }

        // If the entity we are updating doesn't have a position, ensure we
        // remove all of its old sprites
<span class="nc bnc" id="L3503" title="All 2 branches missed.">        if (entity.getPosition() == null) {</span>
            Iterator&lt;EntitySprite&gt; spriteIter;

            // Remove Entity Sprites
<span class="nc" id="L3507">            spriteIter = entitySprites.iterator();</span>
<span class="nc bnc" id="L3508" title="All 2 branches missed.">            while (spriteIter.hasNext()) {</span>
<span class="nc" id="L3509">                EntitySprite sprite = spriteIter.next();</span>
<span class="nc bnc" id="L3510" title="All 2 branches missed.">                if (sprite.entity.equals(entity)) {</span>
<span class="nc" id="L3511">                    spriteIter.remove();</span>
                }
<span class="nc" id="L3513">            }</span>

            //  Update ID -&gt; Sprite map
<span class="nc" id="L3516">            spriteIter = entitySpriteIds.values().iterator();</span>
<span class="nc bnc" id="L3517" title="All 2 branches missed.">            while (spriteIter.hasNext()) {</span>
<span class="nc" id="L3518">                EntitySprite sprite = spriteIter.next();</span>
<span class="nc bnc" id="L3519" title="All 2 branches missed.">                if (sprite.entity.equals(entity)) {</span>
<span class="nc" id="L3520">                    spriteIter.remove();</span>
                }
<span class="nc" id="L3522">            }</span>

            Iterator&lt;IsometricSprite&gt; isoSpriteIter;

            // Remove IsometricSprites
<span class="nc" id="L3527">            isoSpriteIter = isometricSprites.iterator();</span>
<span class="nc bnc" id="L3528" title="All 2 branches missed.">            while (isoSpriteIter.hasNext()) {</span>
<span class="nc" id="L3529">                IsometricSprite sprite = isoSpriteIter.next();</span>
<span class="nc bnc" id="L3530" title="All 2 branches missed.">                if (sprite.entity.equals(entity)) {</span>
<span class="nc" id="L3531">                    isoSpriteIter.remove();</span>
                }
<span class="nc" id="L3533">            }</span>

            // Update ID -&gt; Iso Sprite Map
<span class="nc" id="L3536">            isoSpriteIter  = isometricSpriteIds.values().iterator();</span>
<span class="nc bnc" id="L3537" title="All 2 branches missed.">            while (isoSpriteIter.hasNext()) {</span>
<span class="nc" id="L3538">                IsometricSprite sprite = isoSpriteIter.next();</span>
<span class="nc bnc" id="L3539" title="All 2 branches missed.">                if (sprite.entity.equals(entity)) {</span>
<span class="nc" id="L3540">                    isoSpriteIter.remove();</span>
                }
<span class="nc" id="L3542">            }</span>
        }

        // Create a copy of the sprite list
<span class="nc" id="L3546">        Queue&lt;EntitySprite&gt; newSprites = new PriorityQueue&lt;&gt;(entitySprites);</span>
<span class="nc" id="L3547">        HashMap&lt;List&lt;Integer&gt;, EntitySprite&gt; newSpriteIds =</span>
                new HashMap&lt;&gt;(entitySpriteIds);
<span class="nc" id="L3549">        Queue&lt;IsometricSprite&gt; isoSprites = new PriorityQueue&lt;&gt;(</span>
                isometricSprites);
<span class="nc" id="L3551">        HashMap&lt;List&lt;Integer&gt;, IsometricSprite&gt; newIsoSpriteIds =</span>
                new HashMap&lt;&gt;(isometricSpriteIds);

        // Remove the sprites we are going to update
<span class="nc" id="L3555">        EntitySprite sprite = entitySpriteIds.get(getIdAndLoc(entityId, -1));</span>
<span class="nc" id="L3556">        IsometricSprite isoSprite = isometricSpriteIds.get(getIdAndLoc(</span>
                entityId, -1));
<span class="nc bnc" id="L3558" title="All 2 branches missed.">        if (sprite != null) {</span>
<span class="nc" id="L3559">            newSprites.remove(sprite);</span>
        }
<span class="nc bnc" id="L3561" title="All 2 branches missed.">        if (isoSprite != null) {</span>
<span class="nc" id="L3562">            isoSprites.remove(isoSprite);</span>
        }
<span class="nc bnc" id="L3564" title="All 2 branches missed.">        for (int secondaryPos : oldEntity.getSecondaryPositions().keySet()) {</span>
<span class="nc" id="L3565">            sprite = entitySpriteIds.get(getIdAndLoc(entityId, secondaryPos));</span>
<span class="nc bnc" id="L3566" title="All 2 branches missed.">            if (sprite != null) {</span>
<span class="nc" id="L3567">                newSprites.remove(sprite);</span>
            }
<span class="nc" id="L3569">            isoSprite = isometricSpriteIds.get(getIdAndLoc(entityId,</span>
                    secondaryPos));
<span class="nc bnc" id="L3571" title="All 2 branches missed.">            if (isoSprite != null) {</span>
<span class="nc" id="L3572">                isoSprites.remove(isoSprite);</span>
            }
<span class="nc" id="L3574">        }</span>

        // Create the new sprites
<span class="nc" id="L3577">        Coords position = entity.getPosition();</span>
<span class="nc" id="L3578">        boolean canSee = EntityVisibilityUtils.detectedOrHasVisual(localPlayer, game, entity);</span>

<span class="nc bnc" id="L3580" title="All 4 branches missed.">        if ((position != null) &amp;&amp; canSee) {</span>
            // Add new EntitySprite
            // If no secondary positions, add a sprite for the central position
<span class="nc bnc" id="L3583" title="All 2 branches missed.">            if (entity.getSecondaryPositions().isEmpty()) {</span>
<span class="nc" id="L3584">                sprite = new EntitySprite(this, entity, -1, radarBlipImage);</span>
<span class="nc" id="L3585">                newSprites.add(sprite);</span>
<span class="nc" id="L3586">                newSpriteIds.put(getIdAndLoc(entityId, -1), sprite);</span>
            } else { // Add all secondary position sprites, which includes a
                // sprite for the central hex
<span class="nc bnc" id="L3589" title="All 2 branches missed.">                for (int secondaryPos : entity.getSecondaryPositions().keySet()) {</span>
<span class="nc" id="L3590">                    sprite = new EntitySprite(this, entity, secondaryPos,</span>
                            radarBlipImage);
<span class="nc" id="L3592">                    newSprites.add(sprite);</span>
<span class="nc" id="L3593">                    newSpriteIds.put(getIdAndLoc(entityId, secondaryPos),</span>
                            sprite);
<span class="nc" id="L3595">                }</span>
            }

            // Add new IsometricSprite
            // If no secondary positions, add a sprite for the central position
<span class="nc bnc" id="L3600" title="All 2 branches missed.">            if (entity.getSecondaryPositions().isEmpty()) {</span>
<span class="nc" id="L3601">                isoSprite = new IsometricSprite(this, entity, -1,</span>
                        radarBlipImage);
<span class="nc" id="L3603">                isoSprites.add(isoSprite);</span>
<span class="nc" id="L3604">                newIsoSpriteIds.put(getIdAndLoc(entityId, -1), isoSprite);</span>
            } else { // Add all secondary position sprites, which includes a
                // sprite for the central hex
<span class="nc bnc" id="L3607" title="All 2 branches missed.">                for (int secondaryPos : entity.getSecondaryPositions().keySet()) {</span>
<span class="nc" id="L3608">                    isoSprite = new IsometricSprite(this, entity, secondaryPos,</span>
                            radarBlipImage);
<span class="nc" id="L3610">                    isoSprites.add(isoSprite);</span>
<span class="nc" id="L3611">                    newIsoSpriteIds.put(getIdAndLoc(entityId, secondaryPos),</span>
                            isoSprite);
<span class="nc" id="L3613">                }</span>
            }
        }

        // Update Sprite state with new collections
<span class="nc" id="L3618">        entitySprites = newSprites;</span>
<span class="nc" id="L3619">        entitySpriteIds = newSpriteIds;</span>
<span class="nc" id="L3620">        isometricSprites = isoSprites;</span>
<span class="nc" id="L3621">        isometricSpriteIds = newIsoSpriteIds;</span>

        // Remove C3 sprites
<span class="nc bnc" id="L3624" title="All 2 branches missed.">        for (Iterator&lt;C3Sprite&gt; i = c3Sprites.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L3625">            final C3Sprite c3sprite = i.next();</span>
<span class="nc bnc" id="L3626" title="All 2 branches missed.">            if ((c3sprite.entityId == entity.getId())</span>
<span class="nc bnc" id="L3627" title="All 2 branches missed.">                || (c3sprite.masterId == entity.getId())) {</span>
<span class="nc" id="L3628">                i.remove();</span>
            }
<span class="nc" id="L3630">        }</span>

        // Update C3 link, if necessary
<span class="nc bnc" id="L3633" title="All 8 branches missed.">        if (entity.hasC3() || entity.hasC3i() || entity.hasActiveNovaCEWS() || entity.hasNavalC3()) {</span>
<span class="nc" id="L3634">            addC3Link(entity);</span>
        }

<span class="nc bnc" id="L3637" title="All 2 branches missed.">        for (Iterator&lt;VTOLAttackSprite&gt; iter = vtolAttackSprites.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L3638">            final VTOLAttackSprite s = iter.next();</span>
<span class="nc bnc" id="L3639" title="All 2 branches missed.">            if (s.getEntity().getId() == entity.getId()) {</span>
<span class="nc" id="L3640">                iter.remove();</span>
            }
<span class="nc" id="L3642">        }</span>

        // Remove Flyover Sprites
<span class="nc" id="L3645">        Iterator&lt;FlyOverSprite&gt; flyOverIt = flyOverSprites.iterator();</span>
<span class="nc bnc" id="L3646" title="All 2 branches missed.">        while (flyOverIt.hasNext()) {</span>
<span class="nc" id="L3647">            final FlyOverSprite flyOverSprite = flyOverIt.next();</span>
<span class="nc bnc" id="L3648" title="All 2 branches missed.">            if (flyOverSprite.getEntityId() == entity.getId()) {</span>
<span class="nc" id="L3649">                flyOverIt.remove();</span>
            }
<span class="nc" id="L3651">        }</span>

        // Add Flyover path, if necessary
<span class="nc bnc" id="L3654" title="All 4 branches missed.">        if ((entity.isAirborne() || entity.isMakingVTOLGroundAttack())</span>
<span class="nc bnc" id="L3655" title="All 2 branches missed.">                &amp;&amp; (entity.getPassedThrough().size() &gt; 1)) {</span>
<span class="nc" id="L3656">            addFlyOverPath(entity);</span>
        }

<span class="nc" id="L3659">        updateEcmList();</span>
<span class="nc" id="L3660">        highlightSelectedEntity();</span>
<span class="nc" id="L3661">        scheduleRedraw();</span>
<span class="nc" id="L3662">    }</span>

    /**
     * Clears all old entity sprites out of memory and sets up new ones.
     */
    void redrawAllEntities() {
<span class="nc" id="L3668">        int numEntities = game.getNoOfEntities();</span>
        // Prevent IllegalArgumentException
<span class="nc" id="L3670">        numEntities = Math.max(1, numEntities);</span>
<span class="nc" id="L3671">        Queue&lt;EntitySprite&gt; newSprites = new PriorityQueue&lt;EntitySprite&gt;(</span>
                numEntities);
<span class="nc" id="L3673">        Queue&lt;IsometricSprite&gt; newIsometricSprites = new PriorityQueue&lt;&gt;(</span>
                numEntities);
<span class="nc" id="L3675">        Map&lt;List&lt;Integer&gt;, EntitySprite&gt; newSpriteIds = new HashMap&lt;&gt;(</span>
                numEntities);
<span class="nc" id="L3677">        Map&lt;List&lt;Integer&gt;, IsometricSprite&gt; newIsoSpriteIds = new HashMap&lt;&gt;(</span>
                numEntities);

<span class="nc" id="L3680">        ArrayList&lt;WreckSprite&gt; newWrecks = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L3681">        ArrayList&lt;IsometricWreckSprite&gt; newIsometricWrecks = new ArrayList&lt;&gt;();</span>

<span class="nc" id="L3683">        Enumeration&lt;Entity&gt; e = game.getWreckedEntities();</span>
<span class="nc bnc" id="L3684" title="All 2 branches missed.">        while (e.hasMoreElements()) {</span>
<span class="nc" id="L3685">            Entity entity = e.nextElement();</span>
<span class="nc bnc" id="L3686" title="All 4 branches missed.">            if (!(entity instanceof Infantry) &amp;&amp; (entity.getPosition() != null)) {</span>
                WreckSprite ws;
                IsometricWreckSprite iws;
<span class="nc bnc" id="L3689" title="All 2 branches missed.">                if (entity.getSecondaryPositions().isEmpty()) {</span>
<span class="nc" id="L3690">                    ws = new WreckSprite(this, entity, -1);</span>
<span class="nc" id="L3691">                    newWrecks.add(ws);</span>
<span class="nc" id="L3692">                    iws = new IsometricWreckSprite(this, entity, -1);</span>
<span class="nc" id="L3693">                    newIsometricWrecks.add(iws);</span>
                } else {
<span class="nc bnc" id="L3695" title="All 2 branches missed.">                    for (int secondaryPos : entity.getSecondaryPositions()</span>
<span class="nc" id="L3696">                            .keySet()) {</span>
<span class="nc" id="L3697">                        ws = new WreckSprite(this, entity, secondaryPos);</span>
<span class="nc" id="L3698">                        newWrecks.add(ws);</span>
<span class="nc" id="L3699">                        iws = new IsometricWreckSprite(this, entity,</span>
                                secondaryPos);
<span class="nc" id="L3701">                        newIsometricWrecks.add(iws);</span>
<span class="nc" id="L3702">                    }</span>
                }
            }
<span class="nc" id="L3705">        }</span>

<span class="nc" id="L3707">        clearC3Networks();</span>
<span class="nc" id="L3708">        clearFlyOverPaths();</span>
<span class="nc bnc" id="L3709" title="All 2 branches missed.">        for (Entity entity : game.getEntitiesVector()) {</span>
<span class="nc bnc" id="L3710" title="All 2 branches missed.">            if (entity.getPosition() == null) {</span>
<span class="nc" id="L3711">                continue;</span>
            }
<span class="nc bnc" id="L3713" title="All 2 branches missed.">            if ((localPlayer != null)</span>
<span class="nc bnc" id="L3714" title="All 2 branches missed.">                &amp;&amp; game.getOptions().booleanOption(OptionsConstants.ADVANCED_DOUBLE_BLIND)</span>
<span class="nc bnc" id="L3715" title="All 2 branches missed.">                &amp;&amp; entity.getOwner().isEnemyOf(localPlayer)</span>
<span class="nc bnc" id="L3716" title="All 2 branches missed.">                &amp;&amp; !entity.hasSeenEntity(localPlayer)</span>
<span class="nc bnc" id="L3717" title="All 2 branches missed.">                &amp;&amp; !entity.hasDetectedEntity(localPlayer)) {</span>
<span class="nc" id="L3718">                continue;</span>
            }
<span class="nc bnc" id="L3720" title="All 2 branches missed.">            if ((localPlayer != null)</span>
<span class="nc bnc" id="L3721" title="All 2 branches missed.">                    &amp;&amp; game.getOptions().booleanOption(OptionsConstants.ADVANCED_HIDDEN_UNITS)</span>
<span class="nc bnc" id="L3722" title="All 2 branches missed.">                    &amp;&amp; entity.getOwner().isEnemyOf(localPlayer)</span>
<span class="nc bnc" id="L3723" title="All 2 branches missed.">                    &amp;&amp; entity.isHidden()) {</span>
<span class="nc" id="L3724">                continue;</span>
            }
<span class="nc bnc" id="L3726" title="All 2 branches missed.">            if (entity.getSecondaryPositions().isEmpty()) {</span>
<span class="nc" id="L3727">                EntitySprite sprite = new EntitySprite(this, entity, -1,</span>
                        radarBlipImage);
<span class="nc" id="L3729">                newSprites.add(sprite);</span>
<span class="nc" id="L3730">                newSpriteIds.put(getIdAndLoc(entity.getId(), -1), sprite);</span>
<span class="nc" id="L3731">                IsometricSprite isosprite = new IsometricSprite(this, entity,</span>
                        -1, radarBlipImage);
<span class="nc" id="L3733">                newIsometricSprites.add(isosprite);</span>
<span class="nc" id="L3734">                newIsoSpriteIds.put(getIdAndLoc(entity.getId(), -1), isosprite);</span>
<span class="nc" id="L3735">            } else {</span>
<span class="nc bnc" id="L3736" title="All 2 branches missed.">                for (int secondaryPos : entity.getSecondaryPositions().keySet()) {</span>
<span class="nc" id="L3737">                    EntitySprite sprite = new EntitySprite(this, entity,</span>
                            secondaryPos, radarBlipImage);
<span class="nc" id="L3739">                    newSprites.add(sprite);</span>
<span class="nc" id="L3740">                    newSpriteIds.put(getIdAndLoc(entity.getId(), secondaryPos),</span>
                            sprite);

<span class="nc" id="L3743">                    IsometricSprite isosprite = new IsometricSprite(this,</span>
                            entity, secondaryPos, radarBlipImage);
<span class="nc" id="L3745">                    newIsometricSprites.add(isosprite);</span>
<span class="nc" id="L3746">                    newIsoSpriteIds.put(</span>
<span class="nc" id="L3747">                            getIdAndLoc(entity.getId(), secondaryPos),</span>
                            isosprite);
<span class="nc" id="L3749">                }</span>
            }

<span class="nc bnc" id="L3752" title="All 8 branches missed.">            if (entity.hasC3() || entity.hasC3i() || entity.hasActiveNovaCEWS() || entity.hasNavalC3()) {</span>
<span class="nc" id="L3753">                addC3Link(entity);</span>
            }

<span class="nc bnc" id="L3756" title="All 4 branches missed.">            if ((entity.isAirborne() || entity.isMakingVTOLGroundAttack())</span>
<span class="nc bnc" id="L3757" title="All 2 branches missed.">                    &amp;&amp; (entity.getPassedThrough().size() &gt; 1)) {</span>
<span class="nc" id="L3758">                addFlyOverPath(entity);</span>
            }
<span class="nc" id="L3760">        }</span>

<span class="nc" id="L3762">        entitySprites = newSprites;</span>
<span class="nc" id="L3763">        entitySpriteIds = newSpriteIds;</span>

<span class="nc" id="L3765">        isometricSprites = newIsometricSprites;</span>
<span class="nc" id="L3766">        isometricSpriteIds = newIsoSpriteIds;</span>

<span class="nc" id="L3768">        wreckSprites = newWrecks;</span>
<span class="nc" id="L3769">        isometricWreckSprites = newIsometricWrecks;</span>

        // Update ECM list, to ensure that Sprites are updated with ECM info
<span class="nc" id="L3772">        updateEcmList();</span>
        // Re-highlight a selected entity, if present
<span class="nc" id="L3774">        highlightSelectedEntity();</span>

<span class="nc" id="L3776">        scheduleRedraw();</span>
<span class="nc" id="L3777">    }</span>

    private void redrawAllFlares() {
<span class="nc" id="L3780">        flareSprites.clear();</span>
<span class="nc bnc" id="L3781" title="All 2 branches missed.">        for (Flare f : game.getFlares()) {</span>
<span class="nc" id="L3782">            flareSprites.add(new FlareSprite(this, f));</span>
<span class="nc" id="L3783">        }</span>
<span class="nc" id="L3784">    }</span>

    public Image getFlareImage() {
<span class="nc" id="L3787">        return flareImage;</span>
    }

    /**
     * Moves the cursor to the new position, or hides it, if newPos is null
     */
    private void moveCursor(CursorSprite cursor, Coords newPos) {
<span class="nc" id="L3794">        final Rectangle oldBounds = new Rectangle(cursor.getBounds());</span>
<span class="nc bnc" id="L3795" title="All 2 branches missed.">        if (newPos != null) {</span>
<span class="nc" id="L3796">            cursor.setHexLocation(newPos);</span>
        } else {
<span class="nc" id="L3798">            cursor.setOffScreen();</span>
        }
        // repaint affected area
<span class="nc" id="L3801">        repaint(oldBounds);</span>
<span class="nc" id="L3802">        repaint(cursor.getBounds());</span>
<span class="nc" id="L3803">    }</span>

    /** Centers the board on hex c. Uses smooth centering
     * if activated in the client settings. */
    public void centerOnHex(Coords c) {
<span class="nc bnc" id="L3808" title="All 2 branches missed.">        if (c == null) return;</span>

<span class="nc bnc" id="L3810" title="All 2 branches missed.">        if (GUIPreferences.getInstance().getBoolean(&quot;SOFTCENTER&quot;)) {</span>
            // Soft Centering:
            // set the target point
<span class="nc" id="L3813">            Point p = getCentreHexLocation(c);</span>
<span class="nc" id="L3814">            softCenterTarget.setLocation(</span>
<span class="nc" id="L3815">                    (double)p.x/boardSize.getWidth(),</span>
<span class="nc" id="L3816">                    (double)p.y/boardSize.getHeight());</span>

            // adjust the target point because the board can't
            // center on points too close to an edge
<span class="nc" id="L3820">            double w = scrollpane.getViewport().getWidth();</span>
<span class="nc" id="L3821">            double h = scrollpane.getViewport().getHeight();</span>
<span class="nc" id="L3822">            double bw = boardSize.getWidth();</span>
<span class="nc" id="L3823">            double bh = boardSize.getHeight();</span>

<span class="nc" id="L3825">            double minX = (w/2-HEX_W)/bw;</span>
<span class="nc" id="L3826">            double minY = (h/2-HEX_H)/bh;</span>
<span class="nc" id="L3827">            double maxX = (bw+HEX_W-w/2)/bw;</span>
<span class="nc" id="L3828">            double maxY = (bh+HEX_H-h/2)/bh;</span>

            // here the order is important because the top/left
            // edges always stop the board, the bottom/right
            // only when the board is big enough
<span class="nc" id="L3833">            softCenterTarget.setLocation(</span>
<span class="nc" id="L3834">                    Math.min(softCenterTarget.getX(), maxX),</span>
<span class="nc" id="L3835">                    Math.min(softCenterTarget.getY(), maxY));</span>

<span class="nc" id="L3837">            softCenterTarget.setLocation(</span>
<span class="nc" id="L3838">                    Math.max(softCenterTarget.getX(), minX),</span>
<span class="nc" id="L3839">                    Math.max(softCenterTarget.getY(), minY));</span>

            // get the current board center point
<span class="nc" id="L3842">            double[] v = getVisibleArea();</span>
<span class="nc" id="L3843">            oldCenter.setLocation((v[0]+v[2])/2, (v[1]+v[3])/2);</span>

<span class="nc" id="L3845">            waitTimer = 0;</span>
<span class="nc" id="L3846">            isSoftCentering = true;</span>

<span class="nc" id="L3848">        } else {</span>
            // no soft centering:
            // center on c directly
<span class="nc" id="L3851">            Point p = getCentreHexLocation(c);</span>
<span class="nc" id="L3852">            centerOnPointRel(</span>
<span class="nc" id="L3853">                    (double)p.x/boardSize.getWidth(),</span>
<span class="nc" id="L3854">                    (double)p.y/boardSize.getHeight());</span>
        }
<span class="nc" id="L3856">    }</span>

    /** Moves the board one step towards the final
     * position in during soft centering.
     */
    private synchronized void centerOnHexSoftStep(long deltaTime) {
<span class="nc bnc" id="L3862" title="All 2 branches missed.">        if (isSoftCentering) {</span>
            // don't move the board if 20ms haven't passed since the last move
<span class="nc" id="L3864">            waitTimer += deltaTime;</span>
<span class="nc bnc" id="L3865" title="All 2 branches missed.">            if (waitTimer &lt; 20) return;</span>
<span class="nc" id="L3866">            waitTimer = 0;</span>

            // move the board by a fraction of the distance to the target
<span class="nc" id="L3869">            Point2D newCenter = new Point2D.Double(</span>
<span class="nc" id="L3870">                    oldCenter.getX() + (softCenterTarget.getX() - oldCenter.getX())/SOFT_CENTER_SPEED,</span>
<span class="nc" id="L3871">                    oldCenter.getY() + (softCenterTarget.getY() - oldCenter.getY())/SOFT_CENTER_SPEED );</span>
<span class="nc" id="L3872">            centerOnPointRel(newCenter.getX(), newCenter.getY());</span>

<span class="nc" id="L3874">            oldCenter = newCenter;</span>

            // stop the motion when close enough to the final position
<span class="nc bnc" id="L3877" title="All 2 branches missed.">            if (softCenterTarget.distance(newCenter) &lt; 0.0005) {</span>
<span class="nc" id="L3878">                stopSoftCentering();</span>
<span class="nc" id="L3879">                pingMinimap();</span>
            }
        }
<span class="nc" id="L3882">    }</span>

    public void stopSoftCentering() {
<span class="nc" id="L3885">        isSoftCentering = false;</span>
<span class="nc" id="L3886">    }</span>

    private void adjustVisiblePosition(Coords c, Point dispPoint, double ihdx, double ihdy) {
<span class="nc bnc" id="L3889" title="All 4 branches missed.">        if ((c == null) || (dispPoint == null)) return;</span>

<span class="nc" id="L3891">        Point hexPoint = getCentreHexLocation(c);</span>
        // correct for upper left board padding
<span class="nc" id="L3893">        hexPoint.translate(HEX_W, HEX_H);</span>
<span class="nc" id="L3894">        JScrollBar hscroll = scrollpane.getHorizontalScrollBar();</span>
<span class="nc" id="L3895">        hscroll.setValue(hexPoint.x-dispPoint.x+(int)(ihdx*scale*HEX_W));</span>
<span class="nc" id="L3896">        JScrollBar vscroll = scrollpane.getVerticalScrollBar();</span>
<span class="nc" id="L3897">        vscroll.setValue(hexPoint.y-dispPoint.y+(int)(ihdy*scale*HEX_H));</span>
<span class="nc" id="L3898">        pingMinimap();</span>
<span class="nc" id="L3899">        repaint();</span>
<span class="nc" id="L3900">    }</span>

    /**
     * Centers the board to a point
     * @param xrel the x position relative to board width.
     * @param yrel the y position relative to board height.
     * Both xrel and yrel should be between 0 and 1.
     * The method will clip both values to this range.
     */
    public void centerOnPointRel(double xrel, double yrel) {
        // restrict both values to between 0 and 1
<span class="nc" id="L3911">        xrel = Math.max(0,xrel);</span>
<span class="nc" id="L3912">        xrel = Math.min(1,xrel);</span>
<span class="nc" id="L3913">        yrel = Math.max(0,yrel);</span>
<span class="nc" id="L3914">        yrel = Math.min(1,yrel);</span>
<span class="nc" id="L3915">        Point p = new Point(</span>
<span class="nc" id="L3916">                (int)((double)boardSize.getWidth()*xrel)+HEX_W,</span>
<span class="nc" id="L3917">                (int)((double)boardSize.getHeight()*yrel)+HEX_H);</span>
<span class="nc" id="L3918">        JScrollBar vscroll = scrollpane.getVerticalScrollBar();</span>
<span class="nc" id="L3919">        vscroll.setValue(p.y - (vscroll.getVisibleAmount() / 2));</span>
<span class="nc" id="L3920">        JScrollBar hscroll = scrollpane.getHorizontalScrollBar();</span>
<span class="nc" id="L3921">        hscroll.setValue(p.x - (hscroll.getVisibleAmount() / 2));</span>
<span class="nc" id="L3922">        repaint();</span>
<span class="nc" id="L3923">    }</span>

    /**
     * Returns the currently visible area of the board.
     * @return an array of 4 double values indicating the relative size,
     * where the first two values indicate the x and y position of the upper left
     * corner of the visible area and the second two values the x and y position of
     * the lower right corner.
     * So when the whole board is visible, the values should be 0,0,1,1.
     * When the lower right corner of the board is visible
     * and 90% of width and height: 0.1,0.1,1,1
     * Due to board padding the values can be outside of [0;1]
     */
    public double[] getVisibleArea() {
<span class="nc" id="L3937">        double[] values = new double[4];</span>
<span class="nc" id="L3938">        double x = scrollpane.getViewport().getViewPosition().getX();</span>
<span class="nc" id="L3939">        double y = scrollpane.getViewport().getViewPosition().getY();</span>
<span class="nc" id="L3940">        double w = scrollpane.getViewport().getWidth();</span>
<span class="nc" id="L3941">        double h = scrollpane.getViewport().getHeight();</span>
<span class="nc" id="L3942">        double bw = boardSize.getWidth();</span>
<span class="nc" id="L3943">        double bh = boardSize.getHeight();</span>

<span class="nc" id="L3945">        values[0] = (x-HEX_W)/bw;</span>
<span class="nc" id="L3946">        values[1] = (y-HEX_H)/bh;</span>
<span class="nc" id="L3947">        values[2] = (x-HEX_W+w)/bw;</span>
<span class="nc" id="L3948">        values[3] = (y-HEX_H+h)/bh;</span>

<span class="nc" id="L3950">        return values;</span>
    }

    /**
     * Clears the old movement data and draws the new.
     */
    public void drawMovementData(Entity entity, MovePath md) {
<span class="nc" id="L3957">        MoveStep previousStep = null;</span>

<span class="nc" id="L3959">        clearMovementData();</span>

        // Nothing to do if we don't have a MovePath
<span class="nc bnc" id="L3962" title="All 2 branches missed.">        if (md == null) {</span>
<span class="nc" id="L3963">            movementTarget = null;</span>
<span class="nc" id="L3964">            return;</span>
        }
        // need to update the movement sprites based on the move path for this
        // entity
        // only way to do this is to clear and refresh (seems wasteful)

        // first get the color for the vector
<span class="nc" id="L3971">        Color col = Color.blue;</span>
<span class="nc bnc" id="L3972" title="All 2 branches missed.">        if (md.getLastStep() != null) {</span>
<span class="nc bnc" id="L3973" title="All 5 branches missed.">            switch (md.getLastStep().getMovementType(true)) {</span>
                case MOVE_RUN:
                case MOVE_VTOL_RUN:
                case MOVE_OVER_THRUST:
<span class="nc" id="L3977">                    col = GUIPreferences.getInstance().getColor(</span>
                            &quot;AdvancedMoveRunColor&quot;);
<span class="nc" id="L3979">                    break;</span>
                case MOVE_SPRINT:
                case MOVE_VTOL_SPRINT:
<span class="nc" id="L3982">                    col = GUIPreferences.getInstance().getColor(</span>
                            &quot;AdvancedMoveSprintColor&quot;);
<span class="nc" id="L3984">                    break;</span>
                case MOVE_JUMP:
<span class="nc" id="L3986">                    col = GUIPreferences.getInstance().getColor(</span>
                            &quot;AdvancedMoveJumpColor&quot;);
<span class="nc" id="L3988">                    break;</span>
                case MOVE_ILLEGAL:
<span class="nc" id="L3990">                    col = GUIPreferences.getInstance().getColor(</span>
                            &quot;AdvancedMoveIllegalColor&quot;);
<span class="nc" id="L3992">                    break;</span>
                default:
<span class="nc" id="L3994">                    col = GUIPreferences.getInstance().getColor(</span>
                            &quot;AdvancedMoveDefaultColor&quot;);
                    break;
            }
<span class="nc" id="L3998">            movementTarget = md.getLastStep().getPosition();</span>
        } else {
<span class="nc" id="L4000">            movementTarget = null;</span>
        }

<span class="nc" id="L4003">        refreshMoveVectors(entity, md, col);</span>

<span class="nc bnc" id="L4005" title="All 2 branches missed.">        for (Enumeration&lt;MoveStep&gt; i = md.getSteps(); i.hasMoreElements(); ) {</span>
<span class="nc" id="L4006">            final MoveStep step = i.nextElement();</span>
<span class="nc bnc" id="L4007" title="All 2 branches missed.">            if ((null != previousStep)</span>
<span class="nc bnc" id="L4008" title="All 2 branches missed.">                &amp;&amp; ((step.getType() == MoveStepType.UP)</span>
<span class="nc bnc" id="L4009" title="All 2 branches missed.">                    || (step.getType() == MoveStepType.DOWN)</span>
<span class="nc bnc" id="L4010" title="All 2 branches missed.">                    || (step.getType() == MoveStepType.ACC)</span>
<span class="nc bnc" id="L4011" title="All 2 branches missed.">                    || (step.getType() == MoveStepType.DEC)</span>
<span class="nc bnc" id="L4012" title="All 2 branches missed.">                    || (step.getType() == MoveStepType.ACCN)</span>
<span class="nc bnc" id="L4013" title="All 2 branches missed.">                    || (step.getType() == MoveStepType.DECN))) {</span>
                // Mark the previous elevation change sprite hidden
                // so that we can draw a new one in it's place without
                // having overlap.
<span class="nc" id="L4017">                pathSprites.get(pathSprites.size() - 1).setHidden(true);</span>
            }

<span class="nc bnc" id="L4020" title="All 2 branches missed.">            if (previousStep != null</span>
                    // for advanced movement, we always need to hide prior
                    // because costs will overlap and we only want the current
                    // facing
<span class="nc bnc" id="L4024" title="All 2 branches missed.">                    &amp;&amp; (game.useVectorMove()</span>
                            // A LAM converting from AirMech to Biped uses two convert steps and we
                            // only want to show the last.
<span class="nc bnc" id="L4027" title="All 2 branches missed.">                            || (step.getType() == MoveStepType.CONVERT_MODE</span>
<span class="nc bnc" id="L4028" title="All 2 branches missed.">                            &amp;&amp; previousStep.getType() == MoveStepType.CONVERT_MODE)</span>
<span class="nc bnc" id="L4029" title="All 2 branches missed.">                            || step.getType() == MoveStepType.BOOTLEGGER)) {</span>
<span class="nc" id="L4030">                pathSprites.get(pathSprites.size() - 1).setHidden(true);</span>
            }

<span class="nc" id="L4033">            pathSprites.add(new StepSprite(this, step, md.isEndStep(step)));</span>
<span class="nc" id="L4034">            previousStep = step;</span>
<span class="nc" id="L4035">        }</span>
<span class="nc" id="L4036">        repaint(100);</span>
<span class="nc" id="L4037">    }</span>

    /**
     * Clears current movement data from the screen
     */
    public void clearMovementData() {
<span class="nc" id="L4043">        pathSprites = new ArrayList&lt;StepSprite&gt;();</span>
<span class="nc" id="L4044">        movementTarget = null;</span>
<span class="nc" id="L4045">        checkFoVHexImageCacheClear();</span>
<span class="nc" id="L4046">        repaint();</span>
<span class="nc" id="L4047">        refreshMoveVectors();</span>
<span class="nc" id="L4048">    }</span>

    public void setFiringSolutions(Entity attacker,
            Map&lt;Integer, FiringSolution&gt; firingSolutions) {

<span class="nc" id="L4053">        clearFiringSolutionData();</span>
<span class="nc bnc" id="L4054" title="All 2 branches missed.">        if (firingSolutions == null) {</span>
<span class="nc" id="L4055">            return;</span>
        }
<span class="nc bnc" id="L4057" title="All 2 branches missed.">        for (FiringSolution sln : firingSolutions.values()) {</span>
<span class="nc" id="L4058">            FiringSolutionSprite sprite = new FiringSolutionSprite(this, sln);</span>
<span class="nc" id="L4059">            firingSprites.add(sprite);</span>
<span class="nc" id="L4060">        }</span>
<span class="nc" id="L4061">    }</span>

    public void clearFiringSolutionData() {
<span class="nc" id="L4064">        firingSprites.clear();</span>
<span class="nc" id="L4065">        repaint();</span>
<span class="nc" id="L4066">    }</span>

    public void addStrafingCoords(Coords c) {
<span class="nc" id="L4069">        strafingCoords.add(c);</span>
<span class="nc" id="L4070">    }</span>

    public void clearStrafingCoords() {
<span class="nc" id="L4073">        strafingCoords.clear();</span>
<span class="nc" id="L4074">    }</span>

    public void setMovementEnvelope(Map&lt;Coords, Integer&gt; mvEnvData, int walk,
            int run, int jump, int gear) {
<span class="nc" id="L4078">        clearMovementEnvelope();</span>

<span class="nc bnc" id="L4080" title="All 2 branches missed.">        if (mvEnvData == null) {</span>
<span class="nc" id="L4081">            return;</span>
        }

<span class="nc" id="L4084">        GUIPreferences guip = GUIPreferences.getInstance();</span>
<span class="nc bnc" id="L4085" title="All 2 branches missed.">        for (Coords loc : mvEnvData.keySet()) {</span>
<span class="nc" id="L4086">            Color spriteColor = null;</span>
<span class="nc" id="L4087">            int mvType = -1;</span>
<span class="nc bnc" id="L4088" title="All 4 branches missed.">            if (gear == MovementDisplay.GEAR_JUMP || gear == MovementDisplay.GEAR_DFA) {</span>
<span class="nc bnc" id="L4089" title="All 2 branches missed.">                if (mvEnvData.get(loc) &lt;= jump) {</span>
<span class="nc" id="L4090">                    spriteColor = guip</span>
<span class="nc" id="L4091">                            .getColor(GUIPreferences.ADVANCED_MOVE_JUMP_COLOR);</span>
<span class="nc" id="L4092">                    mvType = 1;</span>
                }
            } else {
<span class="nc bnc" id="L4095" title="All 2 branches missed.">                if (mvEnvData.get(loc) &lt;= walk) {</span>
<span class="nc" id="L4096">                    spriteColor = guip</span>
<span class="nc" id="L4097">                            .getColor(GUIPreferences.ADVANCED_MOVE_DEFAULT_COLOR);</span>
<span class="nc" id="L4098">                    mvType = 2;</span>

<span class="nc bnc" id="L4100" title="All 2 branches missed.">                } else if (mvEnvData.get(loc) &lt;= run) {</span>
<span class="nc" id="L4101">                    spriteColor = guip</span>
<span class="nc" id="L4102">                            .getColor(GUIPreferences.ADVANCED_MOVE_RUN_COLOR);</span>
<span class="nc" id="L4103">                    mvType = 3;</span>
                } else {
<span class="nc" id="L4105">                    spriteColor = guip</span>
<span class="nc" id="L4106">                            .getColor(GUIPreferences.ADVANCED_MOVE_SPRINT_COLOR);</span>
<span class="nc" id="L4107">                    mvType = 4;</span>
                }
            }

            // Next: check the adjacent hexes and find
            // those with the same movement type,
            // send this to the Sprite so it paints only
            // the borders of the movement type areas
            int mvAdjType;
<span class="nc" id="L4116">            int edgesToPaint = 0;</span>
            // cycle through hexes
<span class="nc bnc" id="L4118" title="All 2 branches missed.">            for (int dir = 0; dir &lt; 6; dir++) {</span>
<span class="nc" id="L4119">                mvAdjType = 0;</span>
<span class="nc" id="L4120">                Coords adjacentHex = loc.translated(dir);</span>
                // get the movement type
<span class="nc" id="L4122">                Integer Adjmv = mvEnvData.get(adjacentHex);</span>
<span class="nc bnc" id="L4123" title="All 2 branches missed.">                if (Adjmv != null) {</span>
<span class="nc bnc" id="L4124" title="All 2 branches missed.">                    if (gear == MovementDisplay.GEAR_JUMP) {</span>
<span class="nc bnc" id="L4125" title="All 2 branches missed.">                        if (Adjmv &lt;= jump) mvAdjType = 1;</span>
                    } else {
<span class="nc bnc" id="L4127" title="All 2 branches missed.">                        if (Adjmv &lt;= walk) mvAdjType = 2;</span>
<span class="nc bnc" id="L4128" title="All 2 branches missed.">                        else if (Adjmv &lt;= run) mvAdjType = 3;</span>
<span class="nc" id="L4129">                        else mvAdjType = 4;</span>
                    }
                }
                // other movement type: paint a border in this direction
<span class="nc bnc" id="L4133" title="All 2 branches missed.">                if (mvAdjType != mvType) edgesToPaint += (1 &lt;&lt; dir);</span>
            }

<span class="nc bnc" id="L4136" title="All 2 branches missed.">            if (spriteColor != null) {</span>
<span class="nc" id="L4137">                MovementEnvelopeSprite mvSprite = new MovementEnvelopeSprite(</span>
                        this, spriteColor, loc, edgesToPaint);
<span class="nc" id="L4139">                moveEnvSprites.add(mvSprite);</span>
            }
<span class="nc" id="L4141">        }</span>

<span class="nc" id="L4143">        repaint();</span>

<span class="nc" id="L4145">    }</span>

    public void setMovementModifierEnvelope(Collection&lt;MovePath&gt; movePaths) {
<span class="nc" id="L4148">        moveModEnvSprites.clear();</span>
<span class="nc bnc" id="L4149" title="All 2 branches missed.">        for (MovePath mp : movePaths) {</span>
<span class="nc" id="L4150">            moveModEnvSprites.add(new MovementModifierEnvelopeSprite(this, mp));</span>
<span class="nc" id="L4151">        }</span>
<span class="nc" id="L4152">        repaint();</span>
<span class="nc" id="L4153">    }</span>

    public void clearMovementEnvelope() {
<span class="nc" id="L4156">        moveEnvSprites.clear();</span>
<span class="nc" id="L4157">        moveModEnvSprites.clear();</span>
<span class="nc" id="L4158">        repaint();</span>
<span class="nc" id="L4159">    }</span>

    /**
     * Draws the given &lt;code&gt;text&lt;/code&gt; in the currently active font of the Graphics &lt;code&gt;g2D&lt;/code&gt;
     * at font size &lt;code&gt;fontSize&lt;/code&gt;. The text is centered in both
     * x and y directions around the position &lt;code&gt;pos&lt;/code&gt;. The text is colored with
     * the given &lt;code&gt;color&lt;/code&gt;, made translucent if the flag is set. The outline of the text
     * will be dark gray.
     * @param g2D the graphics to draw to, as &lt;code&gt;Graphics2D&lt;/code&gt;
     * @param text the string to write
     * @param pos the board pixel position
     * @param fontSize the font size. This will be scaled by the current board zoom
     * @param color the color to draw the text in
     * @param translucent (optional)  makes the text translucent if set to true. Defaults to false
     * @param cOutline (optional) the color of the outline. Defaults to Color.DARK_GRAY
     */
    public void drawOutlineText(Graphics2D g2D, String text, Point pos,
            float fontSize, Color color, boolean translucent, Color cOutline) {
<span class="nc" id="L4177">        g2D.setFont(g2D.getFont().deriveFont(fontSize));</span>
<span class="nc" id="L4178">        FontMetrics fm = g2D.getFontMetrics(g2D.getFont());</span>
        // Center the text around pos
<span class="nc" id="L4180">        int cx = pos.x - (fm.stringWidth(text) / 2);</span>
<span class="nc" id="L4181">        int cy = pos.y + (fm.getAscent() - fm.getDescent()) / 2;</span>

        // get text shape and position it
<span class="nc" id="L4184">        GlyphVector gv = g2D.getFont().createGlyphVector(g2D.getFontRenderContext(), text);</span>
<span class="nc" id="L4185">        Shape shape = gv.getOutline();</span>
<span class="nc" id="L4186">        shape = AffineTransform.getTranslateInstance(cx,cy).</span>
<span class="nc" id="L4187">                createTransformedShape(shape);</span>

        // text area fill
<span class="nc bnc" id="L4190" title="All 2 branches missed.">        if (translucent)</span>
<span class="nc" id="L4191">            color = new Color(color.getRGB() &amp; 0x00FFFFFF | 0xA0000000, true);</span>
<span class="nc" id="L4192">        g2D.setColor(color);</span>
<span class="nc" id="L4193">        g2D.fill(shape);</span>

        // outline
<span class="nc" id="L4196">        g2D.setStroke(new BasicStroke(0.5f));</span>
<span class="nc" id="L4197">        Color lineColor = cOutline;</span>
<span class="nc bnc" id="L4198" title="All 2 branches missed.">        if (translucent)</span>
<span class="nc" id="L4199">            lineColor = new Color(lineColor.getRGB() &amp; 0x00FFFFFF | 0xA0000000, true);</span>
<span class="nc" id="L4200">        g2D.setColor(lineColor);</span>
<span class="nc" id="L4201">        g2D.draw(shape);</span>
<span class="nc" id="L4202">    }</span>

    public void drawOutlineText(Graphics2D g2D, String text, Point pos,
            float fontSize, Color color, boolean translucent) {
<span class="nc" id="L4206">        drawOutlineText(g2D, text, pos, fontSize, color, translucent, Color.DARK_GRAY);</span>
<span class="nc" id="L4207">    }</span>

    public void drawOutlineText(Graphics2D g2D, String text, Point pos,
            float fontSize, Color color) {
<span class="nc" id="L4211">        drawOutlineText(g2D, text, pos, fontSize, color, false, Color.DARK_GRAY);</span>
<span class="nc" id="L4212">    }</span>

    public void drawTextShadow(Graphics2D g2D, String text, Point pos,
            Font font) {
<span class="nc" id="L4216">        g2D.setFont(font);</span>
        // to keep the shadow always 1 px wide,
        // counteract the current graph scaling
<span class="nc" id="L4219">        double scX = g2D.getTransform().getScaleX();</span>
<span class="nc" id="L4220">        double scY = g2D.getTransform().getScaleY();</span>

<span class="nc" id="L4222">        drawCenteredText(g2D, text, (float)pos.x+(1.0f)/(float)scX,(float)pos.y, Color.BLACK, false);</span>
<span class="nc" id="L4223">        drawCenteredText(g2D, text, (float)pos.x-(1.0f)/(float)scX,(float)pos.y, Color.BLACK, false);</span>
<span class="nc" id="L4224">        drawCenteredText(g2D, text, (float)pos.x,(float)pos.y+(1.0f)/(float)scY, Color.BLACK, false);</span>
<span class="nc" id="L4225">        drawCenteredText(g2D, text, (float)pos.x,(float)pos.y-(1.0f)/(float)scY, Color.BLACK, false);</span>
<span class="nc" id="L4226">    }</span>

    public void drawCenteredText(Graphics2D g2D, String text, Point pos,
            Color color, boolean translucent) {
<span class="nc" id="L4230">        FontMetrics fm = g2D.getFontMetrics(g2D.getFont());</span>
        // Center the text around pos
<span class="nc" id="L4232">        int cx = pos.x - (fm.stringWidth(text) / 2);</span>
<span class="nc" id="L4233">        int cy = pos.y - fm.getAscent()/2-fm.getDescent() / 2+fm.getAscent();</span>

<span class="nc bnc" id="L4235" title="All 2 branches missed.">        if (translucent)</span>
<span class="nc" id="L4236">            color = new Color(color.getRGB() &amp; 0x00FFFFFF | 0xA0000000, true);</span>
<span class="nc" id="L4237">        g2D.setColor(color);</span>
<span class="nc" id="L4238">        g2D.drawString(text, cx, cy);</span>
<span class="nc" id="L4239">    }</span>

    // This method is used to draw text shadows even when the g2D is scaled
    public void drawCenteredText(Graphics2D g2D, String text, float posx, float posy,
            Color color, boolean translucent) {
<span class="nc" id="L4244">        FontMetrics fm = g2D.getFontMetrics(g2D.getFont());</span>
        // Center the text around pos
<span class="nc" id="L4246">        float cx = posx - (fm.stringWidth(text) / 2);</span>
<span class="nc" id="L4247">        float cy = posy - fm.getAscent()/2-fm.getDescent() / 2+fm.getAscent();</span>

<span class="nc bnc" id="L4249" title="All 2 branches missed.">        if (translucent)</span>
<span class="nc" id="L4250">            color = new Color(color.getRGB() &amp; 0x00FFFFFF | 0xA0000000, true);</span>
<span class="nc" id="L4251">        g2D.setColor(color);</span>
<span class="nc" id="L4252">        g2D.drawString(text, cx, cy);</span>
<span class="nc" id="L4253">    }</span>

    public void drawCenteredText(Graphics2D g2D, String text, Point pos,
            Color color, boolean translucent, Font font) {
<span class="nc" id="L4257">        g2D.setFont(font);</span>
<span class="nc" id="L4258">        drawCenteredText(g2D, text, pos, color, translucent);</span>
<span class="nc" id="L4259">    }</span>

    public void drawCenteredText(Graphics2D g2D, String text, Point pos,
            Color color, boolean translucent, int fontSize) {
<span class="nc" id="L4263">        g2D.setFont(g2D.getFont().deriveFont(fontSize));</span>
<span class="nc" id="L4264">        drawCenteredText(g2D, text, pos, color, translucent);</span>
<span class="nc" id="L4265">    }</span>

    public void setLocalPlayer(IPlayer p) {
<span class="nc" id="L4268">        localPlayer = p;</span>
<span class="nc" id="L4269">    }</span>

    public IPlayer getLocalPlayer() {
<span class="nc" id="L4272">        return localPlayer;</span>
    }

    /**
     * Specifies that this should mark the deployment hexes for a player. If the
     * player is set to null, no hexes will be marked.
     */
    public void markDeploymentHexesFor(Entity ce) {
<span class="nc" id="L4280">        en_Deployer = ce;</span>
<span class="nc" id="L4281">        repaint(100);</span>
<span class="nc" id="L4282">    }</span>

    /**
     * Returns the entity that is currently being deployed
     */
    public Entity getDeployingEntity() {
<span class="nc" id="L4288">        return en_Deployer;</span>
    }

    /**
     * add a fly over path to the sprite list
     */
    public void addFlyOverPath(Entity e) {
<span class="nc bnc" id="L4295" title="All 2 branches missed.">        if (e.getPosition() == null) {</span>
<span class="nc" id="L4296">            return;</span>
        }

<span class="nc bnc" id="L4299" title="All 2 branches missed.">        if (e.isMakingVTOLGroundAttack()) {</span>
<span class="nc" id="L4300">            vtolAttackSprites.add(new VTOLAttackSprite(this, e));</span>
        }
<span class="nc" id="L4302">        flyOverSprites.add(new FlyOverSprite(this, e));</span>
<span class="nc" id="L4303">    }</span>

    public List&lt;Entity&gt; getEntitiesFlyingOver(Coords c) {
<span class="nc" id="L4306">        List&lt;Entity&gt; entities = new ArrayList&lt;Entity&gt;();</span>
<span class="nc bnc" id="L4307" title="All 2 branches missed.">        for (FlyOverSprite fsprite : flyOverSprites) {</span>
            //Spaceborne units shouldn't count here. They show up incorrectly in the firing display when sensors are in use.
<span class="nc bnc" id="L4309" title="All 4 branches missed.">            if (fsprite.getEntity().getPassedThrough().contains(c) &amp;&amp; !fsprite.getEntity().isSpaceborne()) {</span>
<span class="nc" id="L4310">                entities.add(fsprite.getEntity());</span>
            }
<span class="nc" id="L4312">        }</span>
<span class="nc" id="L4313">        return entities;</span>
    }

    /**
     * Adds a c3 line to the sprite list.
     */
    public void addC3Link(Entity e) {
<span class="nc bnc" id="L4320" title="All 2 branches missed.">        if (e.getPosition() == null) {</span>
<span class="nc" id="L4321">            return;</span>
        }

<span class="nc bnc" id="L4324" title="All 2 branches missed.">        if (e.hasC3i()) {</span>
<span class="nc bnc" id="L4325" title="All 2 branches missed.">            for (Entity fe : game.getEntitiesVector()) {</span>
<span class="nc bnc" id="L4326" title="All 2 branches missed.">                if (fe.getPosition() == null) {</span>
<span class="nc" id="L4327">                    return;</span>
                }
<span class="nc bnc" id="L4329" title="All 2 branches missed.">                if (e.onSameC3NetworkAs(fe)</span>
<span class="nc bnc" id="L4330" title="All 2 branches missed.">                        &amp;&amp; !fe.equals(e)</span>
<span class="nc bnc" id="L4331" title="All 2 branches missed.">                        &amp;&amp; !ComputeECM.isAffectedByECM(e, e.getPosition(),</span>
<span class="nc" id="L4332">                                fe.getPosition())) {</span>
<span class="nc" id="L4333">                    c3Sprites.add(new C3Sprite(this, e, fe));</span>
                }
<span class="nc" id="L4335">            }</span>
<span class="nc bnc" id="L4336" title="All 2 branches missed.">        } else if (e.hasNavalC3()) {</span>
<span class="nc bnc" id="L4337" title="All 2 branches missed.">            for (Entity fe : game.getEntitiesVector()) {</span>
<span class="nc bnc" id="L4338" title="All 2 branches missed.">                if (fe.getPosition() == null) {</span>
<span class="nc" id="L4339">                    return;</span>
                }
<span class="nc bnc" id="L4341" title="All 4 branches missed.">                if (e.onSameC3NetworkAs(fe) &amp;&amp; !fe.equals(e)) {</span>
<span class="nc" id="L4342">                    c3Sprites.add(new C3Sprite(this, e, fe));</span>
                }
<span class="nc" id="L4344">            }</span>
<span class="nc bnc" id="L4345" title="All 2 branches missed.">        } else if (e.hasActiveNovaCEWS()) {</span>
            // WOR Nova CEWS
<span class="nc bnc" id="L4347" title="All 2 branches missed.">            for (Entity fe : game.getEntitiesVector()) {</span>
<span class="nc bnc" id="L4348" title="All 2 branches missed.">                if (fe.getPosition() == null) {</span>
<span class="nc" id="L4349">                    return;</span>
                }
<span class="nc" id="L4351">                ECMInfo ecmInfo = ComputeECM.getECMEffects(e, e.getPosition(),</span>
<span class="nc" id="L4352">                        fe.getPosition(), true, null);</span>
<span class="nc bnc" id="L4353" title="All 2 branches missed.">                if (e.onSameC3NetworkAs(fe)</span>
<span class="nc bnc" id="L4354" title="All 4 branches missed.">                    &amp;&amp; !fe.equals(e)</span>
                    &amp;&amp; (ecmInfo != null)
<span class="nc bnc" id="L4356" title="All 2 branches missed.">                    &amp;&amp; !ecmInfo.isNovaECM()) {</span>
<span class="nc" id="L4357">                    c3Sprites.add(new C3Sprite(this, e, fe));</span>
                }
<span class="nc" id="L4359">            }</span>
<span class="nc bnc" id="L4360" title="All 2 branches missed.">        } else if (e.getC3Master() != null) {</span>
<span class="nc" id="L4361">            Entity eMaster = e.getC3Master();</span>
<span class="nc bnc" id="L4362" title="All 2 branches missed.">            if (eMaster.getPosition() == null) {</span>
<span class="nc" id="L4363">                return;</span>
            }

            // ECM cuts off the network
<span class="nc" id="L4367">            boolean blocked = false;</span>
<span class="nc bnc" id="L4368" title="All 4 branches missed.">            if (e.hasBoostedC3() &amp;&amp; eMaster.hasBoostedC3()) {</span>
<span class="nc bnc" id="L4369" title="All 2 branches missed.">                blocked = ComputeECM.isAffectedByAngelECM(e, e.getPosition(),</span>
<span class="nc" id="L4370">                        eMaster.getPosition())</span>
<span class="nc bnc" id="L4371" title="All 2 branches missed.">                        || ComputeECM.isAffectedByAngelECM(eMaster,</span>
<span class="nc" id="L4372">                                eMaster.getPosition(), eMaster.getPosition());</span>
            } else {
<span class="nc bnc" id="L4374" title="All 2 branches missed.">                blocked = ComputeECM.isAffectedByECM(e, e.getPosition(),</span>
<span class="nc" id="L4375">                        eMaster.getPosition())</span>
<span class="nc bnc" id="L4376" title="All 2 branches missed.">                        || ComputeECM.isAffectedByECM(eMaster,</span>
<span class="nc" id="L4377">                                eMaster.getPosition(), eMaster.getPosition());</span>
            }

<span class="nc bnc" id="L4380" title="All 2 branches missed.">            if (!blocked) {</span>
<span class="nc" id="L4381">                c3Sprites.add(new C3Sprite(this, e, e.getC3Master()));</span>
            }
        }
<span class="nc" id="L4384">    }</span>

    /**
     * Adds an attack to the sprite list.
     */
    public synchronized void addAttack(AttackAction aa) {
        // Don't make sprites for unknown entities and sensor returns
<span class="nc" id="L4391">        Entity ae = game.getEntity(aa.getEntityId());</span>
<span class="nc" id="L4392">        Targetable t = game.getTarget(aa.getTargetType(), aa.getTargetId());</span>
<span class="nc bnc" id="L4393" title="All 4 branches missed.">        if ((ae == null) || (t == null)</span>
<span class="nc bnc" id="L4394" title="All 2 branches missed.">            || (t.getTargetType() == Targetable.TYPE_INARC_POD)</span>
<span class="nc bnc" id="L4395" title="All 4 branches missed.">            || (t.getPosition() == null) || (ae.getPosition() == null)) {</span>
<span class="nc" id="L4396">            return;</span>
        }
<span class="nc" id="L4398">        EntitySprite eSprite = entitySpriteIds.get(getIdAndLoc(ae.getId(),</span>
<span class="nc bnc" id="L4399" title="All 2 branches missed.">                ae.getSecondaryPositions().size() &gt; 0 ? 0 : -1));</span>
<span class="nc bnc" id="L4400" title="All 4 branches missed.">        if (eSprite != null &amp;&amp; eSprite.onlyDetectedBySensors()) {</span>
<span class="nc" id="L4401">            return;</span>
        }

<span class="nc" id="L4404">        repaint(100);</span>
<span class="nc bnc" id="L4405" title="All 2 branches missed.">        for (AttackSprite sprite : attackSprites) {</span>
            // can we just add this attack to an existing one?
<span class="nc bnc" id="L4407" title="All 2 branches missed.">            if ((sprite.getEntityId() == aa.getEntityId())</span>
<span class="nc bnc" id="L4408" title="All 2 branches missed.">                &amp;&amp; (sprite.getTargetId() == aa.getTargetId())) {</span>
                // use existing attack, but add this weapon
<span class="nc bnc" id="L4410" title="All 2 branches missed.">                if (aa instanceof WeaponAttackAction) {</span>
<span class="nc" id="L4411">                    WeaponAttackAction waa = (WeaponAttackAction) aa;</span>
<span class="nc bnc" id="L4412" title="All 2 branches missed.">                    if (aa.getTargetType() != Targetable.TYPE_HEX_ARTILLERY) {</span>
<span class="nc" id="L4413">                        sprite.addWeapon(waa);</span>
<span class="nc" id="L4414">                    } else if (waa.getEntity(game).getOwner().getId() == localPlayer</span>
<span class="nc bnc" id="L4415" title="All 2 branches missed.">                            .getId()) {</span>
<span class="nc" id="L4416">                        sprite.addWeapon(waa);</span>
                    }
                }
<span class="nc bnc" id="L4419" title="All 2 branches missed.">                if (aa instanceof KickAttackAction) {</span>
<span class="nc" id="L4420">                    sprite.addWeapon((KickAttackAction) aa);</span>
                }
<span class="nc bnc" id="L4422" title="All 2 branches missed.">                if (aa instanceof PunchAttackAction) {</span>
<span class="nc" id="L4423">                    sprite.addWeapon((PunchAttackAction) aa);</span>
                }
<span class="nc bnc" id="L4425" title="All 2 branches missed.">                if (aa instanceof PushAttackAction) {</span>
<span class="nc" id="L4426">                    sprite.addWeapon((PushAttackAction) aa);</span>
                }
<span class="nc bnc" id="L4428" title="All 2 branches missed.">                if (aa instanceof ClubAttackAction) {</span>
<span class="nc" id="L4429">                    sprite.addWeapon((ClubAttackAction) aa);</span>
                }
<span class="nc bnc" id="L4431" title="All 2 branches missed.">                if (aa instanceof ChargeAttackAction) {</span>
<span class="nc" id="L4432">                    sprite.addWeapon((ChargeAttackAction) aa);</span>
                }
<span class="nc bnc" id="L4434" title="All 2 branches missed.">                if (aa instanceof DfaAttackAction) {</span>
<span class="nc" id="L4435">                    sprite.addWeapon((DfaAttackAction) aa);</span>
                }
<span class="nc bnc" id="L4437" title="All 2 branches missed.">                if (aa instanceof ProtomechPhysicalAttackAction) {</span>
<span class="nc" id="L4438">                    sprite.addWeapon((ProtomechPhysicalAttackAction) aa);</span>
                }
<span class="nc bnc" id="L4440" title="All 2 branches missed.">                if (aa instanceof SearchlightAttackAction) {</span>
<span class="nc" id="L4441">                    sprite.addWeapon((SearchlightAttackAction) aa);</span>
                }
<span class="nc" id="L4443">                return;</span>
            }
<span class="nc" id="L4445">        }</span>
        // no re-use possible, add a new one
        // don't add a sprite for an artillery attack made by the other player
<span class="nc bnc" id="L4448" title="All 2 branches missed.">        if (aa instanceof WeaponAttackAction) {</span>
<span class="nc" id="L4449">            WeaponAttackAction waa = (WeaponAttackAction) aa;</span>
<span class="nc bnc" id="L4450" title="All 2 branches missed.">            if (aa.getTargetType() != Targetable.TYPE_HEX_ARTILLERY) {</span>
<span class="nc" id="L4451">                attackSprites.add(new AttackSprite(this, aa));</span>
<span class="nc" id="L4452">            } else if (waa.getEntity(game).getOwner().getId() == localPlayer</span>
<span class="nc bnc" id="L4453" title="All 2 branches missed.">                    .getId()) {</span>
<span class="nc" id="L4454">                attackSprites.add(new AttackSprite(this, aa));</span>
            }
<span class="nc" id="L4456">        } else {</span>
<span class="nc" id="L4457">            attackSprites.add(new AttackSprite(this, aa));</span>
        }
<span class="nc" id="L4459">    }</span>

    /**
     * Removes all attack sprites from a certain entity
     */
    public synchronized void removeAttacksFor(Entity e) {
<span class="nc bnc" id="L4465" title="All 2 branches missed.">        if (e == null) {</span>
<span class="nc" id="L4466">            return;</span>
        }
<span class="nc" id="L4468">        int entityId = e.getId();</span>
<span class="nc bnc" id="L4469" title="All 2 branches missed.">        for (Iterator&lt;AttackSprite&gt; i = attackSprites.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L4470">            AttackSprite sprite = i.next();</span>
<span class="nc bnc" id="L4471" title="All 2 branches missed.">            if (sprite.getEntityId() == entityId) {</span>
<span class="nc" id="L4472">                i.remove();</span>
            }
<span class="nc" id="L4474">        }</span>
<span class="nc" id="L4475">        repaint(100);</span>
<span class="nc" id="L4476">    }</span>

    /**
     * Clears out all attacks and re-adds the ones in the current game.
     */
    public void refreshAttacks() {
<span class="nc" id="L4482">        clearAllAttacks();</span>
<span class="nc" id="L4483">        for (Enumeration&lt;EntityAction&gt; i = game.getActions(); i</span>
<span class="nc bnc" id="L4484" title="All 2 branches missed.">                .hasMoreElements(); ) {</span>
<span class="nc" id="L4485">            EntityAction ea = i.nextElement();</span>
<span class="nc bnc" id="L4486" title="All 2 branches missed.">            if (ea instanceof AttackAction) {</span>
<span class="nc" id="L4487">                addAttack((AttackAction) ea);</span>
            }
<span class="nc" id="L4489">        }</span>
<span class="nc" id="L4490">        for (Enumeration&lt;AttackAction&gt; i = game.getCharges(); i</span>
<span class="nc bnc" id="L4491" title="All 2 branches missed.">                .hasMoreElements(); ) {</span>
<span class="nc" id="L4492">            EntityAction ea = i.nextElement();</span>
<span class="nc bnc" id="L4493" title="All 2 branches missed.">            if (ea instanceof PhysicalAttackAction) {</span>
<span class="nc" id="L4494">                addAttack((AttackAction) ea);</span>
            }
<span class="nc" id="L4496">        }</span>
<span class="nc" id="L4497">        repaint(100);</span>
<span class="nc" id="L4498">    }</span>

    public void refreshMoveVectors() {
<span class="nc" id="L4501">        clearAllMoveVectors();</span>
<span class="nc bnc" id="L4502" title="All 2 branches missed.">        for (Entity e : game.getEntitiesVector()) {</span>
<span class="nc bnc" id="L4503" title="All 2 branches missed.">            if (e.getPosition() != null) {</span>
<span class="nc" id="L4504">                movementSprites.add(new MovementSprite(this, e, e.getVectors(),</span>
                                                       Color.gray, false));
            }
<span class="nc" id="L4507">        }</span>
<span class="nc" id="L4508">    }</span>

    public void refreshMoveVectors(Entity en, MovePath md, Color col) {
<span class="nc" id="L4511">        clearAllMoveVectors();</span>
        // same as normal but when I find the active entity I used the MovePath
        // to get vector
<span class="nc bnc" id="L4514" title="All 2 branches missed.">        for (Entity e : game.getEntitiesVector()) {</span>
<span class="nc bnc" id="L4515" title="All 2 branches missed.">            if (e.getPosition() != null) {</span>
<span class="nc bnc" id="L4516" title="All 4 branches missed.">                if ((en != null) &amp;&amp; (e.getId() == en.getId())) {</span>
<span class="nc" id="L4517">                    movementSprites.add(new MovementSprite(this, e, md</span>
<span class="nc" id="L4518">                            .getFinalVectors(), col, true));</span>
                } else {
<span class="nc" id="L4520">                    movementSprites.add(new MovementSprite(this, e, e.getVectors(),</span>
                                                           col, false));
                }
            }
<span class="nc" id="L4524">        }</span>
<span class="nc" id="L4525">    }</span>

    public void clearC3Networks() {
<span class="nc" id="L4528">        c3Sprites.clear();</span>
<span class="nc" id="L4529">    }</span>

    public void clearFlyOverPaths() {
<span class="nc" id="L4532">        vtolAttackSprites.clear();</span>
<span class="nc" id="L4533">        flyOverSprites.clear();</span>
<span class="nc" id="L4534">    }</span>

    /**
     * Clears out all attacks that were being drawn
     */
    public void clearAllAttacks() {
<span class="nc" id="L4540">        attackSprites.clear();</span>
<span class="nc" id="L4541">    }</span>

    /**
     * Clears out all movement vectors that were being drawn
     */
    public void clearAllMoveVectors() {
<span class="nc" id="L4547">        movementSprites.clear();</span>
<span class="nc" id="L4548">    }</span>

    protected void firstLOSHex(Coords c) {
<span class="nc bnc" id="L4551" title="All 2 branches missed.">        if (useLOSTool) {</span>
<span class="nc" id="L4552">            moveCursor(secondLOSSprite, null);</span>
<span class="nc" id="L4553">            moveCursor(firstLOSSprite, c);</span>
        }
<span class="nc" id="L4555">    }</span>

    protected void secondLOSHex(Coords c2, Coords c1) {
<span class="nc bnc" id="L4558" title="All 2 branches missed.">        if (useLOSTool) {</span>

<span class="nc" id="L4560">            Entity ae = chooseEntity(c1);</span>
<span class="nc" id="L4561">            Entity te = chooseEntity(c2);</span>

<span class="nc" id="L4563">            StringBuffer message = new StringBuffer();</span>
            LosEffects le;
<span class="nc bnc" id="L4565" title="All 4 branches missed.">            if ((ae == null) || (te == null)) {</span>
<span class="nc" id="L4566">                boolean mechInFirst = GUIPreferences.getInstance()</span>
<span class="nc" id="L4567">                                                    .getMechInFirst();</span>
<span class="nc" id="L4568">                boolean mechInSecond = GUIPreferences.getInstance()</span>
<span class="nc" id="L4569">                                                     .getMechInSecond();</span>
<span class="nc" id="L4570">                LosEffects.AttackInfo ai = new LosEffects.AttackInfo();</span>
<span class="nc" id="L4571">                ai.attackPos = c1;</span>
<span class="nc" id="L4572">                ai.targetPos = c2;</span>
<span class="nc bnc" id="L4573" title="All 2 branches missed.">                ai.attackHeight = mechInFirst ? 1 : 0;</span>
<span class="nc bnc" id="L4574" title="All 2 branches missed.">                ai.targetHeight = mechInSecond ? 1 : 0;</span>
<span class="nc" id="L4575">                ai.targetIsMech = mechInSecond;</span>
<span class="nc" id="L4576">                ai.attackerIsMech = mechInFirst;</span>
<span class="nc" id="L4577">                ai.attackAbsHeight = game.getBoard().getHex(c1).floor()</span>
                                     + ai.attackHeight;
<span class="nc" id="L4579">                ai.targetAbsHeight = game.getBoard().getHex(c2).floor()</span>
                                     + ai.targetHeight;
<span class="nc" id="L4581">                le = LosEffects.calculateLos(game, ai);</span>
<span class="nc" id="L4582">                message.append(Messages</span>
<span class="nc" id="L4583">                                       .getString(</span>
                                               &quot;BoardView1.Attacker&quot;, new Object[]{ //$NON-NLS-1$
<span class="nc bnc" id="L4585" title="All 2 branches missed.">                                                                                    mechInFirst ? Messages</span>
<span class="nc" id="L4586">                                                                                            .getString(&quot;BoardView1.Mech&quot;) : Messages.getString(&quot;BoardView1.NonMech&quot;), //$NON-NLS-1$ //$NON-NLS-2$</span>
<span class="nc" id="L4587">                                                                                    c1.getBoardNum()}));</span>
<span class="nc" id="L4588">                message.append(Messages</span>
<span class="nc" id="L4589">                                       .getString(</span>
                                               &quot;BoardView1.Target&quot;, new Object[]{ //$NON-NLS-1$
<span class="nc bnc" id="L4591" title="All 2 branches missed.">                                                                                  mechInSecond ? Messages</span>
<span class="nc" id="L4592">                                                                                          .getString(&quot;BoardView1.Mech&quot;) : Messages.getString(&quot;BoardView1.NonMech&quot;), //$NON-NLS-1$ //$NON-NLS-2$</span>
<span class="nc" id="L4593">                                                                                  c2.getBoardNum()}));</span>
<span class="nc" id="L4594">            } else {</span>
<span class="nc" id="L4595">                le = LosEffects.calculateLos(game, ae.getId(), te);</span>
<span class="nc" id="L4596">                message.append(Messages.getString(</span>
                        &quot;BoardView1.Attacker&quot;, new Object[]{ //$NON-NLS-1$
<span class="nc" id="L4598">                                                             ae.getDisplayName(), c1.getBoardNum()}));</span>
<span class="nc" id="L4599">                message.append(Messages.getString(</span>
                        &quot;BoardView1.Target&quot;, new Object[]{ //$NON-NLS-1$
<span class="nc" id="L4601">                                                           te.getDisplayName(), c2.getBoardNum()}));</span>
            }
            // Check to see if LoS is blocked
<span class="nc bnc" id="L4604" title="All 2 branches missed.">            if (!le.canSee()) {</span>
<span class="nc" id="L4605">                message.append(Messages.getString(&quot;BoardView1.LOSBlocked&quot;,</span>
                                                  new Object[]{ //$NON-NLS-1$
<span class="nc" id="L4607">                                                                Integer.valueOf(c1.distance(c2))}));</span>
<span class="nc" id="L4608">                ToHitData thd = le.losModifiers(game);</span>
<span class="nc" id="L4609">                message.append(&quot;\t&quot; + thd.getDesc() + &quot;\n&quot;);</span>
<span class="nc" id="L4610">            } else {</span>
<span class="nc" id="L4611">                message.append(Messages.getString(&quot;BoardView1.LOSNotBlocked&quot;,</span>
                                                  new Object[]{ //$NON-NLS-1$
<span class="nc" id="L4613">                                                                Integer.valueOf(c1.distance(c2))}));</span>
<span class="nc bnc" id="L4614" title="All 2 branches missed.">                if (le.getHeavyWoods() &gt; 0) {</span>
<span class="nc" id="L4615">                    message.append(Messages.getString(</span>
                            &quot;BoardView1.HeavyWoods&quot;, new Object[]{ //$NON-NLS-1$
<span class="nc" id="L4617">                                                                   Integer.valueOf(le.getHeavyWoods())}));</span>
                }
<span class="nc bnc" id="L4619" title="All 2 branches missed.">                if (le.getLightWoods() &gt; 0) {</span>
<span class="nc" id="L4620">                    message.append(Messages.getString(</span>
                            &quot;BoardView1.LightWoods&quot;, new Object[]{ //$NON-NLS-1$
<span class="nc" id="L4622">                                                                   Integer.valueOf(le.getLightWoods())}));</span>
                }
<span class="nc bnc" id="L4624" title="All 2 branches missed.">                if (le.getLightSmoke() &gt; 0) {</span>
<span class="nc" id="L4625">                    message.append(Messages.getString(</span>
                            &quot;BoardView1.LightSmoke&quot;, new Object[]{ //$NON-NLS-1$
<span class="nc" id="L4627">                                                                   Integer.valueOf(le.getLightSmoke())}));</span>
                }
<span class="nc bnc" id="L4629" title="All 2 branches missed.">                if (le.getHeavySmoke() &gt; 0) {</span>
<span class="nc" id="L4630">                    message.append(Messages.getString(</span>
                            &quot;BoardView1.HeavySmoke&quot;, new Object[]{ //$NON-NLS-1$
<span class="nc" id="L4632">                                                                   Integer.valueOf(le.getHeavySmoke())}));</span>
                }
<span class="nc bnc" id="L4634" title="All 4 branches missed.">                if (le.isTargetCover() &amp;&amp; le.canSee()) {</span>
<span class="nc" id="L4635">                    message.append(Messages</span>
<span class="nc" id="L4636">                                           .getString(</span>
                                                   &quot;BoardView1.TargetPartialCover&quot;, new Object[]{ //$NON-NLS-1$
<span class="nc" id="L4638">                                                                                                  LosEffects.getCoverName(</span>
<span class="nc" id="L4639">                                                                                                          le.getTargetCover(), true)}));</span>
                }
<span class="nc bnc" id="L4641" title="All 4 branches missed.">                if (le.isAttackerCover() &amp;&amp; le.canSee()) {</span>
<span class="nc" id="L4642">                    message.append(Messages.getString(</span>
                            &quot;BoardView1.AttackerPartialCover&quot;, new Object[]{ //$NON-NLS-1$
<span class="nc" id="L4644">                                                                             LosEffects.getCoverName(le.getAttackerCover(),</span>
                                                                                                     false)}));
                }
            }
<span class="nc" id="L4648">            JOptionPane.showMessageDialog(getRootPane(), message.toString(),</span>
<span class="nc" id="L4649">                                          Messages.getString(&quot;BoardView1.LOSTitle&quot;),</span>
                                          JOptionPane.INFORMATION_MESSAGE);
        }
<span class="nc" id="L4652">    }</span>

    /**
     * Initializes the various overlay polygons with their vertices.
     */
    public void initPolys() {

<span class="nc" id="L4659">        AffineTransform facingRotate = new AffineTransform();</span>

        // facing polygons
<span class="nc" id="L4662">        Polygon facingPolyTmp = new Polygon();</span>
<span class="nc" id="L4663">        facingPolyTmp.addPoint(41, 3);</span>
<span class="nc" id="L4664">        facingPolyTmp.addPoint(35, 9);</span>
<span class="nc" id="L4665">        facingPolyTmp.addPoint(41, 7);</span>
<span class="nc" id="L4666">        facingPolyTmp.addPoint(42, 7);</span>
<span class="nc" id="L4667">        facingPolyTmp.addPoint(48, 9);</span>
<span class="nc" id="L4668">        facingPolyTmp.addPoint(42, 3);</span>

        // create the rotated shapes
<span class="nc" id="L4671">        facingPolys = new Shape[8];</span>
<span class="nc bnc" id="L4672" title="All 2 branches missed.">        for (int dir : allDirections) {</span>
<span class="nc" id="L4673">            facingPolys[dir] = facingRotate.createTransformedShape(facingPolyTmp);</span>
<span class="nc" id="L4674">            facingRotate.rotate(Math.toRadians(60), HEX_W / 2, HEX_H / 2);</span>
        }

        // final facing polygons
<span class="nc" id="L4678">        Polygon finalFacingPolyTmp = new Polygon();</span>
<span class="nc" id="L4679">        finalFacingPolyTmp.addPoint(41, 3);</span>
<span class="nc" id="L4680">        finalFacingPolyTmp.addPoint(21, 18);</span>
<span class="nc" id="L4681">        finalFacingPolyTmp.addPoint(41, 14);</span>
<span class="nc" id="L4682">        finalFacingPolyTmp.addPoint(42, 14);</span>
<span class="nc" id="L4683">        finalFacingPolyTmp.addPoint(61, 18);</span>
<span class="nc" id="L4684">        finalFacingPolyTmp.addPoint(42, 3);</span>

        // create the rotated shapes
<span class="nc" id="L4687">        facingRotate.setToIdentity();</span>
<span class="nc" id="L4688">        finalFacingPolys = new Shape[8];</span>
<span class="nc bnc" id="L4689" title="All 2 branches missed.">        for (int dir : allDirections) {</span>
<span class="nc" id="L4690">            finalFacingPolys[dir] = facingRotate.createTransformedShape(finalFacingPolyTmp);</span>
<span class="nc" id="L4691">            facingRotate.rotate(Math.toRadians(60), HEX_W / 2, HEX_H / 2);</span>
        }

        // movement polygons
<span class="nc" id="L4695">        Polygon movementPolyTmp = new Polygon();</span>
<span class="nc" id="L4696">        movementPolyTmp.addPoint(47, 67);</span>
<span class="nc" id="L4697">        movementPolyTmp.addPoint(48, 66);</span>
<span class="nc" id="L4698">        movementPolyTmp.addPoint(42, 62);</span>
<span class="nc" id="L4699">        movementPolyTmp.addPoint(41, 62);</span>
<span class="nc" id="L4700">        movementPolyTmp.addPoint(35, 66);</span>
<span class="nc" id="L4701">        movementPolyTmp.addPoint(36, 67);</span>

<span class="nc" id="L4703">        movementPolyTmp.addPoint(47, 67);</span>
<span class="nc" id="L4704">        movementPolyTmp.addPoint(45, 68);</span>
<span class="nc" id="L4705">        movementPolyTmp.addPoint(38, 68);</span>
<span class="nc" id="L4706">        movementPolyTmp.addPoint(38, 69);</span>
<span class="nc" id="L4707">        movementPolyTmp.addPoint(45, 69);</span>
<span class="nc" id="L4708">        movementPolyTmp.addPoint(45, 68);</span>

<span class="nc" id="L4710">        movementPolyTmp.addPoint(45, 70);</span>
<span class="nc" id="L4711">        movementPolyTmp.addPoint(38, 70);</span>
<span class="nc" id="L4712">        movementPolyTmp.addPoint(38, 71);</span>
<span class="nc" id="L4713">        movementPolyTmp.addPoint(45, 71);</span>
<span class="nc" id="L4714">        movementPolyTmp.addPoint(45, 68);</span>

        // create the rotated shapes
<span class="nc" id="L4717">        facingRotate.setToIdentity();</span>
<span class="nc" id="L4718">        movementPolys = new Shape[8];</span>
<span class="nc bnc" id="L4719" title="All 2 branches missed.">        for (int dir : allDirections) {</span>
<span class="nc" id="L4720">            movementPolys[dir] = facingRotate.createTransformedShape(movementPolyTmp);</span>
<span class="nc" id="L4721">            facingRotate.rotate(Math.toRadians(60), HEX_W / 2, HEX_H / 2);</span>
        }

        // Up and Down Arrows
<span class="nc" id="L4725">        facingRotate.setToIdentity();</span>
<span class="nc" id="L4726">        facingRotate.translate(0, -31);</span>
<span class="nc" id="L4727">        upArrow = facingRotate.createTransformedShape(movementPolyTmp);</span>

<span class="nc" id="L4729">        facingRotate.setToIdentity();</span>
<span class="nc" id="L4730">        facingRotate.rotate(Math.toRadians(180), HEX_W / 2, HEX_H / 2);</span>
<span class="nc" id="L4731">        facingRotate.translate(0, -31);</span>
<span class="nc" id="L4732">        downArrow = facingRotate.createTransformedShape(movementPolyTmp);</span>
<span class="nc" id="L4733">    }</span>

    synchronized boolean doMoveUnits(long idleTime) {
<span class="nc" id="L4736">        boolean movingSomething = false;</span>

<span class="nc bnc" id="L4738" title="All 2 branches missed.">        if (movingUnits.size() &gt; 0) {</span>
<span class="nc" id="L4739">            moveWait += idleTime;</span>

<span class="nc bnc" id="L4741" title="All 2 branches missed.">            if (moveWait &gt; GUIPreferences.getInstance().getInt(</span>
                    &quot;AdvancedMoveStepDelay&quot;)) {

<span class="nc" id="L4744">                ArrayList&lt;MovingUnit&gt; spent = new ArrayList&lt;MovingUnit&gt;();</span>

<span class="nc bnc" id="L4746" title="All 2 branches missed.">                for (MovingUnit move : movingUnits) {</span>
<span class="nc" id="L4747">                    movingSomething = true;</span>
<span class="nc" id="L4748">                    Entity ge = game.getEntity(move.entity.getId());</span>
<span class="nc bnc" id="L4749" title="All 2 branches missed.">                    if (move.path.size() &gt; 0) {</span>

<span class="nc" id="L4751">                        UnitLocation loc = move.path.get(0);</span>

<span class="nc bnc" id="L4753" title="All 2 branches missed.">                        if (ge != null) {</span>
<span class="nc" id="L4754">                            redrawMovingEntity(move.entity, loc.getCoords(),</span>
<span class="nc" id="L4755">                                    loc.getFacing(), loc.getElevation());</span>
                        }
<span class="nc" id="L4757">                        move.path.remove(0);</span>
<span class="nc" id="L4758">                    } else {</span>
<span class="nc bnc" id="L4759" title="All 2 branches missed.">                        if (ge != null) {</span>
<span class="nc" id="L4760">                            redrawEntity(ge);</span>
                        }
<span class="nc" id="L4762">                        spent.add(move);</span>
                    }

<span class="nc" id="L4765">                }</span>

<span class="nc bnc" id="L4767" title="All 2 branches missed.">                for (MovingUnit move : spent) {</span>
<span class="nc" id="L4768">                    movingUnits.remove(move);</span>
<span class="nc" id="L4769">                }</span>
<span class="nc" id="L4770">                moveWait = 0;</span>

<span class="nc bnc" id="L4772" title="All 2 branches missed.">                if (movingUnits.size() == 0) {</span>
<span class="nc" id="L4773">                    movingEntitySpriteIds.clear();</span>
<span class="nc" id="L4774">                    movingEntitySprites.clear();</span>
<span class="nc" id="L4775">                    ghostEntitySprites.clear();</span>
<span class="nc" id="L4776">                    processBoardViewEvent(new BoardViewEvent(this,</span>
                            BoardViewEvent.FINISHED_MOVING_UNITS));
                }
            }
        }
<span class="nc" id="L4781">        return movingSomething;</span>
    }

    //
    // MouseListener
    //
    public void mousePressed(MouseEvent me) {
<span class="nc" id="L4788">        requestFocusInWindow();</span>
<span class="nc" id="L4789">        stopSoftCentering();</span>
<span class="nc" id="L4790">        Point point = me.getPoint();</span>
<span class="nc bnc" id="L4791" title="All 2 branches missed.">        if (null == point) {</span>
<span class="nc" id="L4792">            return;</span>
        }

        // Button 4: Hide/Show the minimap and unitDisplay
<span class="nc bnc" id="L4796" title="All 2 branches missed.">        if (me.getButton() == 4) {</span>
<span class="nc bnc" id="L4797" title="All 2 branches missed.">            if (clientgui != null) clientgui.toggleMMUDDisplays();</span>
        }

        // we clicked the right mouse button,
        // remember the position if we start to scroll
        // if we drag, we should scroll
<span class="nc bnc" id="L4803" title="All 2 branches missed.">        if (SwingUtilities.isRightMouseButton(me)) {</span>
<span class="nc" id="L4804">            scrollXDifference = me.getX();</span>
<span class="nc" id="L4805">            scrollYDifference = me.getY();</span>
<span class="nc" id="L4806">            shouldScroll = true;</span>
        }

<span class="nc bnc" id="L4809" title="All 4 branches missed.">        if (me.isPopupTrigger() &amp;&amp; !dragging) {</span>
<span class="nc" id="L4810">            mouseAction(getCoordsAt(point), BOARD_HEX_POPUP, me.getModifiers());</span>
<span class="nc" id="L4811">            return;</span>
        }
<span class="nc bnc" id="L4813" title="All 2 branches missed.">        for (int i = 0; i &lt; displayables.size(); i++) {</span>
<span class="nc" id="L4814">            IDisplayable disp = displayables.get(i);</span>
<span class="nc" id="L4815">            double width = scrollpane.getViewport().getSize()</span>
<span class="nc" id="L4816">                                     .getWidth();</span>
<span class="nc" id="L4817">            double height = scrollpane.getViewport().getSize()</span>
<span class="nc" id="L4818">                                      .getHeight();</span>
<span class="nc" id="L4819">            Dimension dispDimension = new Dimension();</span>
<span class="nc" id="L4820">            dispDimension.setSize(width, height);</span>
            // we need to adjust the point, because it should be against the
            // displayable dimension
<span class="nc" id="L4823">            Point dispPoint = new Point();</span>
<span class="nc" id="L4824">            dispPoint.setLocation(point.x + getBounds().x, point.y</span>
<span class="nc" id="L4825">                                                           + getBounds().y);</span>
<span class="nc bnc" id="L4826" title="All 2 branches missed.">            if (disp.isHit(dispPoint, dispDimension)) {</span>
<span class="nc" id="L4827">                return;</span>
            }
        }
<span class="nc" id="L4830">        mouseAction(getCoordsAt(point), BOARD_HEX_DRAG, me.getModifiers());</span>
<span class="nc" id="L4831">    }</span>

    public void mouseReleased(MouseEvent me) {
        // don't show the popup if we are drag-scrolling
<span class="nc bnc" id="L4835" title="All 4 branches missed.">        if (me.isPopupTrigger() &amp;&amp; !dragging) {</span>
<span class="nc" id="L4836">            mouseAction(getCoordsAt(me.getPoint()), BOARD_HEX_POPUP,</span>
<span class="nc" id="L4837">                        me.getModifiers());</span>
            // stop scrolling
<span class="nc" id="L4839">            shouldScroll = false;</span>
<span class="nc" id="L4840">            return;</span>
        }

        // if we released the right mouse button, there's no more
        // scrolling
<span class="nc bnc" id="L4845" title="All 2 branches missed.">        if (SwingUtilities.isRightMouseButton(me)) {</span>
<span class="nc" id="L4846">            scrollXDifference = 0;</span>
<span class="nc" id="L4847">            scrollYDifference = 0;</span>
<span class="nc" id="L4848">            dragging = false;</span>
<span class="nc" id="L4849">            shouldScroll = false;</span>
<span class="nc" id="L4850">            setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));</span>
        }
<span class="nc bnc" id="L4852" title="All 2 branches missed.">        for (int i = 0; i &lt; displayables.size(); i++) {</span>
<span class="nc" id="L4853">            IDisplayable disp = displayables.get(i);</span>
<span class="nc bnc" id="L4854" title="All 2 branches missed.">            if (disp.isReleased()) {</span>
<span class="nc" id="L4855">                return;</span>
            }
        }

<span class="nc bnc" id="L4859" title="All 2 branches missed.">        if (me.getClickCount() == 1) {</span>
<span class="nc" id="L4860">            mouseAction(getCoordsAt(me.getPoint()), BOARD_HEX_CLICK,</span>
<span class="nc" id="L4861">                        me.getModifiers());</span>
        } else {
<span class="nc" id="L4863">            mouseAction(getCoordsAt(me.getPoint()), BOARD_HEX_DOUBLECLICK,</span>
<span class="nc" id="L4864">                        me.getModifiers());</span>
        }
<span class="nc" id="L4866">    }</span>

    public void mouseEntered(MouseEvent me) {
<span class="nc" id="L4869">    }</span>

    public void mouseExited(MouseEvent me) {
        // Reset the tooltip dismissal delay to the preference
        // value so that elements outside the boardview can
        // use tooltips
<span class="nc bnc" id="L4875" title="All 2 branches missed.">        if (GUIPreferences.getInstance().getTooltipDismissDelay() &gt;= 0) {</span>
<span class="nc" id="L4876">            ToolTipManager.sharedInstance().setDismissDelay(</span>
<span class="nc" id="L4877">                    GUIPreferences.getInstance().getTooltipDismissDelay());</span>
        } else {
<span class="nc" id="L4879">            ToolTipManager.sharedInstance().setDismissDelay(dismissDelay);</span>
        }
<span class="nc" id="L4881">    }</span>

    public void mouseClicked(MouseEvent me) {
<span class="nc" id="L4884">    }</span>

    private class MovingUnit {
        public Entity entity;

        public ArrayList&lt;UnitLocation&gt; path;

<span class="nc" id="L4891">        MovingUnit(Entity entity, Vector&lt;UnitLocation&gt; path) {</span>
<span class="nc" id="L4892">            this.entity = entity;</span>
<span class="nc" id="L4893">            this.path = new ArrayList&lt;UnitLocation&gt;(path);</span>
<span class="nc" id="L4894">        }</span>
    }

    /**
     * Determine if the tile manager's images have been loaded.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if all images have been loaded.
     * &lt;code&gt;false&lt;/code&gt; if more need to be loaded.
     */
    public boolean isTileImagesLoaded() {
<span class="nc" id="L4904">        return tileManager.isLoaded();</span>
    }

    public void setUseLOSTool(boolean use) {
<span class="nc" id="L4908">        useLOSTool = use;</span>
<span class="nc" id="L4909">    }</span>

    public TilesetManager getTilesetManager() {
<span class="nc" id="L4912">        return tileManager;</span>
    }

    /**
     * @param lastCursor The lastCursor to set.
     */
    public void setLastCursor(Coords lastCursor) {
<span class="nc" id="L4919">        this.lastCursor = lastCursor;</span>
<span class="nc" id="L4920">    }</span>

    /**
     * @return Returns the lastCursor.
     */
    public Coords getLastCursor() {
<span class="nc" id="L4926">        return lastCursor;</span>
    }

    /**
     * @param highlighted The highlighted to set.
     */
    public void setHighlighted(Coords highlighted) {
<span class="nc" id="L4933">        this.highlighted = highlighted;</span>
<span class="nc" id="L4934">    }</span>

    /**
     * @return Returns the highlighted.
     */
    public Coords getHighlighted() {
<span class="nc" id="L4940">        return highlighted;</span>
    }

    /**
     * @param selected The selected to set.
     */
    public void setSelected(Coords selected) {
<span class="nc bnc" id="L4947" title="All 2 branches missed.">        if (this.selected != selected) {</span>
<span class="nc" id="L4948">            this.selected = selected;</span>
<span class="nc" id="L4949">            checkFoVHexImageCacheClear();</span>
        }
<span class="nc" id="L4951">    }</span>

    /**
     * @return Returns the selected.
     */
    public Coords getSelected() {
<span class="nc" id="L4957">        return selected;</span>
    }

    /**
     * @param firstLOS The firstLOS to set.
     */
    public void setFirstLOS(Coords firstLOS) {
<span class="nc" id="L4964">        this.firstLOS = firstLOS;</span>
<span class="nc" id="L4965">    }</span>

    /**
     * @return Returns the firstLOS.
     */
    public Coords getFirstLOS() {
<span class="nc" id="L4971">        return firstLOS;</span>
    }

    /**
     * Determines if this Board contains the Coords, and if so, &quot;selects&quot; that
     * Coords.
     *
     * @param coords the Coords.
     */
    public void select(Coords coords) {
<span class="nc bnc" id="L4981" title="All 4 branches missed.">        if ((coords == null) || game.getBoard().contains(coords)) {</span>
<span class="nc" id="L4982">            setSelected(coords);</span>
<span class="nc" id="L4983">            moveCursor(selectedSprite, coords);</span>
<span class="nc" id="L4984">            moveCursor(firstLOSSprite, null);</span>
<span class="nc" id="L4985">            moveCursor(secondLOSSprite, null);</span>
<span class="nc" id="L4986">            processBoardViewEvent(new BoardViewEvent(this, coords, null,</span>
                                                     BoardViewEvent.BOARD_HEX_SELECTED, 0));
        }
<span class="nc" id="L4989">    }</span>

    /**
     * &quot;Selects&quot; the specified Coords.
     *
     * @param x the x coordinate.
     * @param y the y coordinate.
     */
    public void select(int x, int y) {
<span class="nc" id="L4998">        select(new Coords(x, y));</span>
<span class="nc" id="L4999">    }</span>

    /**
     * Determines if this Board contains the Coords, and if so, highlights that
     * Coords.
     *
     * @param coords the Coords.
     */
    public void highlight(Coords coords) {
<span class="nc bnc" id="L5008" title="All 4 branches missed.">        if ((coords == null) || game.getBoard().contains(coords)) {</span>
<span class="nc" id="L5009">            setHighlighted(coords);</span>
<span class="nc" id="L5010">            moveCursor(highlightSprite, coords);</span>
<span class="nc" id="L5011">            moveCursor(firstLOSSprite, null);</span>
<span class="nc" id="L5012">            moveCursor(secondLOSSprite, null);</span>
<span class="nc" id="L5013">            processBoardViewEvent(new BoardViewEvent(this, coords, null,</span>
                                                     BoardViewEvent.BOARD_HEX_HIGHLIGHTED, 0));
        }
<span class="nc" id="L5016">    }</span>

    public void setHighlightColor(Color c) {
<span class="nc" id="L5019">        highlightSprite.setColor(c);</span>
<span class="nc" id="L5020">        highlightSprite.prepare();</span>
<span class="nc" id="L5021">        repaint();</span>
<span class="nc" id="L5022">    }</span>

    /**
     * Highlights the specified Coords.
     *
     * @param x the x coordinate.
     * @param y the y coordinate.
     */
    public void highlight(int x, int y) {
<span class="nc" id="L5031">        highlight(new Coords(x, y));</span>
<span class="nc" id="L5032">    }</span>

    public synchronized void highlightSelectedEntity() {
<span class="nc bnc" id="L5035" title="All 2 branches missed.">        for (EntitySprite sprite: entitySprites) {</span>
<span class="nc bnc" id="L5036" title="All 2 branches missed.">            if (sprite.entity.equals(selectedEntity)) {</span>
<span class="nc" id="L5037">                sprite.setSelected(true);</span>
            } else {
<span class="nc" id="L5039">                sprite.setSelected(false);</span>
            }
<span class="nc" id="L5041">        }</span>
<span class="nc" id="L5042">    }</span>

    /**
     * Determines if this Board contains the Coords, and if so, &quot;cursors&quot; that
     * Coords.
     *
     * @param coords the Coords.
     */
    public void cursor(Coords coords) {
<span class="nc bnc" id="L5051" title="All 4 branches missed.">        if ((coords == null) || game.getBoard().contains(coords)) {</span>
<span class="nc bnc" id="L5052" title="All 4 branches missed.">            if ((getLastCursor() == null) || (coords == null)</span>
<span class="nc bnc" id="L5053" title="All 2 branches missed.">                || !coords.equals(getLastCursor())) {</span>
<span class="nc" id="L5054">                setLastCursor(coords);</span>
<span class="nc" id="L5055">                moveCursor(cursorSprite, coords);</span>
<span class="nc" id="L5056">                moveCursor(firstLOSSprite, null);</span>
<span class="nc" id="L5057">                moveCursor(secondLOSSprite, null);</span>
<span class="nc" id="L5058">                processBoardViewEvent(new BoardViewEvent(this, coords, null,</span>
                                                         BoardViewEvent.BOARD_HEX_CURSOR, 0));
            } else {
<span class="nc" id="L5061">                setLastCursor(coords);</span>
            }
        }
<span class="nc" id="L5064">    }</span>

    /**
     * &quot;Cursors&quot; the specified Coords.
     *
     * @param x the x coordinate.
     * @param y the y coordinate.
     */
    public void cursor(int x, int y) {
<span class="nc" id="L5073">        cursor(new Coords(x, y));</span>
<span class="nc" id="L5074">    }</span>

    public void checkLOS(Coords c) {
<span class="nc bnc" id="L5077" title="All 4 branches missed.">        if ((c == null) || game.getBoard().contains(c)) {</span>
<span class="nc bnc" id="L5078" title="All 2 branches missed.">            if (getFirstLOS() == null) {</span>
<span class="nc" id="L5079">                setFirstLOS(c);</span>
<span class="nc" id="L5080">                firstLOSHex(c);</span>
<span class="nc" id="L5081">                processBoardViewEvent(new BoardViewEvent(this, c, null,</span>
                                                         BoardViewEvent.BOARD_FIRST_LOS_HEX, 0));
            } else {
<span class="nc" id="L5084">                secondLOSHex(c, getFirstLOS());</span>
<span class="nc" id="L5085">                processBoardViewEvent(new BoardViewEvent(this, c, null,</span>
                                                         BoardViewEvent.BOARD_SECOND_LOS_HEX, 0));
<span class="nc" id="L5087">                setFirstLOS(null);</span>
            }
        }
<span class="nc" id="L5090">    }</span>

    /**
     * Determines if this Board contains the (x, y) Coords, and if so, notifies
     * listeners about the specified mouse action.
     */
    public void mouseAction(int x, int y, int mtype, int modifiers) {
<span class="nc bnc" id="L5097" title="All 2 branches missed.">        if (game.getBoard().contains(x, y)) {</span>
<span class="nc" id="L5098">            Coords c = new Coords(x, y);</span>
<span class="nc bnc" id="L5099" title="All 5 branches missed.">            switch (mtype) {</span>
                case BOARD_HEX_CLICK:
<span class="nc bnc" id="L5101" title="All 2 branches missed.">                    if ((modifiers &amp; java.awt.event.InputEvent.CTRL_MASK) != 0) {</span>
<span class="nc" id="L5102">                        checkLOS(c);</span>
                    } else {
<span class="nc" id="L5104">                        processBoardViewEvent(new BoardViewEvent(this, c, null,</span>
                                BoardViewEvent.BOARD_HEX_CLICKED, modifiers));
                    }
<span class="nc" id="L5107">                    break;</span>
                case BOARD_HEX_DOUBLECLICK:
<span class="nc" id="L5109">                    processBoardViewEvent(new BoardViewEvent(this, c, null,</span>
                            BoardViewEvent.BOARD_HEX_DOUBLECLICKED, modifiers));
<span class="nc" id="L5111">                    break;</span>
                case BOARD_HEX_DRAG:
<span class="nc" id="L5113">                    processBoardViewEvent(new BoardViewEvent(this, c, null,</span>
                            BoardViewEvent.BOARD_HEX_DRAGGED, modifiers));
<span class="nc" id="L5115">                    break;</span>
                case BOARD_HEX_POPUP:
<span class="nc" id="L5117">                    processBoardViewEvent(new BoardViewEvent(this, c, null,</span>
                            BoardViewEvent.BOARD_HEX_POPUP, modifiers));
                    break;
            }
        }
<span class="nc" id="L5122">    }</span>

    /**
     * Notifies listeners about the specified mouse action.
     *
     * @param coords the Coords.
     */
    public void mouseAction(Coords coords, int mtype, int modifiers) {
<span class="nc" id="L5130">        mouseAction(coords.getX(), coords.getY(), mtype, modifiers);</span>
<span class="nc" id="L5131">    }</span>

    /*
     * (non-Javadoc)
     *
     * @see
     * megamek.common.BoardListener#boardNewBoard(megamek.common.BoardEvent)
     */
    public void boardNewBoard(BoardEvent b) {
<span class="nc" id="L5140">        updateBoard();</span>
<span class="nc" id="L5141">        clearHexImageCache();</span>
<span class="nc" id="L5142">        clearShadowMap();</span>
<span class="nc" id="L5143">        repaint();</span>
<span class="nc" id="L5144">    }</span>

    /*
     * (non-Javadoc)
     *
     * @see
     * megamek.common.BoardListener#boardChangedHex(megamek.common.BoardEvent)
     */
    public void boardChangedHex(BoardEvent b) {
<span class="nc" id="L5153">        hexImageCache.remove(b.getCoords());</span>
        // Also repaint the surrounding hexes because of shadows, border etc.
<span class="nc bnc" id="L5155" title="All 2 branches missed.">        for (int dir: allDirections) { </span>
<span class="nc" id="L5156">            hexImageCache.remove(b.getCoords().translated(dir));</span>
        }
<span class="nc" id="L5158">        clearShadowMap();</span>
<span class="nc" id="L5159">        repaint();</span>
<span class="nc" id="L5160">    }</span>

    /*
     * (non-Javadoc)
     *
     * @see
     * megamek.common.BoardListener#boardChangedHex(megamek.common.BoardEvent)
     */
    public synchronized void boardChangedAllHexes(BoardEvent b) {
<span class="nc" id="L5169">        clearHexImageCache();</span>
<span class="nc" id="L5170">        clearShadowMap();</span>
<span class="nc" id="L5171">        repaint();</span>
<span class="nc" id="L5172">    }</span>

<span class="nc" id="L5174">    private GameListener gameListener = new GameListenerAdapter() {</span>

        @Override
        public void gameEntityNew(GameEntityNewEvent e) {
<span class="nc" id="L5178">            updateEcmList();</span>
<span class="nc" id="L5179">            redrawAllEntities();</span>
<span class="nc bnc" id="L5180" title="All 2 branches missed.">            if (game.getPhase() == IGame.Phase.PHASE_MOVEMENT) {</span>
<span class="nc" id="L5181">                refreshMoveVectors();</span>
            }
<span class="nc" id="L5183">        }</span>

        @Override
        public void gameEntityRemove(GameEntityRemoveEvent e) {
<span class="nc" id="L5187">            updateEcmList();</span>
<span class="nc" id="L5188">            redrawAllEntities();</span>
<span class="nc bnc" id="L5189" title="All 2 branches missed.">            if (game.getPhase() == IGame.Phase.PHASE_MOVEMENT) {</span>
<span class="nc" id="L5190">                refreshMoveVectors();</span>
            }
<span class="nc" id="L5192">        }</span>

        @Override
        public void gameEntityChange(GameEntityChangeEvent e) {
<span class="nc" id="L5196">            final Vector&lt;UnitLocation&gt; mp = e.getMovePath();</span>
<span class="nc" id="L5197">            final Entity en = e.getEntity();</span>
<span class="nc" id="L5198">            final GameOptions gopts = game.getOptions();</span>
<span class="nc" id="L5199">            GUIPreferences guip = GUIPreferences.getInstance();</span>

<span class="nc" id="L5201">            updateEcmList();</span>
            
            //For Entities that have converted to another mode, check for a different sprite
<span class="nc bnc" id="L5204" title="All 2 branches missed.">            if (game.getPhase() == IGame.Phase.PHASE_MOVEMENT</span>
<span class="nc bnc" id="L5205" title="All 2 branches missed.">                    &amp;&amp; en.isConvertingNow()) {</span>
<span class="nc" id="L5206">                tileManager.reloadImage(en);</span>
            }
            
            // for units that have been blown up, damaged or ejected, force a reload
<span class="nc bnc" id="L5210" title="All 2 branches missed.">            if((e.getOldEntity() != null) &amp;&amp;</span>
<span class="nc bnc" id="L5211" title="All 2 branches missed.">                    ((en.getDamageLevel() != e.getOldEntity().getDamageLevel()) ||</span>
<span class="nc bnc" id="L5212" title="All 2 branches missed.">                    (en.isDestroyed() != e.getOldEntity().isDestroyed()) ||</span>
<span class="nc bnc" id="L5213" title="All 2 branches missed.">                    (en.getCrew().isEjected() != e.getOldEntity().getCrew().isEjected()))) {</span>
<span class="nc" id="L5214">                tileManager.reloadImage(en);</span>
            }
            
<span class="nc" id="L5217">            redrawAllEntities();</span>
<span class="nc bnc" id="L5218" title="All 2 branches missed.">            if (game.getPhase() == IGame.Phase.PHASE_MOVEMENT) {</span>
<span class="nc" id="L5219">                refreshMoveVectors();</span>
            }
<span class="nc bnc" id="L5221" title="All 6 branches missed.">            if ((mp != null) &amp;&amp; (mp.size() &gt; 0) &amp;&amp; guip.getShowMoveStep()</span>
<span class="nc bnc" id="L5222" title="All 2 branches missed.">                    &amp;&amp; !gopts.booleanOption(OptionsConstants.INIT_SIMULTANEOUS_MOVEMENT)) {</span>
<span class="nc bnc" id="L5223" title="All 2 branches missed.">                if ((localPlayer == null)</span>
<span class="nc bnc" id="L5224" title="All 2 branches missed.">                        || !game.getOptions().booleanOption(OptionsConstants.ADVANCED_DOUBLE_BLIND)</span>
<span class="nc bnc" id="L5225" title="All 2 branches missed.">                        || !en.getOwner().isEnemyOf(localPlayer)</span>
<span class="nc bnc" id="L5226" title="All 2 branches missed.">                        || en.hasSeenEntity(localPlayer)) {</span>
<span class="nc" id="L5227">                    addMovingUnit(en, mp);</span>
                }
            }
<span class="nc" id="L5230">        }</span>

        @Override
        public void gameNewAction(GameNewActionEvent e) {
<span class="nc" id="L5234">            EntityAction ea = e.getAction();</span>
<span class="nc bnc" id="L5235" title="All 2 branches missed.">            if (ea instanceof AttackAction) {</span>
<span class="nc" id="L5236">                addAttack((AttackAction) ea);</span>
            }
<span class="nc" id="L5238">        }</span>

        @Override
        public void gameBoardNew(GameBoardNewEvent e) {
<span class="nc" id="L5242">            IBoard b = e.getOldBoard();</span>
<span class="nc bnc" id="L5243" title="All 2 branches missed.">            if (b != null) {</span>
<span class="nc" id="L5244">                b.removeBoardListener(BoardView1.this);</span>
            }
<span class="nc" id="L5246">            b = e.getNewBoard();</span>
<span class="nc bnc" id="L5247" title="All 2 branches missed.">            if (b != null) {</span>
<span class="nc" id="L5248">                b.addBoardListener(BoardView1.this);</span>
            }
<span class="nc" id="L5250">            boardBackgrounds.clear();</span>
<span class="nc bnc" id="L5251" title="All 2 branches missed.">            if (b.hasBoardBackground()) {</span>
<span class="nc" id="L5252">                ListIterator&lt;Boolean&gt; flipItHoriz = b.getFlipBGHoriz()</span>
<span class="nc" id="L5253">                        .listIterator();</span>
<span class="nc" id="L5254">                ListIterator&lt;Boolean&gt; flipItVert = b.getFlipBGVert()</span>
<span class="nc" id="L5255">                        .listIterator();</span>
<span class="nc bnc" id="L5256" title="All 2 branches missed.">                for (String path : b.getBackgroundPaths()) {</span>
<span class="nc" id="L5257">                    boolean flipHoriz = flipItHoriz.next();</span>
<span class="nc" id="L5258">                    boolean flipVert = flipItVert.next();</span>
<span class="nc bnc" id="L5259" title="All 2 branches missed.">                    if (path == null) {</span>
<span class="nc" id="L5260">                        boardBackgrounds.add(null);</span>
                    } else {
<span class="nc" id="L5262">                        Image bgImg = ImageUtil.loadImageFromFile(path);</span>
<span class="nc" id="L5263">                        ImageProducer prod = bgImg.getSource();</span>
<span class="nc bnc" id="L5264" title="All 4 branches missed.">                        if (flipHoriz || flipVert) {</span>
<span class="nc" id="L5265">                            AffineTransform at = new AffineTransform();</span>

<span class="nc bnc" id="L5267" title="All 2 branches missed.">                            if (flipHoriz) {</span>
<span class="nc" id="L5268">                                at.concatenate(AffineTransform</span>
<span class="nc" id="L5269">                                        .getScaleInstance(1, -1));</span>
                            }
<span class="nc bnc" id="L5271" title="All 2 branches missed.">                            if (flipVert) {</span>
<span class="nc" id="L5272">                                at.concatenate(AffineTransform</span>
<span class="nc" id="L5273">                                        .getTranslateInstance(0,</span>
<span class="nc" id="L5274">                                                -bgImg.getHeight(null)));</span>
                            }
<span class="nc" id="L5276">                            ((Graphics2D) bgImg.getGraphics()).setTransform(at);</span>
                        }
<span class="nc" id="L5278">                        boardBackgrounds.add(Toolkit.getDefaultToolkit()</span>
<span class="nc" id="L5279">                                .createImage(prod));</span>
                    }
<span class="nc" id="L5281">                }</span>
            }
<span class="nc" id="L5283">            clearHexImageCache();</span>
<span class="nc" id="L5284">            updateBoard();</span>
<span class="nc" id="L5285">            clearShadowMap();</span>
<span class="nc" id="L5286">        }</span>

        @Override
        public void gameBoardChanged(GameBoardChangeEvent e) {
<span class="nc" id="L5290">            clearHexImageCache();</span>
<span class="nc" id="L5291">            boardChanged();</span>
<span class="nc" id="L5292">        }</span>

        @Override
        public void gamePhaseChange(GamePhaseChangeEvent e) {
<span class="nc bnc" id="L5296" title="All 4 branches missed.">            if (GUIPreferences.getInstance().getGameSummaryBoardView() &amp;&amp; ((e.getOldPhase() == Phase.PHASE_DEPLOYMENT)</span>
<span class="nc bnc" id="L5297" title="All 4 branches missed.">                    || (e.getOldPhase() == Phase.PHASE_MOVEMENT) || (e.getOldPhase() == Phase.PHASE_TARGETING)</span>
<span class="nc bnc" id="L5298" title="All 4 branches missed.">                    || (e.getOldPhase() == Phase.PHASE_FIRING) || (e.getOldPhase() == Phase.PHASE_PHYSICAL))) {</span>
<span class="nc" id="L5299">                File dir = new File(Configuration.gameSummaryImagesBVDir(), game.getUUIDString());</span>
<span class="nc bnc" id="L5300" title="All 2 branches missed.">                if (!dir.exists()) {</span>
<span class="nc" id="L5301">                    dir.mkdirs();</span>
                }
<span class="nc" id="L5303">                File imgFile = new File(dir, &quot;round_&quot; + game.getRoundCount() + &quot;_&quot; + e.getOldPhase().ordinal() + &quot;_&quot;</span>
<span class="nc" id="L5304">                        + IGame.Phase.getDisplayableName(e.getOldPhase()) + &quot;.png&quot;);</span>
                try {
<span class="nc" id="L5306">                    ImageIO.write(getEntireBoardImage(false), &quot;png&quot;, imgFile);</span>
<span class="nc" id="L5307">                } catch (Exception ex) {</span>
<span class="nc" id="L5308">                    MegaMek.getLogger().error(ex);</span>
<span class="nc" id="L5309">                }</span>
            }

<span class="nc" id="L5312">            refreshAttacks();</span>

            // Clear some information regardless of what phase it is
<span class="nc" id="L5315">            clearFiringSolutionData();</span>
<span class="nc" id="L5316">            clearMovementEnvelope();</span>

<span class="nc bnc" id="L5318" title="All 7 branches missed.">            switch (e.getNewPhase()) {</span>
                case PHASE_MOVEMENT:
<span class="nc" id="L5320">                    refreshMoveVectors();</span>
                case PHASE_FIRING:
<span class="nc" id="L5322">                    clearAllMoveVectors();</span>
                case PHASE_PHYSICAL:
<span class="nc" id="L5324">                    refreshAttacks();</span>
<span class="nc" id="L5325">                    break;</span>
                case PHASE_INITIATIVE:
<span class="nc" id="L5327">                    clearAllAttacks();</span>
<span class="nc" id="L5328">                    break;</span>
                case PHASE_END:
                case PHASE_VICTORY:
<span class="nc" id="L5331">                    clearSprites();</span>
                case PHASE_LOUNGE:
<span class="nc" id="L5333">                    clearHexImageCache();</span>
<span class="nc" id="L5334">                    clearAllMoveVectors();</span>
<span class="nc" id="L5335">                    clearAllAttacks();</span>
<span class="nc" id="L5336">                    clearSprites();</span>
<span class="nc" id="L5337">                    select(null);</span>
<span class="nc" id="L5338">                    cursor(null);</span>
<span class="nc" id="L5339">                    highlight(null);</span>
                default:
            }
<span class="nc bnc" id="L5342" title="All 2 branches missed.">            for (Entity en: game.getEntitiesVector()) {</span>
<span class="nc bnc" id="L5343" title="All 6 branches missed.">                if ((en.getDamageLevel() != Entity.DMG_NONE) &amp;&amp; </span>
                        ((en.damageThisRound != 0) || (en instanceof GunEmplacement))) {
<span class="nc" id="L5345">                    tileManager.reloadImage(en);</span>
                }
<span class="nc" id="L5347">            }</span>

<span class="nc" id="L5349">        }</span>
    };

    synchronized void boardChanged() {
<span class="nc" id="L5353">        redrawAllEntities();</span>
<span class="nc" id="L5354">        redrawAllFlares();</span>
<span class="nc" id="L5355">    }</span>

    void clearSprites() {
<span class="nc" id="L5358">        pathSprites.clear();</span>
<span class="nc" id="L5359">        firingSprites.clear();</span>
<span class="nc" id="L5360">        attackSprites.clear();</span>
<span class="nc" id="L5361">        c3Sprites.clear();</span>
<span class="nc" id="L5362">        vtolAttackSprites.clear();</span>
<span class="nc" id="L5363">        flyOverSprites.clear();</span>
<span class="nc" id="L5364">        movementSprites.clear();</span>
<span class="nc" id="L5365">        fieldofFireSprites.clear();</span>
<span class="nc" id="L5366">    }</span>

    public synchronized void updateBoard() {
<span class="nc" id="L5369">        updateBoardSize();</span>
<span class="nc" id="L5370">        redrawAllEntities();</span>
<span class="nc" id="L5371">    }</span>

    /**
     * the old redrawworker converted to a runnable which is called now and then
     * from the event thread
     */
<span class="nc" id="L5377">    protected class RedrawWorker implements Runnable {</span>

<span class="nc" id="L5379">        protected long lastTime = System.currentTimeMillis();</span>

<span class="nc" id="L5381">        protected long currentTime = System.currentTimeMillis();</span>

        public void run() {
<span class="nc" id="L5384">            currentTime = System.currentTimeMillis();</span>
<span class="nc bnc" id="L5385" title="All 2 branches missed.">            if (isShowing()) {</span>
<span class="nc" id="L5386">                boolean redraw = false;</span>
<span class="nc bnc" id="L5387" title="All 2 branches missed.">                for (int i = 0; i &lt; displayables.size(); i++) {</span>
<span class="nc" id="L5388">                    IDisplayable disp = displayables.get(i);</span>
<span class="nc bnc" id="L5389" title="All 2 branches missed.">                    if (!disp.isSliding()) {</span>
<span class="nc" id="L5390">                        disp.setIdleTime(currentTime - lastTime, true);</span>
                    } else {
<span class="nc bnc" id="L5392" title="All 4 branches missed.">                        redraw = redraw || disp.slide();</span>
                    }
                }
<span class="nc bnc" id="L5395" title="All 4 branches missed.">                redraw = redraw || doMoveUnits(currentTime - lastTime);</span>
<span class="nc bnc" id="L5396" title="All 2 branches missed.">                if (redraw) {</span>
<span class="nc" id="L5397">                    repaint();</span>
                }
<span class="nc" id="L5399">                centerOnHexSoftStep(currentTime - lastTime);</span>
            }
<span class="nc" id="L5401">            lastTime = currentTime;</span>
<span class="nc" id="L5402">        }</span>
    }

    public synchronized void selectEntity(Entity e) {
<span class="nc" id="L5406">        selectedEntity = e;</span>
<span class="nc" id="L5407">        checkFoVHexImageCacheClear();</span>
        // If we don't do this, the selectedWeapon might not correspond to this
        // entity
<span class="nc" id="L5410">        selectedWeapon = null;</span>
<span class="nc" id="L5411">        updateEcmList();</span>
<span class="nc" id="L5412">        highlightSelectedEntity();</span>
<span class="nc" id="L5413">    }</span>

    public synchronized void weaponSelected(MechDisplayEvent b) {
<span class="nc" id="L5416">        selectedEntity = b.getEntity();</span>
<span class="nc" id="L5417">        selectedWeapon = b.getEquip();</span>
<span class="nc" id="L5418">        repaint();</span>
<span class="nc" id="L5419">    }</span>

    /**
     *  Updates maps that determine how to shade hexes affected by E(C)CM. This
     *  is expensive, so precalculate only when entity changes occur
     **/
    public void updateEcmList() {
<span class="nc" id="L5426">        Map&lt;Coords, Color&gt; newECMHexes = new HashMap&lt;Coords, Color&gt;();</span>
<span class="nc" id="L5427">        Map&lt;Coords, Color&gt; newECMCenters = new HashMap&lt;Coords, Color&gt;();</span>
<span class="nc" id="L5428">        Map&lt;Coords, Color&gt; newECCMHexes = new HashMap&lt;Coords, Color&gt;();</span>
<span class="nc" id="L5429">        Map&lt;Coords, Color&gt; newECCMCenters = new HashMap&lt;Coords, Color&gt;();</span>

        // Compute info about all E(C)CM on the board
<span class="nc" id="L5432">        final List&lt;ECMInfo&gt; allEcmInfo = ComputeECM</span>
<span class="nc" id="L5433">                .computeAllEntitiesECMInfo(game.getEntitiesVector());</span>

        // First, mark the sources of E(C)CM
        // Used for highlighting hexes and tooltips
<span class="nc bnc" id="L5437" title="All 2 branches missed.">        for (Entity e : game.getEntitiesVector()) {</span>
<span class="nc bnc" id="L5438" title="All 2 branches missed.">            if (e.getPosition() == null) {</span>
<span class="nc" id="L5439">                continue;</span>
            }
            // If this unit isn't spotted somehow, it's ECM doesn't show up
<span class="nc bnc" id="L5442" title="All 2 branches missed.">            if ((localPlayer != null)</span>
<span class="nc bnc" id="L5443" title="All 2 branches missed.">                    &amp;&amp; game.getOptions().booleanOption(OptionsConstants.ADVANCED_DOUBLE_BLIND)</span>
<span class="nc bnc" id="L5444" title="All 2 branches missed.">                    &amp;&amp; e.getOwner().isEnemyOf(localPlayer)</span>
<span class="nc bnc" id="L5445" title="All 2 branches missed.">                    &amp;&amp; !e.hasSeenEntity(localPlayer)</span>
<span class="nc bnc" id="L5446" title="All 2 branches missed.">                    &amp;&amp; !e.hasDetectedEntity(localPlayer)) {</span>
<span class="nc" id="L5447">                continue;</span>
            }

<span class="nc" id="L5450">            final Color ecmColor = ECMEffects.getECMColor(e.getOwner());</span>
            // Update ECM center information
<span class="nc bnc" id="L5452" title="All 2 branches missed.">            if (e.getECMInfo() != null) {</span>
<span class="nc" id="L5453">                newECMCenters.put(e.getPosition(), ecmColor);</span>
            }
            // Update ECCM center information
<span class="nc bnc" id="L5456" title="All 2 branches missed.">            if (e.getECCMInfo() != null) {</span>
<span class="nc" id="L5457">                newECCMCenters.put(e.getPosition(), ecmColor);</span>
            }
            // Update Entity sprite's ECM status
<span class="nc" id="L5460">            int secondaryIdx = -1;</span>
<span class="nc bnc" id="L5461" title="All 2 branches missed.">            if (e.getSecondaryPositions().size() &gt; 0) {</span>
<span class="nc" id="L5462">                secondaryIdx = 0;</span>
            }
<span class="nc" id="L5464">            EntitySprite eSprite = entitySpriteIds.get(getIdAndLoc(e.getId(),</span>
                    secondaryIdx));
<span class="nc bnc" id="L5466" title="All 2 branches missed.">            if (eSprite != null) {</span>
<span class="nc" id="L5467">                Coords pos = e.getPosition();</span>
<span class="nc" id="L5468">                eSprite.setAffectedByECM(ComputeECM.isAffectedByECM(e, pos,</span>
                        pos, allEcmInfo));
            }
<span class="nc" id="L5471">        }</span>

        // Keep track of allied ECM and enemy ECCM
<span class="nc" id="L5474">        Map&lt;Coords, ECMEffects&gt; ecmAffectedCoords =</span>
                new HashMap&lt;Coords, ECMEffects&gt;();
        // Keep track of allied ECCM and enemy ECM
<span class="nc" id="L5477">        Map&lt;Coords, ECMEffects&gt; eccmAffectedCoords =</span>
                new HashMap&lt;Coords, ECMEffects&gt;();
<span class="nc bnc" id="L5479" title="All 2 branches missed.">        for (ECMInfo ecmInfo : allEcmInfo) {</span>
            // Can't see ECM field of unspotted unit
<span class="nc bnc" id="L5481" title="All 4 branches missed.">            if ((ecmInfo.getEntity() != null) &amp;&amp; (localPlayer != null)</span>
<span class="nc bnc" id="L5482" title="All 2 branches missed.">                    &amp;&amp; game.getOptions().booleanOption(OptionsConstants.ADVANCED_DOUBLE_BLIND)</span>
<span class="nc bnc" id="L5483" title="All 2 branches missed.">                    &amp;&amp; ecmInfo.getEntity().getOwner().isEnemyOf(localPlayer)</span>
<span class="nc bnc" id="L5484" title="All 2 branches missed.">                    &amp;&amp; !ecmInfo.getEntity().hasSeenEntity(localPlayer)</span>
<span class="nc bnc" id="L5485" title="All 2 branches missed.">                    &amp;&amp; !ecmInfo.getEntity().hasDetectedEntity(localPlayer)) {</span>
<span class="nc" id="L5486">                continue;</span>
            }
<span class="nc" id="L5488">            final Coords ecmPos = ecmInfo.getPos();</span>
<span class="nc" id="L5489">            final int range = ecmInfo.getRange();</span>

            // Add each Coords within range to the list of ECM Coords
<span class="nc bnc" id="L5492" title="All 2 branches missed.">            for (int x = -range; x &lt;= range; x++) {</span>
<span class="nc bnc" id="L5493" title="All 2 branches missed.">                for (int y = -range; y &lt;= range; y++) {</span>
<span class="nc" id="L5494">                    Coords c = new Coords(x + ecmPos.getX(), y + ecmPos.getY());</span>
<span class="nc" id="L5495">                    int dist = ecmPos.distance(c);</span>
<span class="nc" id="L5496">                    int dir = ecmInfo.getDirection();</span>
                    // Direction is the facing of the owning Entity
<span class="nc bnc" id="L5498" title="All 2 branches missed.">                    boolean inArc = (dir == -1)</span>
                            || Compute
<span class="nc bnc" id="L5500" title="All 2 branches missed.">                                    .isInArc(ecmPos, dir, c, Compute.ARC_NOSE);</span>
<span class="nc bnc" id="L5501" title="All 4 branches missed.">                    if ((dist &gt; range) || !inArc) {</span>
<span class="nc" id="L5502">                        continue;</span>
                    }

                    // Check for allied ECCM or enemy ECM
<span class="nc bnc" id="L5506" title="All 4 branches missed.">                    if ((!ecmInfo.isOpposed(localPlayer) &amp;&amp; ecmInfo.isECCM())</span>
<span class="nc bnc" id="L5507" title="All 4 branches missed.">                            || (ecmInfo.isOpposed(localPlayer) &amp;&amp; ecmInfo.isECCM())) {</span>
<span class="nc" id="L5508">                        ECMEffects ecmEffects = eccmAffectedCoords.get(c);</span>
<span class="nc bnc" id="L5509" title="All 2 branches missed.">                        if (ecmEffects == null) {</span>
<span class="nc" id="L5510">                            ecmEffects = new ECMEffects();</span>
<span class="nc" id="L5511">                            eccmAffectedCoords.put(c, ecmEffects);</span>
                        }
<span class="nc" id="L5513">                        ecmEffects.addECM(ecmInfo);</span>
<span class="nc" id="L5514">                    } else {</span>
<span class="nc" id="L5515">                        ECMEffects ecmEffects = ecmAffectedCoords.get(c);</span>
<span class="nc bnc" id="L5516" title="All 2 branches missed.">                        if (ecmEffects == null) {</span>
<span class="nc" id="L5517">                            ecmEffects = new ECMEffects();</span>
<span class="nc" id="L5518">                            ecmAffectedCoords.put(c, ecmEffects);</span>
                        }
<span class="nc" id="L5520">                        ecmEffects.addECM(ecmInfo);</span>
                    }
                }
            }
<span class="nc" id="L5524">        }</span>

        // Finally, determine the color for each affected hex
<span class="nc bnc" id="L5527" title="All 2 branches missed.">        for (Coords c : ecmAffectedCoords.keySet()) {</span>
<span class="nc" id="L5528">            ECMEffects ecm = ecmAffectedCoords.get(c);</span>
<span class="nc" id="L5529">            ECMEffects eccm = eccmAffectedCoords.get(c);</span>
<span class="nc" id="L5530">            processAffectedCoords(c, ecm, eccm, newECMHexes, newECCMHexes);</span>
<span class="nc" id="L5531">        }</span>
<span class="nc bnc" id="L5532" title="All 2 branches missed.">        for (Coords c : eccmAffectedCoords.keySet()) {</span>
<span class="nc" id="L5533">            ECMEffects ecm = ecmAffectedCoords.get(c);</span>
<span class="nc" id="L5534">            ECMEffects eccm = eccmAffectedCoords.get(c);</span>
            // Already processed all ECM affected coords
<span class="nc bnc" id="L5536" title="All 2 branches missed.">            if (ecm != null) {</span>
<span class="nc" id="L5537">             continue;</span>
            }
<span class="nc" id="L5539">            processAffectedCoords(c, ecm, eccm, newECMHexes, newECCMHexes);</span>
<span class="nc" id="L5540">        }</span>

<span class="nc" id="L5542">        Set&lt;Coords&gt; updatedHexes = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L5543" title="All 2 branches missed.">        if (ecmHexes != null) {</span>
<span class="nc" id="L5544">            updatedHexes.addAll(ecmHexes.keySet());</span>
        }
<span class="nc bnc" id="L5546" title="All 2 branches missed.">        if (eccmHexes != null) {</span>
<span class="nc" id="L5547">            updatedHexes.addAll(eccmHexes.keySet());</span>
        }
<span class="nc" id="L5549">        updatedHexes.addAll(newECMHexes.keySet());</span>
<span class="nc" id="L5550">        updatedHexes.addAll(newECCMHexes.keySet());</span>
<span class="nc" id="L5551">        clearHexImageCache(updatedHexes);</span>

<span class="nc" id="L5553">        synchronized (this) {</span>
<span class="nc" id="L5554">            ecmHexes    = newECMHexes;</span>
<span class="nc" id="L5555">            ecmCenters  = newECMCenters;</span>
<span class="nc" id="L5556">            eccmHexes   = newECCMHexes;</span>
<span class="nc" id="L5557">            eccmCenters = newECCMCenters;</span>
<span class="nc" id="L5558">        }</span>

<span class="nc" id="L5560">        repaint();</span>
<span class="nc" id="L5561">    }</span>

    private void processAffectedCoords(Coords c, ECMEffects ecm,
            ECMEffects eccm, Map&lt;Coords, Color&gt; newECMHexes,
            Map&lt;Coords, Color&gt; newECCMHexes) {
<span class="nc" id="L5566">        Color hexColorECM = null;</span>
<span class="nc bnc" id="L5567" title="All 2 branches missed.">        if (ecm != null) {</span>
<span class="nc" id="L5568">            hexColorECM = ecm.getHexColor();</span>
        }
<span class="nc" id="L5570">        Color hexColorECCM = null;</span>
<span class="nc bnc" id="L5571" title="All 2 branches missed.">        if (eccm != null) {</span>
<span class="nc" id="L5572">            hexColorECCM = eccm.getHexColor();</span>
        }
        // Hex color is null if all effects cancel out
<span class="nc bnc" id="L5575" title="All 4 branches missed.">        if ((hexColorECM == null) &amp;&amp; (hexColorECCM == null)) {</span>
<span class="nc" id="L5576">            return;</span>
<span class="nc bnc" id="L5577" title="All 4 branches missed.">        } else if ((hexColorECM != null) &amp;&amp; (hexColorECCM == null)) {</span>
<span class="nc bnc" id="L5578" title="All 2 branches missed.">            if (ecm.isECCM()) {</span>
<span class="nc" id="L5579">                newECCMHexes.put(c, hexColorECM);</span>
            } else {
<span class="nc" id="L5581">                newECMHexes.put(c, hexColorECM);</span>
            }
<span class="nc bnc" id="L5583" title="All 4 branches missed.">        } else if ((hexColorECM == null) &amp;&amp; (hexColorECCM != null)) {</span>
<span class="nc bnc" id="L5584" title="All 2 branches missed.">            if (eccm.isECCM()) {</span>
<span class="nc" id="L5585">                newECCMHexes.put(c, hexColorECCM);</span>
            } else {
<span class="nc" id="L5587">                newECMHexes.put(c, hexColorECCM);</span>
            }
        } else { // Both are non-null
<span class="nc" id="L5590">            newECMHexes.put(c, hexColorECM);</span>
<span class="nc" id="L5591">            newECCMHexes.put(c, hexColorECCM);</span>
        }
<span class="nc" id="L5593">    }</span>

    public Dimension getPreferredScrollableViewportSize() {
<span class="nc" id="L5596">        return getPreferredSize();</span>
    }

    public int getScrollableBlockIncrement(Rectangle arg0, int arg1, int arg2) {
<span class="nc" id="L5600">        final Dimension size = scrollpane.getViewport().getSize();</span>
<span class="nc bnc" id="L5601" title="All 2 branches missed.">        if (arg1 == SwingConstants.VERTICAL) {</span>
<span class="nc" id="L5602">            return size.height;</span>
        }
<span class="nc" id="L5604">        return size.width;</span>
    }

    public boolean getScrollableTracksViewportHeight() {
<span class="nc" id="L5608">        return false;</span>
    }

    public boolean getScrollableTracksViewportWidth() {
<span class="nc" id="L5612">        return false;</span>
    }

    public int getScrollableUnitIncrement(Rectangle arg0, int arg1, int arg2) {
<span class="nc bnc" id="L5616" title="All 2 branches missed.">        if (arg1 == SwingConstants.VERTICAL) {</span>
<span class="nc" id="L5617">            return (int) ((scale * HEX_H) / 2.0);</span>
        }
<span class="nc" id="L5619">        return (int) ((scale * HEX_W) / 2.0);</span>
    }

    @Override
    public void setPreferredSize(Dimension d) {
<span class="nc" id="L5624">        super.setPreferredSize(d);</span>
<span class="nc" id="L5625">        preferredSize = new Dimension(d);</span>
<span class="nc" id="L5626">    }</span>

    @Override
    public Dimension getPreferredSize() {
        // If the board is small, we want the preferred size to fill the whole
        //  ScrollPane viewport, for purposes of drawing the tiled background
        //  icon.
        // However, we also need the scrollable client to be as big as the
        //  board plus the pad size.
<span class="nc" id="L5635">        return new Dimension(</span>
<span class="nc" id="L5636">                Math.max(boardSize.width + (2 * HEX_W), preferredSize.width),</span>
<span class="nc" id="L5637">                Math.max(boardSize.height + (2 * HEX_W), preferredSize.height));</span>
    }

    /**
     * Have the player select an Entity from the entities at the given coords.
     *
     * @param pos - the &lt;code&gt;Coords&lt;/code&gt; containing targets.
     */
    private Entity chooseEntity(Coords pos) {

        // Assume that we have *no* choice.
<span class="nc" id="L5648">        Entity choice = null;</span>

        // Get the available choices.
<span class="nc" id="L5651">        List&lt;Entity&gt; entities = game.getEntitiesVector(pos);</span>


        // Do we have a single choice?
<span class="nc bnc" id="L5655" title="All 2 branches missed.">        if (entities.size() == 1) {</span>
            // Return that choice.
<span class="nc" id="L5657">            choice = entities.get(0);</span>
        }

        // If we have multiple choices, display a selection dialog.
<span class="nc bnc" id="L5661" title="All 2 branches missed.">        else if (entities.size() &gt; 1) {</span>
<span class="nc" id="L5662">            String input = (String) JOptionPane</span>
<span class="nc" id="L5663">                    .showInputDialog(</span>
                            null,
<span class="nc" id="L5665">                            Messages.getString(</span>
<span class="nc" id="L5666">                                    &quot;BoardView1.ChooseEntityDialog.message&quot;, new Object[]{pos.getBoardNum()}), //$NON-NLS-1$</span>
<span class="nc" id="L5667">                            Messages.getString(&quot;BoardView1.ChooseEntityDialog.title&quot;), //$NON-NLS-1$</span>
                            JOptionPane.QUESTION_MESSAGE, null, SharedUtility
<span class="nc" id="L5669">                                    .getDisplayArray(entities), null);</span>
<span class="nc" id="L5670">            choice = (Entity) SharedUtility.getTargetPicked(entities, input);</span>
        } // End have-choices

        // Return the chosen unit.
<span class="nc" id="L5674">        return choice;</span>
    }


    /**
     * The text to be displayed when the mouse is at a certain point.
     */
    @Override
    public String getToolTipText(MouseEvent e) {
        // If new instance of mouse event, redraw obscured hexes and elevations.
<span class="nc" id="L5684">        repaint();</span>

<span class="nc" id="L5686">        StringBuffer txt = new StringBuffer();</span>
<span class="nc" id="L5687">        IHex mhex = null;</span>
<span class="nc" id="L5688">        final Point point = e.getPoint();</span>
<span class="nc bnc" id="L5689" title="All 4 branches missed.">        if (prevTipX &gt; 0 &amp;&amp; prevTipY &gt; 0) {</span>
<span class="nc" id="L5690">            int deltaX = point.x - prevTipX;</span>
<span class="nc" id="L5691">            int deltaY = point.y - prevTipY;</span>
<span class="nc" id="L5692">            double deltaMagnitude = Math.sqrt(deltaX * deltaX + deltaY * deltaY);</span>
<span class="nc bnc" id="L5693" title="All 2 branches missed.">            if (deltaMagnitude &gt; GUIPreferences.getInstance().getTooltipDistSuppression()) {</span>
<span class="nc" id="L5694">                prevTipX = -1; prevTipY = -1;</span>
                // Set the dismissal delay to 0 so that the tooltip
                // goes away and does not reappear until the mouse
                // has moved more than the suppression distance
<span class="nc" id="L5698">                ToolTipManager.sharedInstance().setDismissDelay(0);</span>
<span class="nc" id="L5699">                return new String(&quot;&quot;); //$NON-NLS-1$</span>
            }
        }
<span class="nc" id="L5702">        prevTipX = point.x; prevTipY = point.y;</span>
<span class="nc" id="L5703">        final Coords mcoords = getCoordsAt(point);</span>
<span class="nc" id="L5704">        final ArrayList&lt;ArtilleryAttackAction&gt; artilleryAttacks =</span>
<span class="nc" id="L5705">                getArtilleryAttacksAtLocation(mcoords);</span>
<span class="nc" id="L5706">        final Mounted curWeapon = getSelectedArtilleryWeapon();</span>

<span class="nc bnc" id="L5708" title="All 2 branches missed.">        if (game.getBoard().contains(mcoords))</span>
<span class="nc" id="L5709">            mhex = game.getBoard().getHex(mcoords);</span>

<span class="nc" id="L5711">        txt.append(&quot;&lt;html&gt;&quot;); //$NON-NLS-1$</span>


        // Hex Terrain
<span class="nc bnc" id="L5715" title="All 4 branches missed.">        if (GUIPreferences.getInstance().getShowMapHexPopup() &amp;&amp; (mhex != null)) {</span>

<span class="nc" id="L5717">            txt.append(&quot;&lt;TABLE BORDER=0 BGCOLOR=#DDFFDD width=100%&gt;&lt;TR&gt;&lt;TD&gt;&lt;FONT color=\&quot;black\&quot;&gt;&quot;); //$NON-NLS-1$</span>

<span class="nc" id="L5719">            txt.append(Messages.getString(&quot;BoardView1.Tooltip.Hex&quot;, //$NON-NLS-1$</span>
<span class="nc" id="L5720">                    new Object[] { mcoords.getBoardNum(), mhex.getLevel() }));</span>
<span class="nc" id="L5721">            txt.append(&quot;&lt;br&gt;&quot;); //$NON-NLS-1$</span>

            // cycle through the terrains and report types found
            // this will skip buildings and other constructed units
<span class="nc" id="L5725">            int terrainTypes[] = mhex.getTerrainTypes();</span>
<span class="nc bnc" id="L5726" title="All 2 branches missed.">            for (int i = 0; i &lt; terrainTypes.length; i++) {</span>
<span class="nc" id="L5727">                int terType = terrainTypes[i];</span>
<span class="nc bnc" id="L5728" title="All 2 branches missed.">                if (mhex.containsTerrain(terType)) {</span>
<span class="nc" id="L5729">                    int tf = mhex.getTerrain(terType).getTerrainFactor();</span>
<span class="nc" id="L5730">                    int ttl = mhex.getTerrain(terType).getLevel();</span>
<span class="nc" id="L5731">                    String name = Terrains.getDisplayName(terType, ttl);</span>
<span class="nc bnc" id="L5732" title="All 2 branches missed.">                    if (tf &gt; 0) {</span>
<span class="nc" id="L5733">                        name = name + &quot; (TF: &quot; + tf + &quot;)&quot;; //$NON-NLS-1$ //$NON-NLS-2$</span>
                    }
<span class="nc bnc" id="L5735" title="All 2 branches missed.">                    if (name != null) {</span>
<span class="nc" id="L5736">                        txt.append(name);</span>
<span class="nc" id="L5737">                        txt.append(&quot;&lt;br&gt;&quot;); //$NON-NLS-1$</span>
                    }
                }
            }
<span class="nc" id="L5741">            txt.append(&quot;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&quot;); //$NON-NLS-1$</span>

            // Distance from the selected unit and a planned movement end point
<span class="nc bnc" id="L5744" title="All 2 branches missed.">            if ((selectedEntity != null) &amp;&amp;</span>
<span class="nc bnc" id="L5745" title="All 2 branches missed.">                    (selectedEntity.getPosition() != null)) {</span>
<span class="nc" id="L5746">                int distance = selectedEntity</span>
<span class="nc" id="L5747">                        .getPosition()</span>
<span class="nc" id="L5748">                        .distance(mcoords);</span>
<span class="nc" id="L5749">                txt.append(&quot;&lt;TABLE BORDER=0 BGCOLOR=#FFDDDD width=100%&gt;&lt;TR&gt;&lt;TD&gt;&lt;FONT color=\&quot;black\&quot;&gt;&quot;); //$NON-NLS-1$</span>
<span class="nc bnc" id="L5750" title="All 2 branches missed.">                if (distance == 1) {</span>
<span class="nc" id="L5751">                    txt.append(Messages.getString(&quot;BoardView1.Tooltip.Distance1&quot;)); //$NON-NLS-1$</span>
                } else {
<span class="nc" id="L5753">                    txt.append(Messages.getString(&quot;BoardView1.Tooltip.DistanceN&quot;, //$NON-NLS-1$</span>
<span class="nc" id="L5754">                            new Object[] { distance }));</span>
                }

<span class="nc bnc" id="L5757" title="All 2 branches missed.">                if (game.getOptions().booleanOption(OptionsConstants.ADVANCED_TACOPS_SENSORS)) {</span>
<span class="nc" id="L5758">                    LosEffects los = fovHighlightingAndDarkening.getCachedLosEffects(selectedEntity.getPosition(), mcoords);</span>
<span class="nc" id="L5759">                    int bracket = Compute.getSensorRangeBracket(selectedEntity, null,</span>
                            fovHighlightingAndDarkening.cachedAllECMInfo);
<span class="nc" id="L5761">                    int range = Compute.getSensorRangeByBracket(game, selectedEntity, null, los);</span>

<span class="nc" id="L5763">                    int maxSensorRange = bracket * range;</span>
<span class="nc" id="L5764">                    int minSensorRange = Math.max((bracket - 1) * range, 0);</span>
<span class="nc bnc" id="L5765" title="All 2 branches missed.">                    if (game.getOptions().booleanOption(OptionsConstants.ADVANCED_INCLUSIVE_SENSOR_RANGE)) {</span>
<span class="nc" id="L5766">                        minSensorRange = 0;</span>
                    }
<span class="nc" id="L5768">                    txt.append(&quot;&lt;BR&gt;&quot;);</span>
<span class="nc bnc" id="L5769" title="All 4 branches missed.">                    if ((distance &gt; minSensorRange) &amp;&amp; (distance &lt;= maxSensorRange)) {</span>
<span class="nc" id="L5770">                        txt.append(Messages.getString(&quot;BoardView1.Tooltip.SensorsHexInRange&quot;));</span>
                    } else {
<span class="nc" id="L5772">                        txt.append(Messages.getString(&quot;BoardView1.Tooltip.SensorsHexNotInRange&quot;));</span>
                    }
                }

<span class="nc bnc" id="L5776" title="All 4 branches missed.">                if ((game.getPhase() == Phase.PHASE_MOVEMENT) &amp;&amp;</span>
                        (movementTarget != null)) {
<span class="nc" id="L5778">                    txt.append(&quot;&lt;BR&gt;&quot;);</span>
<span class="nc" id="L5779">                    int disPM = movementTarget.distance(mcoords);</span>
<span class="nc bnc" id="L5780" title="All 2 branches missed.">                    if (disPM == 1) {</span>
<span class="nc" id="L5781">                        txt.append(Messages.getString(&quot;BoardView1.Tooltip.DistanceMove1&quot;)); //$NON-NLS-1$</span>
                    } else {
<span class="nc" id="L5783">                        txt.append(Messages.getString(&quot;BoardView1.Tooltip.DistanceMoveN&quot;, //$NON-NLS-1$</span>
<span class="nc" id="L5784">                                new Object[] { disPM }));</span>
                    }
                }

<span class="nc" id="L5788">                txt.append(&quot;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&quot;); //$NON-NLS-1$</span>
            }

            // Fuel Tank
<span class="nc bnc" id="L5792" title="All 2 branches missed.">            if (mhex.containsTerrain(Terrains.FUEL_TANK)) {</span>
                // In the BoardEditor, buildings have no entry in the
                // buildings list of the board, so get the info from the hex
<span class="nc bnc" id="L5795" title="All 2 branches missed.">                if (clientgui == null) {</span>
<span class="nc" id="L5796">                    txt.append(&quot;&lt;TABLE BORDER=0 BGCOLOR=#999999 width=100%&gt;&lt;TR&gt;&lt;TD&gt;&lt;FONT color=\&quot;black\&quot;&gt;&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L5797">                    txt.append(Messages.getString(&quot;BoardView1.Tooltip.FuelTank&quot;, new Object[] { //$NON-NLS-1$</span>
<span class="nc" id="L5798">                            mhex.terrainLevel(Terrains.FUEL_TANK_ELEV),</span>
<span class="nc" id="L5799">                            Terrains.getEditorName(Terrains.FUEL_TANK),</span>
<span class="nc" id="L5800">                            mhex.terrainLevel(Terrains.FUEL_TANK_CF),</span>
<span class="nc" id="L5801">                            mhex.terrainLevel(Terrains.FUEL_TANK_MAGN)</span>
                    }));
                } else {
<span class="nc" id="L5804">                    Building bldg = game.getBoard().getBuildingAt(mcoords);</span>
<span class="nc" id="L5805">                    txt.append(&quot;&lt;TABLE BORDER=0 BGCOLOR=#999999 width=100%&gt;&lt;TR&gt;&lt;TD&gt;&lt;FONT color=\&quot;black\&quot;&gt;&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L5806">                    txt.append(Messages.getString(&quot;BoardView1.Tooltip.FuelTank&quot;, new Object[] { //$NON-NLS-1$</span>
<span class="nc" id="L5807">                            mhex.terrainLevel(Terrains.FUEL_TANK_ELEV),</span>
<span class="nc" id="L5808">                            bldg.toString(),</span>
<span class="nc" id="L5809">                            bldg.getCurrentCF(mcoords)</span>
                    }));
                }
<span class="nc" id="L5812">                txt.append(&quot;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&quot;); //$NON-NLS-1$</span>
            }

            // Building
<span class="nc bnc" id="L5816" title="All 2 branches missed.">            if (mhex.containsTerrain(Terrains.BUILDING)) {</span>
                // In the BoardEditor, buildings have no entry in the
                // buildings list of the board, so get the info from the hex
<span class="nc bnc" id="L5819" title="All 2 branches missed.">                if (clientgui == null) {</span>
<span class="nc" id="L5820">                    txt.append(&quot;&lt;TABLE BORDER=0 BGCOLOR=#999999 width=100%&gt;&lt;TR&gt;&lt;TD&gt;&lt;FONT color=\&quot;black\&quot;&gt;&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L5821">                    txt.append(Messages.getString(&quot;BoardView1.Tooltip.Building&quot;, new Object[] { //$NON-NLS-1$</span>
<span class="nc" id="L5822">                            mhex.terrainLevel(Terrains.BLDG_ELEV),</span>
<span class="nc" id="L5823">                            Terrains.getEditorName(Terrains.BUILDING),</span>
<span class="nc" id="L5824">                            mhex.terrainLevel(Terrains.BLDG_CF),</span>
<span class="nc" id="L5825">                            Math.max(mhex.terrainLevel(Terrains.BLDG_ARMOR),0),</span>
<span class="nc" id="L5826">                            BasementType.getType(mhex.terrainLevel(Terrains.BLDG_BASEMENT_TYPE)).toString()</span>
                    }));
                } else {
<span class="nc" id="L5829">                    Building bldg = game.getBoard().getBuildingAt(mcoords);</span>
<span class="nc" id="L5830">                    txt.append(&quot;&lt;TABLE BORDER=0 BGCOLOR=#CCCC99 width=100%&gt;&lt;TR&gt;&lt;TD&gt;&lt;FONT color=\&quot;black\&quot;&gt;&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L5831">                    txt.append(Messages.getString(&quot;BoardView1.Tooltip.Building&quot;, new Object[] { //$NON-NLS-1$</span>
<span class="nc" id="L5832">                            mhex.terrainLevel(Terrains.BLDG_ELEV),</span>
<span class="nc" id="L5833">                            bldg.toString(),</span>
<span class="nc" id="L5834">                            bldg.getCurrentCF(mcoords),</span>
<span class="nc" id="L5835">                            bldg.getArmor(mcoords),</span>
<span class="nc" id="L5836">                            bldg.getBasement(mcoords).getDesc()</span>
                    }));

<span class="nc bnc" id="L5839" title="All 2 branches missed.">                    if (bldg.getBasementCollapsed(mcoords)) {</span>
<span class="nc" id="L5840">                        txt.append(Messages</span>
<span class="nc" id="L5841">                                .getString(&quot;BoardView1.Tooltip.BldgBasementCollapsed&quot;)); //$NON-NLS-1$</span>
                    }
                }
<span class="nc" id="L5844">                txt.append(&quot;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&quot;); //$NON-NLS-1$</span>
            }

            // Bridge
<span class="nc bnc" id="L5848" title="All 2 branches missed.">            if (mhex.containsTerrain(Terrains.BRIDGE)) {</span>
                // In the BoardEditor, buildings have no entry in the
                // buildings list of the board, so get the info from the hex
<span class="nc bnc" id="L5851" title="All 2 branches missed.">                if (clientgui == null) {</span>
<span class="nc" id="L5852">                    txt.append(&quot;&lt;TABLE BORDER=0 BGCOLOR=#999999 width=100%&gt;&lt;TR&gt;&lt;TD&gt;&lt;FONT color=\&quot;black\&quot;&gt;&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L5853">                    txt.append(Messages.getString(&quot;BoardView1.Tooltip.Bridge&quot;, new Object[] { //$NON-NLS-1$</span>
<span class="nc" id="L5854">                            mhex.terrainLevel(Terrains.BRIDGE_ELEV),</span>
<span class="nc" id="L5855">                            Terrains.getEditorName(Terrains.BRIDGE),</span>
<span class="nc" id="L5856">                            mhex.terrainLevel(Terrains.BRIDGE_CF),</span>
                    }));
                } else {
<span class="nc" id="L5859">                    Building bldg = game.getBoard().getBuildingAt(mcoords);</span>
<span class="nc" id="L5860">                    txt.append(&quot;&lt;TABLE BORDER=0 BGCOLOR=#999999 width=100%&gt;&lt;TR&gt;&lt;TD&gt;&lt;FONT color=\&quot;black\&quot;&gt;&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L5861">                    txt.append(Messages.getString(&quot;BoardView1.Tooltip.Bridge&quot;, new Object[] { //$NON-NLS-1$</span>
<span class="nc" id="L5862">                            mhex.terrainLevel(Terrains.BRIDGE_ELEV),</span>
<span class="nc" id="L5863">                            bldg.toString(),</span>
<span class="nc" id="L5864">                            bldg.getCurrentCF(mcoords),</span>
                    }));
                }
<span class="nc" id="L5867">                txt.append(&quot;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&quot;); //$NON-NLS-1$</span>
            }

<span class="nc bnc" id="L5870" title="All 2 branches missed.">            if (game.containsMinefield(mcoords)) {</span>
<span class="nc" id="L5871">                Vector&lt;Minefield&gt; minefields = game.getMinefields(mcoords);</span>
<span class="nc bnc" id="L5872" title="All 2 branches missed.">                for (int i = 0; i &lt; minefields.size(); i++) {</span>
<span class="nc" id="L5873">                    Minefield mf = minefields.elementAt(i);</span>
<span class="nc" id="L5874">                    String owner = &quot; (&quot; //$NON-NLS-1$</span>
<span class="nc" id="L5875">                                   + game.getPlayer(mf.getPlayerId()).getName()</span>
                                   + &quot;)&quot;; //$NON-NLS-1$

<span class="nc bnc" id="L5878" title="All 6 branches missed.">                    switch (mf.getType()) {</span>
                        case (Minefield.TYPE_CONVENTIONAL):
<span class="nc" id="L5880">                            txt.append(mf.getName()</span>
<span class="nc" id="L5881">                                       + Messages.getString(&quot;BoardView1.minefield&quot;) //$NON-NLS-1$</span>
<span class="nc" id="L5882">                                       + &quot;(&quot; + mf.getDensity() + &quot;)&quot; + &quot; &quot; + owner); //$NON-NLS-1$ //$NON-NLS-2$</span>
<span class="nc" id="L5883">                            break;</span>
                        case (Minefield.TYPE_COMMAND_DETONATED):
<span class="nc" id="L5885">                            txt.append(mf.getName()</span>
<span class="nc" id="L5886">                                       + Messages.getString(&quot;BoardView1.minefield&quot;) //$NON-NLS-1$</span>
<span class="nc" id="L5887">                                       + &quot;(&quot; + mf.getDensity() + &quot;)&quot; + &quot; &quot; + owner); //$NON-NLS-1$ //$NON-NLS-2$</span>
<span class="nc" id="L5888">                            break;</span>
                        case (Minefield.TYPE_VIBRABOMB):
<span class="nc bnc" id="L5890" title="All 2 branches missed.">                            if (mf.getPlayerId() == localPlayer.getId()) {</span>
<span class="nc" id="L5891">                                txt.append(mf.getName()</span>
                                           + Messages
<span class="nc" id="L5893">                                        .getString(&quot;BoardView1.minefield&quot;) //$NON-NLS-1$</span>
<span class="nc" id="L5894">                                           + &quot;(&quot; + mf.getDensity() + &quot;)&quot; + &quot;(&quot; //$NON-NLS-1$</span>
<span class="nc" id="L5895">                                           + mf.getSetting() + &quot;) &quot; + owner); //$NON-NLS-1$ //$NON-NLS-2$</span>
                            } else {
<span class="nc" id="L5897">                                txt.append(mf.getName()</span>
                                           + Messages
<span class="nc" id="L5899">                                        .getString(&quot;BoardView1.minefield&quot;) //$NON-NLS-1$</span>
<span class="nc" id="L5900">                                           + &quot;(&quot; + mf.getDensity() + &quot;)&quot; + &quot; &quot; + owner); //$NON-NLS-1$ //$NON-NLS-2$</span>
                            }
<span class="nc" id="L5902">                            break;</span>
                        case (Minefield.TYPE_ACTIVE):
<span class="nc" id="L5904">                            txt.append(mf.getName()</span>
<span class="nc" id="L5905">                                       + Messages.getString(&quot;BoardView1.minefield&quot;) //$NON-NLS-1$</span>
<span class="nc" id="L5906">                                       + &quot;(&quot; + mf.getDensity() + &quot;)&quot; + owner); //$NON-NLS-1$ //$NON-NLS-2$</span>
<span class="nc" id="L5907">                            break;</span>
                        case (Minefield.TYPE_INFERNO):
<span class="nc" id="L5909">                            txt.append(mf.getName()</span>
<span class="nc" id="L5910">                                       + Messages.getString(&quot;BoardView1.minefield&quot;) //$NON-NLS-1$</span>
<span class="nc" id="L5911">                                       + &quot;(&quot; + mf.getDensity() + &quot;)&quot; + owner); //$NON-NLS-1$ //$NON-NLS-2$</span>
                            break;
                    }
<span class="nc" id="L5914">                    txt.append(&quot;&lt;br&gt;&quot;); //$NON-NLS-1$</span>
                }
            }

<span class="nc bnc" id="L5918" title="All 2 branches missed.">            if (displayInvalidHexInfo) {</span>
<span class="nc" id="L5919">                StringBuffer errBuff = new StringBuffer();</span>
<span class="nc bnc" id="L5920" title="All 2 branches missed.">                if (!mhex.isValid(errBuff)) {</span>
<span class="nc" id="L5921">                    txt.append(Messages.getString(&quot;BoardView1.invalidHex&quot;));</span>
<span class="nc" id="L5922">                    txt.append(&quot;&lt;br&gt;&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L5923">                    String errors = errBuff.toString();</span>
<span class="nc" id="L5924">                    errors = errors.replace(&quot;\n&quot;, &quot;&lt;br&gt;&quot;);</span>
<span class="nc" id="L5925">                    txt.append(errors);</span>
<span class="nc" id="L5926">                    txt.append(&quot;&lt;br&gt;&quot;); //$NON-NLS-1$</span>
                }
            }
        }

        // Show the player(s) that may deploy here
        // in the artillery autohit designation phase
<span class="nc bnc" id="L5933" title="All 4 branches missed.">        if ((game.getPhase() == IGame.Phase.PHASE_SET_ARTYAUTOHITHEXES) &amp;&amp; (mhex != null)) {</span>
<span class="nc" id="L5934">            txt.append(&quot;&lt;TABLE BORDER=0 width=100%&gt;&lt;TR&gt;&lt;TD&gt;&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L5935">            Enumeration&lt;IPlayer&gt; allP = game.getPlayers();</span>
<span class="nc" id="L5936">            boolean foundPlayer = false;</span>
            // loop through all players
<span class="nc bnc" id="L5938" title="All 2 branches missed.">            while (allP.hasMoreElements())</span>
            {
<span class="nc" id="L5940">                IPlayer cp = allP.nextElement();</span>
<span class="nc bnc" id="L5941" title="All 2 branches missed.">                if (game.getBoard().isLegalDeployment(mcoords, cp.getStartingPos())) {</span>
<span class="nc bnc" id="L5942" title="All 2 branches missed.">                    if (!foundPlayer) {</span>
<span class="nc" id="L5943">                        foundPlayer = true;</span>
<span class="nc" id="L5944">                        txt.append(Messages.getString(&quot;BoardView1.Tooltip.ArtyAutoHeader&quot;)); //$NON-NLS-1$</span>
                    }
<span class="nc" id="L5946">                    txt.append(&quot;&lt;B&gt;&lt;FONT COLOR=#&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L5947">                    txt.append(cp.getColour().getHexString());</span>
<span class="nc" id="L5948">                    txt.append(&quot;&gt;&amp;nbsp;&amp;nbsp;&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L5949">                    txt.append(cp.getName());</span>
<span class="nc" id="L5950">                    txt.append(&quot;&lt;/FONT&gt;&lt;/B&gt;&lt;BR&gt;&quot;); //$NON-NLS-1$</span>
                }
<span class="nc" id="L5952">            }</span>
<span class="nc bnc" id="L5953" title="All 2 branches missed.">            if (foundPlayer) txt.append(&quot;&lt;BR&gt;&quot;); //$NON-NLS-1$</span>

            // Add a hint with keybind that the zones can be shown graphically
<span class="nc" id="L5956">            String keybindText = KeyEvent.getKeyModifiersText(KeyCommandBind.getBindByCmd(&quot;autoArtyDeployZone&quot;).modifiers);</span>
<span class="nc bnc" id="L5957" title="All 2 branches missed.">            if (!keybindText.isEmpty()) keybindText += &quot;+&quot;;</span>
<span class="nc" id="L5958">            keybindText += KeyEvent.getKeyText(KeyCommandBind.getBindByCmd(&quot;autoArtyDeployZone&quot;).key);</span>
<span class="nc" id="L5959">            txt.append(Messages.getString(&quot;BoardView1.Tooltip.ArtyAutoHint&quot;, keybindText));</span>

<span class="nc" id="L5961">            txt.append(&quot;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&quot;); //$NON-NLS-1$</span>
        }


        // check if it's on any flares
<span class="nc bnc" id="L5966" title="All 2 branches missed.">        for (FlareSprite fSprite : flareSprites) {</span>
<span class="nc bnc" id="L5967" title="All 2 branches missed.">            if (fSprite.isInside(point)) {</span>
<span class="nc" id="L5968">                txt.append(fSprite.getTooltip().toString());</span>
            }
<span class="nc" id="L5970">        }</span>

        // check if it's on any attacks
<span class="nc bnc" id="L5973" title="All 2 branches missed.">        for (AttackSprite aSprite : attackSprites) {</span>
<span class="nc bnc" id="L5974" title="All 2 branches missed.">            if (aSprite.isInside(point)) {</span>
<span class="nc" id="L5975">                txt.append(&quot;&lt;TABLE BORDER=0 BGCOLOR=#FFDDDD width=100%&gt;&lt;TR&gt;&lt;TD&gt;&lt;FONT color=\&quot;black\&quot;&gt;&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L5976">                txt.append(aSprite.getTooltip().toString());</span>
<span class="nc" id="L5977">                txt.append(&quot;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&quot;); //$NON-NLS-1$</span>
            }
<span class="nc" id="L5979">        }</span>

        // Entity tooltips
<span class="nc" id="L5982">        int entityCount = 0;</span>
        // Maximum number of entities to show in the tooltip
<span class="nc" id="L5984">        int maxShown = 4;</span>

<span class="nc" id="L5986">        Set&lt;Entity&gt; coordEnts = new HashSet&lt;&gt;(game.getEntitiesVector(mcoords));</span>
<span class="nc" id="L5987">        Set&lt;Entity&gt; usedSet = new HashSet&lt;Entity&gt;(entitySprites.size());</span>
<span class="nc bnc" id="L5988" title="All 2 branches missed.">        for (EntitySprite eSprite : entitySprites) {</span>
<span class="nc bnc" id="L5989" title="All 4 branches missed.">            if ((eSprite.isInside(point) || coordEnts.contains(eSprite.entity))</span>
<span class="nc bnc" id="L5990" title="All 2 branches missed.">                    &amp;&amp; !usedSet.contains(eSprite.entity)) {</span>
<span class="nc" id="L5991">                usedSet.add(eSprite.entity);</span>
<span class="nc" id="L5992">                entityCount++;</span>

                // List only the first four units
<span class="nc bnc" id="L5995" title="All 2 branches missed.">                if (entityCount &lt;= maxShown) {</span>
                    // Table to add a bar to the left of an entity in
                    // the player's color
<span class="nc" id="L5998">                    txt.append(&quot;&lt;hr style=width:90%&gt;&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L5999">                    txt.append(&quot;&lt;TABLE&gt;&lt;TR&gt;&lt;TD bgcolor=#&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L6000">                    txt.append(eSprite.getPlayerColor());</span>
<span class="nc" id="L6001">                    txt.append(&quot; width=6&gt;&lt;/TD&gt;&lt;TD&gt;&quot;); //$NON-NLS-1$</span>

                    // TT generated by Sprite
<span class="nc" id="L6004">                    txt.append(eSprite.getTooltip());</span>

                    // ECM and ECCM source
<span class="nc bnc" id="L6007" title="All 2 branches missed.">                    if (eSprite.entity.hasActiveECM()) {</span>
<span class="nc" id="L6008">                        txt.append(&quot;&lt;br&gt;&lt;FONT SIZE=-2&gt;&lt;img src=file:&quot; //$NON-NLS-1$</span>
<span class="nc" id="L6009">                                + Configuration.widgetsDir()</span>
                                + &quot;/Tooltip/ECM_BW.png&gt;&amp;nbsp;&quot;); //$NON-NLS-1$
<span class="nc" id="L6011">                        txt.append(Messages.getString(&quot;BoardView1.ecmSource&quot;)); //$NON-NLS-1$</span>
<span class="nc" id="L6012">                        txt.append(&quot;&lt;/FONT&gt;&quot;); //$NON-NLS-1$</span>
                    }
<span class="nc bnc" id="L6014" title="All 2 branches missed.">                    if (eSprite.entity.hasActiveECCM()) {</span>
<span class="nc" id="L6015">                        txt.append(&quot;&lt;br&gt;&lt;FONT SIZE=-2&gt;&lt;img src=file:&quot; //$NON-NLS-1$</span>
<span class="nc" id="L6016">                                + Configuration.widgetsDir()</span>
                                + &quot;/Tooltip/ECM_BW.png&gt;&amp;nbsp;&quot;); //$NON-NLS-1$
<span class="nc" id="L6018">                        txt.append(Messages.getString(&quot;BoardView1.eccmSource&quot;)); //$NON-NLS-1$</span>
<span class="nc" id="L6019">                        txt.append(&quot;&lt;/FONT&gt;&quot;);</span>
                    }

<span class="nc" id="L6022">                    txt.append(&quot;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&quot;); //$NON-NLS-1$</span>
                }
            }
<span class="nc" id="L6025">        }</span>
        // Info block if there are more than 4 units in that hex
<span class="nc bnc" id="L6027" title="All 2 branches missed.">        if (entityCount &gt; maxShown)</span>
        {
<span class="nc" id="L6029">            txt.append(&quot;&lt;TABLE BORDER=0 BGCOLOR=#000060 width=100%&gt;&lt;TR&gt;&lt;TD&gt;&lt;FONT COLOR=WHITE&gt;There &quot;);</span>
<span class="nc bnc" id="L6030" title="All 2 branches missed.">            if (entityCount-maxShown == 1)</span>
<span class="nc" id="L6031">                txt.append(&quot;is 1 more&lt;BR&gt;unit&quot;);</span>
            else
<span class="nc" id="L6033">                txt.append(&quot;are &quot;+(entityCount-maxShown)+&quot; more&lt;BR&gt;units&quot;);</span>
<span class="nc" id="L6034">            txt.append(&quot; in this hex...&lt;/FONT&gt;&quot;);</span>
<span class="nc" id="L6035">            txt.append(&quot;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&quot;);</span>
        }

        // Artillery attacks
<span class="nc bnc" id="L6039" title="All 2 branches missed.">        for (ArtilleryAttackAction aaa : artilleryAttacks) {</span>
            // Default texts if no real names can be found
<span class="nc" id="L6041">            String wpName = Messages.getString(&quot;BoardView1.Artillery&quot;);</span>
<span class="nc" id="L6042">            String ammoName = &quot;Unknown&quot;;</span>

            // Get real weapon and ammo name
<span class="nc" id="L6045">            final Entity artyEnt = game.getEntity(aaa.getEntityId());</span>
<span class="nc bnc" id="L6046" title="All 2 branches missed.">            if (artyEnt != null) {</span>
<span class="nc bnc" id="L6047" title="All 2 branches missed.">                if (aaa.getWeaponId() &gt; -1) {</span>
<span class="nc" id="L6048">                    wpName = artyEnt.getEquipment(aaa.getWeaponId()).getName();</span>
<span class="nc bnc" id="L6049" title="All 2 branches missed.">                    if (aaa.getAmmoId() &gt; -1) {</span>
<span class="nc" id="L6050">                        ammoName =  artyEnt.getEquipment(aaa.getAmmoId()).getName();</span>
                    }
                }
            }

<span class="nc" id="L6055">            txt.append(&quot;&lt;TABLE BORDER=0 BGCOLOR=#FFDDDD width=100%&gt;&lt;TR&gt;&lt;TD&gt;&lt;FONT color=\&quot;black\&quot;&gt;&quot;);</span>
<span class="nc bnc" id="L6056" title="All 2 branches missed.">            if (aaa.getTurnsTilHit() == 1)</span>
<span class="nc" id="L6057">                txt.append(Messages.getString(&quot;BoardView1.Tooltip.ArtilleryAttack1&quot;,</span>
                        new Object[] { wpName, ammoName }));
            else
<span class="nc" id="L6060">                txt.append(Messages.getString(&quot;BoardView1.Tooltip.ArtilleryAttackN&quot;,</span>
<span class="nc" id="L6061">                        new Object[] { wpName, ammoName, aaa.getTurnsTilHit() }));</span>
<span class="nc" id="L6062">            txt.append(&quot;&lt;/FONT&gt;&lt;/TD&gt;&lt;/TR&gt;&lt;/TABLE&gt;&quot;);</span>
<span class="nc" id="L6063">        }</span>

        // Artillery fire adjustment
<span class="nc bnc" id="L6066" title="All 4 branches missed.">        if ((curWeapon != null) &amp;&amp; (selectedEntity != null)) {</span>
            // process targetted hexes
<span class="nc" id="L6068">            int amod = 0;</span>
            // Check the predesignated hexes
<span class="nc" id="L6070">            if (selectedEntity.getOwner().getArtyAutoHitHexes()</span>
<span class="nc bnc" id="L6071" title="All 2 branches missed.">                              .contains(mcoords)) {</span>
<span class="nc" id="L6072">                amod = TargetRoll.AUTOMATIC_SUCCESS;</span>
            } else {
<span class="nc" id="L6074">                amod = selectedEntity.aTracker.getModifier(curWeapon, mcoords);</span>
            }

<span class="nc bnc" id="L6077" title="All 2 branches missed.">            if (amod == TargetRoll.AUTOMATIC_SUCCESS) {</span>
<span class="nc" id="L6078">                txt.append(Messages</span>
<span class="nc" id="L6079">                                   .getString(&quot;BoardView1.ArtilleryAutohit&quot;)); //$NON-NLS-1$</span>
<span class="nc" id="L6080">                txt.append(&quot;&lt;br&gt;&quot;); //$NON-NLS-1$</span>
            } else {
<span class="nc" id="L6082">                txt.append(Messages.getString(</span>
                        &quot;BoardView1.ArtilleryAdjustment&quot;, //$NON-NLS-1$
<span class="nc" id="L6084">                        new Object[]{Integer.valueOf(amod)}));</span>
<span class="nc" id="L6085">                txt.append(&quot;&lt;br&gt;&quot;); //$NON-NLS-1$</span>
            }
        }

<span class="nc" id="L6089">        final Collection&lt;SpecialHexDisplay&gt; shdList = game.getBoard()</span>
<span class="nc" id="L6090">                .getSpecialHexDisplay(mcoords);</span>
<span class="nc" id="L6091">        final Phase currPhase = game.getPhase();</span>
<span class="nc" id="L6092">        int round = game.getRoundCount();</span>
<span class="nc bnc" id="L6093" title="All 2 branches missed.">        if (shdList != null) {</span>
<span class="nc" id="L6094">            boolean isHexAutoHit = localPlayer.getArtyAutoHitHexes().contains(</span>
                    mcoords);
<span class="nc bnc" id="L6096" title="All 2 branches missed.">            for (SpecialHexDisplay shd : shdList) {</span>
<span class="nc bnc" id="L6097" title="All 2 branches missed.">                boolean isTypeAutoHit = shd.getType()</span>
                        == SpecialHexDisplay.Type.ARTILLERY_AUTOHIT;
                // Don't draw if this SHD is obscured from this player
                // The SHD list may also contain stale SHDs, so don't show
                // tooltips for SHDs that aren't drawn.
                // The exception is auto hits.  There will be an icon for auto
                // hits, so we need to draw a tooltip
<span class="nc bnc" id="L6104" title="All 2 branches missed.">                if (!shd.isObscured(localPlayer)</span>
<span class="nc bnc" id="L6105" title="All 6 branches missed.">                        &amp;&amp; (shd.drawNow(currPhase, round, localPlayer)</span>
                                || (isHexAutoHit &amp;&amp; isTypeAutoHit))) {
<span class="nc bnc" id="L6107" title="All 2 branches missed.">                    if (shd.getType() == SpecialHexDisplay.Type.PLAYER_NOTE) {</span>
<span class="nc bnc" id="L6108" title="All 2 branches missed.">                        if (localPlayer.equals(shd.getOwner())) {</span>
<span class="nc" id="L6109">                            txt.append(&quot;Note: &quot;);</span>
                        } else {
<span class="nc" id="L6111">                            txt.append(&quot;Note (&quot; + shd.getOwner().getName()</span>
                                       + &quot;): &quot;);
                        }
                    }
<span class="nc" id="L6115">                    String buf = shd.getInfo();</span>
<span class="nc" id="L6116">                    buf = buf.replaceAll(&quot;\\n&quot;, &quot;&lt;br&gt;&quot;);</span>
<span class="nc" id="L6117">                    txt.append(buf);</span>
<span class="nc" id="L6118">                    txt.append(&quot;&lt;br&gt;&quot;); //$NON-NLS-1$</span>
                }
<span class="nc" id="L6120">            }</span>
        }

<span class="nc" id="L6123">        txt.append(&quot;&lt;/html&gt;&quot;); //$NON-NLS-1$</span>

        // Check to see if the tool tip is completely empty
<span class="nc bnc" id="L6126" title="All 2 branches missed.">        if (txt.toString().equals(&quot;&lt;html&gt;&lt;/html&gt;&quot;)) { //$NON-NLS-1$</span>
<span class="nc" id="L6127">            return new String(&quot;&quot;); //$NON-NLS-1$</span>
        }

        // Now that a valid tooltip text seems to be present,
        // (re)set the tooltip dismissal delay time to the preference
        // value so that the tooltip actually appears
<span class="nc bnc" id="L6133" title="All 2 branches missed.">        if (GUIPreferences.getInstance().getTooltipDismissDelay() &gt;= 0) {</span>
<span class="nc" id="L6134">            ToolTipManager.sharedInstance().setDismissDelay(</span>
<span class="nc" id="L6135">                    GUIPreferences.getInstance().getTooltipDismissDelay());</span>
        } else {
<span class="nc" id="L6137">            ToolTipManager.sharedInstance().setDismissDelay(dismissDelay);</span>
        }

<span class="nc" id="L6140">        return txt.toString();</span>
    }

    private ArrayList&lt;ArtilleryAttackAction&gt; getArtilleryAttacksAtLocation(
            Coords c) {
<span class="nc" id="L6145">        ArrayList&lt;ArtilleryAttackAction&gt; v = new ArrayList&lt;ArtilleryAttackAction&gt;();</span>
<span class="nc" id="L6146">        for (Enumeration&lt;ArtilleryAttackAction&gt; attacks = game</span>
<span class="nc bnc" id="L6147" title="All 2 branches missed.">                .getArtilleryAttacks(); attacks.hasMoreElements(); ) {</span>
<span class="nc" id="L6148">            ArtilleryAttackAction a = attacks.nextElement();</span>
<span class="nc bnc" id="L6149" title="All 2 branches missed.">            if (a.getTarget(game).getPosition().equals(c)) {</span>
<span class="nc" id="L6150">                v.add(a);</span>
            }
<span class="nc" id="L6152">        }</span>
<span class="nc" id="L6153">        return v;</span>
    }

    public Component getComponent() {
<span class="nc" id="L6157">        return getComponent(false);</span>
    }

    public Component getComponent(boolean scrollBars) {
        // If we're already configured, return the scrollpane
<span class="nc bnc" id="L6162" title="All 2 branches missed.">        if (scrollpane != null) {</span>
<span class="nc" id="L6163">            return scrollpane;</span>
        }

<span class="nc" id="L6166">        SkinSpecification bvSkinSpec = SkinXMLHandler</span>
<span class="nc" id="L6167">                .getSkin(SkinSpecification.UIComponents.BoardView.getComp());</span>

        // Setup background icons
        try {
            File file;
<span class="nc bnc" id="L6172" title="All 2 branches missed.">            if (bvSkinSpec.backgrounds.size() &gt; 0) {</span>
<span class="nc" id="L6173">                file = new MegaMekFile(Configuration.widgetsDir(),</span>
<span class="nc" id="L6174">                        bvSkinSpec.backgrounds.get(0)).getFile();</span>
<span class="nc bnc" id="L6175" title="All 2 branches missed.">                if (!file.exists()) {</span>
<span class="nc" id="L6176">                    MegaMek.getLogger().error(&quot;BoardView1 Error: icon doesn't exist: &quot;</span>
<span class="nc" id="L6177">                            + file.getAbsolutePath());</span>
                } else {
<span class="nc" id="L6179">                    bvBgImage = (BufferedImage) ImageUtil.loadImageFromFile(</span>
<span class="nc" id="L6180">                            file.getAbsolutePath());</span>
<span class="nc" id="L6181">                    bvBgShouldTile = bvSkinSpec.tileBackground;</span>
                }
            }
<span class="nc bnc" id="L6184" title="All 2 branches missed.">            if (bvSkinSpec.backgrounds.size() &gt; 1) {</span>
<span class="nc" id="L6185">                file = new MegaMekFile(Configuration.widgetsDir(),</span>
<span class="nc" id="L6186">                        bvSkinSpec.backgrounds.get(1)).getFile();</span>
<span class="nc bnc" id="L6187" title="All 2 branches missed.">                if (!file.exists()) {</span>
<span class="nc" id="L6188">                    MegaMek.getLogger().error(&quot;BoardView1 Error: icon doesn't exist: &quot;</span>
<span class="nc" id="L6189">                            + file.getAbsolutePath());</span>
                } else {
<span class="nc" id="L6191">                    scrollPaneBgImg = ImageUtil.loadImageFromFile(file.getAbsolutePath());</span>
                }
            }
<span class="nc" id="L6194">        } catch (Exception e) {</span>
<span class="nc" id="L6195">            MegaMek.getLogger().error(&quot;Error loading BoardView background images!&quot;, e);</span>
<span class="nc" id="L6196">        }</span>

        // Place the board viewer in a set of scrollbars.
<span class="nc" id="L6199">        scrollpane = new JScrollPane(this) {</span>
            private static final long serialVersionUID = 5973610449428194319L;

            @Override
            protected void paintComponent(Graphics g) {
<span class="nc bnc" id="L6204" title="All 2 branches missed.">                if (scrollPaneBgImg == null) {</span>
<span class="nc" id="L6205">                    super.paintComponent(g);</span>
<span class="nc" id="L6206">                    return;</span>
                }
<span class="nc" id="L6208">                int w = getWidth();</span>
<span class="nc" id="L6209">                int h = getHeight();</span>
<span class="nc" id="L6210">                int iW = scrollPaneBgImg.getWidth(null);</span>
<span class="nc" id="L6211">                int iH = scrollPaneBgImg.getHeight(null);</span>
<span class="nc bnc" id="L6212" title="All 2 branches missed.">                if ((scrollPaneBgBuffer == null)</span>
<span class="nc bnc" id="L6213" title="All 2 branches missed.">                    || (scrollPaneBgBuffer.getWidth() != w)</span>
<span class="nc bnc" id="L6214" title="All 2 branches missed.">                    || (scrollPaneBgBuffer.getHeight() != h)) {</span>
<span class="nc" id="L6215">                    scrollPaneBgBuffer = new BufferedImage(w, h,</span>
                            BufferedImage.TYPE_INT_RGB);
<span class="nc" id="L6217">                    Graphics bgGraph = scrollPaneBgBuffer.getGraphics();</span>
                    // If the unit icon not loaded, prevent infinite loop
<span class="nc bnc" id="L6219" title="All 4 branches missed.">                    if ((iW &lt; 1) || (iH &lt; 1)) {</span>
<span class="nc" id="L6220">                        return;</span>
                    }
<span class="nc bnc" id="L6222" title="All 2 branches missed.">                    for (int x = 0; x &lt; w; x += iW) {</span>
<span class="nc bnc" id="L6223" title="All 2 branches missed.">                        for (int y = 0; y &lt; h; y += iH) {</span>
<span class="nc" id="L6224">                            bgGraph.drawImage(scrollPaneBgImg, x, y, null);</span>
                        }
                    }
<span class="nc" id="L6227">                    bgGraph.dispose();</span>
                }
<span class="nc" id="L6229">                g.drawImage(scrollPaneBgBuffer, 0, 0, null);</span>
<span class="nc" id="L6230">            }</span>
        };
<span class="nc" id="L6232">        scrollpane.setBorder(new MegamekBorder(bvSkinSpec));</span>
<span class="nc" id="L6233">        scrollpane.setLayout(new ScrollPaneLayout());</span>
        // we need to use the simple scroll mode because otherwise the
        // IDisplayables that are drawn in fixed positions in the viewport
        // leave artifacts when scrolling
<span class="nc" id="L6237">        scrollpane.getViewport().setScrollMode(JViewport.SIMPLE_SCROLL_MODE);</span>

        // Prevent the default arrow key scrolling
<span class="nc" id="L6240">        scrollpane.getActionMap().put(&quot;unitScrollRight&quot;, DoNothing);</span>
<span class="nc" id="L6241">        scrollpane.getActionMap().put(&quot;unitScrollDown&quot;, DoNothing);</span>
<span class="nc" id="L6242">        scrollpane.getActionMap().put(&quot;unitScrollLeft&quot;, DoNothing);</span>
<span class="nc" id="L6243">        scrollpane.getActionMap().put(&quot;unitScrollUp&quot;, DoNothing);</span>

<span class="nc" id="L6245">        vbar = scrollpane.getVerticalScrollBar();</span>
<span class="nc" id="L6246">        hbar = scrollpane.getHorizontalScrollBar();</span>

<span class="nc bnc" id="L6248" title="All 4 branches missed.">        if (!scrollBars &amp;&amp; !bvSkinSpec.showScrollBars) {</span>
<span class="nc" id="L6249">            vbar.setPreferredSize(new Dimension(0, vbar.getHeight()));</span>
<span class="nc" id="L6250">            hbar.setPreferredSize(new Dimension(hbar.getWidth(), 0));</span>
        }

<span class="nc" id="L6253">        return scrollpane;</span>
    }

<span class="nc" id="L6256">    AbstractAction DoNothing = new AbstractAction() {</span>
        private static final long serialVersionUID = 5944877465265121983L;

        @Override
        public void actionPerformed(ActionEvent e) {
<span class="nc" id="L6261">        }</span>
    };

    /**
     * refresh the IDisplayables
     */
    public void refreshDisplayables() {
<span class="nc" id="L6268">        repaint();</span>
<span class="nc" id="L6269">    }</span>

    private void pingMinimap() {
        // send the minimap a hex moused event to make it
        // update the visible area rectangle
<span class="nc" id="L6274">        BoardViewEvent bve = new BoardViewEvent(this,BoardViewEvent.BOARD_HEX_DRAGGED);</span>
<span class="nc bnc" id="L6275" title="All 2 branches missed.">        if (boardListeners != null) {</span>
<span class="nc bnc" id="L6276" title="All 2 branches missed.">            for (BoardViewListener l : boardListeners) l.hexMoused(bve);</span>
        }
<span class="nc" id="L6278">    }</span>

    public void showPopup(Object popup, Coords c) {
<span class="nc" id="L6281">        Point p = getHexLocation(c);</span>
<span class="nc" id="L6282">        p.x += ((int) (HEX_WC * scale) - scrollpane.getX()) + HEX_W;</span>
<span class="nc" id="L6283">        p.y += ((int) ((HEX_H * scale) / 2) - scrollpane.getY()) + HEX_H;</span>
<span class="nc bnc" id="L6284" title="All 2 branches missed.">        if (((JPopupMenu) popup).getParent() == null) {</span>
<span class="nc" id="L6285">            add((JPopupMenu) popup);</span>
        }
<span class="nc" id="L6287">        ((JPopupMenu) popup).show(this, p.x, p.y);</span>
<span class="nc" id="L6288">    }</span>

    public void refreshMinefields() {
<span class="nc" id="L6291">        repaint();</span>
<span class="nc" id="L6292">    }</span>

    /**
     * Increases zoomIndex and refreshes the map.
     */
    public void zoomIn() {
<span class="nc bnc" id="L6298" title="All 2 branches missed.">        if (zoomIndex == (ZOOM_FACTORS.length - 1)) {</span>
<span class="nc" id="L6299">            return;</span>
        }
<span class="nc" id="L6301">        zoomIndex++;</span>
<span class="nc" id="L6302">        zoom();</span>
<span class="nc" id="L6303">    }</span>

    /**
     * Decreases zoomIndex and refreshes the map.
     */
    public void zoomOut() {
<span class="nc bnc" id="L6309" title="All 2 branches missed.">        if (zoomIndex == 0) {</span>
<span class="nc" id="L6310">            return;</span>
        }
<span class="nc" id="L6312">        zoomIndex--;</span>
<span class="nc" id="L6313">        zoom();</span>
<span class="nc" id="L6314">    }</span>

    public void hideTooltip() {
<span class="nc" id="L6317">        throw new UnsupportedOperationException(&quot;Not supported yet.&quot;);</span>
    }

    private void checkZoomIndex() {
<span class="nc bnc" id="L6321" title="All 2 branches missed.">        if (zoomIndex &gt; (ZOOM_FACTORS.length - 1)) {</span>
<span class="nc" id="L6322">            zoomIndex = ZOOM_FACTORS.length - 1;</span>
        }
<span class="nc bnc" id="L6324" title="All 2 branches missed.">        if (zoomIndex &lt; 0) {</span>
<span class="nc" id="L6325">            zoomIndex = 0;</span>
        }
<span class="nc" id="L6327">    }</span>

    /**
     * Changes hex dimensions and refreshes the map with the new scale
     */
    private void zoom() {

<span class="nc" id="L6334">        checkZoomIndex();</span>
<span class="nc" id="L6335">        stopSoftCentering();</span>
<span class="nc" id="L6336">        scale = ZOOM_FACTORS[zoomIndex];</span>
<span class="nc" id="L6337">        GUIPreferences.getInstance().setMapZoomIndex(zoomIndex);</span>

<span class="nc" id="L6339">        hex_size = new Dimension((int) (HEX_W * scale), (int) (HEX_H * scale));</span>

<span class="nc" id="L6341">        scaledImageCache = new ImageCache&lt;Integer, Image&gt;();</span>

<span class="nc" id="L6343">        cursorSprite.prepare();</span>
<span class="nc" id="L6344">        highlightSprite.prepare();</span>
<span class="nc" id="L6345">        selectedSprite.prepare();</span>
<span class="nc" id="L6346">        firstLOSSprite.prepare();</span>
<span class="nc" id="L6347">        secondLOSSprite.prepare();</span>
<span class="nc bnc" id="L6348" title="All 2 branches missed.">        for (Sprite spr : moveEnvSprites) {</span>
<span class="nc" id="L6349">            spr.prepare();</span>
<span class="nc" id="L6350">        }</span>
<span class="nc bnc" id="L6351" title="All 2 branches missed.">        for (Sprite spr : moveModEnvSprites) {</span>
<span class="nc" id="L6352">            spr.prepare();</span>
<span class="nc" id="L6353">        }</span>
<span class="nc bnc" id="L6354" title="All 2 branches missed.">        for (Sprite spr : fieldofFireSprites) {</span>
<span class="nc" id="L6355">            spr.prepare();</span>
<span class="nc" id="L6356">        }</span>

<span class="nc" id="L6358">        updateFontSizes();</span>
<span class="nc" id="L6359">        updateBoard();</span>
<span class="nc bnc" id="L6360" title="All 2 branches missed.">        for (StepSprite sprite : pathSprites) {</span>
<span class="nc" id="L6361">            sprite.refreshZoomLevel();</span>
<span class="nc" id="L6362">        }</span>
<span class="nc bnc" id="L6363" title="All 2 branches missed.">        for (FiringSolutionSprite sprite : firingSprites) {</span>
<span class="nc" id="L6364">            sprite.prepare();</span>
<span class="nc" id="L6365">        }</span>
<span class="nc" id="L6366">        this.setSize(boardSize);</span>

<span class="nc" id="L6368">        clearHexImageCache();</span>
<span class="nc" id="L6369">        repaint();</span>
<span class="nc" id="L6370">    }</span>

    private void updateFontSizes() {
<span class="nc bnc" id="L6373" title="All 2 branches missed.">        if (zoomIndex &lt;= 4) {</span>
<span class="nc" id="L6374">            font_elev = FONT_7;</span>
<span class="nc" id="L6375">            font_hexnum = FONT_7;</span>
<span class="nc" id="L6376">            font_minefield = FONT_7;</span>
        }
<span class="nc bnc" id="L6378" title="All 6 branches missed.">        if ((zoomIndex &lt;= 5) &amp; (zoomIndex &gt; 4)) {</span>
<span class="nc" id="L6379">            font_elev = FONT_8;</span>
<span class="nc" id="L6380">            font_hexnum = FONT_8;</span>
<span class="nc" id="L6381">            font_minefield = FONT_8;</span>
        }
<span class="nc bnc" id="L6383" title="All 2 branches missed.">        if (zoomIndex &gt; 5) {</span>
<span class="nc" id="L6384">            font_elev = FONT_9;</span>
<span class="nc" id="L6385">            font_hexnum = FONT_9;</span>
<span class="nc" id="L6386">            font_minefield = FONT_9;</span>
        }
<span class="nc" id="L6388">    }</span>

    /**
     * Return a scaled version of the input.  If the useCache flag is set, the
     * scaled image will be stored in an image cache for later retrieval.
     *
     * @param base     The image to get a scaled copy of.  The current zoom level
     *                 is used to determine the scale.
     * @param useCache This flag determines whether the scaled image should
     *                 be stored in a cache for later retrieval.
     */
    Image getScaledImage(Image base, boolean useCache) {
<span class="nc bnc" id="L6400" title="All 2 branches missed.">        if (base == null) {</span>
<span class="nc" id="L6401">            return null;</span>
        }
<span class="nc bnc" id="L6403" title="All 2 branches missed.">        if (zoomIndex == BASE_ZOOM_INDEX) {</span>
<span class="nc" id="L6404">            return base;</span>
        }


        Image scaled;
<span class="nc bnc" id="L6409" title="All 2 branches missed.">        if (useCache) {</span>
            // Check the cache
<span class="nc" id="L6411">            scaled = scaledImageCache.get(base.hashCode());</span>
        } else {
<span class="nc" id="L6413">            scaled = null;</span>
        }
        // Compute the scaled image
<span class="nc bnc" id="L6416" title="All 2 branches missed.">        if (scaled == null) {</span>
<span class="nc" id="L6417">            MediaTracker tracker = new MediaTracker(this);</span>
<span class="nc bnc" id="L6418" title="All 4 branches missed.">            if ((base.getWidth(null) == -1) || (base.getHeight(null) == -1)) {</span>
<span class="nc" id="L6419">                tracker.addImage(base, 0);</span>
                try {
<span class="nc" id="L6421">                    tracker.waitForID(0);</span>
<span class="nc" id="L6422">                } catch (InterruptedException e) {</span>
<span class="nc" id="L6423">                    MegaMek.getLogger().error(e);</span>
<span class="nc" id="L6424">                }</span>
<span class="nc bnc" id="L6425" title="All 2 branches missed.">                if (tracker.isErrorAny()) {</span>
<span class="nc" id="L6426">                    return null;</span>
                }
<span class="nc" id="L6428">                tracker.removeImage(base);</span>
            }
<span class="nc" id="L6430">            int width = (int) (base.getWidth(null) * scale);</span>
<span class="nc" id="L6431">            int height = (int) (base.getHeight(null) * scale);</span>

<span class="nc bnc" id="L6433" title="All 4 branches missed.">            if ((width &lt; 1) || (height &lt; 1)) {</span>
<span class="nc" id="L6434">                return null;</span>
            }

<span class="nc" id="L6437">            scaled = scale(base, width, height);</span>
<span class="nc" id="L6438">            tracker.addImage(scaled, 1);</span>
            // Wait for image to load
            try {
<span class="nc" id="L6441">                tracker.waitForID(1);</span>
<span class="nc" id="L6442">            } catch (InterruptedException e) {</span>
<span class="nc" id="L6443">                MegaMek.getLogger().error(e);</span>
<span class="nc" id="L6444">            }</span>
<span class="nc" id="L6445">            tracker.removeImage(scaled);</span>
            // Cache the image if the flag is set
<span class="nc bnc" id="L6447" title="All 2 branches missed.">            if (useCache) {</span>
<span class="nc" id="L6448">                scaledImageCache.put(base.hashCode(), scaled);</span>
            }
        }
<span class="nc" id="L6451">        return scaled;</span>
    }

    /**
     * The actual scaling code.
     */
    private Image scale(Image img, int width, int height) {
<span class="nc" id="L6458">        return ImageUtil.getScaledImage(img, width, height,</span>
                ZOOM_SCALE_TYPES[zoomIndex]);
    }

    public boolean toggleIsometric() {
<span class="nc bnc" id="L6463" title="All 2 branches missed.">        drawIsometric = !drawIsometric;</span>
<span class="nc bnc" id="L6464" title="All 2 branches missed.">        for (Sprite spr : moveEnvSprites) spr.prepare();</span>
<span class="nc bnc" id="L6465" title="All 2 branches missed.">        for (Sprite spr : moveModEnvSprites) spr.prepare();</span>
<span class="nc bnc" id="L6466" title="All 2 branches missed.">        for (Sprite spr : fieldofFireSprites) spr.prepare();</span>
<span class="nc" id="L6467">        clearHexImageCache();</span>
<span class="nc" id="L6468">        updateBoard();</span>
<span class="nc bnc" id="L6469" title="All 2 branches missed.">        for (MovementEnvelopeSprite sprite: moveEnvSprites)</span>
<span class="nc" id="L6470">            sprite.updateBounds();</span>
<span class="nc bnc" id="L6471" title="All 2 branches missed.">        for (MovementModifierEnvelopeSprite sprite: moveModEnvSprites)</span>
<span class="nc" id="L6472">            sprite.updateBounds();</span>
<span class="nc" id="L6473">        repaint();</span>
<span class="nc" id="L6474">        return drawIsometric;</span>
    }

    public void updateEntityLabels() {
<span class="nc bnc" id="L6478" title="All 2 branches missed.">        for (Entity e: game.getEntitiesVector()) {</span>
<span class="nc" id="L6479">            e.generateShortName();</span>
<span class="nc" id="L6480">        }</span>
<span class="nc bnc" id="L6481" title="All 2 branches missed.">        for (EntitySprite eS: entitySprites) {</span>
<span class="nc" id="L6482">            eS.prepare();</span>
<span class="nc" id="L6483">        }</span>
<span class="nc" id="L6484">        repaint();</span>
<span class="nc" id="L6485">    }</span>

    BufferedImage createShadowMask(Image image) {
<span class="nc" id="L6488">        int hashCode = image.hashCode();</span>
<span class="nc" id="L6489">        BufferedImage mask = shadowImageCache.get(hashCode);</span>
<span class="nc bnc" id="L6490" title="All 2 branches missed.">        if (mask != null) {</span>
<span class="nc" id="L6491">            return mask;</span>
        }
<span class="nc" id="L6493">        mask = new BufferedImage(image.getWidth(null),</span>
<span class="nc" id="L6494">                image.getHeight(null), BufferedImage.TYPE_INT_ARGB);</span>
<span class="nc" id="L6495">        float opacity = 0.4f;</span>
<span class="nc" id="L6496">        Graphics2D g2d = mask.createGraphics();</span>
<span class="nc" id="L6497">        g2d.drawImage(image, 0, 0, null);</span>
<span class="nc" id="L6498">        g2d.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_IN,</span>
                                                    opacity));
<span class="nc" id="L6500">        g2d.setColor(Color.BLACK);</span>
<span class="nc" id="L6501">        g2d.fillRect(0, 0, image.getWidth(null), image.getHeight(null));</span>
<span class="nc" id="L6502">        g2d.dispose();</span>
<span class="nc" id="L6503">        shadowImageCache.put(hashCode, mask);</span>
<span class="nc" id="L6504">        return mask;</span>
    }

    public void die() {
<span class="nc" id="L6508">        ourTask.cancel();</span>
<span class="nc" id="L6509">        fovHighlightingAndDarkening.die();</span>
<span class="nc" id="L6510">    }</span>

    /**
     * Returns true if the BoardView has an active chatter box else false.
     *
     * @return
     */
    public boolean getChatterBoxActive() {
<span class="nc" id="L6518">        return chatterBoxActive;</span>
    }

    /**
     * Sets whether the BoardView has an active chatter box or not.
     *
     * @param cba
     */
    public void setChatterBoxActive(boolean cba) {
<span class="nc" id="L6527">        chatterBoxActive = cba;</span>
<span class="nc" id="L6528">    }</span>

    public void setShouldIgnoreKeys(boolean shouldIgnoreKeys) {
<span class="nc" id="L6531">        this.shouldIgnoreKeys = shouldIgnoreKeys;</span>
<span class="nc" id="L6532">    }</span>

    @Override
    public boolean imageUpdate(Image img, int flags, int x, int y, int w, int h) {
        // If FRAMEBITS is set, then new frame from a multi-frame image is ready
        // This indicates an animated image, which shouldn't be cached
<span class="nc bnc" id="L6538" title="All 2 branches missed.">        if ((flags &amp; ImageObserver.FRAMEBITS) != 0) {</span>
<span class="nc" id="L6539">            animatedImages.add(img.hashCode());</span>
        }
<span class="nc" id="L6541">        return super.imageUpdate(img, flags, x, y, w, h);</span>
    }

    public void clearHexImageCache() {
<span class="nc" id="L6545">        hexImageCache.clear();</span>
<span class="nc" id="L6546">    }</span>

    /**
     * Clear a specific list of Coords from the hex image cache.
     * @param coords
     */
    public void clearHexImageCache(Set&lt;Coords&gt; coords) {
<span class="nc bnc" id="L6553" title="All 2 branches missed.">        for (Coords c : coords) {</span>
<span class="nc" id="L6554">            hexImageCache.remove(c);</span>
<span class="nc" id="L6555">        }</span>
<span class="nc" id="L6556">    }</span>

    /**
     * Check to see if the HexImageCache should be cleared because of
     * field-of-view changes.
     */
    public void checkFoVHexImageCacheClear() {
<span class="nc" id="L6563">        boolean darken = GUIPreferences.getInstance().getBoolean(</span>
                GUIPreferences.FOV_DARKEN);
<span class="nc" id="L6565">        boolean highlight = GUIPreferences.getInstance().getBoolean(</span>
                GUIPreferences.FOV_HIGHLIGHT);
<span class="nc bnc" id="L6567" title="All 6 branches missed.">        if ((game.getPhase() == Phase.PHASE_MOVEMENT)</span>
                &amp;&amp; (darken || highlight)) {
<span class="nc" id="L6569">            clearHexImageCache();</span>
        }
<span class="nc" id="L6571">    }</span>

    public Polygon getHexPoly() {
<span class="nc" id="L6574">        return hexPoly;</span>
    }

    public void clearFieldofF() {
<span class="nc" id="L6578">        fieldofFireWpArc = -1;</span>
<span class="nc" id="L6579">        fieldofFireUnit = null;</span>
<span class="nc" id="L6580">        fieldofFireSprites.clear();</span>
<span class="nc" id="L6581">        repaint();</span>
<span class="nc" id="L6582">    }</span>

    // this is called from MovementDisplay and checks if
    // the unit ends up underwater
    public void setWeaponFieldofFire(Entity ce, MovePath cmd) {
        // if lack of data: clear and return
<span class="nc bnc" id="L6588" title="All 6 branches missed.">        if ((fieldofFireUnit == null)</span>
            || (ce == null)
            || (cmd == null)) {
<span class="nc" id="L6591">            clearFieldofF();</span>
<span class="nc" id="L6592">            return;</span>
        }

        // If the field of fire is not dispalyed
        // for the active unit, then don't change anything
<span class="nc bnc" id="L6597" title="All 2 branches missed.">        if (fieldofFireUnit.equals(ce)) {</span>

<span class="nc" id="L6599">            fieldofFireWpUnderwater = 0;</span>
            // check if the weapon ends up underwater
<span class="nc" id="L6601">            IHex hex = game.getBoard().getHex(cmd.getFinalCoords());</span>

<span class="nc bnc" id="L6603" title="All 4 branches missed.">            if ((hex.terrainLevel(Terrains.WATER) &gt; 0) &amp;&amp; !cmd.isJumping()</span>
<span class="nc bnc" id="L6604" title="All 2 branches missed.">                    &amp;&amp; (cmd.getFinalElevation() &lt; 0)) {</span>
<span class="nc bnc" id="L6605" title="All 4 branches missed.">                if ((fieldofFireUnit instanceof Mech) &amp;&amp; !fieldofFireUnit.isProne()</span>
<span class="nc bnc" id="L6606" title="All 2 branches missed.">                        &amp;&amp; (hex.terrainLevel(Terrains.WATER) == 1)) {</span>
<span class="nc bnc" id="L6607" title="All 4 branches missed.">                    if ((fieldofFireWpLoc == Mech.LOC_RLEG)</span>
                        || (fieldofFireWpLoc == Mech.LOC_LLEG))
<span class="nc" id="L6609">                        fieldofFireWpUnderwater = 1;</span>

<span class="nc bnc" id="L6611" title="All 2 branches missed.">                    if (fieldofFireUnit instanceof QuadMech) {</span>
<span class="nc bnc" id="L6612" title="All 4 branches missed.">                        if ((fieldofFireWpLoc == Mech.LOC_RARM)</span>
                            || (fieldofFireWpLoc == Mech.LOC_LARM))
<span class="nc" id="L6614">                            fieldofFireWpUnderwater = 1;</span>
                    }
<span class="nc bnc" id="L6616" title="All 2 branches missed.">                    if (fieldofFireUnit instanceof TripodMech) {</span>
<span class="nc bnc" id="L6617" title="All 2 branches missed.">                        if (fieldofFireWpLoc == Mech.LOC_CLEG)</span>
<span class="nc" id="L6618">                            fieldofFireWpUnderwater = 1;</span>
                    }
                } else {
<span class="nc" id="L6621">                    fieldofFireWpUnderwater = 1;</span>
                }
            }
<span class="nc" id="L6624">            setWeaponFieldofFire(cmd.getFinalFacing(), cmd.getFinalCoords());</span>
        }
<span class="nc" id="L6626">    }</span>

    // prepares the sprites for a field of fire
    public void setWeaponFieldofFire(int fac, Coords c) {
<span class="nc bnc" id="L6630" title="All 2 branches missed.">        if (fieldofFireUnit == null) {</span>
<span class="nc" id="L6631">            clearFieldofF();</span>
<span class="nc" id="L6632">            return;</span>
        }

        // Do not display anything for offboard units
<span class="nc bnc" id="L6636" title="All 2 branches missed.">        if (fieldofFireUnit.isOffBoard()) {</span>
<span class="nc" id="L6637">            clearFieldofF();</span>
<span class="nc" id="L6638">            return;</span>
        }

        // check if extreme range is used
<span class="nc" id="L6642">        int maxrange = 4;</span>
<span class="nc" id="L6643">        if (game.getOptions().</span>
<span class="nc bnc" id="L6644" title="All 2 branches missed.">                booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_RANGE)) maxrange = 5;</span>

        // create the lists of hexes
<span class="nc" id="L6647">        List&lt;Set&lt;Coords&gt;&gt; fieldFire = new ArrayList&lt;Set&lt;Coords&gt;&gt;(5);</span>
<span class="nc" id="L6648">        int range = 1;</span>
        // for all available range brackets Min/S/M/L/E ...
<span class="nc bnc" id="L6650" title="All 2 branches missed.">        for (int bracket = 0; bracket &lt; maxrange; bracket++) {</span>
<span class="nc" id="L6651">            fieldFire.add(new HashSet&lt;Coords&gt;());</span>
            // Add all hexes up to the weapon range to separate lists
<span class="nc bnc" id="L6653" title="All 2 branches missed.">            while (range&lt;=fieldofFireRanges[fieldofFireWpUnderwater][bracket]) {</span>
<span class="nc" id="L6654">                fieldFire.get(bracket).addAll(c.allAtDistance(range));</span>
<span class="nc" id="L6655">                range++;</span>
<span class="nc bnc" id="L6656" title="All 2 branches missed.">                if (range&gt;100) break; // only to avoid hangs</span>
            }

            // Remove hexes that are not on the board or not in the arc
<span class="nc bnc" id="L6660" title="All 2 branches missed.">            for (Iterator&lt;Coords&gt; iterator = fieldFire.get(bracket).iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L6661">                Coords h = iterator.next();</span>
<span class="nc bnc" id="L6662" title="All 2 branches missed.">                if (!game.getBoard().contains(h)</span>
<span class="nc bnc" id="L6663" title="All 2 branches missed.">                        || !Compute.isInArc(c, fac, h, fieldofFireWpArc)) {</span>
<span class="nc" id="L6664">                    iterator.remove();</span>
                }
<span class="nc" id="L6666">            }</span>
        }

        // create the sprites
        //
<span class="nc" id="L6671">        fieldofFireSprites.clear();</span>

        // for all available range brackets Min/S/M/L/E ...
<span class="nc bnc" id="L6674" title="All 2 branches missed.">        for (int bracket = 0; bracket &lt; fieldFire.size(); bracket++) {</span>
<span class="nc bnc" id="L6675" title="All 2 branches missed.">            if (fieldFire.get(bracket) == null) continue;</span>
<span class="nc bnc" id="L6676" title="All 2 branches missed.">            for (Coords loc : fieldFire.get(bracket)) {</span>
                // check surrounding hexes
<span class="nc" id="L6678">                int edgesToPaint = 0;</span>
<span class="nc bnc" id="L6679" title="All 2 branches missed.">                for (int dir = 0; dir &lt; 6; dir++) {</span>
<span class="nc" id="L6680">                    Coords adjacentHex = loc.translated(dir);</span>
<span class="nc bnc" id="L6681" title="All 2 branches missed.">                    if (!fieldFire.get(bracket).contains(adjacentHex)) edgesToPaint += (1 &lt;&lt; dir);</span>
                }
                // create sprite if there's a border to paint
<span class="nc bnc" id="L6684" title="All 2 branches missed.">                if (edgesToPaint &gt; 0) {</span>
<span class="nc" id="L6685">                    FieldofFireSprite ffSprite = new FieldofFireSprite(</span>
                            this, bracket, loc, edgesToPaint);
<span class="nc" id="L6687">                    fieldofFireSprites.add(ffSprite);</span>
                }
<span class="nc" id="L6689">            }</span>
            // Add range markers (m, S, M, L, E)
            // this looks for a hex in the middle of the range bracket;
            // if outside the board, nearer hexes will be tried until
            // the inner edge of the range bracket is reached
            // the directions tested are those that fall between the
            // hex facings because this makes for a better placement
            // ... most of the time...

            // The directions[][] is used to make the marker placement
            // fairly symmetrical to the unit facing which a simple for
            // loop over the hex facings doesn't do
<span class="nc" id="L6701">            int[][] directions = { {0,1},{0,5},{3,2},{3,4},{1,2},{5,4} };</span>
            // don't paint too many &quot;min&quot; markers
<span class="nc" id="L6703">            int numMinMarkers = 0;</span>
<span class="nc bnc" id="L6704" title="All 2 branches missed.">            for (int[] dir: directions) {</span>
                // find the middle of the range bracket
<span class="nc" id="L6706">                int rangeend = Math.max(fieldofFireRanges[fieldofFireWpUnderwater][bracket],0);</span>
<span class="nc" id="L6707">                int rangebegin = 1;</span>
<span class="nc bnc" id="L6708" title="All 2 branches missed.">                if (bracket&gt;0)</span>
<span class="nc" id="L6709">                    rangebegin = Math.max(fieldofFireRanges[fieldofFireWpUnderwater][bracket-1]+1,1);</span>
<span class="nc" id="L6710">                int dist = (rangeend + rangebegin)/2;</span>
                // translate to the middle of the range bracket
<span class="nc" id="L6712">                Coords mark = c.translated((dir[0]+fac)%6,(dist+1)/2)</span>
<span class="nc" id="L6713">                        .translated((dir[1]+fac)%6,dist/2);</span>
                // traverse back to the unit until a hex is onboard
<span class="nc bnc" id="L6715" title="All 2 branches missed.">                while (!game.getBoard().contains(mark))</span>
<span class="nc" id="L6716">                    mark = Coords.nextHex(mark, c);</span>

                // add a text range marker if the found position is good
<span class="nc bnc" id="L6719" title="All 8 branches missed.">                if (game.getBoard().contains(mark) &amp;&amp; fieldFire.get(bracket).contains(mark)</span>
                        &amp;&amp; ((bracket &gt; 0) || (numMinMarkers &lt; 2))) {
<span class="nc" id="L6721">                    TextMarkerSprite tS = new TextMarkerSprite(this, mark,</span>
                            rangeTexts[bracket], FieldofFireSprite.fieldofFireColors[bracket]);
<span class="nc" id="L6723">                    fieldofFireSprites.add(tS);</span>
<span class="nc bnc" id="L6724" title="All 2 branches missed.">                    if (bracket == 0) numMinMarkers++;</span>
                }
            }
        }

<span class="nc" id="L6729">        repaint();</span>
<span class="nc" id="L6730">    }</span>

    /** Displays a dialog and changes the theme of all
     *  board hexes to the user-chosen theme.
     */
    public void changeTheme() {
<span class="nc bnc" id="L6736" title="All 2 branches missed.">        if (game == null) return;</span>
<span class="nc" id="L6737">        IBoard board = game.getBoard();</span>
<span class="nc bnc" id="L6738" title="All 2 branches missed.">        if (board.inSpace()) return;</span>

<span class="nc" id="L6740">        Set&lt;String&gt; themes = tileManager.getThemes();</span>
<span class="nc bnc" id="L6741" title="All 2 branches missed.">        if (themes.remove(&quot;&quot;)) themes.add(&quot;(No Theme)&quot;);</span>
<span class="nc" id="L6742">        themes.add(&quot;(Original Theme)&quot;);</span>

<span class="nc" id="L6744">        setShouldIgnoreKeys(true);</span>
<span class="nc" id="L6745">        selectedTheme = (String)JOptionPane.showInputDialog(</span>
                null,
                &quot;Choose the desired theme:&quot;,
                &quot;Theme Selection&quot;,
                JOptionPane.PLAIN_MESSAGE,
                null,
<span class="nc" id="L6751">                themes.toArray(),</span>
                selectedTheme);
<span class="nc" id="L6753">        setShouldIgnoreKeys(false);</span>

<span class="nc bnc" id="L6755" title="All 2 branches missed.">        if (selectedTheme == null) {</span>
<span class="nc" id="L6756">            return;</span>
<span class="nc bnc" id="L6757" title="All 2 branches missed.">        } else if (selectedTheme.equals(&quot;(Original Theme)&quot;)) {</span>
<span class="nc" id="L6758">            selectedTheme = null;</span>
<span class="nc bnc" id="L6759" title="All 2 branches missed.">        } else if (selectedTheme.equals(&quot;(No Theme)&quot;)) {</span>
<span class="nc" id="L6760">            selectedTheme = &quot;&quot;;</span>
        }
        
<span class="nc" id="L6763">        board.setTheme(selectedTheme);</span>
<span class="nc" id="L6764">    }</span>

    private Image getBoardBackgroundHexImage(Coords c, IHex hex) {
<span class="nc" id="L6767">        IBoard board = game.getBoard();</span>
<span class="nc bnc" id="L6768" title="All 6 branches missed.">        if ((hex == null) || (board == null) || (hex.getTheme() == null)</span>
<span class="nc bnc" id="L6769" title="All 2 branches missed.">                || !hex.getTheme().equals(HexTileset.TRANSPARENT_THEME)</span>
<span class="nc bnc" id="L6770" title="All 2 branches missed.">                || !board.hasBoardBackground()) {</span>
<span class="nc" id="L6771">            return null;</span>
        }
        // Determine what sub-board the hex came from
<span class="nc" id="L6774">        int boardX = (int)((c.getX() + 0.0) / board.getSubBoardWidth());</span>
<span class="nc" id="L6775">        int boardY = (int)((c.getY() + 0.0) / board.getSubBoardHeight());</span>
<span class="nc" id="L6776">        int linIdx = boardY * board.getNumBoardsWidth() + boardX;</span>
<span class="nc bnc" id="L6777" title="All 4 branches missed.">        if (linIdx &lt; 0 || linIdx &gt; boardBackgrounds.size() - 1) {</span>
<span class="nc" id="L6778">            MegaMek.getLogger().error(&quot;Error computing linear index or missing background images in BoardView1.getBoardBackgroundHexImage!&quot;);</span>
<span class="nc" id="L6779">            return null;</span>
        }
<span class="nc" id="L6781">        Image bgImg = getScaledImage(boardBackgrounds.get(linIdx), true);</span>
<span class="nc" id="L6782">        int bgImgWidth = bgImg.getWidth(null);</span>
<span class="nc" id="L6783">        int bgImgHeight = bgImg.getHeight(null);</span>

<span class="nc" id="L6785">        Point p1SRC = getHexLocationLargeTile(</span>
<span class="nc" id="L6786">                c.getX() - (boardX * board.getSubBoardWidth()),</span>
<span class="nc" id="L6787">                c.getY() - (boardY * board.getSubBoardHeight()));</span>
<span class="nc" id="L6788">        p1SRC.x = p1SRC.x % bgImgWidth;</span>
<span class="nc" id="L6789">        p1SRC.y = p1SRC.y % bgImgHeight;</span>
<span class="nc" id="L6790">        Point p2SRC = new Point((int) (p1SRC.x + HEX_W * scale),</span>
                (int) (p1SRC.y + HEX_H * scale));
<span class="nc" id="L6792">        Point p2DST = new Point((int) (HEX_W * scale),</span>
                (int) (HEX_H * scale));

<span class="nc" id="L6795">        Image hexImage = new BufferedImage(HEX_W,  HEX_H,</span>
                BufferedImage.TYPE_INT_ARGB);
<span class="nc" id="L6797">        Graphics2D g = (Graphics2D)hexImage.getGraphics();</span>

        // hex mask to limit drawing to the hex shape
        // TODO: this is not ideal yet but at least it draws
        // without leaving gaps at any zoom
<span class="nc" id="L6802">        Image hexMask = getScaledImage(tileManager.getHexMask(), true);</span>
<span class="nc" id="L6803">        g.drawImage(hexMask, 0, 0, this);</span>
<span class="nc" id="L6804">        Composite svComp = g.getComposite();</span>
<span class="nc" id="L6805">        g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_ATOP,</span>
              1f));

        // paint the right slice from the big pic
<span class="nc" id="L6809">        g.drawImage(bgImg, 0, 0, p2DST.x, p2DST.y, p1SRC.x, p1SRC.y,</span>
                p2SRC.x, p2SRC.y, null);

        // Handle wrapping of the image
<span class="nc bnc" id="L6813" title="All 4 branches missed.">        if (p2SRC.x &gt; bgImgWidth &amp;&amp; p2SRC.y &lt;= bgImgHeight) {</span>
<span class="nc" id="L6814">            g.drawImage(bgImg, bgImgWidth - p1SRC.x, 0, p2DST.x,</span>
                    p2DST.y, 0, p1SRC.y, p2SRC.x - bgImgWidth, p2SRC.y,
                    null); // paint addtl slice on the left side
<span class="nc bnc" id="L6817" title="All 4 branches missed.">        } else if (p2SRC.x &lt;= bgImgWidth &amp;&amp; p2SRC.y &gt; bgImgHeight) {</span>
<span class="nc" id="L6818">            g.drawImage(bgImg, 0, bgImgHeight - p1SRC.y, p2DST.x,</span>
                    p2DST.y, p1SRC.x, 0, p2SRC.x, p2SRC.y - bgImgHeight,
                    null); // paint addtl slice on the top
<span class="nc bnc" id="L6821" title="All 4 branches missed.">        } else if (p2SRC.x &gt; bgImgWidth &amp;&amp; p2SRC.y &gt; bgImgHeight) {</span>
<span class="nc" id="L6822">            g.drawImage(bgImg, bgImgWidth - p1SRC.x, 0, p2DST.x,</span>
                    p2DST.y, 0, p1SRC.y, p2SRC.x - bgImgWidth, p2SRC.y,
                    null); // paint addtl slice on the top
<span class="nc" id="L6825">            g.drawImage(bgImg, 0, bgImgHeight - p1SRC.y, p2DST.x,</span>
                    p2DST.y, p1SRC.x, 0, p2SRC.x, p2SRC.y - bgImgHeight,
                    null); // paint addtl slice on the left side
            // paint addtl slice on the top left side
<span class="nc" id="L6829">            g.drawImage(bgImg, bgImgWidth - p1SRC.x,</span>
                    bgImgHeight - p1SRC.y, p2DST.x, p2DST.y, 0, 0,
                    p2SRC.x - bgImgWidth, p2SRC.y - bgImgHeight, null);
        }
<span class="nc" id="L6833">        g.setComposite(svComp);</span>
<span class="nc" id="L6834">        return hexImage;</span>
    }

    public void setDisplayInvalidHexInfo(boolean v) {
<span class="nc" id="L6838">        displayInvalidHexInfo = v;</span>
<span class="nc" id="L6839">    }</span>

    public boolean getDisplayInvalidHexInfo() {
<span class="nc" id="L6842">        return displayInvalidHexInfo;</span>
    }
    
    public Rectangle getDisplayablesRect() {
<span class="nc" id="L6846">        return displayablesRect;</span>
    }
    
    public void toggleKeybindsOverlay() {
<span class="nc bnc" id="L6850" title="All 2 branches missed.">        keybindOverlay.setVisible(!keybindOverlay.isVisible());</span>
<span class="nc" id="L6851">        repaint();</span>
<span class="nc" id="L6852">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.4.201905082037</span></div></body></html>