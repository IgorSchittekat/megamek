<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Compute.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">megamek</a> &gt; <a href="index.source.html" class="el_package">megamek.common</a> &gt; <span class="el_source">Compute.java</span></div><h1>Compute.java</h1><pre class="source lang-java linenums">/*
* MegaMek -
* Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005 Ben Mazur (bmazur@sev.org)
* Copyright (C) 2018 The MegaMek Team
*
* This program is free software; you can redistribute it and/or modify it under
* the terms of the GNU General Public License as published by the Free Software
* Foundation; either version 2 of the License, or (at your option) any later
* version.
*
* This program is distributed in the hope that it will be useful, but WITHOUT
* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
* details.
*/
package megamek.common;

import java.util.ArrayList;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.Vector;

import megamek.common.Building.BasementType;
import megamek.common.MovePath.MoveStepType;
import megamek.common.actions.BAVibroClawAttackAction;
import megamek.common.actions.BreakGrappleAttackAction;
import megamek.common.actions.BrushOffAttackAction;
import megamek.common.actions.ClubAttackAction;
import megamek.common.actions.EntityAction;
import megamek.common.actions.GrappleAttackAction;
import megamek.common.actions.JumpJetAttackAction;
import megamek.common.actions.KickAttackAction;
import megamek.common.actions.LayExplosivesAttackAction;
import megamek.common.actions.ProtomechPhysicalAttackAction;
import megamek.common.actions.PunchAttackAction;
import megamek.common.actions.PushAttackAction;
import megamek.common.actions.ThrashAttackAction;
import megamek.common.actions.TripAttackAction;
import megamek.common.actions.WeaponAttackAction;
import megamek.common.annotations.Nullable;
import megamek.common.options.OptionsConstants;
import megamek.common.weapons.InfantryAttack;
import megamek.common.weapons.Weapon;
import megamek.common.weapons.artillery.ArtilleryCannonWeapon;
import megamek.common.weapons.bayweapons.BayWeapon;
import megamek.common.weapons.gaussrifles.HAGWeapon;
import megamek.common.weapons.infantry.InfantryWeapon;
import megamek.common.weapons.mgs.MGWeapon;
import megamek.common.weapons.mortars.MekMortarWeapon;
import megamek.server.Server;
import megamek.server.SmokeCloud;

/**
 * The compute class is designed to provide static methods for mechs and other
 * entities moving, firing, etc.
 */
<span class="nc" id="L62">public class Compute {</span>

    public static final int ARC_360 = 0;
    public static final int ARC_FORWARD = 1;
    public static final int ARC_LEFTARM = 2;
    public static final int ARC_RIGHTARM = 3;
    public static final int ARC_REAR = 4;
    public static final int ARC_LEFTSIDE = 5;
    public static final int ARC_RIGHTSIDE = 6;
    public static final int ARC_MAINGUN = 7;
    public static final int ARC_NORTH = 8;
    public static final int ARC_EAST = 9;
    public static final int ARC_WEST = 10;
    public static final int ARC_NOSE = 11;
    public static final int ARC_LWING = 12;
    public static final int ARC_RWING = 13;
    public static final int ARC_LWINGA = 14;
    public static final int ARC_RWINGA = 15;
    public static final int ARC_LEFTSIDE_SPHERE = 16;
    public static final int ARC_RIGHTSIDE_SPHERE = 17;
    public static final int ARC_LEFTSIDEA_SPHERE = 18;
    public static final int ARC_RIGHTSIDEA_SPHERE = 19;
    public static final int ARC_LEFT_BROADSIDE = 20;
    public static final int ARC_RIGHT_BROADSIDE = 21;
    public static final int ARC_AFT = 22;
    public static final int ARC_LEFT_SPHERE_GROUND = 23;
    public static final int ARC_RIGHT_SPHERE_GROUND = 24;
    public static final int ARC_TURRET = 25;
    public static final int ARC_SPONSON_TURRET_LEFT = 26;
    public static final int ARC_SPONSON_TURRET_RIGHT = 27;
    public static final int ARC_PINTLE_TURRET_LEFT = 28;
    public static final int ARC_PINTLE_TURRET_RIGHT = 29;
    public static final int ARC_PINTLE_TURRET_FRONT = 30;
    public static final int ARC_PINTLE_TURRET_REAR = 31;
    public static final int ARC_VGL_FRONT = 32;
    public static final int ARC_VGL_RF = 33;
    public static final int ARC_VGL_RR = 34;
    public static final int ARC_VGL_REAR = 35;
    public static final int ARC_VGL_LR = 36;
    public static final int ARC_VGL_LF = 37;
    //Expanded arcs for Waypoint Launched Capital Missiles
    public static final int ARC_NOSE_WPL = 38;
    public static final int ARC_LWING_WPL = 39;
    public static final int ARC_RWING_WPL = 40;
    public static final int ARC_LWINGA_WPL = 41;
    public static final int ARC_RWINGA_WPL = 42;
    public static final int ARC_LEFTSIDE_SPHERE_WPL = 43;
    public static final int ARC_RIGHTSIDE_SPHERE_WPL = 44;
    public static final int ARC_LEFTSIDEA_SPHERE_WPL = 45;
    public static final int ARC_RIGHTSIDEA_SPHERE_WPL = 46;
    public static final int ARC_AFT_WPL = 47;
    public static final int ARC_LEFT_BROADSIDE_WPL = 48;
    public static final int ARC_RIGHT_BROADSIDE_WPL = 49;
    
    /** Lookup table for vehicular grenade launcher firing arc from facing */
<span class="fc" id="L117">    private static final int[] VGL_FIRING_ARCS = { ARC_VGL_FRONT, ARC_VGL_RF, ARC_VGL_RR,</span>
            ARC_VGL_REAR, ARC_VGL_LR, ARC_VGL_LF
    };

<span class="fc" id="L121">    private static MMRandom random = MMRandom.generate(MMRandom.R_DEFAULT);</span>

<span class="fc" id="L123">    private static final int[][] clusterHitsTable = new int[][]{</span>
            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
            {2, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2},
            {3, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3},
            {4, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4},
            {5, 1, 2, 2, 3, 3, 3, 3, 4, 4, 5, 5},
            {6, 2, 2, 3, 3, 4, 4, 4, 5, 5, 6, 6},
            {7, 2, 2, 3, 4, 4, 4, 4, 6, 6, 7, 7},
            {8, 2, 3, 3, 4, 4, 5, 5, 6, 7, 8, 8},
            {9, 3, 3, 4, 5, 5, 5, 5, 7, 7, 9, 9},
            {10, 3, 3, 4, 6, 6, 6, 6, 8, 8, 10, 10},
            {11, 4, 4, 5, 7, 7, 7, 7, 9, 9, 11, 11},
            {12, 4, 4, 5, 8, 8, 8, 8, 10, 10, 12, 12},
            {13, 4, 4, 5, 8, 8, 8, 8, 11, 11, 13, 13},
            {14, 5, 5, 6, 9, 9, 9, 9, 11, 11, 14, 14},
            {15, 5, 5, 6, 9, 9, 9, 9, 12, 12, 15, 15},
            {16, 5, 5, 7, 10, 10, 10, 10, 13, 13, 16, 16},
            {17, 5, 5, 7, 10, 10, 10, 10, 14, 14, 17, 17},
            {18, 6, 6, 8, 11, 11, 11, 11, 14, 14, 18, 18},
            {19, 6, 6, 8, 11, 11, 11, 11, 15, 15, 19, 19},
            {20, 6, 6, 9, 12, 12, 12, 12, 16, 16, 20, 20},
            {21, 7, 7, 9, 13, 13, 13, 13, 17, 17, 21, 21},
            {22, 7, 7, 9, 14, 14, 14, 14, 18, 18, 22, 22},
            {23, 7, 7, 10, 15, 15, 15, 15, 19, 19, 23, 23},
            {24, 8, 8, 10, 16, 16, 16, 16, 20, 20, 24, 24},
            {25, 8, 8, 10, 16, 16, 16, 16, 21, 21, 25, 25},
            {26, 9, 9, 11, 17, 17, 17, 17, 21, 21, 26, 26},
            {27, 9, 9, 11, 17, 17, 17, 17, 22, 22, 27, 27},
            {28, 9, 9, 11, 17, 17, 17, 17, 23, 23, 28, 28},
            {29, 10, 10, 12, 18, 18, 18, 18, 23, 23, 29, 29},
            {30, 10, 10, 12, 18, 18, 18, 18, 24, 24, 30, 30},
            {40, 12, 12, 18, 24, 24, 24, 24, 32, 32, 40, 40}};

    /**
     * Wrapper to random#d6(n)
     */
    public static int d6(int dice) {
<span class="fc" id="L160">        Roll roll = random.d6(dice);</span>
<span class="pc bpc" id="L161" title="1 of 2 branches missed.">        if (Server.getServerInstance() != null) {</span>
<span class="nc" id="L162">            if (Server.getServerInstance().getGame().getOptions()</span>
<span class="nc bnc" id="L163" title="All 2 branches missed.">                      .booleanOption(OptionsConstants.BASE_RNG_LOG)) {</span>
<span class="nc" id="L164">                Server.getServerInstance().reportRoll(roll);</span>
            }
        }
<span class="fc" id="L167">        return roll.getIntValue();</span>
    }

    /**
     * Wrapper to random#d6(n)
     */
    public static int d6(int dice, int keep) {
<span class="nc" id="L174">        Roll roll = random.d6(dice, keep);</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">        if (Server.getServerInstance() != null) {</span>
<span class="nc" id="L176">            if (Server.getServerInstance().getGame().getOptions()</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">                      .booleanOption(OptionsConstants.BASE_RNG_LOG)) {</span>
<span class="nc" id="L178">                Server.getServerInstance().reportRoll(roll);</span>
            }
        }
<span class="nc" id="L181">        return roll.getIntValue();</span>
    }

    /**
     * Wrapper to random#d6()
     */
    public static int d6() {
<span class="nc" id="L188">        Roll roll = random.d6();</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">        if (Server.getServerInstance() != null) {</span>
<span class="nc" id="L190">            if (Server.getServerInstance().getGame().getOptions()</span>
<span class="nc bnc" id="L191" title="All 2 branches missed.">                      .booleanOption(OptionsConstants.BASE_RNG_LOG)) {</span>
<span class="nc" id="L192">                Server.getServerInstance().reportRoll(roll);</span>
            }
        }
<span class="nc" id="L195">        return roll.getIntValue();</span>
    }

    /**
     * Input is in format &quot;ndf&quot;, so this can handle 2d6 or 3d10
     * @param number the number of dice to roll
     * @param faces  the number of faces on those dice
     * @return an Integer list of every dice roll, with index 0 containing the summed result
     */
    public static List&lt;Integer&gt; individualDice(final int number, final int faces) {
<span class="nc" id="L205">        final List&lt;Integer&gt; individualRolls = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L206">        int result = 0, roll;</span>
<span class="nc" id="L207">        individualRolls.add(result);</span>

<span class="nc bnc" id="L209" title="All 2 branches missed.">        for (int i = 0; i &lt; number; i++) {</span>
<span class="nc" id="L210">            roll = randomInt(faces) + 1;</span>
<span class="nc" id="L211">            individualRolls.add(roll);</span>
<span class="nc" id="L212">            result += roll;</span>
        }

<span class="nc" id="L215">        individualRolls.set(0, result);</span>

<span class="nc" id="L217">        return individualRolls;</span>
    }

    /**
     * Input is in format &quot;c ndf&quot;, so that this can handle 10 rolls of 3d6
     * @param count  the count of sets of dice to roll
     * @param number the number of dice to roll per set
     * @param faces  the number of faces per die
     * @return an Integer list of every summed dice roll, with index 0 containing the summed result
     */
    public static List&lt;Integer&gt; individualRolls(int count, int number, int faces) {
<span class="nc" id="L228">        List&lt;Integer&gt; individualRolls = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L229">        int result = 0, roll;</span>
<span class="nc" id="L230">        individualRolls.add(result);</span>

<span class="nc bnc" id="L232" title="All 2 branches missed.">        for (int x = 0; x &lt; count; x++) {</span>
<span class="nc" id="L233">            roll = 0;</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">            for (int y = 0; y &lt; number; y++) {</span>
<span class="nc" id="L235">                roll += randomInt(faces) + 1;</span>
            }
<span class="nc" id="L237">            individualRolls.add(roll);</span>
<span class="nc" id="L238">            result += roll;</span>
        }

<span class="nc" id="L241">        individualRolls.set(0, result);</span>

<span class="nc" id="L243">        return individualRolls;</span>
    }

    /**
     * Wrapper to random#randomInt(n)
     */
    public static int randomInt(int maxValue) {
<span class="nc" id="L250">        Roll roll = new MMRoll(random, maxValue);</span>
<span class="nc" id="L251">        return roll.getIntValue();</span>
    }

    /**
     * Wrapper to random#randomFloat()
     */
    public static float randomFloat() {
<span class="nc" id="L258">        return random.randomFloat();</span>
    }

    /**
     * Sets the RNG to the desired type
     */
    public static void setRNG(int type) {
<span class="nc" id="L265">        random = MMRandom.generate(type);</span>
<span class="nc" id="L266">    }</span>

    /**
     * Sets the RNG to the specific instance.
     * @param random A non-null instance of {@see MMRandom} to use
     *               for all random number generation.
     */
    public static void setRNG(MMRandom random) {
<span class="nc" id="L274">        Compute.random = Objects.requireNonNull(random);</span>
<span class="nc" id="L275">    }</span>

    /**
     * Returns the odds that a certain number or above will be rolled on 2d6.
     */
    public static double oddsAbove(int n) {
<span class="fc" id="L281">        return oddsAbove(n, false);</span>
    }


    /**
     * Returns the odds that a certain number or above will be rolled on 2d6,
     * or on 3d6 drop the lowest if the flag is set.
     *
     * @param n
     * @param dropLowest Flag that determines whether 2d6 or 3d6 drop the
     *                   lowest is used
     * @return
     */
    public static double oddsAbove(int n, boolean dropLowest) {
<span class="pc bpc" id="L295" title="1 of 2 branches missed.">        if (n &lt;= 2) {</span>
<span class="nc" id="L296">            return 100.0;</span>
<span class="fc bfc" id="L297" title="All 2 branches covered.">        } else if (n &gt; 12) {</span>
<span class="fc" id="L298">            return 0;</span>
        }

<span class="pc bpc" id="L301" title="1 of 2 branches missed.">        if (dropLowest) {</span>
<span class="nc" id="L302">            final double[] odds = {100.0, 100.0, 100.0, 99.54, 98.15, 94.91,</span>
                                   89.35, 80.56, 68.06, 52.32, 35.65, 19.91, 7.41, 0};
<span class="nc" id="L304">            return odds[n];</span>
        } else {
<span class="fc" id="L306">            final double[] odds = {100.0, 100.0, 100.0, 97.2, 91.6, 83.3, 72.2,</span>
                                   58.3, 41.6, 27.7, 16.6, 8.3, 2.78, 0};
<span class="fc" id="L308">            return odds[n];</span>
        }
    }

    /**
     * Returns an entity if the specified entity would cause a stacking
     * violation entering a hex, or returns null if it would not. The returned
     * entity is the entity causing the violation.
     *
     * The position, and elevation for the stacking violation are derived from
     * the Entity represented by the passed Entity ID.
     */
    public static Entity stackingViolation(IGame game, int enteringId,
            Coords coords) {
<span class="nc" id="L322">        Entity entering = game.getEntity(enteringId);</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">        if (entering == null) {</span>
<span class="nc" id="L324">            return null;</span>
        }
<span class="nc" id="L326">        return Compute.stackingViolation(game, entering, coords, null);</span>
    }

    /**
     * When compiling an unloading step, both the transporter and the unloaded
     * unit probably occupy some other position on the board.
     *
     * The position, and elevation for the stacking violation are derived from
     * the passed Entity.
     *
     * @param transport
     *            Represents the unit transporing entering, which may affect
     *            stacking, can be null
     */
    public static Entity stackingViolation(IGame game, Entity entering,
            Coords dest, Entity transport) {
<span class="nc" id="L342">        return stackingViolation(game, entering, entering.getElevation(), dest,</span>
                transport);
    }

    /**
     * Returns an entity if the specified entity would cause a stacking
     * violation entering a hex, or returns null if it would not. The returned
     * entity is the entity causing the violation.
     *
     * The position is derived from the passed Entity, while the elevation is
     * derived from the passed Entity parameter.
     *
     * @param transport
     *            Represents the unit transporing entering, which may affect
     *            stacking, can be null
     */
    public static Entity stackingViolation(IGame game, Entity entering,
            int elevation, Coords dest, Entity transport) {
<span class="nc" id="L360">        return stackingViolation(game, entering, entering.getPosition(),</span>
                elevation, dest, transport);
    }

    /**
     * Returns an entity if the specified entity would cause a stacking
     * violation entering a hex, or returns null if it would not. The returned
     * entity is the entity causing the violation.
     *
     * The position and elevation is derived from the passed Entity parameter.
     *
     * @param transport
     *            Represents the unit transporing entering, which may affect
     *            stacking, can be null
     */
    public static Entity stackingViolation(IGame game, Entity entering,
            Coords origPosition, int elevation, Coords dest, Entity transport) {
        // no stacking violations on the low-atmosphere and space maps
<span class="nc bnc" id="L378" title="All 2 branches missed.">        if (!game.getBoard().onGround()) {</span>
<span class="nc" id="L379">            return null;</span>
        }

        // no stacking violations for flying aeros
<span class="nc bnc" id="L383" title="All 2 branches missed.">        if (entering.isAirborne()) {</span>
<span class="nc" id="L384">            return null;</span>
        }

<span class="nc bnc" id="L387" title="All 4 branches missed.">        boolean isMech = (entering instanceof Mech)</span>
                || (entering instanceof SmallCraft);
<span class="nc bnc" id="L389" title="All 6 branches missed.">        boolean isLargeSupport = (entering instanceof LargeSupportTank)</span>
                || (entering instanceof Dropship)
                || ((entering instanceof Mech) &amp;&amp; ((Mech) entering)
<span class="nc bnc" id="L392" title="All 2 branches missed.">                        .isSuperHeavy());</span>

<span class="nc bnc" id="L394" title="All 2 branches missed.">        boolean isTrain = !entering.getAllTowedUnits().isEmpty();</span>
<span class="nc" id="L395">        boolean isDropship = entering instanceof Dropship;</span>
<span class="nc" id="L396">        boolean isInfantry = entering instanceof Infantry;</span>
<span class="nc" id="L397">        Entity firstEntity = transport;</span>
<span class="nc" id="L398">        int totalUnits = 1;</span>
<span class="nc" id="L399">        Vector&lt;Coords&gt; positions = new Vector&lt;Coords&gt;();</span>
<span class="nc" id="L400">        positions.add(dest);</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">        if (isDropship) {</span>
<span class="nc bnc" id="L402" title="All 2 branches missed.">            for (int dir = 0; dir &lt; 6; dir++) {</span>
<span class="nc" id="L403">                positions.add(dest.translated(dir));</span>
            }
        }
<span class="nc bnc" id="L406" title="All 2 branches missed.">        for (Coords coords : positions) {</span>
<span class="nc" id="L407">            int thisLowStackingLevel = elevation;</span>
<span class="nc bnc" id="L408" title="All 4 branches missed.">            if ((coords != null) &amp;&amp; (origPosition != null)) {</span>
<span class="nc" id="L409">                thisLowStackingLevel = entering.calcElevation(game.getBoard()</span>
<span class="nc" id="L410">                        .getHex(origPosition), game.getBoard()</span>
<span class="nc" id="L411">                        .getHex(coords), elevation, entering</span>
<span class="nc" id="L412">                        .climbMode(), false);</span>
            }
<span class="nc" id="L414">            int thisHighStackingLevel = thisLowStackingLevel;</span>
            // mechs only occupy one level of a building
<span class="nc bnc" id="L416" title="All 2 branches missed.">            if (!Compute.isInBuilding(game, entering, coords)) {</span>
<span class="nc" id="L417">                thisHighStackingLevel += entering.height();</span>
            }

            // Walk through the entities in the given hex.
<span class="nc bnc" id="L421" title="All 2 branches missed.">            for (Entity inHex : game.getEntitiesVector(coords)) {</span>

<span class="nc bnc" id="L423" title="All 2 branches missed.">                if (inHex.isAirborne()) {</span>
<span class="nc" id="L424">                    continue;</span>
                }

<span class="nc" id="L427">                int lowStackingLevel = inHex.getElevation();</span>
<span class="nc" id="L428">                int highStackingLevel = lowStackingLevel;</span>
                // units only occupy one level of a building
<span class="nc bnc" id="L430" title="All 2 branches missed.">                if (!Compute.isInBuilding(game, inHex)) {</span>
<span class="nc" id="L431">                    highStackingLevel += inHex.height();</span>
                }

                // Only do all this jazz if they're close enough together on lvl
                // to interfere.
<span class="nc bnc" id="L436" title="All 4 branches missed.">                if ((thisLowStackingLevel &lt;= highStackingLevel)</span>
                        &amp;&amp; (thisHighStackingLevel &gt;= lowStackingLevel)) {
                    // Don't compare the entering entity to itself.
<span class="nc bnc" id="L439" title="All 2 branches missed.">                    if (inHex.equals(entering)) {</span>
<span class="nc" id="L440">                        continue;</span>
                    }

                    // Ignore the transport of the entering entity.
<span class="nc bnc" id="L444" title="All 2 branches missed.">                    if (inHex.equals(transport)) {</span>
<span class="nc" id="L445">                        continue;</span>
                    }

                    //ignore the first trailer behind a non-superheavy tractor
                    //which can be in the same hex
<span class="nc bnc" id="L450" title="All 4 branches missed.">                    if (isTrain &amp;&amp; !entering.isSuperHeavy()) {</span>
<span class="nc" id="L451">                        Entity firstTrailer = game.getEntity(entering.getAllTowedUnits().get(0));</span>
<span class="nc bnc" id="L452" title="All 2 branches missed.">                        if (inHex.equals(firstTrailer)) {</span>
<span class="nc" id="L453">                            continue;</span>
                        }
                    }

                    // DFAing units don't count towards stacking
<span class="nc bnc" id="L458" title="All 2 branches missed.">                    if (inHex.isMakingDfa()) {</span>
<span class="nc" id="L459">                        continue;</span>
                    }

                    // If the entering entity is a mech,
                    // then any other mech in the hex is a violation.
                    // Unless grappled (but chain whip grapples don't count)
                    // grounded small craft are treated as mechs for purposes
                    // of stacking
<span class="nc bnc" id="L467" title="All 4 branches missed.">                    if (isMech</span>
                            &amp;&amp; (((inHex instanceof Mech) &amp;&amp; (inHex
<span class="nc bnc" id="L469" title="All 2 branches missed.">                                    .getGrappled() != entering.getId() || inHex</span>
<span class="nc bnc" id="L470" title="All 4 branches missed.">                                    .isChainWhipGrappled())) || (inHex instanceof SmallCraft))) {</span>
<span class="nc" id="L471">                        return inHex;</span>
                    }

                    // only inf can be in the same hex as a large support vee
                    // grounded dropships are treated as large support vees,
                    // ditto for superheavy mechs
<span class="nc bnc" id="L477" title="All 4 branches missed.">                    if (isLargeSupport &amp;&amp; !(inHex instanceof Infantry)) {</span>
<span class="nc" id="L478">                        return inHex;</span>
                    }
<span class="nc bnc" id="L480" title="All 6 branches missed.">                    if (((inHex instanceof LargeSupportTank)</span>
                            || (inHex instanceof Dropship) || ((inHex instanceof Mech) &amp;&amp; ((Mech) inHex)
<span class="nc bnc" id="L482" title="All 4 branches missed.">                            .isSuperHeavy())) &amp;&amp; !isInfantry) {</span>
<span class="nc" id="L483">                        return inHex;</span>
                    }

<span class="nc" id="L486">                    totalUnits++;</span>
                    // If the new one is the most
<span class="nc bnc" id="L488" title="All 2 branches missed.">                    if (totalUnits &gt; 4) {</span>
                        // Arbitrarily return this one, because we can, and it's
                        // simpler.
<span class="nc" id="L491">                        return inHex;</span>
                    }

                    // Otherwise, if there are two present entities controlled
                    // by this player, returns a random one of the two.
                    // Somewhat arbitrary, but how else should we resolve it?
<span class="nc bnc" id="L497" title="All 2 branches missed.">                    if (!inHex.getOwner().isEnemyOf(entering.getOwner())) {</span>
<span class="nc bnc" id="L498" title="All 2 branches missed.">                        if (firstEntity == null) {</span>
<span class="nc" id="L499">                            firstEntity = inHex;</span>
                        } else {
<span class="nc bnc" id="L501" title="All 2 branches missed.">                            return Compute.d6() &gt; 3 ? firstEntity : inHex;</span>
                        }
                    }
                }
<span class="nc" id="L505">            }</span>
<span class="nc" id="L506">        }</span>
        // okay, all clear
<span class="nc" id="L508">        return null;</span>
    }

    /**
     * Returns true if there is any unit that is an enemy of the specified unit
     * in the specified hex. This is only called for stacking purposes, and so
     * does not return true if the enemy unit is currenly making a DFA.
     */
    public static boolean isEnemyIn(IGame game, Entity entity, Coords coords,
                                    boolean onlyMechs, boolean ignoreInfantry, int enLowEl) {
<span class="nc" id="L518">        int enHighEl = enLowEl + entity.getHeight();</span>
<span class="nc bnc" id="L519" title="All 2 branches missed.">        for (Entity inHex : game.getEntitiesVector(coords)) {</span>
<span class="nc" id="L520">            int inHexEnLowEl = inHex.getElevation();</span>
<span class="nc" id="L521">            int inHexEnHighEl = inHexEnLowEl + inHex.getHeight();</span>
<span class="nc bnc" id="L522" title="All 8 branches missed.">            if ((!onlyMechs || (inHex instanceof Mech))</span>
                &amp;&amp; !(ignoreInfantry &amp;&amp; (inHex instanceof Infantry))
<span class="nc bnc" id="L524" title="All 8 branches missed.">                &amp;&amp; inHex.isEnemyOf(entity) &amp;&amp; !inHex.isMakingDfa()</span>
                &amp;&amp; (enLowEl &lt;= inHexEnHighEl) &amp;&amp; (enHighEl &gt;= inHexEnLowEl)) {
<span class="nc" id="L526">                return true;</span>
            }
<span class="nc" id="L528">        }</span>
<span class="nc" id="L529">        return false;</span>
    }

    /**
     * @return true if a piloting skill roll is needed to traverse the terrain
     */
    public static boolean isPilotingSkillNeeded(IGame game, int entityId,
            Coords src, Coords dest, EntityMovementType movementType,
            boolean isTurning, boolean prevStepIsOnPavement, int srcElevation,
            int destElevation, MoveStep moveStep) {
<span class="nc" id="L539">        final Entity entity = game.getEntity(entityId);</span>
<span class="nc" id="L540">        final IHex srcHex = game.getBoard().getHex(src);</span>
<span class="nc" id="L541">        final IHex destHex = game.getBoard().getHex(dest);</span>
<span class="nc" id="L542">        final boolean isInfantry = (entity instanceof Infantry);</span>
<span class="nc" id="L543">        int delta_alt = (destElevation + destHex.getLevel())</span>
<span class="nc" id="L544">                        - (srcElevation + srcHex.getLevel());</span>

        // arguments valid?
<span class="nc bnc" id="L547" title="All 2 branches missed.">        if (entity == null) {</span>
<span class="nc" id="L548">            throw new IllegalArgumentException(&quot;Entity invalid. ID &quot; + entityId);</span>
        }
<span class="nc bnc" id="L550" title="All 2 branches missed.">        if (src.distance(dest) &gt; 1) {</span>
<span class="nc" id="L551">            throw new IllegalArgumentException(&quot;Coordinates must be adjacent.&quot;);</span>
        }

        // let's only worry about actual movement, please
<span class="nc bnc" id="L555" title="All 2 branches missed.">        if (src.equals(dest)) {</span>
<span class="nc" id="L556">            return false;</span>
        }

        // airborne aircraft do not require pavement-related checks
<span class="nc bnc" id="L560" title="All 2 branches missed.">        final boolean isPavementStep = entity.isAirborne() ? false : Compute.canMoveOnPavement(game, src, dest, moveStep);</span>

        // check for rubble
<span class="nc bnc" id="L563" title="All 2 branches missed.">        if ((movementType != EntityMovementType.MOVE_JUMP)</span>
<span class="nc bnc" id="L564" title="All 6 branches missed.">            &amp;&amp; (destHex.terrainLevel(Terrains.RUBBLE) &gt; 0)</span>
            &amp;&amp; (destElevation == 0)
            &amp;&amp; !isPavementStep
<span class="nc bnc" id="L567" title="All 2 branches missed.">            &amp;&amp; entity.canFall()) {</span>
<span class="nc" id="L568">            return true;</span>
        }

        // check for swamp
<span class="nc bnc" id="L572" title="All 2 branches missed.">        if (destHex.containsTerrain(Terrains.SWAMP)</span>
<span class="nc bnc" id="L573" title="All 2 branches missed.">            &amp;&amp; !(entity.getElevation() &gt; destHex.getLevel())</span>
<span class="nc bnc" id="L574" title="All 2 branches missed.">            &amp;&amp; (entity.getMovementMode() != EntityMovementMode.HOVER)</span>
<span class="nc bnc" id="L575" title="All 4 branches missed.">            &amp;&amp; (entity.getMovementMode() != EntityMovementMode.VTOL)</span>
            &amp;&amp; (movementType != EntityMovementType.MOVE_JUMP)
<span class="nc bnc" id="L577" title="All 4 branches missed.">            &amp;&amp; (entity.getMovementMode() != EntityMovementMode.WIGE)</span>
            &amp;&amp; !isPavementStep) {
<span class="nc" id="L579">            return true;</span>
        }

        // check for thin ice
<span class="nc bnc" id="L583" title="All 2 branches missed.">        if (destHex.containsTerrain(Terrains.ICE)</span>
<span class="nc bnc" id="L584" title="All 2 branches missed.">            &amp;&amp; destHex.containsTerrain(Terrains.WATER)</span>
<span class="nc bnc" id="L585" title="All 6 branches missed.">            &amp;&amp; !(entity.getElevation() &gt; destHex.getLevel())</span>
            &amp;&amp; !isPavementStep
            &amp;&amp; (movementType != EntityMovementType.MOVE_JUMP)) {
<span class="nc" id="L588">            return true;</span>
        }

        // Check for water unless we're a hovercraft or naval or using a bridge
        // or flying or QuadVee in vehicle mode.
<span class="nc bnc" id="L593" title="All 2 branches missed.">        if ((movementType != EntityMovementType.MOVE_JUMP)</span>
<span class="nc bnc" id="L594" title="All 2 branches missed.">                &amp;&amp; !(entity.getElevation() &gt; destHex.surface())</span>
<span class="nc bnc" id="L595" title="All 2 branches missed.">                &amp;&amp; !((entity.getMovementMode() == EntityMovementMode.HOVER)</span>
<span class="nc bnc" id="L596" title="All 2 branches missed.">                        || (entity.getMovementMode() == EntityMovementMode.NAVAL)</span>
<span class="nc bnc" id="L597" title="All 2 branches missed.">                        || (entity.getMovementMode() == EntityMovementMode.HYDROFOIL)</span>
<span class="nc bnc" id="L598" title="All 2 branches missed.">                        || (entity.getMovementMode() == EntityMovementMode.SUBMARINE)</span>
<span class="nc bnc" id="L599" title="All 2 branches missed.">                        || (entity.getMovementMode() == EntityMovementMode.INF_UMU)</span>
<span class="nc bnc" id="L600" title="All 2 branches missed.">                        || (entity.getMovementMode() == EntityMovementMode.BIPED_SWIM)</span>
<span class="nc bnc" id="L601" title="All 2 branches missed.">                        || (entity.getMovementMode() == EntityMovementMode.QUAD_SWIM)</span>
<span class="nc bnc" id="L602" title="All 4 branches missed.">                        || (entity.getMovementMode() == EntityMovementMode.WIGE)</span>
<span class="nc bnc" id="L603" title="All 2 branches missed.">                        || (entity instanceof QuadVee &amp;&amp; entity.getConversionMode() == QuadVee.CONV_MODE_VEHICLE))</span>
<span class="nc bnc" id="L604" title="All 4 branches missed.">                &amp;&amp; (destHex.terrainLevel(Terrains.WATER) &gt; 0)</span>
                &amp;&amp; !isPavementStep) {
<span class="nc" id="L606">            return true;</span>
        }
        
        // Sheer Cliffs, TO p.39
        // Roads over cliffs cancel the cliff effects for units that move on roads
<span class="nc bnc" id="L611" title="All 2 branches missed.">        boolean quadveeVehMode = entity instanceof QuadVee </span>
<span class="nc bnc" id="L612" title="All 2 branches missed.">                &amp;&amp; entity.getConversionMode() == QuadVee.CONV_MODE_VEHICLE;</span>
<span class="nc bnc" id="L613" title="All 2 branches missed.">        boolean vehicleAffectedByCliff = entity instanceof Tank </span>
<span class="nc bnc" id="L614" title="All 2 branches missed.">                &amp;&amp; !entity.isAirborneVTOLorWIGE();</span>
<span class="nc bnc" id="L615" title="All 6 branches missed.">        boolean mechAffectedByCliff = (entity instanceof Mech || entity instanceof Protomech) </span>
                &amp;&amp; movementType != EntityMovementType.MOVE_JUMP
<span class="nc bnc" id="L617" title="All 2 branches missed.">                &amp;&amp; !entity.isAero(); // LAM</span>
<span class="nc" id="L618">        int stepHeight = destElevation + destHex.getLevel() - (srcElevation + srcHex.getLevel());</span>
        // Cliffs should only exist towards 1 or 2 level drops, check just to make sure
        // Everything that does not have a 1 or 2 level drop shouldn't be handled as a cliff
<span class="nc bnc" id="L621" title="All 2 branches missed.">        boolean isUpCliff = !src.equals(dest)</span>
<span class="nc bnc" id="L622" title="All 6 branches missed.">                &amp;&amp; destHex.hasCliffTopTowards(srcHex)</span>
                &amp;&amp; (stepHeight == 1 || stepHeight == 2);
<span class="nc bnc" id="L624" title="All 2 branches missed.">        boolean isDownCliff = !src.equals(dest) </span>
<span class="nc bnc" id="L625" title="All 6 branches missed.">                &amp;&amp; srcHex.hasCliffTopTowards(destHex)</span>
                &amp;&amp; (stepHeight == -1 || stepHeight == -2);

        // Mechs and Vehicles moving down a cliff
        // Quadvees in vee mode ignore PSRs to avoid falls, IO p.133 
<span class="nc bnc" id="L630" title="All 10 branches missed.">        if ((mechAffectedByCliff || vehicleAffectedByCliff) </span>
                &amp;&amp; !quadveeVehMode
                &amp;&amp; isDownCliff
                &amp;&amp; !isPavementStep) {
<span class="nc" id="L634">            return true;</span>
        }

        // Mechs moving up a cliff
<span class="nc bnc" id="L638" title="All 8 branches missed.">        if (mechAffectedByCliff </span>
                &amp;&amp; !quadveeVehMode 
                &amp;&amp; isUpCliff
                &amp;&amp; !isPavementStep) {
<span class="nc" id="L642">            return true;</span>
        }

        // Check for skid. Please note, the skid will be rolled on the
        // current step, but starts from the previous step's location.
        // TODO: add check for elevation of pavement, road,
        // or bridge matches entity elevation.
        /*
         * Bug 754610: Revert fix for bug 702735. if ( (
         * srcHex.contains(Terrain.PAVEMENT) || srcHex.contains(Terrain.ROAD) ||
         * srcHex.contains(Terrain.BRIDGE) )
         */
<span class="nc bnc" id="L654" title="All 6 branches missed.">        if (((prevStepIsOnPavement</span>
                &amp;&amp; ((movementType == EntityMovementType.MOVE_RUN)
                        || (movementType == EntityMovementType.MOVE_SPRINT)))
<span class="nc bnc" id="L657" title="All 4 branches missed.">                        || ((srcHex.containsTerrain(Terrains.ICE))</span>
                                &amp;&amp; (movementType != EntityMovementType.MOVE_JUMP)))
<span class="nc bnc" id="L659" title="All 2 branches missed.">                &amp;&amp; (entity.getMovementMode() != EntityMovementMode.HOVER)</span>
<span class="nc bnc" id="L660" title="All 6 branches missed.">                &amp;&amp; (entity.getMovementMode() != EntityMovementMode.WIGE)</span>
                &amp;&amp; isTurning &amp;&amp; !isInfantry) {
<span class="nc" id="L662">            return true;</span>
        }

        // If we entering a building, all non-infantry
        // need to make a piloting check to avoid damage.
<span class="nc bnc" id="L667" title="All 4 branches missed.">        if ((destElevation &lt; destHex.terrainLevel(Terrains.BLDG_ELEV))</span>
            &amp;&amp; !(entity instanceof Infantry)) {
<span class="nc" id="L669">            Building bldg = game.getBoard().getBuildingAt(dest);</span>
<span class="nc bnc" id="L670" title="All 2 branches missed.">            boolean insideHangar = (null != bldg)</span>
<span class="nc bnc" id="L671" title="All 2 branches missed.">                                   &amp;&amp; bldg.isIn(src)</span>
<span class="nc bnc" id="L672" title="All 2 branches missed.">                                   &amp;&amp; (bldg.getBldgClass() == Building.HANGAR)</span>
<span class="nc" id="L673">                                   &amp;&amp; (destHex.terrainLevel(Terrains.BLDG_ELEV) &gt; entity</span>
<span class="nc bnc" id="L674" title="All 2 branches missed.">                    .height());</span>
<span class="nc bnc" id="L675" title="All 2 branches missed.">            if (!insideHangar) {</span>
<span class="nc" id="L676">                return true;</span>
            }
        }

        // check sideslips
<span class="nc bnc" id="L681" title="All 2 branches missed.">        if ((entity instanceof VTOL)</span>
<span class="nc bnc" id="L682" title="All 2 branches missed.">                || (entity.getMovementMode() == EntityMovementMode.HOVER)</span>
<span class="nc bnc" id="L683" title="All 6 branches missed.">                || (entity.getMovementMode() == EntityMovementMode.WIGE</span>
                        &amp;&amp; destElevation &gt; 0 &amp;&amp; !(entity instanceof Protomech))) {
<span class="nc bnc" id="L685" title="All 10 branches missed.">            if (isTurning</span>
                    &amp;&amp; ((movementType == EntityMovementType.MOVE_RUN)
                            || (movementType == EntityMovementType.MOVE_SPRINT)
                            || (movementType == EntityMovementType.MOVE_VTOL_RUN)
                            || (movementType == EntityMovementType.MOVE_VTOL_SPRINT))) {
<span class="nc" id="L690">                return true;</span>
            }
            // Controlled sideslip requires check to avoid extra hex of sideslip movement.
<span class="nc bnc" id="L693" title="All 2 branches missed.">            if ((moveStep.getType() == MoveStepType.LATERAL_LEFT</span>
<span class="nc bnc" id="L694" title="All 2 branches missed.">                    || moveStep.getType() == MoveStepType.LATERAL_RIGHT</span>
<span class="nc bnc" id="L695" title="All 2 branches missed.">                    || moveStep.getType() == MoveStepType.LATERAL_LEFT_BACKWARDS</span>
<span class="nc bnc" id="L696" title="All 2 branches missed.">                    || moveStep.getType() == MoveStepType.LATERAL_RIGHT_BACKWARDS)</span>
<span class="nc bnc" id="L697" title="All 6 branches missed.">                    &amp;&amp; (!entity.isUsingManAce()</span>
                            || movementType != EntityMovementType.MOVE_WALK
                            || movementType != EntityMovementType.MOVE_VTOL_WALK)) {
<span class="nc" id="L700">                return true;</span>
            }
        }

        // check leaps
<span class="nc bnc" id="L705" title="All 10 branches missed.">        if ((entity instanceof Mech) &amp;&amp; (delta_alt &lt; -2)</span>
            &amp;&amp; (movementType != EntityMovementType.MOVE_JUMP
            &amp;&amp; (movementType != EntityMovementType.MOVE_VTOL_WALK
            &amp;&amp; (movementType != EntityMovementType.MOVE_VTOL_RUN)))) {
<span class="nc" id="L709">            return true;</span>
        }

<span class="nc" id="L712">        return false;</span>
    }

    /**
     * Can the defending unit be displaced from the source to the destination?
     */
    public static boolean isValidDisplacement(IGame game, int entityId,
            Coords src, int direction) {
<span class="nc" id="L720">        return Compute.isValidDisplacement(game, entityId, src,</span>
<span class="nc" id="L721">                src.translated(direction));</span>
    }

    /**
     * Can the defending unit be displaced from the source to the destination?
     */
    public static boolean isValidDisplacement(IGame game, int entityId,
            Coords src, Coords dest) {
<span class="nc" id="L729">        final Entity entity = game.getEntity(entityId);</span>
<span class="nc" id="L730">        final IHex srcHex = game.getBoard().getHex(src);</span>
<span class="nc" id="L731">        final IHex destHex = game.getBoard().getHex(dest);</span>
<span class="nc" id="L732">        final ArrayList&lt;Coords&gt; intervening = Coords.intervening(src, dest);</span>
<span class="nc" id="L733">        final int direction = src.direction(dest);</span>

        // arguments valid?
<span class="nc bnc" id="L736" title="All 2 branches missed.">        if (entity == null) {</span>
<span class="nc" id="L737">            throw new IllegalArgumentException(&quot;Entity invalid.&quot;);</span>
        }

        // dropships should never be displaceable
        // this should also take care of the situation of displacing another
        // entity
        // into a grounded droppers hex, because of the stacking violation check
        // below
<span class="nc bnc" id="L745" title="All 2 branches missed.">        if (entity instanceof Dropship) {</span>
<span class="nc" id="L746">            return false;</span>
        }

        // an easy check
<span class="nc bnc" id="L750" title="All 2 branches missed.">        if (!game.getBoard().contains(dest)) {</span>
<span class="nc bnc" id="L751" title="All 2 branches missed.">            if (game.getOptions().booleanOption(OptionsConstants.BASE_PUSH_OFF_BOARD)) {</span>
<span class="nc" id="L752">                return true;</span>
            }
<span class="nc" id="L754">            return false;</span>
        }

        // can't be displaced into prohibited terrain
        // unless we're displacing a tracked or wheeled vee into water
<span class="nc bnc" id="L759" title="All 4 branches missed.">        if (entity.isLocationProhibited(dest)</span>
                &amp;&amp; !((entity instanceof Tank)
<span class="nc bnc" id="L761" title="All 6 branches missed.">                        &amp;&amp; destHex.containsTerrain(Terrains.WATER)</span>
                        &amp;&amp; ((entity.movementMode == EntityMovementMode.TRACKED)
                                || (entity.movementMode == EntityMovementMode.WHEELED)))) {
<span class="nc" id="L764">            return false;</span>
        }

        // can't go up more levels than normally possible
<span class="nc bnc" id="L768" title="All 2 branches missed.">        for (Coords c : intervening) {</span>
            // ignore off-board hexes
<span class="nc bnc" id="L770" title="All 2 branches missed.">            if (!game.getBoard().contains(c)) {</span>
<span class="nc" id="L771">                continue;</span>
            }
<span class="nc" id="L773">            final IHex hex = game.getBoard().getHex(c);</span>
<span class="nc" id="L774">            int change = entity.elevationOccupied(hex)</span>
<span class="nc" id="L775">                         - entity.elevationOccupied(srcHex);</span>
<span class="nc bnc" id="L776" title="All 2 branches missed.">            if (change &gt; entity.getMaxElevationChange()) {</span>
<span class="nc" id="L777">                return false;</span>
            }
<span class="nc" id="L779">        }</span>

        // if there's an entity in the way, can they be displaced in that
        // direction?
<span class="nc" id="L783">        Entity inTheWay = Compute.stackingViolation(game, entityId, dest);</span>
<span class="nc bnc" id="L784" title="All 2 branches missed.">        if (inTheWay != null) {</span>
<span class="nc" id="L785">            return Compute.isValidDisplacement(game, inTheWay.getId(),</span>
<span class="nc" id="L786">                    inTheWay.getPosition(), direction);</span>
        }

        // okay, that's about all the checks
<span class="nc" id="L790">        return true;</span>
    }

    /**
     * Gets a valid displacement, from the hexes around src, as close to the
     * original direction as is possible.
     *
     * @return valid displacement coords, or null if none
     */
    public static Coords getValidDisplacement(IGame game, int entityId,
            Coords src, int direction) {
        // check the surrounding hexes, nearest to the original direction first
<span class="nc" id="L802">        int[] offsets = {0, 1, 5, 2, 4, 3};</span>
<span class="nc" id="L803">        int range = 1;</span>
        // check for a central dropship hex and if so, then displace to a two
        // hex radius
<span class="nc bnc" id="L806" title="All 2 branches missed.">        for (Entity en : game.getEntitiesVector(src)) {</span>
<span class="nc bnc" id="L807" title="All 4 branches missed.">            if ((en instanceof Dropship) &amp;&amp; !en.isAirborne()</span>
<span class="nc bnc" id="L808" title="All 2 branches missed.">                &amp;&amp; en.getPosition().equals(src)) {</span>
<span class="nc" id="L809">                range = 2;</span>
            }
<span class="nc" id="L811">        }</span>
<span class="nc bnc" id="L812" title="All 2 branches missed.">        for (int offset : offsets) {</span>
<span class="nc" id="L813">            Coords dest = src.translated((direction + offset) % 6, range);</span>
<span class="nc bnc" id="L814" title="All 2 branches missed.">            if (Compute.isValidDisplacement(game, entityId, src, dest)) {</span>
<span class="nc" id="L815">                return dest;</span>
            }
            // code here borrowed from Compute.coordsAtRange
<span class="nc bnc" id="L818" title="All 2 branches missed.">            for (int count = 1; count &lt; range; count++) {</span>
<span class="nc" id="L819">                dest = dest.translated((direction + offset + 2) % 6);</span>
<span class="nc bnc" id="L820" title="All 2 branches missed.">                if (Compute.isValidDisplacement(game, entityId, src, dest)) {</span>
<span class="nc" id="L821">                    return dest;</span>
                }
            }
        }
        // have fun being insta-killed!
<span class="nc" id="L826">        return null;</span>
    }

    /**
     * Gets a preferred displacement. Right now this picks the surrounding hex
     * with the same elevation as original hex, if not available it picks the
     * highest elevation that is a valid displacement. This will preferably not
     * displace into friendly units
     *
     * @return valid displacement coords, or null if none
     */
    public static Coords getPreferredDisplacement(IGame game, int entityId,
            Coords src, int direction) {
<span class="nc" id="L839">        final Entity entity = game.getEntity(entityId);</span>
<span class="nc" id="L840">        int highestElev = Integer.MIN_VALUE;</span>
<span class="nc" id="L841">        Coords highest = null;</span>
<span class="nc" id="L842">        int srcElevation =</span>
<span class="nc" id="L843">                entity.elevationOccupied(game.getBoard().getHex(src));</span>

        // check the surrounding hexes, nearest to the original direction first
<span class="nc" id="L846">        int[] offsets = {0, 1, 5, 2, 4, 3};</span>
        // first, try not to displace into friendly units
<span class="nc bnc" id="L848" title="All 2 branches missed.">        for (int offset : offsets) {</span>
<span class="nc" id="L849">            Coords dest = src.translated((direction + offset) % 6);</span>
<span class="nc bnc" id="L850" title="All 2 branches missed.">            if (Compute.isValidDisplacement(game, entityId, src, dest)</span>
<span class="nc bnc" id="L851" title="All 2 branches missed.">                &amp;&amp; game.getBoard().contains(dest)) {</span>
<span class="nc" id="L852">                Iterator&lt;Entity&gt; entities = game.getFriendlyEntities(dest,</span>
<span class="nc" id="L853">                        game.getEntity(entityId));</span>
<span class="nc bnc" id="L854" title="All 2 branches missed.">                if (entities.hasNext()) {</span>
                    // friendly unit here, try next hex
<span class="nc" id="L856">                    continue;</span>
                }
<span class="nc" id="L858">                IHex hex = game.getBoard().getHex(dest);</span>
<span class="nc" id="L859">                int elevation = entity.elevationOccupied(hex);</span>
<span class="nc bnc" id="L860" title="All 2 branches missed.">                if (elevation &gt; highestElev) {</span>
<span class="nc" id="L861">                    highestElev = elevation;</span>
<span class="nc" id="L862">                    highest = dest;</span>
                }
                // preferably, go to same elevation
<span class="nc bnc" id="L865" title="All 2 branches missed.">                if (elevation == srcElevation) {</span>
<span class="nc" id="L866">                    return dest;</span>
                }
            }
        }
<span class="nc bnc" id="L870" title="All 2 branches missed.">        if (highest != null) {</span>
<span class="nc" id="L871">            return highest;</span>
        }
        // ok, all hexes occupied, now displace preferably to same elevation,
        // else highest
<span class="nc bnc" id="L875" title="All 2 branches missed.">        for (int offset : offsets) {</span>
<span class="nc" id="L876">            Coords dest = src.translated((direction + offset) % 6);</span>
<span class="nc bnc" id="L877" title="All 2 branches missed.">            if (Compute.isValidDisplacement(game, entityId, src, dest)</span>
<span class="nc bnc" id="L878" title="All 2 branches missed.">                &amp;&amp; game.getBoard().contains(dest)) {</span>
<span class="nc" id="L879">                IHex hex = game.getBoard().getHex(dest);</span>
<span class="nc" id="L880">                int elevation = entity.elevationOccupied(hex);</span>
<span class="nc bnc" id="L881" title="All 2 branches missed.">                if (elevation &gt; highestElev) {</span>
<span class="nc" id="L882">                    highestElev = elevation;</span>
<span class="nc" id="L883">                    highest = dest;</span>
                }
                // preferably, go to same elevation
<span class="nc bnc" id="L886" title="All 2 branches missed.">                if (elevation == entity.getElevation()) {</span>
<span class="nc" id="L887">                    return dest;</span>
                }
            }
        }
<span class="nc" id="L891">        return highest;</span>
    }

    /**
     * Gets a hex to displace a missed charge to. Picks left or right, first
     * preferring higher hexes, then randomly, or returns the base hex if
     * they're impassible.
     */
    public static Coords getMissedChargeDisplacement(IGame game, int entityId,
                                                     Coords src, int direction) {
<span class="nc" id="L901">        Coords first = src.translated((direction + 1) % 6);</span>
<span class="nc" id="L902">        Coords second = src.translated((direction + 5) % 6);</span>
<span class="nc" id="L903">        IHex firstHex = game.getBoard().getHex(first);</span>
<span class="nc" id="L904">        IHex secondHex = game.getBoard().getHex(second);</span>
<span class="nc" id="L905">        Entity entity = game.getEntity(entityId);</span>

<span class="nc bnc" id="L907" title="All 4 branches missed.">        if ((firstHex == null) || (secondHex == null)) {</span>
            // leave it, will be handled
<span class="nc" id="L909">        } else if (entity.elevationOccupied(firstHex) &gt; entity</span>
<span class="nc bnc" id="L910" title="All 2 branches missed.">                .elevationOccupied(secondHex)) {</span>
            // leave it
<span class="nc" id="L912">        } else if (entity.elevationOccupied(firstHex) &lt; entity</span>
<span class="nc bnc" id="L913" title="All 2 branches missed.">                .elevationOccupied(secondHex)) {</span>
            // switch
<span class="nc" id="L915">            Coords temp = first;</span>
<span class="nc" id="L916">            first = second;</span>
<span class="nc" id="L917">            second = temp;</span>
<span class="nc bnc" id="L918" title="All 2 branches missed.">        } else if (Compute.d6() &gt; 3) {</span>
            // switch randomly
<span class="nc" id="L920">            Coords temp = first;</span>
<span class="nc" id="L921">            first = second;</span>
<span class="nc" id="L922">            second = temp;</span>
        }

<span class="nc bnc" id="L925" title="All 2 branches missed.">        if (Compute.isValidDisplacement(game, entityId, src,</span>
<span class="nc" id="L926">                                        src.direction(first))</span>
<span class="nc bnc" id="L927" title="All 2 branches missed.">            &amp;&amp; game.getBoard().contains(first)) {</span>
<span class="nc" id="L928">            return first;</span>
<span class="nc bnc" id="L929" title="All 2 branches missed.">        } else if (Compute.isValidDisplacement(game, entityId, src,</span>
<span class="nc" id="L930">                                               src.direction(second))</span>
<span class="nc bnc" id="L931" title="All 2 branches missed.">                   &amp;&amp; game.getBoard().contains(second)) {</span>
<span class="nc" id="L932">            return second;</span>
        } else {
<span class="nc" id="L934">            return src;</span>
        }
    }

    /**
     * Finds the best spotter for the attacker. The best spotter is the one with
     * the lowest attack modifiers, of course. LOS modifiers and movement are
     * considered.
     */
    public static Entity findSpotter(IGame game, Entity attacker,
                                     Targetable target) {
<span class="nc" id="L945">        Entity spotter = null;</span>
<span class="nc" id="L946">        int taggedBy = -1;</span>
<span class="nc bnc" id="L947" title="All 2 branches missed.">        if (target instanceof Entity) {</span>
<span class="nc" id="L948">            taggedBy = ((Entity) target).getTaggedBy();</span>
        }
<span class="nc" id="L950">        ToHitData bestMods = new ToHitData(TargetRoll.IMPOSSIBLE, &quot;&quot;);</span>

<span class="nc bnc" id="L952" title="All 2 branches missed.">        for (Entity other : game.getEntitiesVector()) {</span>
<span class="nc bnc" id="L953" title="All 2 branches missed.">            if (((other.isSpotting() &amp;&amp; (other.getSpotTargetId() == target</span>
<span class="nc bnc" id="L954" title="All 4 branches missed.">                    .getTargetId())) || (taggedBy == other.getId()))</span>
<span class="nc bnc" id="L955" title="All 2 branches missed.">                &amp;&amp; !attacker.isEnemyOf(other)) {</span>
                // what are this guy's mods to the attack?
<span class="nc" id="L957">                LosEffects los = LosEffects.calculateLos(game, other.getId(),</span>
                        target, true);
<span class="nc" id="L959">                ToHitData mods = los.losModifiers(game);</span>
                // If the target isn't spotted, can't target
<span class="nc bnc" id="L961" title="All 2 branches missed.">                if (game.getOptions().booleanOption(OptionsConstants.ADVANCED_DOUBLE_BLIND)</span>
<span class="nc bnc" id="L962" title="All 2 branches missed.">                    &amp;&amp; !Compute.inVisualRange(game, los, other, target)</span>
<span class="nc bnc" id="L963" title="All 2 branches missed.">                    &amp;&amp; !Compute.inSensorRange(game, los, other, target, null)) {</span>
<span class="nc" id="L964">                    mods.addModifier(TargetRoll.IMPOSSIBLE,</span>
                                     &quot;outside of visual and sensor range&quot;);
                }
<span class="nc" id="L967">                los.setTargetCover(LosEffects.COVER_NONE);</span>
<span class="nc" id="L968">                mods.append(Compute.getAttackerMovementModifier(game,</span>
<span class="nc" id="L969">                                                                other.getId()));</span>
                
                // a spotter suffers a penalty if it's also making an attack this round
                // unless it has a command console or has TAGged the target
<span class="nc bnc" id="L973" title="All 4 branches missed.">                if (other.isAttackingThisTurn() &amp;&amp; !other.getCrew().hasActiveCommandConsole() &amp;&amp; </span>
<span class="nc bnc" id="L974" title="All 4 branches missed.">                        (!isTargetTagged(attacker, target, game) || (taggedBy != -1))) {</span>
<span class="nc" id="L975">                    mods.addModifier(1, &quot;spotter is making an attack this turn&quot;);</span>
                }
                
                // is this guy a better spotter?
<span class="nc bnc" id="L979" title="All 2 branches missed.">                if ((spotter == null)</span>
<span class="nc bnc" id="L980" title="All 2 branches missed.">                    || (mods.getValue() &lt; bestMods.getValue())) {</span>
<span class="nc" id="L981">                    spotter = other;</span>
<span class="nc" id="L982">                    bestMods = mods;</span>
                }
            }
<span class="nc" id="L985">        }</span>

<span class="nc" id="L987">        return spotter;</span>
    }

    /**
     * Worker function to determine if the target has been tagged.
     * @param target The non-entity target to check
     * @param game Game object
     * @return Whether or not the given entity or other targetable is tagged.
     */
    public static boolean isTargetTagged(Targetable target, IGame game) {
<span class="nc" id="L997">        boolean targetTagged = false;</span>
        
<span class="nc" id="L999">        Entity te = null;</span>
<span class="nc bnc" id="L1000" title="All 2 branches missed.">        if(target instanceof Entity) {</span>
<span class="nc" id="L1001">            te = (Entity) target;</span>
        }
        
        // If this is an entity, we can see if it's tagged
<span class="nc bnc" id="L1005" title="All 2 branches missed.">        if (te != null) {</span>
<span class="nc bnc" id="L1006" title="All 2 branches missed.">            targetTagged = te.getTaggedBy() != -1;</span>
        } else { // Non entities will require us to look harder
<span class="nc bnc" id="L1008" title="All 2 branches missed.">            for (TagInfo ti : game.getTagInfo()) {</span>
<span class="nc bnc" id="L1009" title="All 2 branches missed.">                if (target.getTargetId() == ti.target.getTargetId()) {</span>
<span class="nc" id="L1010">                    return true;</span>
                }
<span class="nc" id="L1012">            }</span>
        }
        
<span class="nc" id="L1015">        return targetTagged;</span>
    }
    
    /**
     * Worker function to determine if the target has been tagged by the specific attacker.
     * @param attacker The attacker.
     * @param target The non-entity target to check
     * @param game Game object
     * @return Whether or not the given entity or other targetable is tagged by the specific attacker.
     */
    public static boolean isTargetTagged(Entity attacker, Targetable target, IGame game) {
<span class="nc" id="L1026">        boolean targetTagged = false;</span>
        
<span class="nc" id="L1028">        Entity te = null;</span>
<span class="nc bnc" id="L1029" title="All 2 branches missed.">        if(target instanceof Entity) {</span>
<span class="nc" id="L1030">            te = (Entity) target;</span>
        }
        
        // If this is an entity, we can see if it's tagged
<span class="nc bnc" id="L1034" title="All 2 branches missed.">        if (te != null) {</span>
<span class="nc bnc" id="L1035" title="All 2 branches missed.">            targetTagged = te.getTaggedBy() == attacker.getId();</span>
        } else { // Non entities will require us to look harder
<span class="nc bnc" id="L1037" title="All 2 branches missed.">            for (TagInfo ti : game.getTagInfo()) {</span>
<span class="nc bnc" id="L1038" title="All 2 branches missed.">                if ((target.getTargetId() == ti.target.getTargetId()) &amp;&amp;</span>
<span class="nc bnc" id="L1039" title="All 2 branches missed.">                        (ti.attackerId == attacker.getId())) {</span>
<span class="nc" id="L1040">                    return true;</span>
                }
<span class="nc" id="L1042">            }</span>
        }
        
<span class="nc" id="L1045">        return targetTagged;</span>
    }
    
    
    public static ToHitData getImmobileMod(Targetable target) {
<span class="nc" id="L1050">        return Compute.getImmobileMod(target, Entity.LOC_NONE,</span>
                                      IAimingModes.AIM_MODE_NONE);
    }

    /**
     * Gets the ToHitData associated with firing at an immobile target. Returns null if target isn't.
     * @param target The target being considered for firing
     * @param aimingAt The location of the unit being aimed at
     * @param aimingMode The aiming mode
     * @return The relevant ToHitData
     */
    @Nullable
    public static ToHitData getImmobileMod(Targetable target, int aimingAt,
                                           int aimingMode) {
        // if we are bombing hexes, they are not considered immobile.
<span class="nc bnc" id="L1065" title="All 2 branches missed.">        if(target.getTargetType() == Targetable.TYPE_HEX_BOMB ||</span>
<span class="nc bnc" id="L1066" title="All 2 branches missed.">           target.getTargetType() == Targetable.TYPE_HEX_AERO_BOMB) {</span>
<span class="nc" id="L1067">            return null;</span>
        }

<span class="nc bnc" id="L1070" title="All 2 branches missed.">        if (target.isImmobile()) {</span>
<span class="nc bnc" id="L1071" title="All 6 branches missed.">            if ((target instanceof Mech) &amp;&amp; (aimingAt == Mech.LOC_HEAD)</span>
                &amp;&amp; (aimingMode == IAimingModes.AIM_MODE_IMMOBILE)) {
<span class="nc" id="L1073">                return new ToHitData(3, &quot;aiming at head&quot;);</span>
            }
<span class="nc" id="L1075">            return new ToHitData(-4, &quot;target immobile&quot;);</span>
        }
<span class="nc" id="L1077">        return null;</span>
    }

    /**
     * Determines the to-hit modifier due to range for an attack with the
     * specified parameters. Includes minimum range, infantry 0-range mods, and
     * target stealth mods. Accounts for friendly C3 units.
     *
     * @return the modifiers
     */
    public static ToHitData getRangeMods(IGame game, Entity ae, int weaponId,
                                         Targetable target) {
<span class="nc" id="L1089">        Mounted weapon = ae.getEquipment(weaponId);</span>
<span class="nc" id="L1090">        WeaponType wtype = (WeaponType) weapon.getType();</span>
<span class="nc" id="L1091">        int[] weaponRanges = wtype.getRanges(weapon);</span>
<span class="nc" id="L1092">        boolean isAttackerInfantry = (ae instanceof Infantry);</span>
<span class="nc" id="L1093">        boolean isAttackerBA = (ae instanceof BattleArmor);</span>
<span class="nc bnc" id="L1094" title="All 4 branches missed.">        boolean isWeaponInfantry = (wtype instanceof InfantryWeapon) &amp;&amp; !wtype.hasFlag(WeaponType.F_TAG);</span>
<span class="nc" id="L1095">        boolean isSwarmOrLegAttack = (wtype instanceof InfantryAttack);</span>
<span class="nc bnc" id="L1096" title="All 2 branches missed.">        boolean isIndirect = ((wtype.getAmmoType() == AmmoType.T_LRM)</span>
<span class="nc bnc" id="L1097" title="All 2 branches missed.">                || (wtype.getAmmoType() == AmmoType.T_LRM_IMP)</span>
<span class="nc bnc" id="L1098" title="All 2 branches missed.">                || (wtype.getAmmoType() == AmmoType.T_MML)</span>
<span class="nc bnc" id="L1099" title="All 2 branches missed.">                || (wtype.getAmmoType() == AmmoType.T_EXLRM)</span>
<span class="nc bnc" id="L1100" title="All 2 branches missed.">                || (wtype.getAmmoType() == AmmoType.T_TBOLT_5)</span>
<span class="nc bnc" id="L1101" title="All 2 branches missed.">                || (wtype.getAmmoType() == AmmoType.T_TBOLT_10)</span>
<span class="nc bnc" id="L1102" title="All 2 branches missed.">                || (wtype.getAmmoType() == AmmoType.T_TBOLT_15)</span>
<span class="nc bnc" id="L1103" title="All 2 branches missed.">                || (wtype.getAmmoType() == AmmoType.T_TBOLT_20)</span>
<span class="nc bnc" id="L1104" title="All 2 branches missed.">                || (wtype.getAmmoType() == AmmoType.T_IATM)</span>
<span class="nc bnc" id="L1105" title="All 2 branches missed.">                || (wtype.getAmmoType() == AmmoType.T_LRM_TORPEDO)</span>
<span class="nc bnc" id="L1106" title="All 4 branches missed.">                || (wtype.getAmmoType() == AmmoType.T_MEK_MORTAR)</span>
                || (wtype instanceof ArtilleryCannonWeapon))
<span class="nc bnc" id="L1108" title="All 2 branches missed.">                &amp;&amp; weapon.curMode().equals(&quot;Indirect&quot;);</span>
<span class="nc" id="L1109">        boolean useExtremeRange = game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_RANGE);</span>
<span class="nc" id="L1110">        boolean useLOSRange = game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_LOS_RANGE);</span>
        //Naval C3 only provides full C3 range benefits to energy weapons and guided missiles
<span class="nc bnc" id="L1112" title="All 2 branches missed.">        boolean nc3EnergyGuided = ((wtype.hasFlag(WeaponType.F_ENERGY))</span>
<span class="nc bnc" id="L1113" title="All 2 branches missed.">                || (wtype.getAtClass() == WeaponType.CLASS_CAPITAL_MISSILE)</span>
<span class="nc bnc" id="L1114" title="All 2 branches missed.">                || (wtype.getAtClass() == WeaponType.CLASS_TELE_MISSILE)</span>
<span class="nc bnc" id="L1115" title="All 2 branches missed.">                || (wtype.getAtClass() == WeaponType.CLASS_AR10)</span>
<span class="nc bnc" id="L1116" title="All 2 branches missed.">                || (wtype.getAtClass() == WeaponType.CLASS_ATM)</span>
<span class="nc bnc" id="L1117" title="All 2 branches missed.">                || (wtype.getAtClass() == WeaponType.CLASS_LRM)</span>
<span class="nc bnc" id="L1118" title="All 2 branches missed.">                || (wtype.getAtClass() == WeaponType.CLASS_SRM)</span>
<span class="nc bnc" id="L1119" title="All 2 branches missed.">                || (wtype.getAtClass() == WeaponType.CLASS_MML)</span>
<span class="nc bnc" id="L1120" title="All 2 branches missed.">                || (wtype.getAtClass() == WeaponType.CLASS_THUNDERBOLT));</span>

<span class="nc bnc" id="L1122" title="All 2 branches missed.">        if (ae.isAirborne()) {</span>
<span class="nc" id="L1123">            useExtremeRange = true;</span>
            // This is a separate SO rule, and isn't implemented yet
<span class="nc" id="L1125">            useLOSRange = false;</span>
        }

<span class="nc" id="L1128">        ToHitData mods = new ToHitData();</span>

<span class="nc" id="L1130">        Entity te = null;</span>
<span class="nc bnc" id="L1131" title="All 2 branches missed.">        if (target instanceof Entity) {</span>
<span class="nc" id="L1132">            te = (Entity) target;</span>
        }

        // We need to adjust the ranges for Centurion Weapon Systems: it's
        //  default range is 6/12/18 but that's only for units that are
        //  susceptible to CWS, for those that aren't the ranges are 1/2/3
<span class="nc bnc" id="L1138" title="All 4 branches missed.">        if (wtype.hasFlag(WeaponType.F_CWS)</span>
<span class="nc bnc" id="L1139" title="All 2 branches missed.">            &amp;&amp; ((te == null) || !te.hasQuirk(&quot;susceptible_cws&quot;))) {</span>
<span class="nc" id="L1140">            weaponRanges[RangeType.RANGE_MINIMUM] = 0;</span>
<span class="nc" id="L1141">            weaponRanges[RangeType.RANGE_SHORT] = 1;</span>
<span class="nc" id="L1142">            weaponRanges[RangeType.RANGE_MEDIUM] = 2;</span>
<span class="nc" id="L1143">            weaponRanges[RangeType.RANGE_LONG] = 3;</span>
<span class="nc" id="L1144">            weaponRanges[RangeType.RANGE_EXTREME] = 4;</span>
        }

        //
        // modifiy the ranges for PPCs when field inhibitors are turned off
        // TODO: See above, it should be coded elsewhere...
        //
<span class="nc bnc" id="L1151" title="All 2 branches missed.">        if (wtype.hasFlag(WeaponType.F_PPC)) {</span>
<span class="nc bnc" id="L1152" title="All 2 branches missed.">            if (game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_PPC_INHIBITORS)) {</span>
<span class="nc bnc" id="L1153" title="All 2 branches missed.">                if ((weapon.curMode() != null)</span>
<span class="nc bnc" id="L1154" title="All 2 branches missed.">                    &amp;&amp; weapon.curMode().equals(&quot;Field Inhibitor OFF&quot;)) {</span>
<span class="nc" id="L1155">                    weaponRanges[RangeType.RANGE_MINIMUM] = 0;</span>
                }
            }
        }

        // Hotloaded weapons
<span class="nc bnc" id="L1161" title="All 2 branches missed.">        if (weapon.isHotLoaded()</span>
<span class="nc bnc" id="L1162" title="All 2 branches missed.">            &amp;&amp; game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_HOTLOAD)) {</span>
<span class="nc" id="L1163">            weaponRanges[RangeType.RANGE_MINIMUM] = 0;</span>
        }

        // is water involved?
<span class="nc" id="L1167">        IHex targHex = game.getBoard().getHex(target.getPosition());</span>
<span class="nc" id="L1168">        int targTop = target.relHeight();</span>
<span class="nc" id="L1169">        int targBottom = target.getElevation();</span>

<span class="nc" id="L1171">        boolean targetInPartialWater = false;</span>
<span class="nc" id="L1172">        boolean targetUnderwater = false;</span>
<span class="nc bnc" id="L1173" title="All 2 branches missed.">        boolean weaponUnderwater = (ae.getLocationStatus(weapon.getLocation()) == ILocationExposureStatus.WET);</span>
<span class="nc bnc" id="L1174" title="All 4 branches missed.">        if ((target.getTargetType() == Targetable.TYPE_ENTITY)</span>
<span class="nc bnc" id="L1175" title="All 4 branches missed.">            &amp;&amp; (targHex != null) &amp;&amp; targHex.containsTerrain(Terrains.WATER) </span>
            &amp;&amp; (targBottom &lt; 0)) {
            
<span class="nc bnc" id="L1178" title="All 2 branches missed.">                if (targTop &gt;= 0) {</span>
<span class="nc" id="L1179">                    targetInPartialWater = true;</span>
                } else {
<span class="nc" id="L1181">                    targetUnderwater = true;</span>
                }
        }

        // allow naval units on surface to be attacked from above or below
<span class="nc bnc" id="L1186" title="All 4 branches missed.">        if ((null != te) &amp;&amp; (targBottom == 0)</span>
<span class="nc bnc" id="L1187" title="All 2 branches missed.">            &amp;&amp; (te.getUnitType() == UnitType.NAVAL)) {</span>
<span class="nc" id="L1188">            targetInPartialWater = true;</span>
        }

        // allow naval units to target underwater units,
        // torpedo tubes are mounted underwater
<span class="nc bnc" id="L1193" title="All 2 branches missed.">        if ((targetUnderwater</span>
<span class="nc bnc" id="L1194" title="All 2 branches missed.">                || (wtype.getAmmoType() == AmmoType.T_LRM_TORPEDO) || (wtype</span>
<span class="nc bnc" id="L1195" title="All 2 branches missed.">                .getAmmoType() == AmmoType.T_SRM_TORPEDO))</span>
<span class="nc bnc" id="L1196" title="All 2 branches missed.">            &amp;&amp; (ae.getUnitType() == UnitType.NAVAL)) {</span>
<span class="nc" id="L1197">            weaponUnderwater = true;</span>
<span class="nc" id="L1198">            weaponRanges = wtype.getWRanges();</span>
        }
        
        // allow ice to be cleared from below
<span class="nc bnc" id="L1202" title="All 4 branches missed.">        if ((targHex != null) &amp;&amp; targHex.containsTerrain(Terrains.WATER)</span>
<span class="nc bnc" id="L1203" title="All 2 branches missed.">            &amp;&amp; (target.getTargetType() == Targetable.TYPE_HEX_CLEAR)) {</span>
<span class="nc" id="L1204">            targetInPartialWater = true;</span>
        }

<span class="nc bnc" id="L1207" title="All 2 branches missed.">        if (weaponUnderwater) {</span>
<span class="nc" id="L1208">            weaponRanges = wtype.getWRanges();</span>
<span class="nc" id="L1209">            boolean MPM = false;</span>
<span class="nc bnc" id="L1210" title="All 2 branches missed.">            if ((wtype.getAmmoType() == AmmoType.T_SRM)</span>
<span class="nc bnc" id="L1211" title="All 2 branches missed.">                || (wtype.getAmmoType() == AmmoType.T_SRM_IMP)</span>
<span class="nc bnc" id="L1212" title="All 2 branches missed.">                || (wtype.getAmmoType() == AmmoType.T_MRM)</span>
<span class="nc bnc" id="L1213" title="All 2 branches missed.">                || (wtype.getAmmoType() == AmmoType.T_LRM)</span>
<span class="nc bnc" id="L1214" title="All 2 branches missed.">                || (wtype.getAmmoType() == AmmoType.T_LRM_IMP)</span>
<span class="nc bnc" id="L1215" title="All 2 branches missed.">                || (wtype.getAmmoType() == AmmoType.T_MML)) {</span>
<span class="nc" id="L1216">                AmmoType atype = (AmmoType) weapon.getLinked().getType();</span>
<span class="nc bnc" id="L1217" title="All 2 branches missed.">                if (atype.getMunitionType() == AmmoType.M_TORPEDO) {</span>
<span class="nc" id="L1218">                    weaponRanges = wtype.getRanges(weapon);</span>
<span class="nc bnc" id="L1219" title="All 2 branches missed.">                } else if (atype.getMunitionType() == AmmoType.M_MULTI_PURPOSE) {</span>
<span class="nc" id="L1220">                    weaponRanges = wtype.getRanges(weapon);</span>
<span class="nc" id="L1221">                    MPM = true;</span>
                }
            }

            // HACK on ranges: for those without underwater range,
            // long == medium; iteration in rangeBracket() allows this
<span class="nc bnc" id="L1227" title="All 2 branches missed.">            if (weaponRanges[RangeType.RANGE_SHORT] == 0) {</span>
<span class="nc" id="L1228">                return new ToHitData(TargetRoll.IMPOSSIBLE,</span>
                                     &quot;Weapon cannot fire underwater.&quot;);
            }
<span class="nc bnc" id="L1231" title="All 6 branches missed.">            if (!targetUnderwater &amp;&amp; !targetInPartialWater &amp;&amp; !MPM) {</span>
                // target on land or over water
<span class="nc" id="L1233">                return new ToHitData(TargetRoll.IMPOSSIBLE,</span>
                                     &quot;Weapon underwater, but not target.&quot;);
            }
            // special case: mechs can only fire upper body weapons at surface
            // naval
<span class="nc bnc" id="L1238" title="All 2 branches missed.">            if ((te != null)</span>
<span class="nc bnc" id="L1239" title="All 4 branches missed.">                &amp;&amp; (te.getUnitType() == UnitType.NAVAL)</span>
<span class="nc bnc" id="L1240" title="All 2 branches missed.">                &amp;&amp; (ae instanceof Mech) &amp;&amp; (ae.height() &gt; 0)</span>
<span class="nc bnc" id="L1241" title="All 2 branches missed.">                &amp;&amp; (ae.getElevation() == -1)) {</span>
<span class="nc" id="L1242">                return new ToHitData(TargetRoll.IMPOSSIBLE,</span>
                                     &quot;Partially submerged mech cannot fire leg weapons at surface naval vessels.&quot;);
            }
<span class="nc bnc" id="L1245" title="All 2 branches missed.">        } else if (targetUnderwater) {</span>
<span class="nc" id="L1246">            return new ToHitData(TargetRoll.IMPOSSIBLE,</span>
                                 &quot;Target underwater, but not weapon.&quot;);
<span class="nc bnc" id="L1248" title="All 2 branches missed.">        } else if ((wtype.getAmmoType() == AmmoType.T_LRM_TORPEDO)</span>
<span class="nc bnc" id="L1249" title="All 2 branches missed.">                   || (wtype.getAmmoType() == AmmoType.T_SRM_TORPEDO)) {</span>
            // Torpedos only fire underwater.
<span class="nc" id="L1251">            return new ToHitData(TargetRoll.IMPOSSIBLE,</span>
                                 &quot;Weapon can only fire underwater.&quot;);
        }

        // if Aero then adjust to standard ranges
<span class="nc bnc" id="L1256" title="All 4 branches missed.">        if (ae.isAero() &amp;&amp; (ae.isAirborne()</span>
<span class="nc bnc" id="L1257" title="All 4 branches missed.">            || (ae.usesWeaponBays() &amp;&amp; game.getBoard().onGround()))) {</span>
<span class="nc" id="L1258">            weaponRanges = wtype.getATRanges();</span>
        }
        // And if you're using bearings-only capital missiles, update the extreme range
<span class="nc bnc" id="L1261" title="All 2 branches missed.">        if (weapon.isInBearingsOnlyMode()) {</span>
<span class="nc" id="L1262">            weaponRanges = new int[] { Integer.MIN_VALUE, 12, 24, 40, RangeType.RANGE_BEARINGS_ONLY_OUT };</span>
        }

        // determine base distance &amp; range bracket
<span class="nc" id="L1266">        int distance = Compute.effectiveDistance(game, ae, target, false);</span>
<span class="nc" id="L1267">        int range = RangeType.rangeBracket(distance, weaponRanges,</span>
                                           useExtremeRange, useLOSRange);

        // Additional checks for LOS range and some weapon types, TO 85
<span class="nc bnc" id="L1271" title="All 2 branches missed.">        if (range == RangeType.RANGE_LOS) {</span>
            // Swarm or leg attacks can't use LoS range
<span class="nc bnc" id="L1273" title="All 2 branches missed.">            if (isSwarmOrLegAttack) {</span>
<span class="nc" id="L1274">                range = RangeType.RANGE_OUT;</span>
            }

            // MGs lack range for LOS Range, but don't have F_DIRECT_FIRE flag
<span class="nc bnc" id="L1278" title="All 2 branches missed.">            if (wtype instanceof MGWeapon) {</span>
<span class="nc" id="L1279">                range = RangeType.RANGE_OUT;</span>
            }

            // AMS lack range for LOS Range, but don't have F_DIRECT_FIRE flag
<span class="nc bnc" id="L1283" title="All 2 branches missed.">            if (wtype.hasFlag(WeaponType.F_AMS)) {</span>
<span class="nc" id="L1284">                range = RangeType.RANGE_OUT;</span>
            }

            // Flamers lack range for LOS Range, but don't have F_DIRECT_FIRE
<span class="nc bnc" id="L1288" title="All 2 branches missed.">            if (wtype.hasFlag(WeaponType.F_FLAMER)) {</span>
<span class="nc" id="L1289">                range = RangeType.RANGE_OUT;</span>
            }

<span class="nc" id="L1292">            int longRange = wtype.getRanges(weapon)[RangeType.RANGE_LONG];</span>
            // No Missiles or Direct Fire Ballistics with range &lt; 13
<span class="nc bnc" id="L1294" title="All 2 branches missed.">            if (wtype.hasFlag(WeaponType.F_MISSILE)</span>
<span class="nc bnc" id="L1295" title="All 2 branches missed.">                || (wtype.hasFlag(WeaponType.F_DIRECT_FIRE)</span>
<span class="nc bnc" id="L1296" title="All 2 branches missed.">                    &amp;&amp; wtype.hasFlag(WeaponType.F_BALLISTIC))) {</span>
<span class="nc bnc" id="L1297" title="All 2 branches missed.">                if (longRange &lt; 13) {</span>
<span class="nc" id="L1298">                    range = RangeType.RANGE_OUT;</span>
                }
            }
            // No Direct Fire Energy or Pulse with range &lt; 7
<span class="nc bnc" id="L1302" title="All 2 branches missed.">            if (wtype.hasFlag(WeaponType.F_PULSE)</span>
<span class="nc bnc" id="L1303" title="All 2 branches missed.">                || (wtype.hasFlag(WeaponType.F_ENERGY)</span>
<span class="nc bnc" id="L1304" title="All 2 branches missed.">                    &amp;&amp; wtype.hasFlag(WeaponType.F_DIRECT_FIRE))) {</span>
<span class="nc bnc" id="L1305" title="All 2 branches missed.">                if (longRange &lt; 7) {</span>
<span class="nc" id="L1306">                    range = RangeType.RANGE_OUT;</span>
                }
            }
        }
<span class="nc" id="L1310">        int maxRange = wtype.getMaxRange(weapon);</span>

        // if aero and greater than max range then swith to range_out
<span class="nc bnc" id="L1313" title="All 4 branches missed.">        if ((ae.isAirborne() || (ae.usesWeaponBays() &amp;&amp; game.getBoard()</span>
<span class="nc bnc" id="L1314" title="All 4 branches missed.">                .onGround())) &amp;&amp; (range &gt; maxRange)) {</span>
<span class="nc" id="L1315">            range = RangeType.RANGE_OUT;</span>
        }

        // Swarm/Leg attacks need to  be impossible, not auto-fail, so that the
        // attack can't even be attempted
<span class="nc bnc" id="L1320" title="All 4 branches missed.">        if (isSwarmOrLegAttack &amp;&amp; (distance &gt; 0)) {</span>
<span class="nc" id="L1321">            return new ToHitData(TargetRoll.IMPOSSIBLE,</span>
                    &quot;Swarm/Leg attacks can &quot;
                            + &quot;only target units in the same hex!&quot;);
        }
        // short circuit if at zero range or out of range
<span class="nc bnc" id="L1326" title="All 4 branches missed.">        if ((range == RangeType.RANGE_OUT) &amp;&amp; !isWeaponInfantry) {</span>
<span class="nc" id="L1327">            return new ToHitData(TargetRoll.AUTOMATIC_FAIL,</span>
                                 &quot;Target out of range&quot;);
        }

        // Infantry with infantry weapons (rifles, etc, i.e. not field pieces)
        //  and BattleArmor can fire at zero range, among other things
<span class="nc bnc" id="L1333" title="All 10 branches missed.">        if ((distance == 0)</span>
            &amp;&amp; (!isAttackerInfantry ||
                !(isWeaponInfantry || isSwarmOrLegAttack
                  || isAttackerBA))
<span class="nc bnc" id="L1337" title="All 2 branches missed.">            &amp;&amp; !(ae.isAirborne())</span>
<span class="nc bnc" id="L1338" title="All 6 branches missed.">            &amp;&amp; !(ae.isBomber() &amp;&amp; ((IBomber)ae).isVTOLBombing())</span>
<span class="nc bnc" id="L1339" title="All 2 branches missed.">            &amp;&amp; !((ae instanceof Dropship) &amp;&amp; ((Dropship) ae).isSpheroid()</span>
<span class="nc bnc" id="L1340" title="All 6 branches missed.">                 &amp;&amp; !ae.isAirborne() &amp;&amp; !ae.isSpaceborne())</span>
<span class="nc" id="L1341">            &amp;&amp; !((ae instanceof Mech) &amp;&amp; (((Mech) ae).getGrappled() == target</span>
<span class="nc bnc" id="L1342" title="All 2 branches missed.">                .getTargetId()))) {</span>
<span class="nc" id="L1343">            return new ToHitData(TargetRoll.AUTOMATIC_FAIL,</span>
                                 &quot;Only infantry weapons shoot at zero range&quot;);
        }

        // Account for &quot;dead zones&quot; between Aeros at different altitudes
<span class="nc bnc" id="L1348" title="All 4 branches missed.">        if (!Compute.useSpheroidAtmosphere(game, ae) &amp;&amp; Compute.inDeadZone(game, ae, target)) {</span>
<span class="nc" id="L1349">            return new ToHitData(TargetRoll.IMPOSSIBLE, &quot;Target in dead zone&quot;);</span>
        }

        // find any c3 spotters that could help
<span class="nc" id="L1353">        Entity c3spotter = Compute.findC3Spotter(game, ae, target);</span>
<span class="nc bnc" id="L1354" title="All 2 branches missed.">        if (isIndirect) {</span>
<span class="nc" id="L1355">            c3spotter = ae; // no c3 when using indirect fire</span>
        }
<span class="nc bnc" id="L1357" title="All 2 branches missed.">        if (isIndirect</span>
<span class="nc bnc" id="L1358" title="All 2 branches missed.">            &amp;&amp; game.getOptions().booleanOption(OptionsConstants.BASE_INDIRECT_FIRE)</span>
<span class="nc bnc" id="L1359" title="All 2 branches missed.">            &amp;&amp; !game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_INDIRECT_ALWAYS_POSSIBLE)</span>
<span class="nc bnc" id="L1360" title="All 2 branches missed.">            &amp;&amp; LosEffects.calculateLos(game, ae.getId(), target).canSee()</span>
<span class="nc bnc" id="L1361" title="All 2 branches missed.">            &amp;&amp; (!game.getOptions().booleanOption(OptionsConstants.ADVANCED_DOUBLE_BLIND) || Compute</span>
<span class="nc bnc" id="L1362" title="All 4 branches missed.">                .canSee(game, ae, target))</span>
            &amp;&amp; !(wtype instanceof MekMortarWeapon)) {
<span class="nc" id="L1364">            return new ToHitData(TargetRoll.IMPOSSIBLE,</span>
                    &quot;Indirect fire impossible with direct LOS&quot;);
        }

<span class="nc" id="L1368">        int c3dist = Compute.effectiveDistance(game, c3spotter, target, false);</span>
        // C3 can't benefit from LOS range
<span class="nc" id="L1370">        int c3range = RangeType.rangeBracket(c3dist, weaponRanges,</span>
                useExtremeRange, false);

        /*
         * Tac Ops Extreme Range Rule p. 85 if the weapons normal range is
         * Extreme then C3 uses the next highest range bracket, i.e. medium
         * instead of short.
         */
<span class="nc bnc" id="L1378" title="All 4 branches missed.">        if ((range == RangeType.RANGE_EXTREME) &amp;&amp; (c3range &lt; range)) {</span>
<span class="nc" id="L1379">            c3range++;</span>
        }

        // determine which range we're using
<span class="nc" id="L1383">        int usingRange = Math.min(range, c3range);</span>

        // add range modifier, C3 can't be used with LOS Range
<span class="nc bnc" id="L1386" title="All 8 branches missed.">        if ((usingRange == range) || (range == RangeType.RANGE_LOS) || (ae.hasNavalC3() &amp;&amp; !nc3EnergyGuided)) {</span>
            // Ensure usingRange is set to range, ie with C3
<span class="nc" id="L1388">            usingRange = range;</span>
            // Naval C3 adjustment for ballistic and unguided weapons
<span class="nc bnc" id="L1390" title="All 6 branches missed.">            if ((ae.hasNavalC3() &amp;&amp; !nc3EnergyGuided) &amp;&amp; (c3range &lt; range)) {</span>
<span class="nc bnc" id="L1391" title="All 4 branches missed.">                if (((range == RangeType.RANGE_SHORT) || (range == RangeType.RANGE_MINIMUM))</span>
<span class="nc bnc" id="L1392" title="All 2 branches missed.">                        &amp;&amp; (ae.getShortRangeModifier() != 0)) {</span>
<span class="nc" id="L1393">                    mods.addModifier((ae.getShortRangeModifier() / 2), &quot;NC3 modified short range&quot;);</span>
<span class="nc bnc" id="L1394" title="All 2 branches missed.">                } else if (range == RangeType.RANGE_MEDIUM) {</span>
<span class="nc" id="L1395">                    mods.addModifier((ae.getMediumRangeModifier() / 2), &quot;NC3 modified medium range&quot;);</span>
<span class="nc bnc" id="L1396" title="All 2 branches missed.">                } else if (range == RangeType.RANGE_LONG) {</span>
<span class="nc" id="L1397">                    mods.addModifier((ae.getLongRangeModifier() / 2), &quot;NC3 modified long range&quot;);</span>
<span class="nc bnc" id="L1398" title="All 2 branches missed.">                } else if (range == RangeType.RANGE_EXTREME) {</span>
<span class="nc" id="L1399">                    mods.addModifier((ae.getExtremeRangeModifier() / 2), &quot;NC3 modified Extreme range&quot;);</span>
                }
            } else {
                // no c3 adjustment
<span class="nc bnc" id="L1403" title="All 4 branches missed.">                if (((range == RangeType.RANGE_SHORT) || (range == RangeType.RANGE_MINIMUM))</span>
<span class="nc bnc" id="L1404" title="All 2 branches missed.">                        &amp;&amp; (ae.getShortRangeModifier() != 0)) {</span>
<span class="nc" id="L1405">                    mods.addModifier(ae.getShortRangeModifier(), &quot;short range&quot;);</span>
<span class="nc bnc" id="L1406" title="All 2 branches missed.">                } else if (range == RangeType.RANGE_MEDIUM) {</span>
                    // Right now, the range-mod affecting targeting systems DON'T
                    // affect medium range, so we won't add that here ever.
<span class="nc" id="L1409">                    mods.addModifier(ae.getMediumRangeModifier(), &quot;medium range&quot;);</span>
<span class="nc bnc" id="L1410" title="All 2 branches missed.">                } else if (range == RangeType.RANGE_LONG) {</span>
                    // Protos that loose head sensors can't shoot long range.
<span class="nc bnc" id="L1412" title="All 2 branches missed.">                    if ((ae instanceof Protomech)</span>
                            &amp;&amp; (2 == ((Protomech) ae)
<span class="nc bnc" id="L1414" title="All 2 branches missed.">                            .getCritsHit(Protomech.LOC_HEAD))) {</span>
<span class="nc" id="L1415">                        mods.addModifier(TargetRoll.IMPOSSIBLE,</span>
                                         &quot;No long range attacks with destroyed head sensors.&quot;);
                    } else {
<span class="nc" id="L1418">                        mods.addModifier(ae.getLongRangeModifier(), &quot;long range&quot;);</span>
                    }
<span class="nc bnc" id="L1420" title="All 2 branches missed.">                } else if (range == RangeType.RANGE_EXTREME) {</span>
                    // Protos that loose head sensors can't shoot extreme range.
<span class="nc bnc" id="L1422" title="All 2 branches missed.">                    if ((ae instanceof Protomech)</span>
                            &amp;&amp; (2 == ((Protomech) ae)
<span class="nc bnc" id="L1424" title="All 2 branches missed.">                            .getCritsHit(Protomech.LOC_HEAD))) {</span>
<span class="nc" id="L1425">                        mods.addModifier(TargetRoll.IMPOSSIBLE,</span>
                                         &quot;No extreme range attacks with destroyed head sensors.&quot;);
                    } else {
<span class="nc" id="L1428">                        mods.addModifier(ae.getExtremeRangeModifier(),</span>
                                         &quot;extreme range&quot;);
                    }
<span class="nc bnc" id="L1431" title="All 2 branches missed.">                } else if (range == RangeType.RANGE_LOS) {</span>
                    // Protos that loose head sensors can't shoot LOS range.
<span class="nc bnc" id="L1433" title="All 2 branches missed.">                    if ((ae instanceof Protomech)</span>
                            &amp;&amp; (2 == ((Protomech) ae)
<span class="nc bnc" id="L1435" title="All 2 branches missed.">                            .getCritsHit(Protomech.LOC_HEAD))) {</span>
<span class="nc" id="L1436">                        mods.addModifier(TargetRoll.IMPOSSIBLE,</span>
                                         &quot;No LOS range attacks with destroyed head sensors.&quot;);
                    } else {
<span class="nc" id="L1439">                        mods.addModifier(ae.getLOSRangeModifier(),</span>
                                         &quot;LOS range&quot;);
                    }
                }
            }
        } else {
            // report c3 adjustment
<span class="nc bnc" id="L1446" title="All 4 branches missed.">            if ((c3range == RangeType.RANGE_SHORT)</span>
                || (c3range == RangeType.RANGE_MINIMUM)) {
<span class="nc" id="L1448">                mods.addModifier(ae.getShortRangeModifier(),</span>
                                 &quot;short range due to C3 spotter&quot;);
<span class="nc bnc" id="L1450" title="All 2 branches missed.">            } else if (c3range == RangeType.RANGE_MEDIUM) {</span>
<span class="nc" id="L1451">                mods.addModifier(ae.getMediumRangeModifier(),</span>
                                 &quot;medium range due to C3 spotter&quot;);
<span class="nc bnc" id="L1453" title="All 2 branches missed.">            } else if (c3range == RangeType.RANGE_LONG) {</span>
<span class="nc" id="L1454">                mods.addModifier(ae.getLongRangeModifier(),</span>
                                 &quot;long range due to C3 spotter&quot;);
            }
        }

        // add minimum range modifier (only for ground-to-ground attacks)
<span class="nc" id="L1460">        int minRange = weaponRanges[RangeType.RANGE_MINIMUM];</span>
<span class="nc bnc" id="L1461" title="All 4 branches missed.">        if ((minRange &gt; 0) &amp;&amp; (distance &lt;= minRange)</span>
<span class="nc bnc" id="L1462" title="All 2 branches missed.">            &amp;&amp; Compute.isGroundToGround(ae, target)) {</span>
<span class="nc" id="L1463">            int minPenalty = (minRange - distance) + 1;</span>
<span class="nc" id="L1464">            mods.addModifier(minPenalty, &quot;minimum range&quot;);</span>
        }

        // if this is an infantry weapon then we use a whole different
        // calculation
        // to figure out range, so overwrite whatever we have at this point
<span class="nc bnc" id="L1470" title="All 2 branches missed.">        if (isWeaponInfantry) {</span>
<span class="nc" id="L1471">            mods = Compute.getInfantryRangeMods(Math.min(distance, c3dist),</span>
                    (InfantryWeapon) wtype,
<span class="nc bnc" id="L1473" title="All 2 branches missed.">                    (ae instanceof Infantry)? ((Infantry)ae).getSecondaryWeapon() : null,</span>
                            weaponUnderwater);

<span class="nc" id="L1476">            int rangeModifier = mods.getValue();</span>
<span class="nc bnc" id="L1477" title="All 2 branches missed.">            if (rangeModifier == TargetRoll.AUTOMATIC_FAIL) {</span>
<span class="nc" id="L1478">                usingRange = RangeType.RANGE_OUT;</span>
<span class="nc bnc" id="L1479" title="All 2 branches missed.">            } else if (rangeModifier == 0) {</span>
<span class="nc" id="L1480">                usingRange = RangeType.RANGE_SHORT;</span>
<span class="nc bnc" id="L1481" title="All 2 branches missed.">            } else if (rangeModifier &lt;= 2) {</span>
<span class="nc" id="L1482">                usingRange = RangeType.RANGE_MEDIUM;</span>
<span class="nc bnc" id="L1483" title="All 2 branches missed.">            } else if (rangeModifier &lt;= 4) {</span>
<span class="nc" id="L1484">                usingRange = RangeType.RANGE_LONG;</span>
            } else {
<span class="nc" id="L1486">                usingRange = RangeType.RANGE_EXTREME;</span>
            }
        }

        // add any target stealth modifier
<span class="nc bnc" id="L1491" title="All 2 branches missed.">        if (target instanceof Entity) {</span>
<span class="nc" id="L1492">            TargetRoll tmpTR = ((Entity) target).getStealthModifier(usingRange,</span>
                                                                    ae);
<span class="nc bnc" id="L1494" title="All 4 branches missed.">            if ((tmpTR != null) &amp;&amp; (tmpTR.getValue() != 0)) {</span>
<span class="nc" id="L1495">                mods.append(((Entity) target)</span>
<span class="nc" id="L1496">                                    .getStealthModifier(usingRange, ae));</span>
            }
        }

<span class="nc" id="L1500">        return mods;</span>
    }

    /**
     * Calculate the range modifiers for a conventional infantry attack.
     *
     * @param distance - range to target
     * @param wpn - the weapon used to calculate range -- secondary if 2/squad, otherwise primary
     * @param secondary - the secondary weapon, if any. Range zero penalties apply even if primary is used for range
     * @param underwater - underwater range is half, rounded down
     * @return - all modifiers for range
     */
    public static ToHitData getInfantryRangeMods(int distance, InfantryWeapon wpn,
            InfantryWeapon secondary, boolean underwater) {
<span class="nc" id="L1514">        ToHitData mods = new ToHitData();</span>
<span class="nc" id="L1515">        int range = wpn.getInfantryRange();</span>
<span class="nc bnc" id="L1516" title="All 2 branches missed.">        if (underwater) {</span>
<span class="nc" id="L1517">            range /= 2;</span>
        }
<span class="nc" id="L1519">        int mod = 0;</span>

<span class="nc bnc" id="L1521" title="All 9 branches missed.">        switch (range) {</span>
            case 0:
<span class="nc bnc" id="L1523" title="All 2 branches missed.">                if (distance &gt; 0) {</span>
<span class="nc" id="L1524">                    return new ToHitData(TargetRoll.AUTOMATIC_FAIL,</span>
                                         &quot;Target out of range&quot;);
<span class="nc bnc" id="L1526" title="All 2 branches missed.">                } else if (distance == 0) {</span>
<span class="nc" id="L1527">                    mod = 0;</span>
                }
                break;
            case 1:
<span class="nc bnc" id="L1531" title="All 2 branches missed.">                if (distance &gt; 3) {</span>
<span class="nc" id="L1532">                    return new ToHitData(TargetRoll.AUTOMATIC_FAIL,</span>
                                         &quot;Target out of range&quot;);
<span class="nc bnc" id="L1534" title="All 2 branches missed.">                } else if (distance == 0) {</span>
<span class="nc" id="L1535">                    mod = -2;</span>
<span class="nc bnc" id="L1536" title="All 2 branches missed.">                } else if (distance == 2) {</span>
<span class="nc" id="L1537">                    mod = 2;</span>
<span class="nc bnc" id="L1538" title="All 2 branches missed.">                } else if (distance == 3) {</span>
<span class="nc" id="L1539">                    mod = 4;</span>
                }
                break;
            case 2:
<span class="nc bnc" id="L1543" title="All 2 branches missed.">                if (distance &gt; 6) {</span>
<span class="nc" id="L1544">                    return new ToHitData(TargetRoll.AUTOMATIC_FAIL,</span>
                                         &quot;Target out of range&quot;);
<span class="nc bnc" id="L1546" title="All 2 branches missed.">                } else if (distance &gt; 4) {</span>
<span class="nc" id="L1547">                    mod = 4;</span>
<span class="nc bnc" id="L1548" title="All 2 branches missed.">                } else if (distance &gt; 2) {</span>
<span class="nc" id="L1549">                    mod = 2;</span>
<span class="nc bnc" id="L1550" title="All 2 branches missed.">                } else if (distance == 0) {</span>
<span class="nc" id="L1551">                    mod = -2;</span>
                }
                break;
            case 3:
<span class="nc bnc" id="L1555" title="All 2 branches missed.">                if (distance &gt; 9) {</span>
<span class="nc" id="L1556">                    return new ToHitData(TargetRoll.AUTOMATIC_FAIL,</span>
                                         &quot;Target out of range&quot;);
<span class="nc bnc" id="L1558" title="All 2 branches missed.">                } else if (distance &gt; 6) {</span>
<span class="nc" id="L1559">                    mod = 4;</span>
<span class="nc bnc" id="L1560" title="All 2 branches missed.">                } else if (distance &gt; 3) {</span>
<span class="nc" id="L1561">                    mod = 2;</span>
<span class="nc bnc" id="L1562" title="All 2 branches missed.">                } else if (distance == 0) {</span>
<span class="nc" id="L1563">                    mod = -2;</span>
                }
                break;
            case 4:
<span class="nc bnc" id="L1567" title="All 2 branches missed.">                if (distance &gt; 12) {</span>
<span class="nc" id="L1568">                    return new ToHitData(TargetRoll.AUTOMATIC_FAIL,</span>
                                         &quot;Target out of range&quot;);
<span class="nc bnc" id="L1570" title="All 2 branches missed.">                } else if (distance &gt; 10) {</span>
<span class="nc" id="L1571">                    mod = 4;</span>
<span class="nc bnc" id="L1572" title="All 2 branches missed.">                } else if (distance &gt; 8) {</span>
<span class="nc" id="L1573">                    mod = 3;</span>
<span class="nc bnc" id="L1574" title="All 2 branches missed.">                } else if (distance &gt; 6) {</span>
<span class="nc" id="L1575">                    mod = 2;</span>
<span class="nc bnc" id="L1576" title="All 2 branches missed.">                } else if (distance &gt; 4) {</span>
<span class="nc" id="L1577">                    mod = 1;</span>
<span class="nc bnc" id="L1578" title="All 2 branches missed.">                } else if (distance == 0) {</span>
<span class="nc" id="L1579">                    mod = -2;</span>
                }
                break;
            case 5:
<span class="nc bnc" id="L1583" title="All 2 branches missed.">                if (distance &gt; 15) {</span>
<span class="nc" id="L1584">                    return new ToHitData(TargetRoll.AUTOMATIC_FAIL,</span>
                                         &quot;Target out of range&quot;);
<span class="nc bnc" id="L1586" title="All 2 branches missed.">                } else if (distance &gt; 12) {</span>
<span class="nc" id="L1587">                    mod = 4;</span>
<span class="nc bnc" id="L1588" title="All 2 branches missed.">                } else if (distance &gt; 10) {</span>
<span class="nc" id="L1589">                    mod = 3;</span>
<span class="nc bnc" id="L1590" title="All 2 branches missed.">                } else if (distance &gt; 7) {</span>
<span class="nc" id="L1591">                    mod = 2;</span>
<span class="nc bnc" id="L1592" title="All 2 branches missed.">                } else if (distance &gt; 5) {</span>
<span class="nc" id="L1593">                    mod = 1;</span>
<span class="nc bnc" id="L1594" title="All 2 branches missed.">                } else if (distance == 0) {</span>
<span class="nc" id="L1595">                    mod = -1;</span>
                }
                break;
            case 6:
<span class="nc bnc" id="L1599" title="All 2 branches missed.">                if (distance &gt; 18) {</span>
<span class="nc" id="L1600">                    return new ToHitData(TargetRoll.AUTOMATIC_FAIL,</span>
                                         &quot;Target out of range&quot;);
<span class="nc bnc" id="L1602" title="All 2 branches missed.">                } else if (distance &gt; 15) {</span>
<span class="nc" id="L1603">                    mod = 5;</span>
<span class="nc bnc" id="L1604" title="All 2 branches missed.">                } else if (distance &gt; 12) {</span>
<span class="nc" id="L1605">                    mod = 4;</span>
<span class="nc bnc" id="L1606" title="All 2 branches missed.">                } else if (distance &gt; 9) {</span>
<span class="nc" id="L1607">                    mod = 2;</span>
<span class="nc bnc" id="L1608" title="All 2 branches missed.">                } else if (distance &gt; 6) {</span>
<span class="nc" id="L1609">                    mod = 1;</span>
<span class="nc bnc" id="L1610" title="All 2 branches missed.">                } else if (distance == 0) {</span>
<span class="nc" id="L1611">                    mod = -1;</span>
                }
                break;
            case 7:
<span class="nc bnc" id="L1615" title="All 2 branches missed.">                if (distance &gt; 21) {</span>
<span class="nc" id="L1616">                    return new ToHitData(TargetRoll.AUTOMATIC_FAIL,</span>
                                         &quot;Target out of range&quot;);
<span class="nc bnc" id="L1618" title="All 2 branches missed.">                } else if (distance &gt; 17) {</span>
<span class="nc" id="L1619">                    mod = 6;</span>
<span class="nc bnc" id="L1620" title="All 2 branches missed.">                } else if (distance &gt; 14) {</span>
<span class="nc" id="L1621">                    mod = 4;</span>
<span class="nc bnc" id="L1622" title="All 2 branches missed.">                } else if (distance &gt; 10) {</span>
<span class="nc" id="L1623">                    mod = 2;</span>
<span class="nc bnc" id="L1624" title="All 2 branches missed.">                } else if (distance &gt; 7) {</span>
<span class="nc" id="L1625">                    mod = 1;</span>
<span class="nc bnc" id="L1626" title="All 2 branches missed.">                } else if (distance == 0) {</span>
<span class="nc" id="L1627">                    mod = -1;</span>
                }
                break;
            default:
<span class="nc" id="L1631">                return new ToHitData(TargetRoll.AUTOMATIC_FAIL,</span>
                                     &quot;Target out of range&quot;);
        }

        // a bunch of special conditions at range 0
        // penalties due to point blank or encumbering apply for secondary weapon even if
        // primary is used to determine range
<span class="nc bnc" id="L1638" title="All 2 branches missed.">        if (distance == 0) {</span>

<span class="nc bnc" id="L1640" title="All 4 branches missed.">            if (wpn.hasFlag(WeaponType.F_INF_POINT_BLANK)</span>
<span class="nc bnc" id="L1641" title="All 2 branches missed.">                    || (secondary != null &amp;&amp; secondary.hasFlag(WeaponType.F_INF_POINT_BLANK))) {</span>
<span class="nc" id="L1642">                mods.addModifier(1, &quot;point blank weapon&quot;);</span>
            }
<span class="nc bnc" id="L1644" title="All 6 branches missed.">            if (wpn.hasFlag(WeaponType.F_INF_ENCUMBER) || (wpn.getCrew() &gt; 1)</span>
                    || (secondary != null
<span class="nc bnc" id="L1646" title="All 2 branches missed.">                        &amp;&amp; (secondary.hasFlag(WeaponType.F_INF_ENCUMBER)</span>
<span class="nc bnc" id="L1647" title="All 2 branches missed.">                                || secondary.getCrew() &gt; 1))) {</span>
<span class="nc" id="L1648">                mods.addModifier(1, &quot;point blank support weapon&quot;);</span>
            }

<span class="nc bnc" id="L1651" title="All 2 branches missed.">            if (wpn.hasFlag(WeaponType.F_INF_BURST)) {</span>
<span class="nc" id="L1652">                mods.addModifier(-1, &quot;point blank burst fire weapon&quot;);</span>
            }
        }

        // TODO: we need to adjust for stealth modifiers for Chameleon LPS but
        // we don't have range brackets
        // http://bg.battletech.com/forums/index.php/topic,27433.new.html#new

<span class="nc bnc" id="L1660" title="All 2 branches missed.">        if (mod != 0) {</span>
<span class="nc" id="L1661">            mods.addModifier(mod, &quot;infantry range&quot;);</span>
        }

<span class="nc" id="L1664">        return mods;</span>
    }

    /**
     * Finds the effective distance between an attacker and a target. Includes
     * the distance bonus if the attacker and target are in the same building
     * and on different levels. Also takes account of altitude differences
     *
     * @return the effective distance
     */
    public static int effectiveDistance(IGame game, Entity attacker, Targetable target) {
<span class="nc" id="L1675">        return Compute.effectiveDistance(game, attacker, target, false);</span>
    }

    /**
     * Finds the effective distance between an attacker and a target. Includes
     * the distance bonus if the attacker and target are in the same building
     * and on different levels. Also takes account of altitude differences
     *
     * @return the effective distance
     */
    public static int effectiveDistance(IGame game, Entity attacker, Targetable target,
                                        boolean useGroundDistance) {
<span class="nc bnc" id="L1687" title="All 2 branches missed.">        if (Compute.isAirToGround(attacker, target)</span>
<span class="nc bnc" id="L1688" title="All 4 branches missed.">                || (attacker.isBomber() &amp;&amp; target.getTargetType() == Targetable.TYPE_HEX_AERO_BOMB)) {</span>
            // always a distance of zero
<span class="nc" id="L1690">            return 0;</span>
        }

<span class="nc" id="L1693">        Vector&lt;Coords&gt; attackPos = new Vector&lt;&gt;();</span>
<span class="nc" id="L1694">        attackPos.add(attacker.getPosition());</span>
<span class="nc" id="L1695">        Vector&lt;Coords&gt; targetPos = new Vector&lt;&gt;();</span>
<span class="nc" id="L1696">        targetPos.add(target.getPosition());</span>
        // if a grounded dropship is the attacker, then it gets to choose the
        // best secondary position for LoS
<span class="nc bnc" id="L1699" title="All 6 branches missed.">        if ((attacker instanceof Dropship) &amp;&amp; !attacker.isAirborne() &amp;&amp; !attacker.isSpaceborne()) {</span>
<span class="nc" id="L1700">            attackPos = new Vector&lt;&gt;();</span>
<span class="nc bnc" id="L1701" title="All 2 branches missed.">            for (int key : attacker.getSecondaryPositions().keySet()) {</span>
<span class="nc" id="L1702">                attackPos.add(attacker.getSecondaryPositions().get(key));</span>
<span class="nc" id="L1703">            }</span>
        }
<span class="nc bnc" id="L1705" title="All 6 branches missed.">        if ((target instanceof Dropship) &amp;&amp; !target.isAirborne() &amp;&amp; !((Entity) target).isSpaceborne()) {</span>
<span class="nc" id="L1706">            targetPos = new Vector&lt;&gt;();</span>
<span class="nc bnc" id="L1707" title="All 2 branches missed.">            for (final int key : target.getSecondaryPositions().keySet()) {</span>
<span class="nc" id="L1708">                targetPos.add(target.getSecondaryPositions().get(key));</span>
<span class="nc" id="L1709">            }</span>
        }
<span class="nc" id="L1711">        int distance = Integer.MAX_VALUE;</span>
<span class="nc bnc" id="L1712" title="All 2 branches missed.">        for (Coords apos : attackPos) {</span>
<span class="nc bnc" id="L1713" title="All 2 branches missed.">            for (Coords tpos : targetPos) {</span>
<span class="nc bnc" id="L1714" title="All 4 branches missed.">                if ((tpos != null) &amp;&amp; (apos != null)</span>
<span class="nc bnc" id="L1715" title="All 2 branches missed.">                    &amp;&amp; (apos.distance(tpos) &lt; distance)) {</span>
<span class="nc" id="L1716">                    distance = apos.distance(tpos);</span>
                }
<span class="nc" id="L1718">            }</span>
<span class="nc" id="L1719">        }</span>

<span class="nc bnc" id="L1721" title="All 4 branches missed.">        if (Compute.isGroundToAir(attacker, target) &amp;&amp; (target instanceof Entity)) {</span>
            // distance is determined by closest point on flight path
<span class="nc" id="L1723">            distance = attacker.getPosition().distance(getClosestFlightPath(attacker.getId(),</span>
<span class="nc" id="L1724">                    attacker.getPosition(), (Entity) target));</span>

            // if the ground attacker uses weapon bays and we are on a
            // ground map, then we will divide this distance by 16
            // This is totally crazy, but I don't see how else to do it. Use
            // the unofficial
            // &quot;grounded dropships use individual weapons&quot; for sanity.
<span class="nc bnc" id="L1731" title="All 4 branches missed.">            if (attacker.usesWeaponBays() &amp;&amp; game.getBoard().onGround()) {</span>
<span class="nc" id="L1732">                distance = (int) Math.ceil(distance / 16.0);</span>
            }
        }

        // if this is an air-to-air attack on the ground map, then divide
        // distance by 16
<span class="nc bnc" id="L1738" title="All 6 branches missed.">        if (Compute.isAirToAir(attacker, target) &amp;&amp; game.getBoard().onGround() &amp;&amp; !useGroundDistance) {</span>
<span class="nc" id="L1739">            distance = (int) Math.ceil(distance / 16.0);</span>
        }

        // If the attack is completely inside a building, add the difference
        // in elevations between the attacker and target to the range.
        // TODO: should the player be explicitly notified?
<span class="nc bnc" id="L1745" title="All 2 branches missed.">        if (Compute.isInSameBuilding(game, attacker, target)) {</span>
<span class="nc" id="L1746">            int aElev = attacker.getElevation();</span>
<span class="nc" id="L1747">            int tElev = target.getElevation();</span>
<span class="nc" id="L1748">            distance += Math.abs(aElev - tElev);</span>
        }

        // air-to-air attacks add one for altitude differences
<span class="nc bnc" id="L1752" title="All 2 branches missed.">        if (Compute.isAirToAir(attacker, target)) {</span>
<span class="nc" id="L1753">            int aAlt = attacker.getAltitude();</span>
<span class="nc" id="L1754">            int tAlt = target.getAltitude();</span>
<span class="nc bnc" id="L1755" title="All 2 branches missed.">            if (target.isAirborneVTOLorWIGE()) {</span>
<span class="nc" id="L1756">                tAlt++;</span>
            }
<span class="nc" id="L1758">            distance += Math.abs(aAlt - tAlt);</span>
        }

<span class="nc bnc" id="L1761" title="All 2 branches missed.">        if (Compute.isGroundToAir(attacker, target)) {</span>
<span class="nc bnc" id="L1762" title="All 4 branches missed.">            if (attacker.usesWeaponBays() &amp;&amp; game.getBoard().onGround()) {</span>
<span class="nc" id="L1763">                distance += (target.getAltitude());</span>
            } else {
<span class="nc" id="L1765">                distance += (2 * target.getAltitude());</span>
            }
        }

        // Attacking a ground unit while dropping
<span class="nc bnc" id="L1770" title="All 4 branches missed.">        if (attacker.isDropping() &amp;&amp; target.getAltitude() == 0) {</span>
<span class="nc" id="L1771">            distance += (2 * attacker.getAltitude());</span>
        }

<span class="nc" id="L1774">        return distance;</span>
    }

    /**
     * @param aPos the attacker's position
     * @param te the target entity
     * @return the closest position along &lt;code&gt;te&lt;/codeE&gt;'s flight path to &lt;code&gt;aPos&lt;/code&gt;. In
     * the case of multiple equi-distance positions, the first one is picked unless
     * &lt;code&gt;te&lt;/code&gt;'s playerPickedPassThrough position is non-null.
     */
    public static @Nullable Coords getClosestFlightPath(int attackerId, Coords aPos, Entity te) {
<span class="nc" id="L1785">        Coords finalPos = te.getPosition();</span>
<span class="nc bnc" id="L1786" title="All 2 branches missed.">        if (te.getPlayerPickedPassThrough(attackerId) != null) {</span>
<span class="nc" id="L1787">            finalPos = te.getPlayerPickedPassThrough(attackerId);</span>
        }
<span class="nc" id="L1789">        int distance = Integer.MAX_VALUE;</span>
<span class="nc bnc" id="L1790" title="All 2 branches missed.">        if (finalPos != null) {</span>
<span class="nc" id="L1791">            distance = aPos.distance(finalPos);</span>
        }
        // don't return zero distance Coords, but rather the Coords immediately
        // before this
        // This is necessary to determine angle of attack and arc information
        // for direct fly-overs
<span class="nc bnc" id="L1797" title="All 2 branches missed.">        for (Coords c : te.getPassedThrough()) {</span>
<span class="nc bnc" id="L1798" title="All 4 branches missed.">            if (!aPos.equals(c) &amp;&amp; (c != null)</span>
<span class="nc bnc" id="L1799" title="All 4 branches missed.">                &amp;&amp; ((aPos.distance(c) &lt; distance) || (distance == 0))) {</span>
<span class="nc" id="L1800">                finalPos = c;</span>
<span class="nc" id="L1801">                distance = aPos.distance(c);</span>
            }
<span class="nc" id="L1803">        }</span>
<span class="nc" id="L1804">        return finalPos;</span>
    }

    public static int getClosestFlightPathFacing(int attackerId,
            Coords aPos, Entity te) {

<span class="nc" id="L1810">        Coords finalPos = te.getPosition();</span>
<span class="nc bnc" id="L1811" title="All 2 branches missed.">        if (te.getPlayerPickedPassThrough(attackerId) != null) {</span>
<span class="nc" id="L1812">            finalPos = te.getPlayerPickedPassThrough(attackerId);</span>
        }
<span class="nc" id="L1814">        int distance = Integer.MAX_VALUE;</span>
<span class="nc bnc" id="L1815" title="All 2 branches missed.">        if (finalPos != null) {</span>
<span class="nc" id="L1816">            distance = aPos.distance(finalPos);</span>
        }
<span class="nc" id="L1818">        int finalFacing = te.getFacing();</span>
        // don't return zero distance Coords, but rather the Coords immediately
        // before this
        // This is necessary to determine angle of attack and arc information
        // for direct fly-overs
<span class="nc bnc" id="L1823" title="All 2 branches missed.">        for (int i = 0; i &lt; te.getPassedThrough().size(); i++) {</span>
<span class="nc" id="L1824">            Coords c = te.getPassedThrough().get(i);</span>
<span class="nc bnc" id="L1825" title="All 4 branches missed.">            if (!aPos.equals(c) &amp;&amp; (c != null)</span>
<span class="nc bnc" id="L1826" title="All 4 branches missed.">                &amp;&amp; ((aPos.distance(c) &lt; distance) || (distance == 0))) {</span>
<span class="nc" id="L1827">                finalFacing = te.getPassedThroughFacing().get(i);</span>
<span class="nc" id="L1828">                finalPos = c;</span>
<span class="nc" id="L1829">                distance = aPos.distance(c);</span>
<span class="nc bnc" id="L1830" title="All 2 branches missed.">            } else if (c.equals(finalPos)) {</span>
<span class="nc" id="L1831">                finalFacing = te.getPassedThroughFacing().get(i);</span>
            }
        }
<span class="nc" id="L1834">        return finalFacing;</span>
    }

    /**
     * WOR: Need this function to find out where my nova stuff doesn't work.
     * Delete it if nova works but remember to alter the /nova debug server
     * command.
     */
    public static Entity exposed_findC3Spotter(IGame game, Entity attacker,
                                               Targetable target) {
<span class="nc" id="L1844">        return findC3Spotter(game, attacker, target);</span>
    }

    /**
     * find a c3, c3i, NC3, or nova spotter that is closer to the target than the
     * attacker.
     *
     * @param game
     * @param attacker
     * @param target
     * @return A closer C3/C3i/Nova spotter, or the attacker if no spotters are
     *         found
     */
    private static Entity findC3Spotter(IGame game, Entity attacker,
            Targetable target) {
        // no available C3-like system
<span class="nc bnc" id="L1860" title="All 4 branches missed.">        if (!attacker.hasC3() &amp;&amp; !attacker.hasC3i()</span>
<span class="nc bnc" id="L1861" title="All 4 branches missed.">                &amp;&amp; !attacker.hasActiveNovaCEWS() &amp;&amp; !attacker.hasNavalC3()) {</span>
<span class="nc" id="L1862">            return attacker;</span>
        }

<span class="nc" id="L1865">        ArrayList&lt;Entity&gt; network = new ArrayList&lt;Entity&gt;();</span>

        // Compute friends in network
<span class="nc bnc" id="L1868" title="All 2 branches missed.">        for (Entity friend : game.getEntitiesVector()) {</span>

<span class="nc bnc" id="L1870" title="All 2 branches missed.">            if (attacker.equals(friend)</span>
<span class="nc bnc" id="L1871" title="All 2 branches missed.">                    || !attacker.onSameC3NetworkAs(friend, true)</span>
<span class="nc bnc" id="L1872" title="All 2 branches missed.">                    || !friend.isDeployed()</span>
<span class="nc bnc" id="L1873" title="All 2 branches missed.">                    || (friend.getTransportId() != Entity.NONE)) {</span>
<span class="nc" id="L1874">                continue; // useless to us...</span>
            }

            // Must have LoS, Compute.canSee considers sensors and visual range
<span class="nc bnc" id="L1878" title="All 2 branches missed.">            if (!LosEffects.calculateLos(game, friend.getId(), target).canSee()) {</span>
<span class="nc" id="L1879">                continue;</span>
            }

<span class="nc" id="L1882">            int buddyRange = Compute.effectiveDistance(game, friend, target,</span>
                    false);

<span class="nc" id="L1885">            boolean added = false;</span>
            // put everyone in the C3 network into a list and sort it by range.
<span class="nc bnc" id="L1887" title="All 2 branches missed.">            for (int pos = 0; pos &lt; network.size(); pos++) {</span>
<span class="nc bnc" id="L1888" title="All 2 branches missed.">                if (Compute.effectiveDistance(game, network.get(pos), target,</span>
                        false) &gt;= buddyRange) {
<span class="nc" id="L1890">                    network.add(pos, friend);</span>
<span class="nc" id="L1891">                    added = true;</span>
<span class="nc" id="L1892">                    break;</span>
                }
            }

<span class="nc bnc" id="L1896" title="All 2 branches missed.">            if (!added) {</span>
<span class="nc" id="L1897">                network.add(friend);</span>
            }
<span class="nc" id="L1899">        }</span>

        // ensure network connectivity
<span class="nc" id="L1902">        List&lt;ECMInfo&gt; allECMInfo = ComputeECM.computeAllEntitiesECMInfo(game</span>
<span class="nc" id="L1903">                .getEntitiesVector());</span>
<span class="nc" id="L1904">        int position = 0;</span>
<span class="nc bnc" id="L1905" title="All 2 branches missed.">        for (Entity spotter : network) {</span>
<span class="nc bnc" id="L1906" title="All 2 branches missed.">            for (int count = position++; count &lt; network.size(); count++) {</span>
<span class="nc bnc" id="L1907" title="All 2 branches missed.">                if (Compute.canCompleteNodePath(spotter, attacker, network,</span>
                        count, allECMInfo)) {
<span class="nc" id="L1909">                    return spotter;</span>
                }
            }
<span class="nc" id="L1912">        }</span>

<span class="nc" id="L1914">        return attacker;</span>
    }

    /**
     * Looks through the network list to ensure that the given Entity is
     * connected to the network.
     *
     * @param start
     * @param end
     * @param network
     * @param startPosition
     * @return
     */
    private static boolean canCompleteNodePath(Entity start, Entity end,
            ArrayList&lt;Entity&gt; network, int startPosition,
            List&lt;ECMInfo&gt; allECMInfo) {

<span class="nc" id="L1931">        Entity spotter = network.get(startPosition);</span>

        // ECMInfo for line between spotter's position and start's position
<span class="nc" id="L1934">        ECMInfo spotterStartECM = ComputeECM.getECMEffects(spotter,</span>
<span class="nc" id="L1935">                start.getPosition(), spotter.getPosition(), true, allECMInfo);</span>

        // Check for ECM between spotter and start
<span class="nc bnc" id="L1938" title="All 4 branches missed.">        boolean isC3BDefeated = start.hasBoostedC3()</span>
<span class="nc bnc" id="L1939" title="All 2 branches missed.">                &amp;&amp; (spotterStartECM != null) &amp;&amp; spotterStartECM.isAngelECM();</span>
<span class="nc bnc" id="L1940" title="All 4 branches missed.">        boolean isNovaDefeated = start.hasNovaCEWS()</span>
<span class="nc bnc" id="L1941" title="All 2 branches missed.">                &amp;&amp; (spotterStartECM != null) &amp;&amp; spotterStartECM.isNovaECM();</span>
<span class="nc bnc" id="L1942" title="All 6 branches missed.">        boolean isC3Defeated = !(start.hasBoostedC3() || start.hasNovaCEWS())</span>
<span class="nc bnc" id="L1943" title="All 2 branches missed.">                &amp;&amp; (spotterStartECM != null) &amp;&amp; spotterStartECM.isECM();</span>
<span class="nc bnc" id="L1944" title="All 6 branches missed.">        if (isC3BDefeated || isNovaDefeated || isC3Defeated) {</span>
<span class="nc" id="L1945">            return false;</span>
        }

        // ECMInfo for line between spotter's position and end's position
<span class="nc" id="L1949">        ECMInfo spotterEndECM = ComputeECM.getECMEffects(spotter,</span>
<span class="nc" id="L1950">                spotter.getPosition(), end.getPosition(), true, allECMInfo);</span>
<span class="nc bnc" id="L1951" title="All 4 branches missed.">        isC3BDefeated = start.hasBoostedC3() &amp;&amp; (spotterEndECM != null)</span>
<span class="nc bnc" id="L1952" title="All 2 branches missed.">                &amp;&amp; spotterEndECM.isAngelECM();</span>
<span class="nc bnc" id="L1953" title="All 4 branches missed.">        isNovaDefeated = start.hasNovaCEWS() &amp;&amp; (spotterEndECM != null)</span>
<span class="nc bnc" id="L1954" title="All 2 branches missed.">                &amp;&amp; spotterEndECM.isNovaECM();</span>
<span class="nc bnc" id="L1955" title="All 6 branches missed.">        isC3Defeated = !(start.hasBoostedC3() || start.hasNovaCEWS())</span>
<span class="nc bnc" id="L1956" title="All 2 branches missed.">                &amp;&amp; (spotterEndECM != null) &amp;&amp; spotterEndECM.isECM();</span>
        // If there's no ECM between spotter and end, we're done
<span class="nc bnc" id="L1958" title="All 6 branches missed.">        if (!(isC3BDefeated || isNovaDefeated || isC3Defeated)) {</span>
<span class="nc" id="L1959">            return true;</span>
        }

<span class="nc bnc" id="L1962" title="All 2 branches missed.">        for (++startPosition; startPosition &lt; network.size(); startPosition++) {</span>
<span class="nc bnc" id="L1963" title="All 2 branches missed.">            if (Compute.canCompleteNodePath(spotter, end, network,</span>
                    startPosition, allECMInfo)) {
<span class="nc" id="L1965">                return true;</span>
            }
        }

<span class="nc" id="L1969">        return false;</span>
    }

    /**
     * Gets the modifiers, if any, that the mech receives from being prone.
     *
     * @return any applicable modifiers due to being prone
     */
    public static ToHitData getProneMods(IGame game, Entity attacker,
                                         int weaponId) {
<span class="nc bnc" id="L1979" title="All 2 branches missed.">        if (!attacker.isProne()) {</span>
<span class="nc" id="L1980">            return null; // no modifier</span>
        }
<span class="nc" id="L1982">        ToHitData mods = new ToHitData();</span>
<span class="nc" id="L1983">        Mounted weapon = attacker.getEquipment(weaponId);</span>
<span class="nc bnc" id="L1984" title="All 2 branches missed.">        if (attacker.entityIsQuad()) {</span>
<span class="nc" id="L1985">            int legsDead = ((Mech) attacker).countBadLegs();</span>
<span class="nc bnc" id="L1986" title="All 4 branches missed.">            if (legsDead == 0 &amp;&amp; !((Mech)attacker).hasHipCrit()) {</span>
                // No legs destroyed and no hip crits: no penalty and can fire all weapons
<span class="nc" id="L1988">                return null; // no modifier</span>
<span class="nc bnc" id="L1989" title="All 2 branches missed.">            } else if (legsDead &gt;= 3) {</span>
<span class="nc" id="L1990">                return new ToHitData(TargetRoll.IMPOSSIBLE,</span>
                                     &quot;Prone with three or more legs destroyed.&quot;);
            }
            // we have one or two dead legs...

            // Need an intact front leg
<span class="nc bnc" id="L1996" title="All 2 branches missed.">            if (attacker.isLocationBad(Mech.LOC_RARM)</span>
<span class="nc bnc" id="L1997" title="All 2 branches missed.">                &amp;&amp; attacker.isLocationBad(Mech.LOC_LARM)) {</span>
<span class="nc" id="L1998">                return new ToHitData(TargetRoll.IMPOSSIBLE,</span>
                                     &quot;Prone with both front legs destroyed.&quot;);
            }

            // front leg-mounted weapons have addidional trouble
<span class="nc bnc" id="L2003" title="All 4 branches missed.">            if ((weapon.getLocation() == Mech.LOC_RARM) || (weapon.getSecondLocation() == Mech.LOC_RARM)</span>
<span class="nc bnc" id="L2004" title="All 4 branches missed.">                || (weapon.getLocation() == Mech.LOC_LARM || (weapon.getSecondLocation() == Mech.LOC_LARM))) {</span>
<span class="nc bnc" id="L2005" title="All 2 branches missed.">                int otherArm = (weapon.getLocation() == Mech.LOC_RARM</span>
<span class="nc bnc" id="L2006" title="All 2 branches missed.">                        || weapon.getSecondLocation() == Mech.LOC_RARM)? Mech.LOC_LARM</span>
<span class="nc" id="L2007">                                                                     : Mech.LOC_RARM;</span>
                // check previous attacks for weapons fire from the other arm
<span class="nc bnc" id="L2009" title="All 2 branches missed.">                if (Compute.isFiringFromArmAlready(game, weaponId, attacker,</span>
                                                   otherArm)) {
<span class="nc" id="L2011">                    return new ToHitData(TargetRoll.IMPOSSIBLE,</span>
                                         &quot;Prone and firing from other front leg already.&quot;);
                }
            }
            // can't fire rear leg weapons
<span class="nc bnc" id="L2016" title="All 2 branches missed.">            if ((weapon.getLocation() == Mech.LOC_LLEG)</span>
<span class="nc bnc" id="L2017" title="All 2 branches missed.">                || (weapon.getLocation() == Mech.LOC_RLEG)) {</span>
<span class="nc" id="L2018">                return new ToHitData(TargetRoll.IMPOSSIBLE,</span>
                                     &quot;Can't fire rear leg-mounted weapons while prone with destroyed legs.&quot;);
            }
<span class="nc bnc" id="L2021" title="All 2 branches missed.">            if (((Mech)attacker).getCockpitType() == Mech.COCKPIT_DUAL</span>
<span class="nc bnc" id="L2022" title="All 2 branches missed.">                    &amp;&amp; attacker.getCrew().hasDedicatedGunner()) {</span>
<span class="nc" id="L2023">                mods.addModifier(1, &quot;attacker prone&quot;);</span>
            } else {
<span class="nc" id="L2025">                mods.addModifier(2, &quot;attacker prone&quot;);</span>
            }
<span class="nc" id="L2027">        } else {</span>
<span class="nc" id="L2028">            int l3ProneFiringArm = Entity.LOC_NONE;</span>

<span class="nc bnc" id="L2030" title="All 2 branches missed.">            if (attacker.isLocationBad(Mech.LOC_RARM)</span>
<span class="nc bnc" id="L2031" title="All 2 branches missed.">                || attacker.isLocationBad(Mech.LOC_LARM)) {</span>
<span class="nc bnc" id="L2032" title="All 2 branches missed.">                if (game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_PRONE_FIRE)) {</span>
                    // Can fire with only one arm
<span class="nc bnc" id="L2034" title="All 2 branches missed.">                    if (attacker.isLocationBad(Mech.LOC_RARM)</span>
<span class="nc bnc" id="L2035" title="All 2 branches missed.">                        &amp;&amp; attacker.isLocationBad(Mech.LOC_LARM)) {</span>
<span class="nc" id="L2036">                        return new ToHitData(TargetRoll.IMPOSSIBLE,</span>
                                             &quot;Prone with both arms destroyed.&quot;);
                    }

<span class="nc bnc" id="L2040" title="All 2 branches missed.">                    l3ProneFiringArm = attacker.isLocationBad(Mech.LOC_RARM) ? Mech.LOC_LARM</span>
<span class="nc" id="L2041">                                                                             : Mech.LOC_RARM;</span>
                } else {
                    // must have an arm intact
<span class="nc" id="L2044">                    return new ToHitData(TargetRoll.IMPOSSIBLE,</span>
                                         &quot;Prone with one or both arms destroyed.&quot;);
                }
            }

            // arm-mounted weapons have addidional trouble
<span class="nc bnc" id="L2050" title="All 4 branches missed.">            if ((weapon.getLocation() == Mech.LOC_RARM) || (weapon.getSecondLocation() == Mech.LOC_RARM)</span>
<span class="nc bnc" id="L2051" title="All 4 branches missed.">                || (weapon.getLocation() == Mech.LOC_LARM) || (weapon.getSecondLocation() == Mech.LOC_LARM)) {</span>
<span class="nc bnc" id="L2052" title="All 2 branches missed.">                if (l3ProneFiringArm == weapon.getLocation()</span>
<span class="nc bnc" id="L2053" title="All 4 branches missed.">                        || (weapon.getSecondLocation() != Entity.NONE &amp;&amp; l3ProneFiringArm == weapon.getSecondLocation())) {</span>
<span class="nc" id="L2054">                    return new ToHitData(TargetRoll.IMPOSSIBLE,</span>
                                         &quot;Prone and propping up with this arm.&quot;);
                }

<span class="nc bnc" id="L2058" title="All 2 branches missed.">                int otherArm = (weapon.getLocation() == Mech.LOC_RARM</span>
<span class="nc bnc" id="L2059" title="All 2 branches missed.">                        || weapon.getSecondLocation() == Mech.LOC_RARM)? Mech.LOC_LARM</span>
<span class="nc" id="L2060">                                                                        : Mech.LOC_RARM;</span>
                // check previous attacks for weapons fire from the other arm
<span class="nc bnc" id="L2062" title="All 2 branches missed.">                if (Compute.isFiringFromArmAlready(game, weaponId, attacker,</span>
                                                   otherArm)) {
<span class="nc" id="L2064">                    return new ToHitData(TargetRoll.IMPOSSIBLE,</span>
                                         &quot;Prone and firing from other arm already.&quot;);
                }
            }
            // can't fire leg weapons
<span class="nc bnc" id="L2069" title="All 2 branches missed.">            if ((weapon.getLocation() == Mech.LOC_LLEG)</span>
<span class="nc bnc" id="L2070" title="All 2 branches missed.">                || (weapon.getLocation() == Mech.LOC_RLEG)) {</span>
<span class="nc" id="L2071">                return new ToHitData(TargetRoll.IMPOSSIBLE,</span>
                                     &quot;Can't fire leg-mounted weapons while prone.&quot;);
            }
<span class="nc bnc" id="L2074" title="All 2 branches missed.">            if (((Mech)attacker).getCockpitType() == Mech.COCKPIT_DUAL</span>
<span class="nc bnc" id="L2075" title="All 2 branches missed.">                    &amp;&amp; attacker.getCrew().hasDedicatedGunner()) {</span>
<span class="nc" id="L2076">                mods.addModifier(1, &quot;attacker prone&quot;);</span>
            } else {
<span class="nc" id="L2078">                mods.addModifier(2, &quot;attacker prone&quot;);</span>
            }

<span class="nc bnc" id="L2081" title="All 2 branches missed.">            if (l3ProneFiringArm != Entity.LOC_NONE) {</span>
<span class="nc" id="L2082">                mods.addModifier(1, &quot;attacker propping on single arm&quot;);</span>
            }
        }
<span class="nc" id="L2085">        return mods;</span>
    }

    /**
     * Checks to see if there is an attack previous to the one with this weapon
     * from the specified arm.
     *
     * @return true if there is a previous attack from this arm
     */
    private static boolean isFiringFromArmAlready(IGame game, int weaponId,
                                                  final Entity attacker, int armLoc) {
<span class="nc" id="L2096">        int torsoLoc = Mech.getInnerLocation(armLoc);</span>
<span class="nc" id="L2097">        for (Enumeration&lt;EntityAction&gt; i = game.getActions(); i</span>
<span class="nc bnc" id="L2098" title="All 2 branches missed.">                .hasMoreElements(); ) {</span>
<span class="nc" id="L2099">            EntityAction ea = i.nextElement();</span>
<span class="nc bnc" id="L2100" title="All 2 branches missed.">            if (!(ea instanceof WeaponAttackAction)) {</span>
<span class="nc" id="L2101">                continue;</span>
            }
<span class="nc" id="L2103">            WeaponAttackAction prevAttack = (WeaponAttackAction) ea;</span>
            // stop when we get to this weaponattack (does this always work?)
<span class="nc bnc" id="L2105" title="All 2 branches missed.">            if ((prevAttack.getEntityId() == attacker.getId())</span>
<span class="nc bnc" id="L2106" title="All 2 branches missed.">                &amp;&amp; (prevAttack.getWeaponId() == weaponId)) {</span>
<span class="nc" id="L2107">                break;</span>
            }
<span class="nc bnc" id="L2109" title="All 2 branches missed.">            if (((prevAttack.getEntityId() == attacker.getId()) &amp;&amp; (attacker</span>
<span class="nc" id="L2110">                                                                            .getEquipment(prevAttack.getWeaponId())</span>
<span class="nc bnc" id="L2111" title="All 2 branches missed.">                                                                            .getLocation() == armLoc))</span>
<span class="nc bnc" id="L2112" title="All 2 branches missed.">                || ((prevAttack.getEntityId() == attacker.getId())</span>
<span class="nc" id="L2113">                    &amp;&amp; (attacker.getEquipment(prevAttack.getWeaponId())</span>
<span class="nc bnc" id="L2114" title="All 2 branches missed.">                                .getLocation() == torsoLoc) &amp;&amp; attacker</span>
<span class="nc bnc" id="L2115" title="All 2 branches missed.">                            .getEquipment(prevAttack.getWeaponId()).isSplit())) {</span>
<span class="nc" id="L2116">                return true;</span>
            }
<span class="nc" id="L2118">        }</span>
<span class="nc" id="L2119">        return false;</span>
    }

    /**
     * Adds any damage modifiers from arm critical hits or sensor damage.
     *
     * @return Any applicable damage modifiers
     */
    public static ToHitData getDamageWeaponMods(Entity attacker, Mounted weapon) {
<span class="fc" id="L2128">        ToHitData mods = new ToHitData();</span>
<span class="pc bpc" id="L2129" title="1 of 2 branches missed.">        if (attacker instanceof Protomech) {</span>
            // Head criticals add to target number of all weapons.
<span class="nc" id="L2131">            int hits = ((Protomech) attacker).getCritsHit(Protomech.LOC_HEAD);</span>
<span class="nc bnc" id="L2132" title="All 2 branches missed.">            if (hits &gt; 0) {</span>
<span class="nc" id="L2133">                mods.addModifier(hits, hits + &quot; head critical(s)&quot;);</span>
            }

            // Arm mounted (and main gun) weapons get DRMs from arm crits.
<span class="nc bnc" id="L2137" title="All 3 branches missed.">            switch (weapon.getLocation()) {</span>
                case Protomech.LOC_LARM:
                case Protomech.LOC_RARM:
<span class="nc" id="L2140">                    hits = ((Protomech) attacker).getCritsHit(weapon</span>
<span class="nc" id="L2141">                                                                      .getLocation());</span>
<span class="nc bnc" id="L2142" title="All 2 branches missed.">                    if (hits &gt; 0) {</span>
<span class="nc" id="L2143">                        mods.addModifier(hits, hits + &quot; arm critical(s)&quot;);</span>
                    }
                    break;
                case Protomech.LOC_MAINGUN:
                    // Main gun is affected by crits in *both* arms.
<span class="nc" id="L2148">                    hits = ((Protomech) attacker)</span>
<span class="nc" id="L2149">                            .getCritsHit(Protomech.LOC_LARM);</span>
<span class="nc" id="L2150">                    hits += ((Protomech) attacker)</span>
<span class="nc" id="L2151">                            .getCritsHit(Protomech.LOC_RARM);</span>
<span class="nc bnc" id="L2152" title="All 2 branches missed.">                    if (4 == hits) {</span>
<span class="nc" id="L2153">                        mods.addModifier(TargetRoll.IMPOSSIBLE,</span>
                                         &quot;Cannot fire main gun with no arms.&quot;);
<span class="nc bnc" id="L2155" title="All 2 branches missed.">                    } else if (hits &gt; 0) {</span>
<span class="nc" id="L2156">                        mods.addModifier(hits, hits + &quot; arm critical(s)&quot;);</span>
                    }
                    break;
            }

<span class="nc" id="L2161">        } // End attacker-is-Protomech</span>

        // only mechs have arm actuators - for those, we check whether
        // there is arm actuator damage
<span class="fc bfc" id="L2165" title="All 2 branches covered.">        else if(attacker instanceof Mech) {</span>
            // split weapons need to account for arm actuator hits, too
            // see bug 1363690
            // we don't need to specifically check for weapons split between
            // torso and leg, because for those, the location stored in the
            // Mounted is the leg.
<span class="fc" id="L2171">            int location = weapon.getLocation();</span>
<span class="pc bpc" id="L2172" title="1 of 2 branches missed.">            if (weapon.isSplit()) {</span>
<span class="nc bnc" id="L2173" title="All 3 branches missed.">                switch (location) {</span>
                    case Mech.LOC_LT:
<span class="nc" id="L2175">                        location = Mech.LOC_LARM;</span>
<span class="nc" id="L2176">                        break;</span>
                    case Mech.LOC_RT:
<span class="nc" id="L2178">                        location = Mech.LOC_RARM;</span>
<span class="nc" id="L2179">                        break;</span>
                    default:
                }
            }
            
            // only arms can have damaged arm actuators
<span class="pc bpc" id="L2185" title="2 of 4 branches missed.">            if(location == Mech.LOC_LARM || location == Mech.LOC_RARM) {</span>
<span class="pc bpc" id="L2186" title="1 of 2 branches missed.">                if (attacker.getBadCriticals(CriticalSlot.TYPE_SYSTEM,</span>
                                             Mech.ACTUATOR_SHOULDER, location) &gt; 0) {
<span class="nc" id="L2188">                    mods.addModifier(4, &quot;shoulder actuator destroyed&quot;);</span>
                } else {
                    // no shoulder hits, add other arm hits
<span class="fc" id="L2191">                    int actuatorHits = 0;</span>
<span class="pc bpc" id="L2192" title="1 of 2 branches missed.">                    if (attacker.getBadCriticals(CriticalSlot.TYPE_SYSTEM,</span>
                                                 Mech.ACTUATOR_UPPER_ARM, location) &gt; 0) {
<span class="nc" id="L2194">                        actuatorHits++;</span>
                    }
<span class="pc bpc" id="L2196" title="1 of 2 branches missed.">                    if (attacker.getBadCriticals(CriticalSlot.TYPE_SYSTEM,</span>
                                                 Mech.ACTUATOR_LOWER_ARM, location) &gt; 0) {
<span class="nc" id="L2198">                        actuatorHits++;</span>
                    }
<span class="pc bpc" id="L2200" title="1 of 2 branches missed.">                    if (actuatorHits &gt; 0) {</span>
<span class="nc" id="L2201">                        mods.addModifier(actuatorHits, actuatorHits</span>
                                                       + &quot; destroyed arm actuators&quot;);
                    }
                }
            }
        }

        // sensors critical hit to attacker
<span class="fc" id="L2209">        int sensorHits = attacker.getBadCriticals(CriticalSlot.TYPE_SYSTEM,</span>
                                                  Mech.SYSTEM_SENSORS, Mech.LOC_HEAD);
<span class="fc bfc" id="L2211" title="All 2 branches covered.">        if ((attacker instanceof Mech)</span>
<span class="pc bpc" id="L2212" title="1 of 2 branches missed.">            &amp;&amp; (((Mech) attacker).getCockpitType() == Mech.COCKPIT_TORSO_MOUNTED)) {</span>
<span class="nc" id="L2213">            sensorHits += attacker.getBadCriticals(CriticalSlot.TYPE_SYSTEM,</span>
                                                   Mech.SYSTEM_SENSORS, Mech.LOC_CT);
<span class="nc bnc" id="L2215" title="All 2 branches missed.">            if (sensorHits &gt; 1) {</span>
<span class="nc" id="L2216">                mods.addModifier(4, &quot;attacker sensors badly damaged&quot;);</span>
<span class="nc bnc" id="L2217" title="All 2 branches missed.">            } else if (sensorHits &gt; 0) {</span>
<span class="nc" id="L2218">                mods.addModifier(2, &quot;attacker sensors damaged&quot;);</span>
            }
<span class="fc bfc" id="L2220" title="All 2 branches covered.">        } else if (sensorHits &gt; 0) {</span>
<span class="pc bpc" id="L2221" title="2 of 4 branches missed.">            if (attacker instanceof Mech &amp;&amp; ((Mech)attacker).getCockpitType() == Mech.COCKPIT_DUAL</span>
<span class="nc bnc" id="L2222" title="All 2 branches missed.">                    &amp;&amp; attacker.getCrew().hasDedicatedGunner()) {</span>
<span class="nc" id="L2223">                mods.addModifier(1, &quot;attacker sensors damaged&quot;);</span>
            } else {
<span class="fc" id="L2225">                mods.addModifier(2, &quot;attacker sensors damaged&quot;);</span>
            }
        }

        // if partial sensor/stabilizer/fcs/cic repairs are present the shot will be more difficult
<span class="pc bpc" id="L2230" title="1 of 2 branches missed.">        if (attacker.getPartialRepairs() != null) {</span>
<span class="nc bnc" id="L2231" title="All 2 branches missed.">            if (attacker.getPartialRepairs().booleanOption(&quot;sensors_1_crit&quot;)) {</span>
<span class="nc" id="L2232">                mods.addModifier(1, &quot;sensor damage&quot;);</span>
            }
<span class="nc bnc" id="L2234" title="All 2 branches missed.">            if (attacker.getPartialRepairs().booleanOption(&quot;mech_sensors_2_crit&quot;)) {</span>
<span class="nc" id="L2235">                mods.addModifier(2, &quot;sensor damage&quot;);</span>
            }
<span class="nc bnc" id="L2237" title="All 2 branches missed.">            if (attacker.getPartialRepairs().booleanOption(&quot;veh_stabilizer_crit&quot;)) {</span>
<span class="nc" id="L2238">                mods.addModifier(1, &quot;stabilizer damage&quot;);</span>
            }
<span class="nc bnc" id="L2240" title="All 2 branches missed.">            if (attacker.getPartialRepairs().booleanOption(&quot;aero_cic_fcs_replace&quot;)) {</span>
<span class="nc" id="L2241">                mods.addModifier(1, &quot;misreplaced cic/fcs equipment&quot;);</span>
            }
<span class="nc bnc" id="L2243" title="All 2 branches missed.">            if (attacker.getPartialRepairs().booleanOption(&quot;aero_cic_fcs_crit&quot;)) {</span>
<span class="nc" id="L2244">                 mods.addModifier(1, &quot;faulty cic/fcs repairs&quot;);</span>
            }
        }

<span class="fc" id="L2248">        return mods;</span>
    }

    /**
     * Determines if the current target is a secondary target, and if so,
     * returns the appropriate modifier.
     *
     * @return The secondary target modifier.
     * @author Ben
     */
    public static ToHitData getSecondaryTargetMod(IGame game, Entity attacker,
            Targetable target) {

        // large craft do not get secondary target mod
        // http://www.classicbattletech.com/forums/index.php/topic,37661.0.html
<span class="nc bnc" id="L2263" title="All 2 branches missed.">        if (attacker.getCrew().getCrewType().getMaxPrimaryTargets() &lt; 0) {</span>
<span class="nc" id="L2264">            return null;</span>
        }

<span class="nc" id="L2267">        boolean curInFrontArc = Compute</span>
<span class="nc" id="L2268">                .isInArc(attacker.getPosition(), attacker.getSecondaryFacing(),</span>
<span class="nc" id="L2269">                         target, attacker.getForwardArc());</span>
<span class="nc" id="L2270">        boolean curInRearArc = Compute.isInArc(attacker.getPosition(),</span>
<span class="nc" id="L2271">                                               attacker.getSecondaryFacing(), target, attacker.getRearArc());</span>
<span class="nc bnc" id="L2272" title="All 4 branches missed.">        if (!curInRearArc &amp;&amp; attacker.hasQuirk(OptionsConstants.QUIRK_POS_MULTI_TRAC)) {</span>
<span class="nc" id="L2273">            return null;</span>
        }

<span class="nc" id="L2276">        int primaryTarget = Entity.NONE;</span>
<span class="nc" id="L2277">        boolean primaryInFrontArc = false;</span>
        // Track # of targets, for secondary modifiers w/ multi-crew vehicles
<span class="nc" id="L2279">        Set&lt;Integer&gt; targIds = new HashSet&lt;&gt;();</span>
<span class="nc" id="L2280">        for (Enumeration&lt;EntityAction&gt; i = game.getActions(); i</span>
<span class="nc bnc" id="L2281" title="All 2 branches missed.">                .hasMoreElements(); ) {</span>
<span class="nc" id="L2282">            Object o = i.nextElement();</span>
<span class="nc bnc" id="L2283" title="All 2 branches missed.">            if (!(o instanceof WeaponAttackAction)) {</span>
<span class="nc" id="L2284">                continue;</span>
            }
<span class="nc" id="L2286">            WeaponAttackAction prevAttack = (WeaponAttackAction) o;</span>
<span class="nc bnc" id="L2287" title="All 2 branches missed.">            if (prevAttack.getEntityId() == attacker.getId()) {</span>
                // Don't add id of current target, as it gets counted elsewhere
<span class="nc bnc" id="L2289" title="All 2 branches missed.">                if (prevAttack.getTargetId() != target.getTargetId()) {</span>
<span class="nc" id="L2290">                    targIds.add(prevAttack.getTargetId());</span>
                }
                // first front arc target is our primary.
                // if first target is non-front, and either a later target or
                // the current one is in front, use that instead.
<span class="nc bnc" id="L2295" title="All 2 branches missed.">                if (!game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_NO_FORCED_PRIMARY_TARGETS)) {</span>
<span class="nc" id="L2296">                    Targetable pte = game.getTarget(prevAttack.getTargetType(),</span>
<span class="nc" id="L2297">                                                    prevAttack.getTargetId());</span>
                    // in double blind play, we might not have the target in our
                    // local copy of the game. In that case, the sprite won't
                    // have the correct to-hit number, but at least we don't crash
<span class="nc bnc" id="L2301" title="All 2 branches missed.">                    if (pte == null) {</span>
<span class="nc" id="L2302">                        continue;</span>
                    }

                    // Determine primary target
<span class="nc bnc" id="L2306" title="All 4 branches missed.">                    if ((primaryTarget == Entity.NONE || !primaryInFrontArc)</span>
<span class="nc bnc" id="L2307" title="All 2 branches missed.">                        &amp;&amp; Compute.isInArc(attacker.getPosition(),</span>
<span class="nc" id="L2308">                                           attacker.getSecondaryFacing(), pte,</span>
<span class="nc" id="L2309">                                           attacker.getForwardArc())) {</span>
<span class="nc" id="L2310">                        primaryTarget = prevAttack.getTargetId();</span>
<span class="nc" id="L2311">                        primaryInFrontArc = true;</span>
<span class="nc bnc" id="L2312" title="All 4 branches missed.">                    } else if ((primaryTarget == Entity.NONE) &amp;&amp; !curInFrontArc) {</span>
<span class="nc" id="L2313">                        primaryTarget = prevAttack.getTargetId();</span>
                    }
<span class="nc bnc" id="L2315" title="All 2 branches missed.">                } else if (primaryTarget == Entity.NONE){</span>
<span class="nc" id="L2316">                    primaryTarget = prevAttack.getTargetId();</span>
                }
            }
<span class="nc" id="L2319">        }</span>

        // # of targets, +1 for the passed target
<span class="nc" id="L2322">        int countTargets = 1 + targIds.size();</span>

<span class="nc" id="L2324">        int maxPrimary = 1;</span>
        //Tripods and QuadVees with dedicated gunnery can target up to three units before incurring a penalty, and two for dual cockpit
<span class="nc bnc" id="L2326" title="All 2 branches missed.">        if (attacker.getCrew().hasDedicatedGunner()) {</span>
<span class="nc" id="L2327">            maxPrimary = attacker.getCrew().getCrewType().getMaxPrimaryTargets();</span>
        }
<span class="nc bnc" id="L2329" title="All 4 branches missed.">        if (game.getOptions().booleanOption(&quot;tacops_tank_crews&quot;)</span>
            &amp;&amp; (attacker instanceof Tank)) {

            // If we are a tank, and only have 1 crew then we have some special
            //  restrictions
<span class="nc bnc" id="L2334" title="All 4 branches missed.">            if (countTargets &gt; 1 &amp;&amp; attacker.getCrew().getSize() == 1) {</span>
<span class="nc" id="L2335">                return new ToHitData(TargetRoll.IMPOSSIBLE,</span>
                        &quot;Vehicles with only 1 crewman may not attack &quot;
                                + &quot;secondary targets&quot;);
            }
            // If we are a tank, we can have Crew Size - 1 targets before
            //  incurring a secondary target penalty (or crew size - 2 secondary
            //  targets without penalty)
<span class="nc" id="L2342">            maxPrimary =  attacker.getCrew().getSize() - 1;</span>
        }
<span class="nc bnc" id="L2344" title="All 2 branches missed.">        if (countTargets &lt;= maxPrimary) {</span>
<span class="nc" id="L2345">            return null; // no modifier</span>
        }

<span class="nc bnc" id="L2348" title="All 2 branches missed.">        if ((primaryTarget == Entity.NONE)</span>
<span class="nc bnc" id="L2349" title="All 2 branches missed.">            || (primaryTarget == target.getTargetId())) {</span>
            // current target is primary target
<span class="nc" id="L2351">            return null; // no modifier</span>
        }

        // current target is secondary

        // Stealthed Mechs can't be secondary targets (TW, pg. 142)
<span class="nc bnc" id="L2357" title="All 6 branches missed.">        if (((target instanceof Tank) || (target instanceof Mech) || (target instanceof Aero))</span>
<span class="nc bnc" id="L2358" title="All 2 branches missed.">            &amp;&amp; ((Entity) target).isStealthActive()) {</span>
<span class="nc" id="L2359">            return new ToHitData(TargetRoll.IMPOSSIBLE,</span>
                                 &quot;Can't target unit with active stealth armor as &quot; +
                                 &quot;secondary target&quot;);
        }

<span class="nc" id="L2364">        int mod = 2;</span>
<span class="nc bnc" id="L2365" title="All 4 branches missed.">        if (curInFrontArc || (attacker instanceof BattleArmor)) {</span>
<span class="nc" id="L2366">            mod--;</span>
        }
<span class="nc bnc" id="L2368" title="All 2 branches missed.">        if (attacker.hasAbility(OptionsConstants.GUNNERY_MULTI_TASKER)) {</span>
<span class="nc" id="L2369">            mod--;</span>
        }
<span class="nc" id="L2371">        return new ToHitData(mod, &quot;secondary target modifier&quot;);</span>
    }

    /**
     * Damage that a mech does with a accidental fall from above.
     */

    public static int getAffaDamageFor(Entity entity) {
<span class="nc" id="L2379">        return (int) entity.getWeight() / 10;</span>
    }

    /**
     * Modifier to attacks due to attacker movement
     */
    public static ToHitData getAttackerMovementModifier(IGame game, int entityId) {
<span class="nc" id="L2386">        return Compute.getAttackerMovementModifier(game, entityId,</span>
<span class="nc" id="L2387">                                                   game.getEntity(entityId).moved);</span>
    }

    /**
     * Modifier to attacks due to attacker movement
     */
    public static ToHitData getAttackerMovementModifier(IGame game,
            int entityId, EntityMovementType movement) {
<span class="nc" id="L2395">        final Entity entity = game.getEntity(entityId);</span>
<span class="nc" id="L2396">        ToHitData toHit = new ToHitData();</span>

        // infantry aren't affected by their own movement.
<span class="nc bnc" id="L2399" title="All 2 branches missed.">        if (entity instanceof Infantry) {</span>
<span class="nc" id="L2400">            return toHit;</span>
        }

<span class="nc bnc" id="L2403" title="All 2 branches missed.">        if ((entity.getMovementMode() == EntityMovementMode.BIPED_SWIM)</span>
<span class="nc bnc" id="L2404" title="All 2 branches missed.">            || (entity.getMovementMode() == EntityMovementMode.QUAD_SWIM)) {</span>
<span class="nc" id="L2405">            toHit.addModifier(3, &quot;attacker used UMUs&quot;);</span>
<span class="nc bnc" id="L2406" title="All 4 branches missed.">        } else if (entity instanceof LandAirMech &amp;&amp; movement == EntityMovementType.MOVE_VTOL_WALK) {</span>
<span class="nc" id="L2407">            toHit.addModifier(3, &quot;attacker cruised&quot;);</span>
<span class="nc bnc" id="L2408" title="All 4 branches missed.">        } else if (entity instanceof LandAirMech &amp;&amp; movement == EntityMovementType.MOVE_VTOL_RUN) {</span>
<span class="nc" id="L2409">            toHit.addModifier(4, &quot;attacker flanked&quot;);</span>
<span class="nc bnc" id="L2410" title="All 6 branches missed.">        } else if ((movement == EntityMovementType.MOVE_WALK) || (movement == EntityMovementType.MOVE_VTOL_WALK)</span>
                || (movement == EntityMovementType.MOVE_CAREFUL_STAND)) {
<span class="nc" id="L2412">            toHit.addModifier(1, &quot;attacker walked&quot;);</span>
<span class="nc bnc" id="L2413" title="All 4 branches missed.">        } else if ((movement == EntityMovementType.MOVE_RUN) || (movement == EntityMovementType.MOVE_VTOL_RUN)) {</span>
<span class="nc" id="L2414">            toHit.addModifier(2, &quot;attacker ran&quot;);</span>
<span class="nc bnc" id="L2415" title="All 2 branches missed.">        } else if (movement == EntityMovementType.MOVE_SKID) {</span>
<span class="nc" id="L2416">            toHit.addModifier(3, &quot;attacker ran and skidded&quot;);</span>
<span class="nc bnc" id="L2417" title="All 2 branches missed.">        } else if (movement == EntityMovementType.MOVE_JUMP) {</span>
<span class="nc bnc" id="L2418" title="All 2 branches missed.">            if (entity.hasAbility(OptionsConstants.PILOT_JUMPING_JACK)) {</span>
<span class="nc" id="L2419">                toHit.addModifier(1, &quot;attacker jumped&quot;);</span>
<span class="nc bnc" id="L2420" title="All 2 branches missed.">            } else if (entity.hasAbility(OptionsConstants.PILOT_HOPPING_JACK)) {</span>
<span class="nc" id="L2421">                toHit.addModifier(2, &quot;attacker jumped&quot;);</span>
            } else {
<span class="nc" id="L2423">                toHit.addModifier(3, &quot;attacker jumped&quot;);</span>
            }
<span class="nc bnc" id="L2425" title="All 4 branches missed.">        } else if (movement == EntityMovementType.MOVE_SPRINT</span>
                || movement == EntityMovementType.MOVE_VTOL_SPRINT) {
<span class="nc" id="L2427">            return new ToHitData(TargetRoll.AUTOMATIC_FAIL, &quot;attacker sprinted&quot;);</span>
        }

        //Dual cockpit with both pilot and gunner has lower modifier for attacker movement.
<span class="nc bnc" id="L2431" title="All 4 branches missed.">        if (toHit.getValue() != TargetRoll.AUTOMATIC_FAIL</span>
<span class="nc bnc" id="L2432" title="All 2 branches missed.">                &amp;&amp; entity instanceof Mech &amp;&amp; ((Mech)entity).getCockpitType() == Mech.COCKPIT_DUAL</span>
<span class="nc bnc" id="L2433" title="All 2 branches missed.">                &amp;&amp; entity.getCrew().hasDedicatedGunner()) {</span>
<span class="nc bnc" id="L2434" title="All 2 branches missed.">            for (TargetRollModifier mod : toHit.getModifiers()) {</span>
<span class="nc" id="L2435">                mod.setValue(mod.getValue() / 2);</span>
<span class="nc" id="L2436">            }</span>
        }
<span class="nc" id="L2438">        return toHit;</span>
    }

    /**
     * Modifier to attacks due to spotter movement
     */
    public static ToHitData getSpotterMovementModifier(IGame game, int entityId) {
<span class="nc" id="L2445">        return Compute.getSpotterMovementModifier(game, entityId,</span>
<span class="nc" id="L2446">                                                  game.getEntity(entityId).moved);</span>
    }

    /**
     * Modifier to attacks due to spotter movement
     */
    public static ToHitData getSpotterMovementModifier(IGame game,
                                                       int entityId, EntityMovementType movement) {
<span class="nc" id="L2454">        ToHitData toHit = new ToHitData();</span>

<span class="nc" id="L2456">        Entity e = game.getEntity(entityId);</span>
<span class="nc bnc" id="L2457" title="All 4 branches missed.">        if ((e != null) &amp;&amp; (e instanceof Infantry)) {</span>
<span class="nc" id="L2458">            return toHit;</span>
        }

<span class="nc bnc" id="L2461" title="All 4 branches missed.">        if ((movement == EntityMovementType.MOVE_WALK)</span>
            || (movement == EntityMovementType.MOVE_VTOL_WALK)) {
<span class="nc" id="L2463">            toHit.addModifier(1, &quot;spotter walked&quot;);</span>
<span class="nc bnc" id="L2464" title="All 6 branches missed.">        } else if ((movement == EntityMovementType.MOVE_RUN)</span>
                   || (movement == EntityMovementType.MOVE_VTOL_RUN)
                   || (movement == EntityMovementType.MOVE_SKID)) {
<span class="nc" id="L2467">            toHit.addModifier(2, &quot;spotter ran&quot;);</span>
<span class="nc bnc" id="L2468" title="All 2 branches missed.">        } else if (movement == EntityMovementType.MOVE_JUMP) {</span>
<span class="nc" id="L2469">            toHit.addModifier(3, &quot;spotter jumped&quot;);</span>
<span class="nc bnc" id="L2470" title="All 4 branches missed.">        } else if (movement == EntityMovementType.MOVE_SPRINT</span>
                || movement == EntityMovementType.MOVE_VTOL_SPRINT) {
<span class="nc" id="L2472">            return new ToHitData(TargetRoll.IMPOSSIBLE, &quot;spotter sprinted&quot;);</span>
        }

<span class="nc" id="L2475">        return toHit;</span>
    }

    /**
     * Modifier to physical attack BTH due to pilot advantages
     */
    public static void modifyPhysicalBTHForAdvantages(final Entity attacker, final Entity target,
                                                      final ToHitData toHit, final IGame game) {
<span class="nc" id="L2483">        Objects.requireNonNull(attacker);</span>

<span class="nc bnc" id="L2485" title="All 4 branches missed.">        if (attacker.hasAbility(OptionsConstants.PILOT_MELEE_SPECIALIST)</span>
                &amp;&amp; (attacker instanceof Mech)) {
<span class="nc" id="L2487">            toHit.addModifier(-1, &quot;melee specialist&quot;);</span>
        }

<span class="nc bnc" id="L2490" title="All 6 branches missed.">        if (attacker.hasAbility(OptionsConstants.PILOT_TM_FROGMAN)</span>
                &amp;&amp; ((attacker instanceof Mech) || (attacker instanceof Protomech))
<span class="nc bnc" id="L2492" title="All 2 branches missed.">                &amp;&amp; (game.getBoard().getHex(attacker.getPosition()).terrainLevel(Terrains.WATER) &gt; 1)) {</span>
<span class="nc" id="L2493">            toHit.addModifier(-1, &quot;Frogman&quot;);</span>
        }

<span class="nc bnc" id="L2496" title="All 2 branches missed.">        if (attacker.hasAbility(OptionsConstants.UNOFF_CLAN_PILOT_TRAINING)) {</span>
<span class="nc" id="L2497">            toHit.addModifier(1, &quot;clan pilot training&quot;);</span>
        }

        // Mek targets that are dodging are harder to hit.
<span class="nc bnc" id="L2501" title="All 2 branches missed.">        if ((target instanceof Mech)</span>
<span class="nc bnc" id="L2502" title="All 4 branches missed.">                &amp;&amp; target.hasAbility(OptionsConstants.PILOT_DODGE_MANEUVER) &amp;&amp; target.dodging) {</span>
<span class="nc" id="L2503">            toHit.addModifier(2, &quot;target is dodging&quot;);</span>
        }
<span class="nc" id="L2505">    }</span>

    /**
     * Modifier to attacks due to target movement
     */
    public static ToHitData getTargetMovementModifier(IGame game, int entityId) {
<span class="nc" id="L2511">        Entity entity = game.getEntity(entityId);</span>

<span class="nc bnc" id="L2513" title="All 2 branches missed.">        if (entity.isAero()) {</span>
<span class="nc" id="L2514">            return new ToHitData();</span>
        }

        //If we're a trailer and being towed, return data for the tractor
<span class="nc bnc" id="L2518" title="All 4 branches missed.">        if (entity.isTrailer() &amp;&amp; entity.getTractor() != Entity.NONE) {</span>
<span class="nc" id="L2519">            return getTargetMovementModifier(game, entity.getTractor());</span>
        }

<span class="nc bnc" id="L2522" title="All 4 branches missed.">        if (game.getOptions().booleanOption(OptionsConstants.ADVGRNDMOV_TACOPS_STANDING_STILL)</span>
            &amp;&amp; (entity.mpUsed == 0)
<span class="nc bnc" id="L2524" title="All 8 branches missed.">            &amp;&amp; !entity.isImmobile()</span>
            &amp;&amp; !((entity instanceof Infantry) || (entity instanceof VTOL) || (entity instanceof GunEmplacement))) {
<span class="nc" id="L2526">            ToHitData toHit = new ToHitData();</span>
<span class="nc" id="L2527">            toHit.addModifier(-1, &quot;target didn't move&quot;);</span>
<span class="nc" id="L2528">            return toHit;</span>
        }

<span class="nc bnc" id="L2531" title="All 2 branches missed.">        if (entity.isAssaultDropInProgress()) {</span>
<span class="nc" id="L2532">            ToHitData toHit = new ToHitData();</span>
<span class="nc" id="L2533">            toHit.addModifier(3, &quot;target is assault dropping&quot;);</span>
<span class="nc" id="L2534">            return toHit;</span>
        }

<span class="nc" id="L2537">        ToHitData toHit = Compute</span>
<span class="nc" id="L2538">                .getTargetMovementModifier(</span>
                        entity.delta_distance,
<span class="nc bnc" id="L2540" title="All 14 branches missed.">                        (entity.getMovementMode() != EntityMovementMode.WIGE)</span>
                        &amp;&amp; ((entity.moved == EntityMovementType.MOVE_JUMP)
                                || (entity.moved == EntityMovementType.MOVE_VTOL_RUN)
                                || (entity.moved == EntityMovementType.MOVE_VTOL_WALK)
                                || (entity.moved == EntityMovementType.MOVE_VTOL_SPRINT)),

                        (entity.moved == EntityMovementType.MOVE_VTOL_RUN)
                        || (entity.moved == EntityMovementType.MOVE_VTOL_WALK)
<span class="nc bnc" id="L2548" title="All 4 branches missed.">                        || (entity.getMovementMode() == EntityMovementMode.VTOL)</span>
                        || (entity.moved == EntityMovementType.MOVE_VTOL_SPRINT),
                        game);
<span class="nc bnc" id="L2551" title="All 6 branches missed.">        if (entity.moved != EntityMovementType.MOVE_JUMP</span>
                &amp;&amp; entity.delta_distance &gt; 0
<span class="nc bnc" id="L2553" title="All 2 branches missed.">                &amp;&amp; entity instanceof Mech &amp;&amp; ((Mech)entity).getCockpitType() == Mech.COCKPIT_DUAL</span>
<span class="nc bnc" id="L2554" title="All 2 branches missed.">                &amp;&amp; entity.getCrew().hasDedicatedPilot()) {</span>
<span class="nc bnc" id="L2555" title="All 2 branches missed.">            if (toHit.getModifiers().isEmpty()) {</span>
<span class="nc" id="L2556">                toHit.addModifier(1, &quot;target moved 1-2 hexes&quot;);</span>
            } else {
<span class="nc" id="L2558">                toHit.getModifiers().get(0).setValue(toHit.getModifiers().get(0).getValue() + 1);</span>
            }
        }

        // Did the target skid this turn?
<span class="nc bnc" id="L2563" title="All 2 branches missed.">        if (entity.moved == EntityMovementType.MOVE_SKID) {</span>
<span class="nc" id="L2564">            toHit.addModifier(2, &quot;target skidded&quot;);</span>
        }
<span class="nc bnc" id="L2566" title="All 2 branches missed.">        if ((entity.getElevation() &gt; 0)</span>
<span class="nc bnc" id="L2567" title="All 2 branches missed.">            &amp;&amp; (entity.getMovementMode() == EntityMovementMode.WIGE)) {</span>
<span class="nc" id="L2568">                toHit.addModifier(1, &quot;target is airborne&quot;);</span>
        }

        // did the target sprint?
<span class="nc bnc" id="L2572" title="All 4 branches missed.">        if (entity.moved == EntityMovementType.MOVE_SPRINT</span>
                || entity.moved == EntityMovementType.MOVE_VTOL_SPRINT) {
<span class="nc" id="L2574">            toHit.addModifier(-1, &quot;target sprinted&quot;);</span>
        }

<span class="nc" id="L2577">        return toHit;</span>
    }

    /**
     * Target movement modifer for the specified delta_distance
     */
    public static ToHitData getTargetMovementModifier(int distance,
            boolean jumped, boolean isVTOL, IGame game) {
<span class="nc" id="L2585">        ToHitData toHit = new ToHitData();</span>
<span class="nc bnc" id="L2586" title="All 4 branches missed.">        if (distance == 0 &amp;&amp; !jumped) {</span>
<span class="nc" id="L2587">            return toHit;</span>
        }

<span class="nc bnc" id="L2590" title="All 2 branches missed.">        if ((game != null)</span>
<span class="nc bnc" id="L2591" title="All 2 branches missed.">            &amp;&amp; game.getOptions().booleanOption(OptionsConstants.ADVANCED_MAXTECH_MOVEMENT_MODS)) {</span>
<span class="nc bnc" id="L2592" title="All 4 branches missed.">            if ((distance &gt;= 3) &amp;&amp; (distance &lt;= 4)) {</span>
<span class="nc" id="L2593">                toHit.addModifier(1, &quot;target moved 3-4 hexes&quot;);</span>
<span class="nc bnc" id="L2594" title="All 4 branches missed.">            } else if ((distance &gt;= 5) &amp;&amp; (distance &lt;= 6)) {</span>
<span class="nc" id="L2595">                toHit.addModifier(2, &quot;target moved 5-6 hexes&quot;);</span>
<span class="nc bnc" id="L2596" title="All 4 branches missed.">            } else if ((distance &gt;= 7) &amp;&amp; (distance &lt;= 9)) {</span>
<span class="nc" id="L2597">                toHit.addModifier(3, &quot;target moved 7-9 hexes&quot;);</span>
<span class="nc bnc" id="L2598" title="All 4 branches missed.">            } else if ((distance &gt;= 10) &amp;&amp; (distance &lt;= 13)) {</span>
<span class="nc" id="L2599">                toHit.addModifier(4, &quot;target moved 10-13 hexes&quot;);</span>
<span class="nc bnc" id="L2600" title="All 4 branches missed.">            } else if ((distance &gt;= 14) &amp;&amp; (distance &lt;= 18)) {</span>
<span class="nc" id="L2601">                toHit.addModifier(5, &quot;target moved 18-24 hexes&quot;);</span>
<span class="nc bnc" id="L2602" title="All 4 branches missed.">            } else if ((distance &gt;= 19) &amp;&amp; (distance &lt;= 24)) {</span>
<span class="nc" id="L2603">                toHit.addModifier(6, &quot;target moved 18-24 hexes&quot;);</span>
<span class="nc bnc" id="L2604" title="All 2 branches missed.">            } else if (distance &gt;= 25) {</span>
<span class="nc" id="L2605">                toHit.addModifier(7, &quot;target moved 25+ hexes&quot;);</span>
            }
        } else {
<span class="nc bnc" id="L2608" title="All 4 branches missed.">            if ((distance &gt;= 3) &amp;&amp; (distance &lt;= 4)) {</span>
<span class="nc" id="L2609">                toHit.addModifier(1, &quot;target moved 3-4 hexes&quot;);</span>
<span class="nc bnc" id="L2610" title="All 4 branches missed.">            } else if ((distance &gt;= 5) &amp;&amp; (distance &lt;= 6)) {</span>
<span class="nc" id="L2611">                toHit.addModifier(2, &quot;target moved 5-6 hexes&quot;);</span>
<span class="nc bnc" id="L2612" title="All 4 branches missed.">            } else if ((distance &gt;= 7) &amp;&amp; (distance &lt;= 9)) {</span>
<span class="nc" id="L2613">                toHit.addModifier(3, &quot;target moved 7-9 hexes&quot;);</span>
<span class="nc bnc" id="L2614" title="All 4 branches missed.">            } else if ((distance &gt;= 10) &amp;&amp; (distance &lt;= 17)) {</span>
<span class="nc" id="L2615">                toHit.addModifier(4, &quot;target moved 10-17 hexes&quot;);</span>
<span class="nc bnc" id="L2616" title="All 4 branches missed.">            } else if ((distance &gt;= 18) &amp;&amp; (distance &lt;= 24)) {</span>
<span class="nc" id="L2617">                toHit.addModifier(5, &quot;target moved 18-24 hexes&quot;);</span>
<span class="nc bnc" id="L2618" title="All 2 branches missed.">            } else if (distance &gt;= 25) {</span>
<span class="nc" id="L2619">                toHit.addModifier(6, &quot;target moved 25+ hexes&quot;);</span>
            }
        }

<span class="nc bnc" id="L2623" title="All 2 branches missed.">        if (jumped) {</span>
<span class="nc bnc" id="L2624" title="All 4 branches missed.">            if (isVTOL &amp;&amp; (distance &gt; 0)) {</span>
<span class="nc" id="L2625">                toHit.addModifier(1, &quot;target VTOL used MPs&quot;);</span>
            } else {
<span class="nc" id="L2627">                toHit.addModifier(1, &quot;target jumped&quot;);</span>
            }
        }

<span class="nc" id="L2631">        return toHit;</span>
    }

    /**
     * Modifier to attacks due to attacker terrain
     */
    public static ToHitData getAttackerTerrainModifier(IGame game, int entityId) {
<span class="nc" id="L2638">        final Entity attacker = game.getEntity(entityId);</span>
<span class="nc" id="L2639">        final IHex hex = game.getBoard().getHex(attacker.getPosition());</span>

<span class="nc" id="L2641">        ToHitData toHit = new ToHitData();</span>

        // space screens; bonus depends on number (level)
<span class="nc bnc" id="L2644" title="All 4 branches missed.">        if ((hex != null) &amp;&amp; (hex.terrainLevel(Terrains.SCREEN) &gt; 0)) {</span>
<span class="nc" id="L2645">            toHit.addModifier(hex.terrainLevel(Terrains.SCREEN) + 1,</span>
                              &quot;attacker in screen(s)&quot;);
        }

<span class="nc" id="L2649">        return toHit;</span>
    }

    /**
     * Modifier to attacks due to target terrain TODO:um....should VTOLs get
     * modifiers for smoke, etc.
     */
    public static ToHitData getTargetTerrainModifier(IGame game, Targetable t) {
<span class="nc" id="L2657">        return Compute.getTargetTerrainModifier(game, t, 0);</span>
    }

    public static ToHitData getTargetTerrainModifier(IGame game, Targetable t,
                                                     int eistatus) {
<span class="nc" id="L2662">        return Compute.getTargetTerrainModifier(game, t, eistatus, false);</span>
    }

    public static ToHitData getTargetTerrainModifier(IGame game, Targetable t,
                                                     int eistatus, boolean attackerInSameBuilding) {
<span class="nc" id="L2667">        return Compute.getTargetTerrainModifier(game, t, eistatus,</span>
                                                attackerInSameBuilding, false);
    }

    public static ToHitData getTargetTerrainModifier(IGame game, Targetable t,
                                                     int eistatus, boolean attackerInSameBuilding,
                                                     boolean underwaterWeapon) {
<span class="nc" id="L2674">        ToHitData toHit = new ToHitData();</span>

        // no terrain mods for bombs, artillery strikes
<span class="nc bnc" id="L2677" title="All 2 branches missed.">        if (t.getTargetType() == Targetable.TYPE_HEX_AERO_BOMB ||</span>
<span class="nc bnc" id="L2678" title="All 2 branches missed.">                t.getTargetType() == Targetable.TYPE_HEX_ARTILLERY) {</span>
<span class="nc" id="L2679">            return toHit;</span>
        }
        
<span class="nc" id="L2682">        Entity entityTarget = null;</span>
<span class="nc" id="L2683">        IHex hex = game.getBoard().getHex(t.getPosition());</span>
<span class="nc bnc" id="L2684" title="All 2 branches missed.">        if (t.getTargetType() == Targetable.TYPE_ENTITY) {</span>
<span class="nc" id="L2685">            entityTarget = (Entity) t;</span>
<span class="nc bnc" id="L2686" title="All 2 branches missed.">            if (hex == null) {</span>
<span class="nc" id="L2687">                entityTarget.setPosition(game.getEntity(entityTarget.getId())</span>
<span class="nc" id="L2688">                                             .getPosition());</span>
<span class="nc" id="L2689">                hex = game.getBoard().getHex(</span>
<span class="nc" id="L2690">                        game.getEntity(entityTarget.getId()).getPosition());</span>
            }
        }
        
        // if the hex doesn't exist, it's unlikely to have terrain modifiers
<span class="nc bnc" id="L2695" title="All 2 branches missed.">        if (hex == null) {</span>
<span class="nc" id="L2696">            return toHit;</span>
        }


<span class="nc bnc" id="L2700" title="All 4 branches missed.">        boolean hasWoods = hex.containsTerrain(Terrains.WOODS) || hex.containsTerrain(Terrains.JUNGLE);</span>
        // Standard mechs (standing) report their height as 1, tanks as 0
        // Standard mechs should not benefit from 1 level high woods
        
<span class="nc bnc" id="L2704" title="All 2 branches missed.">        boolean isAboveWoods = (entityTarget == null) </span>
<span class="nc bnc" id="L2705" title="All 2 branches missed.">                || (entityTarget.relHeight() + 1 &gt; hex.terrainLevel(Terrains.FOLIAGE_ELEV)) </span>
<span class="nc bnc" id="L2706" title="All 4 branches missed.">                || entityTarget.isAirborne() </span>
                || !hasWoods;
<span class="nc bnc" id="L2708" title="All 2 branches missed.">        boolean isAboveSmoke = (entityTarget == null)</span>
<span class="nc bnc" id="L2709" title="All 2 branches missed.">                || (entityTarget.relHeight() + 1 &gt; 2) </span>
<span class="nc bnc" id="L2710" title="All 2 branches missed.">                || !hex.containsTerrain(Terrains.SMOKE);</span>
<span class="nc bnc" id="L2711" title="All 2 branches missed.">        boolean isUnderwater = (entityTarget != null)</span>
<span class="nc bnc" id="L2712" title="All 4 branches missed.">                               &amp;&amp; hex.containsTerrain(Terrains.WATER) &amp;&amp; (hex.depth() &gt; 0)</span>
<span class="nc bnc" id="L2713" title="All 2 branches missed.">                               &amp;&amp; (entityTarget.getElevation() &lt; hex.surface());</span>

        // if we have in-building combat, it's a +1
<span class="nc bnc" id="L2716" title="All 2 branches missed.">        if (attackerInSameBuilding) {</span>
<span class="nc" id="L2717">            toHit.addModifier(1, &quot;target in a building hex&quot;);</span>
        }

        // Smoke and woods. With L3, the effects STACK.
<span class="nc" id="L2721">        int woodsLevel = hex.terrainLevel(Terrains.WOODS);</span>
<span class="nc" id="L2722">        int jungleLevel = hex.terrainLevel(Terrains.JUNGLE);</span>
<span class="nc" id="L2723">        String woodsText = &quot;woods&quot;;</span>
<span class="nc bnc" id="L2724" title="All 2 branches missed.">        if (woodsLevel &lt; jungleLevel) {</span>
<span class="nc" id="L2725">            woodsLevel = jungleLevel;</span>
<span class="nc" id="L2726">            woodsText = &quot;jungle&quot;;</span>
        }
<span class="nc bnc" id="L2728" title="All 2 branches missed.">        if (woodsLevel == 1) {</span>
<span class="nc" id="L2729">            woodsText = &quot;target in light &quot; + woodsText;</span>
<span class="nc bnc" id="L2730" title="All 2 branches missed.">        } else if (woodsLevel == 2) {</span>
<span class="nc" id="L2731">            woodsText = &quot;target in heavy &quot; + woodsText;</span>
<span class="nc bnc" id="L2732" title="All 2 branches missed.">        } else if (woodsLevel == 3) {</span>
<span class="nc" id="L2733">            woodsText = &quot;target in ultra heavy &quot; + woodsText;</span>
        }

<span class="nc bnc" id="L2736" title="All 4 branches missed.">        if (!game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_WOODS_COVER)</span>
            &amp;&amp; !isAboveWoods
<span class="nc bnc" id="L2738" title="All 2 branches missed.">            &amp;&amp; !((t.getTargetType() == Targetable.TYPE_HEX_CLEAR)</span>
<span class="nc bnc" id="L2739" title="All 2 branches missed.">                 || (t.getTargetType() == Targetable.TYPE_HEX_IGNITE)</span>
<span class="nc bnc" id="L2740" title="All 2 branches missed.">                 || (t.getTargetType() == Targetable.TYPE_HEX_BOMB)</span>
<span class="nc bnc" id="L2741" title="All 2 branches missed.">                 || (t.getTargetType() == Targetable.TYPE_HEX_ARTILLERY)</span>
<span class="nc bnc" id="L2742" title="All 2 branches missed.">                 || (t.getTargetType() == Targetable.TYPE_MINEFIELD_DELIVER))) {</span>
<span class="nc bnc" id="L2743" title="All 4 branches missed.">            if ((woodsLevel == 1) &amp;&amp; (eistatus != 2)) {</span>
<span class="nc" id="L2744">                toHit.addModifier(1, woodsText);</span>
<span class="nc bnc" id="L2745" title="All 2 branches missed.">            } else if (woodsLevel &gt; 1) {</span>
<span class="nc bnc" id="L2746" title="All 2 branches missed.">                if (eistatus &gt; 0) {</span>
<span class="nc" id="L2747">                    toHit.addModifier(woodsLevel - 1, woodsText);</span>
                } else {
<span class="nc" id="L2749">                    toHit.addModifier(woodsLevel, woodsText);</span>
                }
            }
        }
<span class="nc bnc" id="L2753" title="All 6 branches missed.">        if (!isAboveSmoke &amp;&amp; !isUnderwater &amp;&amp; !underwaterWeapon) {</span>
<span class="nc bnc" id="L2754" title="All 2 branches missed.">            if ((hex.terrainLevel(Terrains.SMOKE) == SmokeCloud.SMOKE_LIGHT)</span>
<span class="nc bnc" id="L2755" title="All 2 branches missed.">                || (hex.terrainLevel(Terrains.SMOKE) == SmokeCloud.SMOKE_LI_LIGHT)</span>
<span class="nc bnc" id="L2756" title="All 2 branches missed.">                || (hex.terrainLevel(Terrains.SMOKE) == SmokeCloud.SMOKE_LI_HEAVY)</span>
<span class="nc bnc" id="L2757" title="All 2 branches missed.">                || (hex.terrainLevel(Terrains.SMOKE) == SmokeCloud.SMOKE_CHAFF_LIGHT)) {</span>
<span class="nc" id="L2758">                toHit.addModifier(1, &quot;target in light smoke&quot;);</span>
<span class="nc bnc" id="L2759" title="All 2 branches missed.">            } else if (hex.terrainLevel(Terrains.SMOKE) == SmokeCloud.SMOKE_HEAVY) {</span>
<span class="nc bnc" id="L2760" title="All 2 branches missed.">                if (eistatus &gt; 0) {</span>
<span class="nc" id="L2761">                    toHit.addModifier(1, &quot;target in heavy smoke&quot;);</span>
                } else {
<span class="nc" id="L2763">                    toHit.addModifier(2, &quot;target in heavy smoke&quot;);</span>
                }
            }
        }
<span class="nc bnc" id="L2767" title="All 2 branches missed.">        if (hex.terrainLevel(Terrains.GEYSER) == 2) {</span>
<span class="nc bnc" id="L2768" title="All 2 branches missed.">            if (eistatus &gt; 0) {</span>
<span class="nc" id="L2769">                toHit.addModifier(1, &quot;target in erupting geyser&quot;);</span>
            } else {
<span class="nc" id="L2771">                toHit.addModifier(2, &quot;target in erupting geyser&quot;);</span>
            }
        }

<span class="nc bnc" id="L2775" title="All 2 branches missed.">        if (hex.containsTerrain(Terrains.INDUSTRIAL)) {</span>
<span class="nc" id="L2776">            toHit.addModifier(+1, &quot;target in heavy industrial zone&quot;);</span>
        }
        // space screens; bonus depends on number (level)
<span class="nc bnc" id="L2779" title="All 2 branches missed.">        if (hex.terrainLevel(Terrains.SCREEN) &gt; 0) {</span>
<span class="nc" id="L2780">            toHit.addModifier(hex.terrainLevel(Terrains.SCREEN) + 1,</span>
                              &quot;target in screen(s)&quot;);
        }

        // only entities get remaining terrain bonuses
        // TODO: should this be changed for buildings???
<span class="nc bnc" id="L2786" title="All 2 branches missed.">        if (entityTarget == null) {</span>
<span class="nc" id="L2787">            return toHit;</span>
<span class="nc bnc" id="L2788" title="All 2 branches missed.">        } else if (entityTarget.isMakingDfa()) {</span>
            // you don't get terrain modifiers in midair
            // should be abstracted more into a 'not on the ground'
            // flag for vtols and such
<span class="nc" id="L2792">            return toHit;</span>
        }

<span class="nc bnc" id="L2795" title="All 2 branches missed.">        if (entityTarget.isStuck()) {</span>
<span class="nc" id="L2796">            toHit.addModifier(-2, &quot;target stuck in swamp&quot;);</span>
        }
<span class="nc bnc" id="L2798" title="All 2 branches missed.">        if ((entityTarget instanceof Infantry)</span>
<span class="nc bnc" id="L2799" title="All 2 branches missed.">            &amp;&amp; hex.containsTerrain(Terrains.FIELDS)) {</span>
<span class="nc" id="L2800">            toHit.addModifier(+1, &quot;target in planted fields&quot;);</span>
        }
<span class="nc" id="L2802">        return toHit;</span>
    }

    public static ToHitData getStrafingTerrainModifier(IGame game,
                                                       int eistatus, IHex hex) {
<span class="nc" id="L2807">        ToHitData toHit = new ToHitData();</span>
        // Smoke and woods. With L3, the effects STACK.
<span class="nc" id="L2809">        int woodsLevel = hex.terrainLevel(Terrains.WOODS);</span>
<span class="nc" id="L2810">        int jungleLevel = hex.terrainLevel(Terrains.JUNGLE);</span>
<span class="nc" id="L2811">        String woodsText = &quot;woods&quot;;</span>
<span class="nc bnc" id="L2812" title="All 2 branches missed.">        if (woodsLevel &lt; jungleLevel) {</span>
<span class="nc" id="L2813">            woodsLevel = jungleLevel;</span>
<span class="nc" id="L2814">            woodsText = &quot;jungle&quot;;</span>
        }
<span class="nc bnc" id="L2816" title="All 2 branches missed.">        if (woodsLevel == 1) {</span>
<span class="nc" id="L2817">            woodsText = &quot;light &quot; + woodsText;</span>
<span class="nc bnc" id="L2818" title="All 2 branches missed.">        } else if (woodsLevel == 2) {</span>
<span class="nc" id="L2819">            woodsText = &quot;heavy &quot; + woodsText;</span>
<span class="nc bnc" id="L2820" title="All 2 branches missed.">        } else if (woodsLevel == 3) {</span>
<span class="nc" id="L2821">            woodsText = &quot;heavy &quot; + woodsText;</span>
        }

<span class="nc bnc" id="L2824" title="All 2 branches missed.">        if (!game.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_WOODS_COVER)) {</span>
<span class="nc bnc" id="L2825" title="All 4 branches missed.">            if ((woodsLevel == 1) &amp;&amp; (eistatus != 2)) {</span>
<span class="nc" id="L2826">                toHit.addModifier(1, woodsText);</span>
<span class="nc bnc" id="L2827" title="All 2 branches missed.">            } else if (woodsLevel &gt; 1) {</span>
<span class="nc bnc" id="L2828" title="All 2 branches missed.">                if (eistatus &gt; 0) {</span>
<span class="nc" id="L2829">                    toHit.addModifier(woodsLevel - 1, woodsText);</span>
                } else {
<span class="nc" id="L2831">                    toHit.addModifier(woodsLevel, woodsText);</span>
                }
            }
        }

<span class="nc bnc" id="L2836" title="All 2 branches missed.">        if ((hex.terrainLevel(Terrains.SMOKE) == SmokeCloud.SMOKE_LIGHT)</span>
<span class="nc bnc" id="L2837" title="All 2 branches missed.">            || (hex.terrainLevel(Terrains.SMOKE) == SmokeCloud.SMOKE_LI_LIGHT)</span>
<span class="nc bnc" id="L2838" title="All 2 branches missed.">            || (hex.terrainLevel(Terrains.SMOKE) == SmokeCloud.SMOKE_LI_HEAVY)</span>
<span class="nc bnc" id="L2839" title="All 2 branches missed.">            || (hex.terrainLevel(Terrains.SMOKE) == SmokeCloud.SMOKE_CHAFF_LIGHT)) {</span>
<span class="nc" id="L2840">            toHit.addModifier(1, &quot;light smoke&quot;);</span>
<span class="nc bnc" id="L2841" title="All 2 branches missed.">        } else if (hex.terrainLevel(Terrains.SMOKE) == SmokeCloud.SMOKE_HEAVY) {</span>
<span class="nc bnc" id="L2842" title="All 2 branches missed.">            if (eistatus &gt; 0) {</span>
<span class="nc" id="L2843">                toHit.addModifier(1, &quot;heavy smoke&quot;);</span>
            } else {
<span class="nc" id="L2845">                toHit.addModifier(2, &quot;heavy smoke&quot;);</span>
            }
        }

<span class="nc bnc" id="L2849" title="All 2 branches missed.">        if (hex.terrainLevel(Terrains.GEYSER) == 2) {</span>
<span class="nc bnc" id="L2850" title="All 2 branches missed.">            if (eistatus &gt; 0) {</span>
<span class="nc" id="L2851">                toHit.addModifier(1, &quot;erupting geyser&quot;);</span>
            } else {
<span class="nc" id="L2853">                toHit.addModifier(2, &quot;erupting geyser&quot;);</span>
            }
        }
<span class="nc" id="L2856">        return toHit;</span>
    }

    /**
     * Calculates the current theoretical damage absorbable(armor+structure, etc) by the given target.
     * Used as a measure of the potential durability of the target under fire.
     */
    public static int getTargetTotalHP(IGame game, Targetable target) {
<span class="nc" id="L2864">        int targetType = target.getTargetType();</span>
<span class="nc" id="L2865">        int targetId = target.getTargetId();</span>
<span class="nc" id="L2866">        Coords position = target.getPosition();</span>

        //First, handle buildings versus entities, since they are handled differently.
<span class="nc bnc" id="L2869" title="All 2 branches missed.">        if(targetType == Targetable.TYPE_BUILDING) {</span>
            //Buildings are a simple sum of their current CF and armor values.
<span class="nc" id="L2871">            Building parentBuilding = game.getBoard().getBuildingAt(position); //the building the targeted hex belongs to. We have to get this and then get values for the specific hex internally to it.</span>
<span class="nc" id="L2872">            int targetCF = parentBuilding.getCurrentCF(position);</span>
<span class="nc" id="L2873">            int targetArmor = parentBuilding.getArmor(position);</span>
<span class="nc" id="L2874">            return targetCF + targetArmor;</span>
<span class="nc bnc" id="L2875" title="All 2 branches missed.">        } else if (targetType == Targetable.TYPE_ENTITY) {</span>
            //I don't *think* we have to handle infantry differently here- I think these methods should return the total number of men remaining as internal structure.
<span class="nc" id="L2877">            Entity targetEntity = game.getEntity(targetId);</span>

<span class="nc bnc" id="L2879" title="All 2 branches missed.">            if (targetEntity instanceof GunEmplacement) { //If this is a gun emplacement, handle it as the building hex it is in.</span>
<span class="nc" id="L2880">                Building parentBuilding = game.getBoard().getBuildingAt(position);</span>
<span class="nc" id="L2881">                int targetCF = parentBuilding.getCurrentCF(position);</span>
<span class="nc" id="L2882">                int targetArmor = parentBuilding.getArmor(position);</span>
<span class="nc" id="L2883">                return targetCF + targetArmor;</span>
            }
<span class="nc" id="L2885">            int targetArmor = targetEntity.getTotalArmor();</span>
<span class="nc" id="L2886">            int targetStructure = targetEntity.getTotalInternal();</span>
<span class="nc" id="L2887">            return targetArmor + targetStructure;</span>
<span class="nc bnc" id="L2888" title="All 2 branches missed.">        } else if (targetType == Targetable.TYPE_HEX_CLEAR) {</span>
            // clearing a hex - the &quot;HP&quot; is the terrain factor of destroyable terrain on this hex
<span class="nc" id="L2890">            IHex mhex = game.getBoard().getHex(position);</span>
<span class="nc" id="L2891">            int terrainTypes[] = mhex.getTerrainTypes();</span>
<span class="nc" id="L2892">            int totalTF = 0;</span>
            
<span class="nc bnc" id="L2894" title="All 2 branches missed.">            for (int i = 0; i &lt; terrainTypes.length; i++) {</span>
<span class="nc" id="L2895">                int tf = 0;</span>
<span class="nc" id="L2896">                int terType = terrainTypes[i];</span>
<span class="nc bnc" id="L2897" title="All 2 branches missed.">                if (mhex.containsTerrain(terType)) {</span>
<span class="nc" id="L2898">                    tf = mhex.getTerrain(terType).getTerrainFactor();</span>
                }
                
<span class="nc" id="L2901">                totalTF += tf;</span>
            }
            
<span class="nc" id="L2904">            return totalTF;</span>
        } else { //something else, e.g. terrain. We probably don't need to handle it for now.
<span class="nc" id="L2906">            return 0;</span>
        }
    }

    /**
     * Returns the weapon attack out of a list that has the highest expected
     * damage
     */
    public static WeaponAttackAction getHighestExpectedDamage(IGame g,
            List&lt;WeaponAttackAction&gt; vAttacks, boolean assumeHit) {
<span class="nc" id="L2916">        float fHighest = -1.0f;</span>
<span class="nc" id="L2917">        WeaponAttackAction waaHighest = null;</span>
<span class="nc bnc" id="L2918" title="All 2 branches missed.">        for (int x = 0, n = vAttacks.size(); x &lt; n; x++) {</span>
<span class="nc" id="L2919">            WeaponAttackAction waa = vAttacks.get(x);</span>
<span class="nc" id="L2920">            float fDanger = Compute.getExpectedDamage(g, waa, assumeHit);</span>
<span class="nc bnc" id="L2921" title="All 2 branches missed.">            if (fDanger &gt; fHighest) {</span>
<span class="nc" id="L2922">                fHighest = fDanger;</span>
<span class="nc" id="L2923">                waaHighest = waa;</span>
            }
        }
<span class="nc" id="L2926">        return waaHighest;</span>
    }

    // store these as constants since the tables will never change
<span class="fc" id="L2930">    private static float[] expectedHitsByRackSize = { 0.0f, 1.0f, 1.58f, 2.0f,</span>
            2.63f, 3.17f, 4.0f, 4.49f, 4.98f, 5.47f, 6.31f, 7.23f, 8.14f,
            8.59f, 9.04f, 9.5f, 10.1f, 10.8f, 11.42f, 12.1f, 12.7f };

    /*
     * | No Modifier | +2 (Artemis, Narc) | -2 (HAG, AMS v Art)| -4 (AMS) | |
     * Avg | Avg | Avg | Avg | | Hits Pct | Hits Pct | Hits Pct | Hits Pct | |
     * Avg Per vs | Avg Per vs | Avg Per vs | Avg Per vs | Size| Hits Size Avg |
     * Hits Size Avg | Hits Size Avg | Hits Size Avg |
     * ----+--------------------+
     * --------------------+--------------------+--------------------+ 2 | 1.42
     * 0.708 9.1 | 1.72 0.861 10.3 | 1.17 0.583 10.7 | 1.03 0.514 21.9 | 3 |
     * 2.00 0.667 2.7 | 2.39 0.796 2.0 | 1.61 0.537 2.0 | 1.28 0.426 1.0 | 4 |
     * 2.64 0.660 1.6 | 3.11 0.778 -0.4 | 2.11 0.528 0.2 | 1.67 0.417 -1.2 | 5 |
     * 3.17 0.633 -2.5 | 3.83 0.767 -1.8 | 2.50 0.500 -5.1 | 1.86 0.372 -11.7 |
     * 6 | 4.00 0.667 2.7 | 4.78 0.796 2.0 | 3.22 0.537 2.0 | 2.58 0.431 2.1 | 7
     * | 4.39 0.627 -3.4 | 5.42 0.774 -0.9 | 3.47 0.496 -5.8 | 2.69 0.385 -8.7 |
     * 8 | 5.08 0.635 -2.1 | 6.06 0.757 -3.0 | 4.22 0.528 0.2 | 3.58 0.448 6.2 |
     * 9 | 5.47 0.608 -6.4 | 6.69 0.744 -4.7 | 4.47 0.497 -5.7 | 3.69 0.410 -2.7
     * | 10 | 6.31 0.631 -2.9 | 7.67 0.767 -1.8 | 5.06 0.506 -4.0 | 3.97 0.397
     * -5.8 | 11 | 7.31 0.664 2.3 | 8.67 0.788 0.9 | 6.06 0.551 4.5 | 4.97 0.452
     * 7.2 | 12 | 8.14 0.678 4.5 | 9.64 0.803 2.9 | 6.64 0.553 5.0 | 5.25 0.438
     * 3.7 | 13 | 8.42 0.647 -0.3 | 10.22 0.786 0.7 | 6.72 0.517 -1.8 | 5.25
     * 0.404 -4.2 | 14 | 9.22 0.659 1.5 | 10.92 0.780 -0.1 | 7.64 0.546 3.6 |
     * 6.25 0.446 5.9 | 15 | 9.50 0.633 -2.5 | 11.50 0.767 -1.8 | 7.72 0.515
     * -2.3 | 6.25 0.417 -1.2 | 16 | 10.42 0.651 0.3 | 12.50 0.781 0.1 | 8.44
     * 0.528 0.2 | 6.67 0.417 -1.2 | 17 | 10.69 0.629 -3.1 | 13.08 0.770 -1.4 |
     * 8.53 0.502 -4.8 | 6.67 0.392 -7.0 | 18 | 11.50 0.639 -1.6 | 13.78 0.765
     * -1.9 | 9.44 0.525 -0.4 | 7.67 0.426 1.0 | 19 | 11.78 0.620 -4.5 | 14.36
     * 0.756 -3.2 | 9.53 0.501 -4.8 | 7.67 0.404 -4.3 | 20 | 12.69 0.635 -2.2 |
     * 15.36 0.768 -1.6 | 10.25 0.512 -2.7 | 8.08 0.404 -4.2 | 21 | 13.61 0.648
     * -0.2 | 16.33 0.778 -0.4 | 11.11 0.529 0.4 | 8.94 0.426 1.0 | 22 | 14.44
     * 0.657 1.1 | 17.31 0.787 0.8 | 11.69 0.532 0.9 | 9.22 0.419 -0.6 | 23 |
     * 15.36 0.668 2.9 | 18.31 0.796 2.0 | 12.42 0.540 2.5 | 9.64 0.419 -0.6 |
     * 24 | 16.28 0.678 4.5 | 19.28 0.803 2.9 | 13.28 0.553 5.0 | 10.50 0.438
     * 3.7 | 25 | 16.56 0.662 2.0 | 19.86 0.794 1.8 | 13.36 0.534 1.5 | 10.50
     * 0.420 -0.4 | 26 | 17.36 0.668 2.8 | 20.56 0.791 1.3 | 14.28 0.549 4.2 |
     * 11.50 0.442 4.9 | 27 | 17.64 0.653 0.6 | 21.14 0.783 0.3 | 14.36 0.532
     * 1.0 | 11.50 0.426 1.0 | 28 | 17.92 0.640 -1.4 | 21.72 0.776 -0.6 | 14.44
     * 0.516 -2.1 | 11.50 0.411 -2.6 | 29 | 18.72 0.646 -0.6 | 22.42 0.773 -1.0
     * | 15.36 0.530 0.6 | 12.50 0.431 2.2 | 30 | 19.00 0.633 -2.5 | 23.00 0.767
     * -1.8 | 15.44 0.515 -2.3 | 12.50 0.417 -1.2 | 40 | 25.39 0.635 -2.2 |
     * 30.72 0.768 -1.6 | 20.50 0.512 -2.7 | 16.17 0.404 -4.2 | ----- -----
     * ----- ----- Average: 0.649 0.781 0.527 0.422 1.202 0.811 0.649
     */

    /**
     * Determines the expected damage of a weapon attack, based on to-hit, salvo
     * sizes, etc.
     */
    public static float getExpectedDamage(IGame g, WeaponAttackAction waa,
            boolean assumeHit) {
<span class="nc" id="L2982">        return Compute.getExpectedDamage(g, waa, assumeHit, null);</span>
    }

    /**
     * Determines the expected damage of a weapon attack, based on to-hit, salvo
     * sizes, etc.
     */
    public static float getExpectedDamage(IGame g, WeaponAttackAction waa,
            boolean assumeHit, List&lt;ECMInfo&gt; allECMInfo) {
<span class="nc" id="L2991">        boolean use_table = false;</span>

<span class="nc" id="L2993">        AmmoType loaded_ammo = new AmmoType();</span>

<span class="nc" id="L2995">        Entity attacker = g.getEntity(waa.getEntityId());</span>
<span class="nc" id="L2996">        Entity target = g.getEntity(waa.getTargetId());</span>
        
<span class="nc bnc" id="L2998" title="All 2 branches missed.">        int baShootingStrength = attacker instanceof BattleArmor ? </span>
<span class="nc" id="L2999">                ((BattleArmor) attacker).getShootingStrength() : 0;</span>
        
<span class="nc" id="L3001">        int infShootingStrength = 0;</span>
<span class="nc" id="L3002">        double infDamagePerTrooper = 0;</span>
                
<span class="nc" id="L3004">        Mounted weapon = attacker.getEquipment(waa.getWeaponId());</span>
        Mounted lnk_guide;

<span class="nc" id="L3007">        ToHitData hitData = waa.toHit(g, allECMInfo);</span>

<span class="nc bnc" id="L3009" title="All 2 branches missed.">        if (attacker.isConventionalInfantry()) {</span>
<span class="nc" id="L3010">            infShootingStrength = ((Infantry) attacker).getShootingStrength();</span>
<span class="nc" id="L3011">            infDamagePerTrooper = ((Infantry) attacker).getDamagePerTrooper();</span>
        }

<span class="nc" id="L3014">        WeaponType wt = (WeaponType) weapon.getType();</span>

<span class="nc" id="L3016">        float fDamage = 0.0f;</span>
<span class="nc" id="L3017">        float fChance = 0.0f;</span>
<span class="nc bnc" id="L3018" title="All 2 branches missed.">        if (assumeHit) {</span>
<span class="nc" id="L3019">            fChance = 1.0f;</span>
        } else {
<span class="nc bnc" id="L3021" title="All 2 branches missed.">            if ((hitData.getValue() == TargetRoll.IMPOSSIBLE)</span>
<span class="nc bnc" id="L3022" title="All 2 branches missed.">                || (hitData.getValue() == TargetRoll.AUTOMATIC_FAIL)) {</span>
<span class="nc" id="L3023">                return 0.0f;</span>
            }

<span class="nc bnc" id="L3026" title="All 2 branches missed.">            if (hitData.getValue() == TargetRoll.AUTOMATIC_SUCCESS) {</span>
<span class="nc" id="L3027">                fChance = 1.0f;</span>
            } else {
<span class="nc" id="L3029">                fChance = (float) Compute.oddsAbove(hitData.getValue(),</span>
<span class="nc" id="L3030">                                                    attacker.hasAbility(OptionsConstants.PILOT_APTITUDE_GUNNERY))</span>
                          / 100.0f;
            }
        }

        // Missiles, HAGs, LBX cluster rounds, and ultra/rotary cannons (when
        // spun up)
        // use the missile hits table
<span class="nc bnc" id="L3038" title="All 2 branches missed.">        if (wt.getDamage() == WeaponType.DAMAGE_BY_CLUSTERTABLE) {</span>
<span class="nc" id="L3039">            use_table = true;</span>
        }

        //Unless it's a fighter squadron, which uses a weird group of single weapons and should return mass AV
<span class="nc bnc" id="L3043" title="All 2 branches missed.">        if (attacker.isCapitalFighter()) {</span>
<span class="nc" id="L3044">            use_table = false;</span>
        }

<span class="nc bnc" id="L3047" title="All 2 branches missed.">        if ((wt.getAmmoType() == AmmoType.T_AC_LBX)</span>
<span class="nc bnc" id="L3048" title="All 2 branches missed.">            || (wt.getAmmoType() == AmmoType.T_AC_LBX_THB)</span>
<span class="nc bnc" id="L3049" title="All 2 branches missed.">            || (wt.getAmmoType() == AmmoType.T_AC_LBX_THB)) {</span>
<span class="nc" id="L3050">            loaded_ammo = (AmmoType) weapon.getLinked().getType();</span>
<span class="nc bnc" id="L3051" title="All 2 branches missed.">            if (((loaded_ammo.getAmmoType() == AmmoType.T_AC_LBX) || (loaded_ammo</span>
<span class="nc bnc" id="L3052" title="All 2 branches missed.">                                                                              .getAmmoType() == AmmoType.T_AC_LBX_THB))</span>
<span class="nc bnc" id="L3053" title="All 2 branches missed.">                &amp;&amp; (loaded_ammo.getMunitionType() == AmmoType.M_CLUSTER)) {</span>
<span class="nc" id="L3054">                use_table = true;</span>
            }
        }

<span class="nc bnc" id="L3058" title="All 2 branches missed.">        if ((wt.getAmmoType() == AmmoType.T_AC_ULTRA)</span>
<span class="nc bnc" id="L3059" title="All 2 branches missed.">            || (wt.getAmmoType() == AmmoType.T_AC_ULTRA_THB)</span>
<span class="nc bnc" id="L3060" title="All 2 branches missed.">            || (wt.getAmmoType() == AmmoType.T_AC_ROTARY)) {</span>
<span class="nc bnc" id="L3061" title="All 2 branches missed.">            if ((weapon.curMode().getName().equals(&quot;Ultra&quot;))</span>
<span class="nc bnc" id="L3062" title="All 2 branches missed.">                || (weapon.curMode().getName().equals(&quot;2-shot&quot;))</span>
<span class="nc bnc" id="L3063" title="All 2 branches missed.">                || (weapon.curMode().getName().equals(&quot;3-shot&quot;))</span>
<span class="nc bnc" id="L3064" title="All 2 branches missed.">                || (weapon.curMode().getName().equals(&quot;4-shot&quot;))</span>
<span class="nc bnc" id="L3065" title="All 2 branches missed.">                || (weapon.curMode().getName().equals(&quot;5-shot&quot;))</span>
<span class="nc bnc" id="L3066" title="All 2 branches missed.">                || (weapon.curMode().getName().equals(&quot;6-shot&quot;))) {</span>
<span class="nc" id="L3067">                use_table = true;</span>
            }
        }

        // Kinda cheap, but lets use the missile hits table for Battle armor
        // weapons too

<span class="nc bnc" id="L3074" title="All 2 branches missed.">        if (attacker instanceof BattleArmor) {</span>
<span class="nc bnc" id="L3075" title="All 2 branches missed.">            if ((wt.getInternalName() != Infantry.SWARM_MEK)</span>
<span class="nc bnc" id="L3076" title="All 2 branches missed.">                &amp;&amp; (wt.getInternalName() != Infantry.LEG_ATTACK)) {</span>
<span class="nc" id="L3077">                use_table = true;</span>
            }
        }

<span class="nc bnc" id="L3081" title="All 2 branches missed.">        if (use_table == true) {</span>
<span class="nc bnc" id="L3082" title="All 2 branches missed.">            if (!(attacker instanceof BattleArmor)) {</span>
<span class="nc bnc" id="L3083" title="All 2 branches missed.">                if (weapon.getLinked() == null) {</span>
<span class="nc" id="L3084">                    return 0.0f;</span>
                }
            }
<span class="nc" id="L3087">            AmmoType at = null;</span>
<span class="nc bnc" id="L3088" title="All 2 branches missed.">            if ((weapon.getLinked() != null)</span>
<span class="nc bnc" id="L3089" title="All 2 branches missed.">                    &amp;&amp; (weapon.getLinked().getType() instanceof AmmoType)) {</span>
<span class="nc" id="L3090">                at = (AmmoType) weapon.getLinked().getType();</span>
<span class="nc" id="L3091">                fDamage = at.getDamagePerShot();</span>
            }

<span class="nc" id="L3094">            float fHits = 0.0f;</span>
<span class="nc bnc" id="L3095" title="All 4 branches missed.">            if ((wt.getRackSize() != 40) &amp;&amp; (wt.getRackSize() != 30)) {</span>
<span class="nc" id="L3096">                fHits = expectedHitsByRackSize[wt.getRackSize()];</span>
            } else {
<span class="nc" id="L3098">                fHits = 2.0f * expectedHitsByRackSize[wt.getRackSize() / 2];</span>
            }
<span class="nc bnc" id="L3100" title="All 2 branches missed.">            if (((wt.getAmmoType() == AmmoType.T_SRM_STREAK)</span>
<span class="nc bnc" id="L3101" title="All 2 branches missed.">                    || (wt.getAmmoType() == AmmoType.T_MRM_STREAK) || (wt</span>
<span class="nc bnc" id="L3102" title="All 2 branches missed.">                    .getAmmoType() == AmmoType.T_LRM_STREAK))</span>
<span class="nc bnc" id="L3103" title="All 2 branches missed.">                    &amp;&amp; !ComputeECM.isAffectedByAngelECM(attacker, attacker</span>
<span class="nc" id="L3104">                            .getPosition(), waa.getTarget(g).getPosition(),</span>
                            allECMInfo)) {
<span class="nc" id="L3106">                fHits = wt.getRackSize();</span>
            }
<span class="nc bnc" id="L3108" title="All 2 branches missed.">            if ((wt.getAmmoType() == AmmoType.T_AC_ULTRA)</span>
<span class="nc bnc" id="L3109" title="All 2 branches missed.">                || (wt.getAmmoType() == AmmoType.T_AC_ULTRA_THB)</span>
<span class="nc bnc" id="L3110" title="All 2 branches missed.">                || (wt.getAmmoType() == AmmoType.T_AC_ROTARY)) {</span>
<span class="nc bnc" id="L3111" title="All 2 branches missed.">                if ((weapon.curMode().getName().equals(&quot;Ultra&quot;))</span>
<span class="nc bnc" id="L3112" title="All 2 branches missed.">                    || (weapon.curMode().getName().equals(&quot;2-shot&quot;))) {</span>
<span class="nc" id="L3113">                    fHits = expectedHitsByRackSize[2];</span>
                }
<span class="nc bnc" id="L3115" title="All 2 branches missed.">                if (weapon.curMode().getName().equals(&quot;3-shot&quot;)) {</span>
<span class="nc" id="L3116">                    fHits = expectedHitsByRackSize[3];</span>
                }
<span class="nc bnc" id="L3118" title="All 2 branches missed.">                if (weapon.curMode().getName().equals(&quot;4-shot&quot;)) {</span>
<span class="nc" id="L3119">                    fHits = expectedHitsByRackSize[4];</span>
                }
<span class="nc bnc" id="L3121" title="All 2 branches missed.">                if (weapon.curMode().getName().equals(&quot;5-shot&quot;)) {</span>
<span class="nc" id="L3122">                    fHits = expectedHitsByRackSize[5];</span>
                }
<span class="nc bnc" id="L3124" title="All 2 branches missed.">                if (weapon.curMode().getName().equals(&quot;6-shot&quot;)) {</span>
<span class="nc" id="L3125">                    fHits = expectedHitsByRackSize[6];</span>
                }
            }

            // Most Battle Armor units have a weapon per trooper, plus their
            // weapons do odd things when mounting multiples
<span class="nc bnc" id="L3131" title="All 2 branches missed.">            if (attacker instanceof BattleArmor) {</span>
                // The number of troopers hitting
<span class="nc" id="L3133">                fHits = expectedHitsByRackSize[baShootingStrength];</span>
<span class="nc bnc" id="L3134" title="All 2 branches missed.">                if (wt.getDamage() == WeaponType.DAMAGE_BY_CLUSTERTABLE) {</span>
<span class="nc" id="L3135">                    fHits *= expectedHitsByRackSize[wt.getRackSize()];</span>
                }
<span class="nc bnc" id="L3137" title="All 2 branches missed.">                if (wt.getDamage() != WeaponType.DAMAGE_BY_CLUSTERTABLE) {</span>
<span class="nc bnc" id="L3138" title="All 2 branches missed.">                    if (wt.getDamage() != WeaponType.DAMAGE_VARIABLE) {</span>
<span class="nc" id="L3139">                        fDamage = wt.getDamage();</span>
                    } else {
<span class="nc" id="L3141">                        fDamage = wt.getRackSize();</span>
                    }
                }
<span class="nc bnc" id="L3144" title="All 2 branches missed.">                if (wt.hasFlag(WeaponType.F_MISSILE_HITS)) {</span>
<span class="nc" id="L3145">                    fHits *= expectedHitsByRackSize[wt.getRackSize()];</span>
                }
            }

            // If there is no ECM coverage to the target, guidance systems are
            // good for another 1.20x damage on missile weapons
<span class="nc bnc" id="L3151" title="All 2 branches missed.">            if ((!ComputeECM.isAffectedByECM(attacker, attacker.getPosition(), g</span>
<span class="nc" id="L3152">                    .getEntity(waa.getTargetId()).getPosition(), allECMInfo))</span>
<span class="nc bnc" id="L3153" title="All 2 branches missed.">                &amp;&amp; (wt.getDamage() == WeaponType.DAMAGE_BY_CLUSTERTABLE)</span>
<span class="nc bnc" id="L3154" title="All 2 branches missed.">                &amp;&amp; (wt.hasFlag(WeaponType.F_MISSILE))) {</span>
                // Check for linked artemis guidance system
<span class="nc bnc" id="L3156" title="All 2 branches missed.">                if ((wt.getAmmoType() == AmmoType.T_LRM)</span>
<span class="nc bnc" id="L3157" title="All 2 branches missed.">                        || (wt.getAmmoType() == AmmoType.T_LRM_IMP)</span>
<span class="nc bnc" id="L3158" title="All 2 branches missed.">                        || (wt.getAmmoType() == AmmoType.T_MML)</span>
<span class="nc bnc" id="L3159" title="All 2 branches missed.">                        || (wt.getAmmoType() == AmmoType.T_SRM)</span>
<span class="nc bnc" id="L3160" title="All 2 branches missed.">                        || (wt.getAmmoType() == AmmoType.T_SRM_IMP)) {</span>
<span class="nc" id="L3161">                    lnk_guide = weapon.getLinkedBy();</span>
<span class="nc bnc" id="L3162" title="All 6 branches missed.">                    if ((lnk_guide != null) &amp;&amp; (lnk_guide.getType() instanceof MiscType) &amp;&amp; !lnk_guide.isDestroyed()</span>
<span class="nc bnc" id="L3163" title="All 4 branches missed.">                            &amp;&amp; !lnk_guide.isMissing() &amp;&amp; !lnk_guide.isBreached()</span>
<span class="nc bnc" id="L3164" title="All 2 branches missed.">                            &amp;&amp; lnk_guide.getType().hasFlag(MiscType.F_ARTEMIS)) {</span>

                        // Don't use artemis if this is indirect fire
                        // -&gt; Hook for Artemis V Level 3 Clan tech here; use
                        // 1.30f multiplier when implemented
<span class="nc bnc" id="L3169" title="All 4 branches missed.">                        if (((weapon.curMode() == null) || !weapon.curMode().equals(&quot;Indirect&quot;))</span>
<span class="nc bnc" id="L3170" title="All 2 branches missed.">                                &amp;&amp; (at.getMunitionType() == AmmoType.M_ARTEMIS_CAPABLE)) {</span>
<span class="nc" id="L3171">                            fHits *= 1.2f;</span>
                        }
<span class="nc bnc" id="L3173" title="All 4 branches missed.">                        if (((weapon.curMode() == null) || !weapon.curMode().equals(&quot;Indirect&quot;))</span>
<span class="nc bnc" id="L3174" title="All 2 branches missed.">                                &amp;&amp; (at.getMunitionType() == AmmoType.M_ARTEMIS_V_CAPABLE)) {</span>
<span class="nc" id="L3175">                            fHits *= 1.3f;</span>
                        }
                    }
                }

                // Check for ATMs, which have built in Artemis
<span class="nc bnc" id="L3181" title="All 2 branches missed.">                if (wt.getAmmoType() == AmmoType.T_ATM) {</span>
<span class="nc" id="L3182">                    fHits *= 1.2f;</span>
                }

                // Check for target with attached Narc or iNarc homing pod from
                // friendly unit
<span class="nc bnc" id="L3187" title="All 2 branches missed.">                if (target.isNarcedBy(attacker.getOwner().getTeam())</span>
<span class="nc bnc" id="L3188" title="All 2 branches missed.">                        || target.isINarcedBy(attacker.getOwner().getTeam())) {</span>
<span class="nc bnc" id="L3189" title="All 2 branches missed.">                    if (((at.getAmmoType() == AmmoType.T_LRM)</span>
<span class="nc bnc" id="L3190" title="All 2 branches missed.">                            || (at.getAmmoType() == AmmoType.T_LRM_IMP)</span>
<span class="nc bnc" id="L3191" title="All 2 branches missed.">                            || (at.getAmmoType() == AmmoType.T_MML)</span>
<span class="nc bnc" id="L3192" title="All 2 branches missed.">                            || (at.getAmmoType() == AmmoType.T_SRM)</span>
<span class="nc bnc" id="L3193" title="All 2 branches missed.">                            || (at.getAmmoType() == AmmoType.T_SRM_IMP))</span>
<span class="nc bnc" id="L3194" title="All 2 branches missed.">                            &amp;&amp; (at.getMunitionType() == AmmoType.M_NARC_CAPABLE)) {</span>
<span class="nc" id="L3195">                        fHits *= 1.2f;</span>
                    }
                }
            }

<span class="nc bnc" id="L3200" title="All 2 branches missed.">            if (wt.getAmmoType() == AmmoType.T_MRM) {</span>
<span class="nc" id="L3201">                lnk_guide = weapon.getLinkedBy();</span>
<span class="nc bnc" id="L3202" title="All 2 branches missed.">                if ((lnk_guide != null)</span>
<span class="nc bnc" id="L3203" title="All 2 branches missed.">                    &amp;&amp; (lnk_guide.getType() instanceof MiscType)</span>
<span class="nc bnc" id="L3204" title="All 4 branches missed.">                    &amp;&amp; !lnk_guide.isDestroyed() &amp;&amp; !lnk_guide.isMissing()</span>
<span class="nc bnc" id="L3205" title="All 2 branches missed.">                    &amp;&amp; !lnk_guide.isBreached()</span>
<span class="nc bnc" id="L3206" title="All 2 branches missed.">                    &amp;&amp; lnk_guide.getType().hasFlag(MiscType.F_APOLLO)) {</span>
<span class="nc" id="L3207">                    fHits *= .9f;</span>
                }
            }

            // adjust for previous AMS
<span class="nc bnc" id="L3212" title="All 2 branches missed.">            if ((wt.getDamage() == WeaponType.DAMAGE_BY_CLUSTERTABLE)</span>
<span class="nc bnc" id="L3213" title="All 2 branches missed.">                &amp;&amp; wt.hasFlag(WeaponType.F_MISSILE)) {</span>
<span class="nc" id="L3214">                ArrayList&lt;Mounted&gt; vCounters = waa.getCounterEquipment();</span>
<span class="nc bnc" id="L3215" title="All 2 branches missed.">                if (vCounters != null) {</span>
<span class="nc bnc" id="L3216" title="All 2 branches missed.">                    for (int x = 0; x &lt; vCounters.size(); x++) {</span>
<span class="nc" id="L3217">                        EquipmentType type = vCounters.get(x).getType();</span>
<span class="nc bnc" id="L3218" title="All 2 branches missed.">                        if ((type instanceof WeaponType)</span>
<span class="nc bnc" id="L3219" title="All 2 branches missed.">                            &amp;&amp; type.hasFlag(WeaponType.F_AMS)) {</span>
<span class="nc" id="L3220">                            fHits *= 0.6;</span>
                        }
                    }
                }
            }

            // * HAGs modify their cluster hits for range.
<span class="nc bnc" id="L3227" title="All 2 branches missed.">            if (wt instanceof HAGWeapon) {</span>
<span class="nc" id="L3228">                int distance = attacker.getPosition().distance(</span>
<span class="nc" id="L3229">                        target.getPosition());</span>
<span class="nc bnc" id="L3230" title="All 2 branches missed.">                if (distance &lt;= wt.getShortRange()) {</span>
<span class="nc" id="L3231">                    fHits *= 1.2;</span>
<span class="nc bnc" id="L3232" title="All 2 branches missed.">                } else if (distance &gt; wt.getMediumRange()) {</span>
<span class="nc" id="L3233">                    fHits *= 0.8;</span>
                }
            }

<span class="nc" id="L3237">            fDamage *= fHits;</span>

<span class="nc bnc" id="L3239" title="All 2 branches missed.">            if ((wt.getAmmoType() == AmmoType.T_AC_ULTRA)</span>
<span class="nc bnc" id="L3240" title="All 2 branches missed.">                || (wt.getAmmoType() == AmmoType.T_AC_ULTRA_THB)</span>
<span class="nc bnc" id="L3241" title="All 2 branches missed.">                || (wt.getAmmoType() == AmmoType.T_AC_ROTARY)) {</span>
<span class="nc" id="L3242">                fDamage = fHits * wt.getDamage();</span>
            }

<span class="nc" id="L3245">        } else {</span>
            // Direct fire weapons (and LBX slug rounds) just do a single shot
            // so they don't use the missile hits table. Weapon bays also deal
            // damage in a single block
<span class="nc bnc" id="L3249" title="All 2 branches missed.">            if ((attacker.getPosition() != null)</span>
<span class="nc bnc" id="L3250" title="All 2 branches missed.">                &amp;&amp; (target.getPosition() != null)) {</span>
                // Damage may vary by range for some weapons, so let's see how far
                // away we actually are and then set the damage accordingly.
<span class="nc" id="L3253">                int rangeToTarget = attacker.getPosition().distance(target.getPosition());</span>
                
                //Convert AV to fDamage for bay weapons, fighters, etc
<span class="nc bnc" id="L3256" title="All 2 branches missed.">                if (attacker.usesWeaponBays()){</span>
<span class="nc" id="L3257">                    double av = 0;</span>
<span class="nc" id="L3258">                    double threat = 1;</span>
<span class="nc bnc" id="L3259" title="All 2 branches missed.">                    for (int wId : weapon.getBayWeapons()) {</span>
<span class="nc" id="L3260">                        Mounted bayW = attacker.getEquipment(wId);</span>
<span class="nc" id="L3261">                        WeaponType bayWType = ((WeaponType) bayW.getType());</span>
                        //Capital weapons have a different range scale
<span class="nc bnc" id="L3263" title="All 2 branches missed.">                        if (wt.isCapital()) {</span>
                            // Capital missiles get higher priority than standard missiles:
                            // damage plus a bonus for the critical hit threat they represent
<span class="nc" id="L3266">                            threat = 12;</span>
<span class="nc bnc" id="L3267" title="All 2 branches missed.">                            if (rangeToTarget &gt; 50) {</span>
<span class="nc" id="L3268">                                av = 0;</span>
<span class="nc bnc" id="L3269" title="All 2 branches missed.">                            } else if (rangeToTarget &gt; 40) {</span>
<span class="nc" id="L3270">                                av += bayWType.getExtAV();</span>
<span class="nc bnc" id="L3271" title="All 2 branches missed.">                            } else if (rangeToTarget &gt; 25) {</span>
<span class="nc" id="L3272">                                av += bayWType.getLongAV();</span>
<span class="nc bnc" id="L3273" title="All 2 branches missed.">                            } else if (rangeToTarget &gt; 12) {</span>
<span class="nc" id="L3274">                                av += bayWType.getMedAV();</span>
                            } else {
<span class="nc" id="L3276">                                av += bayWType.getShortAV();</span>
                            }
                        } else {
<span class="nc bnc" id="L3279" title="All 2 branches missed.">                            if (rangeToTarget &gt; 25) {</span>
<span class="nc" id="L3280">                                av = 0;</span>
<span class="nc bnc" id="L3281" title="All 2 branches missed.">                            } else if (rangeToTarget &gt; 20) {</span>
<span class="nc" id="L3282">                                av += bayWType.getExtAV();</span>
<span class="nc bnc" id="L3283" title="All 2 branches missed.">                            } else if (rangeToTarget &gt; 12) {</span>
<span class="nc" id="L3284">                                av += bayWType.getLongAV();</span>
<span class="nc bnc" id="L3285" title="All 2 branches missed.">                            } else if (rangeToTarget &gt; 6) {</span>
<span class="nc" id="L3286">                                av += bayWType.getMedAV();</span>
                            } else {
<span class="nc" id="L3288">                                av += bayWType.getShortAV();</span>
                            }
                        }
<span class="nc" id="L3291">                        fDamage = (float) (av * threat);</span>
<span class="nc" id="L3292">                    }</span>
<span class="nc bnc" id="L3293" title="All 2 branches missed.">                } else if (attacker.isCapitalFighter()) {</span>
<span class="nc" id="L3294">                    double av = 0;</span>
<span class="nc" id="L3295">                    double threat = 1;</span>
                    //Capital weapons have a different range scale
<span class="nc bnc" id="L3297" title="All 2 branches missed.">                    if (wt.isCapital()) {</span>
                        // Capital missiles should have higher priority than standard missiles
<span class="nc" id="L3299">                        threat = 12;</span>
<span class="nc bnc" id="L3300" title="All 2 branches missed.">                        if (rangeToTarget &gt; 50) {</span>
<span class="nc" id="L3301">                            av = 0;</span>
<span class="nc bnc" id="L3302" title="All 2 branches missed.">                        } else if (rangeToTarget &gt; 40) {</span>
<span class="nc" id="L3303">                            av += (wt.getExtAV() * weapon.getNWeapons());</span>
<span class="nc bnc" id="L3304" title="All 2 branches missed.">                        } else if (rangeToTarget &gt; 25) {</span>
<span class="nc" id="L3305">                            av += (wt.getLongAV() * weapon.getNWeapons());</span>
<span class="nc bnc" id="L3306" title="All 2 branches missed.">                        } else if (rangeToTarget &gt; 12) {</span>
<span class="nc" id="L3307">                            av += (wt.getMedAV() * weapon.getNWeapons());</span>
                        } else {
<span class="nc" id="L3309">                            av += (wt.getShortAV() * weapon.getNWeapons());</span>
                        }
                    } else {
<span class="nc bnc" id="L3312" title="All 2 branches missed.">                        if (rangeToTarget &gt; 25) {</span>
<span class="nc" id="L3313">                            av = 0;</span>
<span class="nc bnc" id="L3314" title="All 2 branches missed.">                        } else if (rangeToTarget &gt; 20) {</span>
<span class="nc" id="L3315">                            av += (wt.getExtAV() * weapon.getNWeapons());</span>
<span class="nc bnc" id="L3316" title="All 2 branches missed.">                        } else if (rangeToTarget &gt; 12) {</span>
<span class="nc" id="L3317">                            av += (wt.getLongAV() * weapon.getNWeapons());</span>
<span class="nc bnc" id="L3318" title="All 2 branches missed.">                        } else if (rangeToTarget &gt; 6) {</span>
<span class="nc" id="L3319">                            av += (wt.getMedAV() * weapon.getNWeapons());</span>
                        } else {
<span class="nc" id="L3321">                            av += (wt.getShortAV() * weapon.getNWeapons());</span>
                        }
                    }
<span class="nc" id="L3324">                    fDamage = (float) (av * threat);</span>

<span class="nc bnc" id="L3326" title="All 2 branches missed.">                } else if ((wt.getAmmoType() == AmmoType.T_ARROW_IV)</span>
<span class="nc bnc" id="L3327" title="All 2 branches missed.">                        || wt.getAmmoType() == BombType.B_HOMING) {</span>
                    //This is for arrow IV AMS threat processing
<span class="nc" id="L3329">                    fDamage = (float) wt.getRackSize();</span>
                } else {
<span class="nc" id="L3331">                    fDamage = wt.getDamage(rangeToTarget);</span>
                }
            }

            // Infantry follow some special rules, but do fixed amounts of damage
            // Anti-mek attacks are weapon-like in nature, so include them here as well
<span class="nc bnc" id="L3337" title="All 2 branches missed.">            if (attacker instanceof Infantry) {</span>
<span class="nc bnc" id="L3338" title="All 2 branches missed.">                if (wt.getInternalName() == Infantry.LEG_ATTACK) {</span>
<span class="nc" id="L3339">                    fDamage = 20.0f; // Actually 5, but the chance of crits</span>
                    // deserves a boost
                // leg attacks are mutually exclusive with swarm attacks, 
                } else {                
<span class="nc bnc" id="L3343" title="All 4 branches missed.">                    boolean targetIsSwarmable = (target instanceof Mech) || (target instanceof Tank);</span>
    
<span class="nc bnc" id="L3345" title="All 2 branches missed.">                    if (attacker.isConventionalInfantry()) {</span>
<span class="nc bnc" id="L3346" title="All 2 branches missed.">                        if (wt.getInternalName() == Infantry.SWARM_MEK) {</span>
                            // If the target is a Mek that is not swarmed, this is a
                            // good thing
<span class="nc bnc" id="L3349" title="All 4 branches missed.">                            if ((target.getSwarmAttackerId() == Entity.NONE) &amp;&amp; targetIsSwarmable) {</span>
<span class="nc" id="L3350">                                fDamage = 1.5f</span>
                                        * (float) infDamagePerTrooper
                                        * infShootingStrength;
                            }
                            // Otherwise, call it 0 damage
                            else {
<span class="nc" id="L3356">                                fDamage = 0.0f;</span>
                            }
                        } else {
                            // conventional weapons; field guns should be handled
                            // under the standard weapons section
<span class="nc" id="L3361">                            fDamage = 0.6f</span>
                                    * (float) infDamagePerTrooper
                                    * infShootingStrength;
                        }
                    } else {
                        // Battle armor units conducting swarm attack
<span class="nc bnc" id="L3367" title="All 2 branches missed.">                        if (wt.getInternalName() == Infantry.SWARM_MEK) {</span>
                            // If the target is a Mek that is not swarmed, this is a
                            // good thing
<span class="nc bnc" id="L3370" title="All 4 branches missed.">                            if ((target.getSwarmAttackerId() == Entity.NONE) &amp;&amp; targetIsSwarmable) {</span>
                                // Overestimated, but the chance at crits and head
                                // shots deserves a boost
<span class="nc" id="L3373">                                fDamage = 10.0f * baShootingStrength;</span>
                            }
                            // Otherwise, call it 0 damage
                            else {
<span class="nc" id="L3377">                                fDamage = 0.0f;</span>
                            }
                        }
                    }
                }
            }

        }

        // Need to adjust damage if the target is infantry.
<span class="nc bnc" id="L3387" title="All 2 branches missed.">        if (g.getEntity(waa.getTargetId()).isConventionalInfantry()) {</span>
<span class="nc" id="L3388">            fDamage = directBlowInfantryDamage(fDamage, 0,</span>
<span class="nc" id="L3389">                    wt.getInfantryDamageClass(), ((Infantry) (g.getEntity(waa</span>
<span class="nc" id="L3390">                            .getTargetId()))).isMechanized(), false);</span>
        }

<span class="nc" id="L3393">        fDamage *= fChance;</span>

        // Conventional infantry take double damage in the open
<span class="nc bnc" id="L3396" title="All 2 branches missed.">        if (g.getEntity(waa.getTargetId()).isConventionalInfantry()) {</span>
<span class="nc" id="L3397">            IHex e_hex = g.getBoard().getHex(</span>
<span class="nc" id="L3398">                    g.getEntity(waa.getTargetId()).getPosition().getX(),</span>
<span class="nc" id="L3399">                    g.getEntity(waa.getTargetId()).getPosition().getY());</span>
<span class="nc bnc" id="L3400" title="All 2 branches missed.">            if (!e_hex.containsTerrain(Terrains.WOODS)</span>
<span class="nc bnc" id="L3401" title="All 2 branches missed.">                &amp;&amp; !e_hex.containsTerrain(Terrains.JUNGLE)</span>
<span class="nc bnc" id="L3402" title="All 2 branches missed.">                &amp;&amp; !e_hex.containsTerrain(Terrains.BUILDING)) {</span>
<span class="nc" id="L3403">                fDamage *= 2.0f;</span>
            }

            // Cap damage to prevent run-away values
<span class="nc bnc" id="L3407" title="All 2 branches missed.">            if (infShootingStrength &gt; 0) {</span>
<span class="nc" id="L3408">                fDamage = Math.min(infShootingStrength, fDamage);</span>
            }
        }
<span class="nc" id="L3411">        return fDamage;</span>
    }

    /**
     * If the unit is carrying multiple types of ammo for the specified weapon,
     * cycle through them and choose the type best suited to engage the
     * specified target Value returned is expected damage Note that some ammo
     * types, such as infernos, do no damage or have special properties and so
     * the damage is an estimation of effectiveness
     */

    public static double getAmmoAdjDamage(IGame cgame, WeaponAttackAction atk) {
<span class="nc" id="L3423">        boolean no_bin = true;</span>
<span class="nc" id="L3424">        boolean multi_bin = false;</span>

        double ammo_multiple, ex_damage, max_damage;

        Entity shooter, target;

        Mounted fabin, best_bin;
<span class="nc" id="L3431">        AmmoType abin_type = new AmmoType();</span>
<span class="nc" id="L3432">        AmmoType fabin_type = new AmmoType();</span>
<span class="nc" id="L3433">        WeaponType wtype = new WeaponType();</span>
<span class="nc" id="L3434">        WeaponType target_weapon = new WeaponType();</span>

        // Get shooter entity, target entity, and weapon being fired
<span class="nc" id="L3437">        target = cgame.getEntity(atk.getTargetId());</span>
<span class="nc" id="L3438">        shooter = atk.getEntity(cgame);</span>
<span class="nc" id="L3439">        wtype = (WeaponType) shooter.getEquipment(atk.getWeaponId()).getType();</span>

<span class="nc" id="L3441">        max_damage = 0.0;</span>

        // If the weapon doesn't require ammo, just get the estimated damage
<span class="nc bnc" id="L3444" title="All 2 branches missed.">        if (wtype.hasFlag(WeaponType.F_ENERGY)</span>
<span class="nc bnc" id="L3445" title="All 2 branches missed.">            || wtype.hasFlag(WeaponType.F_ONESHOT)</span>
<span class="nc bnc" id="L3446" title="All 2 branches missed.">            || wtype.hasFlag(WeaponType.F_INFANTRY)</span>
<span class="nc bnc" id="L3447" title="All 2 branches missed.">            || (wtype.getAmmoType() == AmmoType.T_NA)) {</span>
<span class="nc" id="L3448">            return Compute.getExpectedDamage(cgame, atk, false);</span>
        }

        // Get a list of ammo bins and the first valid bin
<span class="nc" id="L3452">        fabin = null;</span>
<span class="nc" id="L3453">        best_bin = null;</span>

<span class="nc bnc" id="L3455" title="All 2 branches missed.">        for (Mounted abin : shooter.getAmmo()) {</span>
<span class="nc bnc" id="L3456" title="All 2 branches missed.">            if (shooter.loadWeapon(shooter.getEquipment(atk.getWeaponId()),</span>
                                   abin)) {
<span class="nc bnc" id="L3458" title="All 2 branches missed.">                if (abin.getUsableShotsLeft() &gt; 0) {</span>
<span class="nc" id="L3459">                    abin_type = (AmmoType) abin.getType();</span>
<span class="nc bnc" id="L3460" title="All 2 branches missed.">                    if (!AmmoType.canDeliverMinefield(abin_type)) {</span>
<span class="nc" id="L3461">                        fabin = abin;</span>
<span class="nc" id="L3462">                        fabin_type = (AmmoType) fabin.getType();</span>
<span class="nc" id="L3463">                        break;</span>
                    }
                }
            }
<span class="nc" id="L3467">        }</span>

        // To save processing time, lets see if we have more than one type of
        // bin
        // Thunder-type ammos and empty bins are excluded from the list
<span class="nc bnc" id="L3472" title="All 2 branches missed.">        for (Mounted abin : shooter.getAmmo()) {</span>
<span class="nc bnc" id="L3473" title="All 2 branches missed.">            if (shooter.loadWeapon(shooter.getEquipment(atk.getWeaponId()),</span>
                                   abin)) {
<span class="nc bnc" id="L3475" title="All 2 branches missed.">                if (abin.getUsableShotsLeft() &gt; 0) {</span>
<span class="nc" id="L3476">                    abin_type = (AmmoType) abin.getType();</span>
<span class="nc bnc" id="L3477" title="All 2 branches missed.">                    if (!AmmoType.canDeliverMinefield(abin_type)) {</span>
<span class="nc" id="L3478">                        no_bin = false;</span>
<span class="nc" id="L3479">                        if (abin_type.getMunitionType() != fabin_type</span>
<span class="nc bnc" id="L3480" title="All 2 branches missed.">                                .getMunitionType()) {</span>
<span class="nc" id="L3481">                            multi_bin = true;</span>
<span class="nc" id="L3482">                            break;</span>
                        }
                    }
                }
            }
<span class="nc" id="L3487">        }</span>

        // If no_bin is true, then either all bins are empty or contain
        // Thunder-type rounds and
        // we can safely say that the expected damage is 0.0
        // If no_bin is false, then we have at least one good bin
<span class="nc bnc" id="L3493" title="All 2 branches missed.">        if (no_bin) {</span>
<span class="nc" id="L3494">            return 0.0;</span>
        }
        // If multi_bin is true, then multiple ammo types are present and an
        // appropriate type must be selected
        // If multi_bin is false, then all bin types are the same; skip down
        // to getting the expected damage
<span class="nc bnc" id="L3500" title="All 2 branches missed.">        if (!multi_bin) {</span>
<span class="nc" id="L3501">            return Compute.getExpectedDamage(cgame, atk, false);</span>
        }
<span class="nc bnc" id="L3503" title="All 2 branches missed.">        if (multi_bin) {</span>

            // Set default max damage as 0, and the best bin as the first
            // bin
<span class="nc" id="L3507">            max_damage = 0.0;</span>
<span class="nc" id="L3508">            best_bin = fabin;</span>

            // For each valid ammo bin
<span class="nc bnc" id="L3511" title="All 2 branches missed.">            for (Mounted abin : shooter.getAmmo()) {</span>
<span class="nc bnc" id="L3512" title="All 2 branches missed.">                if (shooter.loadWeapon(shooter.getEquipment(atk.getWeaponId()), abin)) {</span>
<span class="nc bnc" id="L3513" title="All 2 branches missed.">                    if (abin.getUsableShotsLeft() &gt; 0) {</span>
<span class="nc" id="L3514">                        abin_type = (AmmoType) abin.getType();</span>
<span class="nc bnc" id="L3515" title="All 2 branches missed.">                        if (!AmmoType.canDeliverMinefield(abin_type)) {</span>

                            // Load weapon with specified bin
<span class="nc" id="L3518">                            shooter.loadWeapon(shooter.getEquipment(atk.getWeaponId()), abin);</span>
<span class="nc" id="L3519">                            atk.setAmmoId(shooter.getEquipmentNum(abin));</span>

                            // Get expected damage
<span class="nc" id="L3522">                            ex_damage = Compute.getExpectedDamage(cgame, atk, false);</span>

                            // Calculate any modifiers due to ammo type
<span class="nc" id="L3525">                            ammo_multiple = 1.0;</span>

                            // Frag missiles, flechette AC rounds do double
                            // damage against conventional infantry
                            // and 0 damage against everything else
                            // Any further anti-personnel specialized rounds
                            // should be tested for here
<span class="nc bnc" id="L3532" title="All 2 branches missed.">                            if (((((abin_type.getAmmoType() == AmmoType.T_LRM)</span>
<span class="nc bnc" id="L3533" title="All 2 branches missed.">                                    || (abin_type.getAmmoType() == AmmoType.T_LRM_IMP)</span>
<span class="nc bnc" id="L3534" title="All 2 branches missed.">                                    || (abin_type.getAmmoType() == AmmoType.T_MML)</span>
<span class="nc bnc" id="L3535" title="All 2 branches missed.">                                    || (abin_type.getAmmoType() == AmmoType.T_SRM)</span>
<span class="nc bnc" id="L3536" title="All 2 branches missed.">                                    || (abin_type.getAmmoType() == AmmoType.T_SRM_IMP)))</span>
<span class="nc bnc" id="L3537" title="All 2 branches missed.">                                    &amp;&amp; (abin_type.getMunitionType() == AmmoType.M_FRAGMENTATION))</span>
<span class="nc bnc" id="L3538" title="All 2 branches missed.">                                    || (((abin_type.getAmmoType() == AmmoType.T_AC)</span>
<span class="nc bnc" id="L3539" title="All 2 branches missed.">                                            || (abin_type.getAmmoType() == AmmoType.T_LAC)</span>
<span class="nc bnc" id="L3540" title="All 2 branches missed.">                                            || (abin_type.getAmmoType() == AmmoType.T_AC_IMP)</span>
<span class="nc bnc" id="L3541" title="All 2 branches missed.">                                            || (abin_type.getAmmoType() == AmmoType.T_PAC))</span>
<span class="nc bnc" id="L3542" title="All 2 branches missed.">                                            &amp;&amp; (abin_type.getMunitionType() == AmmoType.M_FLECHETTE))) {</span>
<span class="nc bnc" id="L3543" title="All 2 branches missed.">                                ammo_multiple = target.isConventionalInfantry() ? 2.0 : 0.0;</span>
                            }

                            // LBX cluster rounds work better against units
                            // with little armor, vehicles, and Meks in
                            // partial cover
                            // Other ammo that deliver lots of small
                            // submunitions should be tested for here too
<span class="nc bnc" id="L3551" title="All 2 branches missed.">                            if (((abin_type.getAmmoType() == AmmoType.T_AC_LBX)</span>
<span class="nc bnc" id="L3552" title="All 2 branches missed.">                                    || (abin_type.getAmmoType() == AmmoType.T_AC_LBX_THB)</span>
<span class="nc bnc" id="L3553" title="All 2 branches missed.">                                    || (abin_type.getAmmoType() == AmmoType.T_SBGAUSS))</span>
<span class="nc bnc" id="L3554" title="All 2 branches missed.">                                    &amp;&amp; (abin_type.getMunitionType() == AmmoType.M_CLUSTER)) {</span>
<span class="nc bnc" id="L3555" title="All 2 branches missed.">                                if (target.getArmorRemainingPercent() &lt;= 0.25) {</span>
<span class="nc" id="L3556">                                    ammo_multiple = 1.0 + (wtype.getRackSize() / 10.0);</span>
                                }
<span class="nc bnc" id="L3558" title="All 2 branches missed.">                                if (target instanceof Tank) {</span>
<span class="nc" id="L3559">                                    ammo_multiple += 1.0;</span>
                                }
                            }

                            // AP autocannon rounds work much better against
                            // Meks and vehicles than infantry,
                            // give a damage boost in proportion to calibre
                            // to reflect scaled crit chance
                            // Other armor-penetrating ammo types should be
                            // tested here, such as Tandem-charge SRMs
<span class="nc bnc" id="L3569" title="All 2 branches missed.">                            if (((abin_type.getAmmoType() == AmmoType.T_AC)</span>
<span class="nc bnc" id="L3570" title="All 2 branches missed.">                                    || (abin_type.getAmmoType() == AmmoType.T_LAC)</span>
<span class="nc bnc" id="L3571" title="All 2 branches missed.">                                    || (abin_type.getAmmoType() == AmmoType.T_AC_IMP)</span>
<span class="nc bnc" id="L3572" title="All 2 branches missed.">                                    || (abin_type.getAmmoType() == AmmoType.T_PAC))</span>
<span class="nc bnc" id="L3573" title="All 2 branches missed.">                                &amp;&amp; (abin_type.getMunitionType() == AmmoType.M_ARMOR_PIERCING)) {</span>
<span class="nc bnc" id="L3574" title="All 4 branches missed.">                                if ((target instanceof Mech)</span>
                                    || (target instanceof Tank)) {
<span class="nc" id="L3576">                                    ammo_multiple = 1.0 + (wtype.getRackSize() / 10);</span>
                                }
<span class="nc bnc" id="L3578" title="All 2 branches missed.">                                if (target instanceof Infantry) {</span>
<span class="nc" id="L3579">                                    ammo_multiple = 0.6;</span>
                                }
                            }

                            // Inferno SRMs work better against overheating
                            // Meks that are not/almost not on fire,
                            // and against vehicles and protos if allowed by
                            // game option
<span class="nc bnc" id="L3587" title="All 2 branches missed.">                            if (((abin_type.getAmmoType() == AmmoType.T_SRM)</span>
<span class="nc bnc" id="L3588" title="All 2 branches missed.">                                    || (abin_type.getAmmoType() == AmmoType.T_SRM_IMP)</span>
<span class="nc bnc" id="L3589" title="All 2 branches missed.">                                    || (abin_type.getAmmoType() == AmmoType.T_MML))</span>
<span class="nc bnc" id="L3590" title="All 2 branches missed.">                                &amp;&amp; (abin_type.getMunitionType() == AmmoType.M_INFERNO)) {</span>
<span class="nc" id="L3591">                                ammo_multiple = 0.5;</span>
<span class="nc bnc" id="L3592" title="All 2 branches missed.">                                if (target instanceof Mech) {</span>
<span class="nc bnc" id="L3593" title="All 4 branches missed.">                                    if ((target.infernos.getTurnsLeftToBurn() &lt; 4)</span>
                                        &amp;&amp; (target.heat &gt;= 5)) {
<span class="nc" id="L3595">                                        ammo_multiple = 1.1;</span>
                                    }
                                }
<span class="nc bnc" id="L3598" title="All 2 branches missed.">                                if ((target instanceof Tank)</span>
<span class="nc" id="L3599">                                    &amp;&amp; !(cgame.getOptions()</span>
<span class="nc bnc" id="L3600" title="All 2 branches missed.">                                              .booleanOption(OptionsConstants.ADVCOMBAT_VEHICLES_SAFE_FROM_INFERNOS))) {</span>
<span class="nc" id="L3601">                                    ammo_multiple = 1.1;</span>
                                }
<span class="nc bnc" id="L3603" title="All 2 branches missed.">                                if ((target instanceof Protomech)</span>
<span class="nc" id="L3604">                                    &amp;&amp; !(cgame.getOptions()</span>
<span class="nc bnc" id="L3605" title="All 2 branches missed.">                                              .booleanOption(OptionsConstants.ADVCOMBAT_PROTOS_SAFE_FROM_INFERNOS))) {</span>
<span class="nc" id="L3606">                                    ammo_multiple = 1.1;</span>
                                }
                            }

                            // Narc beacon doesn't really do damage but if
                            // the target is not infantry and doesn't have
                            // one, give 'em one by making it an attractive
                            // option
<span class="nc bnc" id="L3614" title="All 2 branches missed.">                            if ((wtype.getAmmoType() == AmmoType.T_NARC)</span>
<span class="nc bnc" id="L3615" title="All 2 branches missed.">                                    &amp;&amp; (abin_type.getMunitionType() == AmmoType.M_STANDARD)) {</span>
<span class="nc bnc" id="L3616" title="All 4 branches missed.">                                if (!(target.isNarcedBy(shooter.getOwner().getTeam()))</span>
                                        &amp;&amp; !(target instanceof Infantry)) {
<span class="nc" id="L3618">                                    ex_damage = 5.0;</span>
                                } else {
<span class="nc" id="L3620">                                    ex_damage = 0.5;</span>
                                }
                            }

                            // iNarc beacon doesn't really do damage, but if
                            // the target is not infantry and doesn't have
                            // one, give 'em one by making it an attractive
                            // option
<span class="nc bnc" id="L3628" title="All 2 branches missed.">                            if (wtype.getAmmoType() == AmmoType.T_INARC) {</span>
<span class="nc bnc" id="L3629" title="All 4 branches missed.">                                if ((abin_type.getMunitionType() == AmmoType.M_STANDARD)</span>
                                        &amp;&amp; !(target instanceof Infantry)) {
<span class="nc bnc" id="L3631" title="All 2 branches missed.">                                    if (!(target.isINarcedBy(shooter.getOwner().getTeam()))) {</span>
<span class="nc" id="L3632">                                        ex_damage = 7.0;</span>
                                    } else {
<span class="nc" id="L3634">                                        ex_damage = 1.0;</span>
                                    }
                                }

                                // iNarc ECM doesn't really do damage, but
                                // if the target has a C3 link or missile
                                // launchers
                                // make it a priority
                                // Checking for actual ammo types carried
                                // would be nice, but can't be sure of exact
                                // loads
                                // when &quot;true&quot; double blind is implemented
<span class="nc bnc" id="L3646" title="All 2 branches missed.">                                if ((abin_type.getAmmoType() == AmmoType.T_INARC)</span>
<span class="nc bnc" id="L3647" title="All 4 branches missed.">                                        &amp;&amp; (abin_type.getMunitionType() == AmmoType.M_ECM)</span>
                                        &amp;&amp; !(target instanceof Infantry)) {
<span class="nc bnc" id="L3649" title="All 2 branches missed.">                                    if (!target.isINarcedWith(AmmoType.M_ECM)) {</span>
<span class="nc bnc" id="L3650" title="All 2 branches missed.">                                        if (!(target.getC3MasterId() == Entity.NONE)</span>
<span class="nc bnc" id="L3651" title="All 2 branches missed.">                                                || target.hasC3M()</span>
<span class="nc bnc" id="L3652" title="All 2 branches missed.">                                                || target.hasC3MM()</span>
<span class="nc bnc" id="L3653" title="All 2 branches missed.">                                                || target.hasC3i()) {</span>
<span class="nc" id="L3654">                                            ex_damage = 8.0;</span>
                                        } else {
<span class="nc" id="L3656">                                            ex_damage = 0.5;</span>
                                        }
<span class="nc bnc" id="L3658" title="All 2 branches missed.">                                        for (Mounted weapon : shooter.getWeaponList()) {</span>
<span class="nc" id="L3659">                                            target_weapon = (WeaponType) weapon.getType();</span>
<span class="nc bnc" id="L3660" title="All 2 branches missed.">                                            if ((target_weapon.getAmmoType() == AmmoType.T_LRM)</span>
<span class="nc bnc" id="L3661" title="All 2 branches missed.">                                                    || (target_weapon.getAmmoType() == AmmoType.T_LRM_IMP)</span>
<span class="nc bnc" id="L3662" title="All 2 branches missed.">                                                    || (target_weapon.getAmmoType() == AmmoType.T_MML)</span>
<span class="nc bnc" id="L3663" title="All 2 branches missed.">                                                    || (target_weapon.getAmmoType() == AmmoType.T_SRM)</span>
<span class="nc bnc" id="L3664" title="All 2 branches missed.">                                                    || (target_weapon.getAmmoType() == AmmoType.T_SRM_IMP)) {</span>
<span class="nc" id="L3665">                                                ex_damage = ex_damage + (target_weapon.getRackSize() / 2);</span>
                                            }
<span class="nc" id="L3667">                                        }</span>
                                    }
                                }

                                // iNarc Nemesis doesn't really do damage,
                                // but if the target is not infantry and
                                // doesn't have
                                // one give it a try; make fast units a
                                // priority because they are usually out
                                // front
<span class="nc bnc" id="L3677" title="All 2 branches missed.">                                if ((abin_type.getAmmoType() == AmmoType.T_INARC)</span>
<span class="nc bnc" id="L3678" title="All 4 branches missed.">                                        &amp;&amp; (abin_type.getMunitionType() == AmmoType.M_NEMESIS)</span>
                                        &amp;&amp; !(target instanceof Infantry)) {
<span class="nc bnc" id="L3680" title="All 2 branches missed.">                                    if (!target.isINarcedWith(AmmoType.M_NEMESIS)) {</span>
<span class="nc" id="L3681">                                        ex_damage = (double) (target.getWalkMP() + target.getJumpMP()) / 2;</span>
                                    } else {
<span class="nc" id="L3683">                                        ex_damage = 0.5;</span>
                                    }
                                }
                            }

                            // If the adjusted damage is highest, store the
                            // damage and bin
<span class="nc bnc" id="L3690" title="All 2 branches missed.">                            if ((ex_damage * ammo_multiple) &gt; max_damage) {</span>
<span class="nc" id="L3691">                                max_damage = ex_damage * ammo_multiple;</span>
<span class="nc" id="L3692">                                best_bin = abin;</span>
                            }
                        }
                    }
                }
<span class="nc" id="L3697">            }</span>

            // Now that the best bin has been found, reload the weapon with
            // it
<span class="nc" id="L3701">            shooter.loadWeapon(shooter.getEquipment(atk.getWeaponId()),</span>
                               best_bin);
<span class="nc" id="L3703">            atk.setAmmoId(shooter.getEquipmentNum(best_bin));</span>
        }
<span class="nc" id="L3705">        return max_damage;</span>
    }

    /**
     * If this is an ultra or rotary cannon, lets see about 'spinning it up' for
     * extra damage
     *
     * @return the &lt;code&gt;int&lt;/code&gt; ID of weapon mode
     */
    public static int spinUpCannon(IGame cgame, WeaponAttackAction atk) {
<span class="nc" id="L3715">        return spinUpCannon(cgame, atk, Compute.d6(2) - 1);</span>
    }
    
    /**
     * If this is an ultra or rotary cannon, lets see about 'spinning it up' for
     * extra damage
     *
     * @return the &lt;code&gt;int&lt;/code&gt; ID of weapon mode
     */

    public static int spinUpCannon(IGame cgame, WeaponAttackAction atk, int spinupThreshold) {

<span class="fc" id="L3727">        int threshold = 12;</span>
        int final_spin;
        Entity shooter;
        Mounted weapon;
<span class="fc" id="L3731">        WeaponType wtype = new WeaponType();</span>

        // Double check this is an Ultra or Rotary cannon
        // or a standard AC with the TacOps rapid fire rule turned on
<span class="fc" id="L3735">        shooter = atk.getEntity(cgame);</span>
<span class="fc" id="L3736">        weapon = shooter.getEquipment(atk.getWeaponId());</span>
<span class="fc" id="L3737">        wtype = (WeaponType) shooter.getEquipment(atk.getWeaponId()).getType();</span>
        
<span class="pc bpc" id="L3739" title="3 of 4 branches missed.">        boolean rapidAC = (wtype.getAmmoType() == AmmoType.T_AC) &amp;&amp; cgame.getOptions().booleanOption(OptionsConstants.ADVCOMBAT_TACOPS_RAPID_AC);</span>

<span class="pc bpc" id="L3741" title="1 of 2 branches missed.">        if (!((wtype.getAmmoType() == AmmoType.T_AC_ULTRA)</span>
<span class="pc bpc" id="L3742" title="1 of 2 branches missed.">              || (wtype.getAmmoType() == AmmoType.T_AC_ULTRA_THB) </span>
<span class="pc bpc" id="L3743" title="2 of 4 branches missed.">              || (wtype.getAmmoType() == AmmoType.T_AC_ROTARY)</span>
              || rapidAC)) {
<span class="fc" id="L3745">            return 0;</span>
        }

        // Get the to-hit number
<span class="nc" id="L3749">        threshold = atk.toHit(cgame).getValue();</span>

        // Set the weapon to single shot mode
<span class="nc bnc" id="L3752" title="All 2 branches missed.">        weapon.setMode(rapidAC ? &quot;&quot; : Weapon.MODE_AC_SINGLE);</span>
<span class="nc" id="L3753">        final_spin = 0;</span>

        // If weapon can't hit target, exit the function with the weapon on
        // single shot
<span class="nc bnc" id="L3757" title="All 4 branches missed.">        if ((threshold == TargetRoll.IMPOSSIBLE)</span>
            || (threshold == TargetRoll.AUTOMATIC_FAIL)) {
<span class="nc" id="L3759">            return final_spin;</span>
        }

        // If random roll is &gt;= to-hit + 1, then set double-spin
<span class="nc bnc" id="L3763" title="All 2 branches missed.">        if (spinupThreshold &gt;= threshold) {</span>
<span class="nc" id="L3764">            final_spin = 1;</span>
<span class="nc bnc" id="L3765" title="All 2 branches missed.">            if ((wtype.getAmmoType() == AmmoType.T_AC_ULTRA)</span>
<span class="nc bnc" id="L3766" title="All 2 branches missed.">                || (wtype.getAmmoType() == AmmoType.T_AC_ULTRA_THB)) {</span>
<span class="nc" id="L3767">                weapon.setMode(Weapon.MODE_UAC_ULTRA);</span>
<span class="nc bnc" id="L3768" title="All 2 branches missed.">            } else if (wtype.getAmmoType() == AmmoType.T_AC_ROTARY) {</span>
<span class="nc" id="L3769">                weapon.setMode(Weapon.MODE_RAC_TWO_SHOT);</span>
<span class="nc bnc" id="L3770" title="All 2 branches missed.">            } else if (rapidAC) {</span>
<span class="nc" id="L3771">                weapon.setMode(Weapon.MODE_AC_RAPID);</span>
            }
        }

        // If this is a Rotary cannon
<span class="nc bnc" id="L3776" title="All 2 branches missed.">        if (wtype.getAmmoType() == AmmoType.T_AC_ROTARY) {</span>

            // If random roll is &gt;= to-hit + 2 then set to quad-spin
<span class="nc bnc" id="L3779" title="All 2 branches missed.">            if (spinupThreshold &gt;= (threshold + 1)) {</span>
<span class="nc" id="L3780">                final_spin = 2;</span>
<span class="nc" id="L3781">                weapon.setMode(Weapon.MODE_RAC_FOUR_SHOT);</span>
            }

            // If random roll is &gt;= to-hit + 3 then set to six-spin
<span class="nc bnc" id="L3785" title="All 2 branches missed.">            if (spinupThreshold &gt;= (threshold + 2)) {</span>
<span class="nc" id="L3786">                final_spin = 3;</span>
<span class="nc" id="L3787">                weapon.setMode(Weapon.MODE_RAC_SIX_SHOT);</span>
            }
        }
<span class="nc" id="L3790">        return final_spin;</span>
    }

    /**
     * Checks to see if a target is in arc of the specified weapon, on the
     * specified entity
     */
    public static boolean isInArc(IGame game, int attackerId, int weaponId,
            Targetable t) {
<span class="nc" id="L3799">        Entity ae = game.getEntity(attackerId);</span>
<span class="nc bnc" id="L3800" title="All 2 branches missed.">        if ((ae instanceof Mech)</span>
<span class="nc bnc" id="L3801" title="All 2 branches missed.">            &amp;&amp; (((Mech) ae).getGrappled() == t.getTargetId())) {</span>
<span class="nc" id="L3802">            return true;</span>
        }
<span class="nc bnc" id="L3804" title="All 2 branches missed.">        int facing = ae.isSecondaryArcWeapon(weaponId) ? ae</span>
<span class="nc" id="L3805">                .getSecondaryFacing() : ae.getFacing();</span>
<span class="nc bnc" id="L3806" title="All 2 branches missed.">        if ((ae instanceof Tank)</span>
<span class="nc" id="L3807">            &amp;&amp; (ae.getEquipment(weaponId).getLocation() == ((Tank) ae)</span>
<span class="nc bnc" id="L3808" title="All 2 branches missed.">                .getLocTurret2())) {</span>
<span class="nc" id="L3809">            facing = ((Tank) ae).getDualTurretFacing();</span>
        }
<span class="nc bnc" id="L3811" title="All 2 branches missed.">        if (ae.getEquipment(weaponId).isMechTurretMounted()) {</span>
<span class="nc" id="L3812">            facing = ae.getSecondaryFacing()</span>
<span class="nc" id="L3813">                     + (ae.getEquipment(weaponId).getFacing() % 6);</span>
        }
<span class="nc" id="L3815">        Coords aPos = ae.getPosition();</span>
<span class="nc" id="L3816">        Vector&lt;Coords&gt; tPosV = new Vector&lt;Coords&gt;();</span>
<span class="nc" id="L3817">        Coords tPos = t.getPosition();</span>
        // aeros in the same hex in space may still be able to fire at one
        // another. First I need to translate
        // their positions to see who was further back
<span class="nc bnc" id="L3821" title="All 2 branches missed.">        if (game.getBoard().inSpace()</span>
<span class="nc bnc" id="L3822" title="All 2 branches missed.">            &amp;&amp; ae.getPosition().equals(t.getPosition())</span>
<span class="nc bnc" id="L3823" title="All 4 branches missed.">            &amp;&amp; ae.isAero() &amp;&amp; t.isAero()) {</span>
<span class="nc" id="L3824">            int moveSort = shouldMoveBackHex(ae, (Entity)t);</span>
<span class="nc bnc" id="L3825" title="All 2 branches missed.">            if (moveSort &lt; 0) {</span>
<span class="nc" id="L3826">                aPos = ae.getPriorPosition();</span>
            }
<span class="nc bnc" id="L3828" title="All 2 branches missed.">            if (moveSort &gt; 0) {</span>
<span class="nc" id="L3829">                tPos = ((Entity) t).getPriorPosition();</span>
            }
        }

        // if using advanced AA options, then ground-to-air fire determines arc
        // by closest position
<span class="nc bnc" id="L3835" title="All 4 branches missed.">        if (isGroundToAir(ae, t) &amp;&amp; (t instanceof Entity)) {</span>
<span class="nc" id="L3836">            tPos = getClosestFlightPath(ae.getId(), ae.getPosition(),</span>
                    (Entity) t);
        }

        // AMS defending against Ground to Air fire needs to calculate arc based on the closest flight path
        // Technically it's an AirToGround attack since the AMS is on the aircraft
<span class="nc bnc" id="L3842" title="All 4 branches missed.">        if (isAirToGround(ae, t) &amp;&amp; (t instanceof Entity)</span>
<span class="nc bnc" id="L3843" title="All 2 branches missed.">                &amp;&amp; (ae.getEquipment(weaponId).getType().hasFlag(WeaponType.F_AMS)</span>
<span class="nc bnc" id="L3844" title="All 2 branches missed.">                        || ae.getEquipment(weaponId).getType().hasFlag(WeaponType.F_AMSBAY))) {</span>
<span class="nc" id="L3845">            Entity te = (Entity) t;</span>
<span class="nc" id="L3846">            aPos = getClosestFlightPath(te.getId(), te.getPosition(),</span>
                    ae);
        }

<span class="nc" id="L3850">        tPosV.add(tPos);</span>
        // check for secondary positions
<span class="nc bnc" id="L3852" title="All 2 branches missed.">        if ((t instanceof Entity)</span>
<span class="nc bnc" id="L3853" title="All 2 branches missed.">            &amp;&amp; (null != ((Entity) t).getSecondaryPositions())) {</span>
<span class="nc bnc" id="L3854" title="All 2 branches missed.">            for (int key : ((Entity) t).getSecondaryPositions().keySet()) {</span>
<span class="nc" id="L3855">                tPosV.add(((Entity) t).getSecondaryPositions().get(key));</span>
<span class="nc" id="L3856">            }</span>
        }
<span class="nc" id="L3858">        return Compute.isInArc(aPos, facing, tPosV, ae.getWeaponArc(weaponId));</span>
    }

    /**
     * Returns true if the line between source Coords and target goes through
     * the hex in front of the attacker
     */
    public static boolean isThroughFrontHex(IGame game, Coords src, Entity t) {
<span class="nc" id="L3866">        Coords dest = t.getPosition();</span>
<span class="nc" id="L3867">        int fa = dest.degree(src) - (t.getFacing() * 60);</span>
<span class="nc bnc" id="L3868" title="All 2 branches missed.">        if (fa &lt; 0) {</span>
<span class="nc" id="L3869">            fa += 360;</span>
        }
<span class="nc bnc" id="L3871" title="All 4 branches missed.">        return (fa &gt; 330) || (fa &lt; 30);</span>
    }
    
    /**
     * Converts the facing of a vehicular grenade launcher to the corresponding firing arc.
     * 
     * @param facing The VGL facing returned by {@link Mounted#getFacing()}
     * @return       The firing arc
     */
    public static int firingArcFromVGLFacing(int facing) {
<span class="nc" id="L3881">        return VGL_FIRING_ARCS[facing % 6];</span>
    }

    public static boolean isInArc(Coords src, int facing, Targetable target,
                                  int arc) {

<span class="nc" id="L3887">        Vector&lt;Coords&gt; tPosV = new Vector&lt;Coords&gt;();</span>
<span class="nc" id="L3888">        tPosV.add(target.getPosition());</span>
        // check for secondary positions
<span class="nc bnc" id="L3890" title="All 2 branches missed.">        if ((target instanceof Entity)</span>
<span class="nc bnc" id="L3891" title="All 2 branches missed.">            &amp;&amp; (null != ((Entity) target).getSecondaryPositions())) {</span>
<span class="nc bnc" id="L3892" title="All 2 branches missed.">            for (int key : ((Entity) target).getSecondaryPositions().keySet()) {</span>
<span class="nc" id="L3893">                tPosV.add(((Entity) target).getSecondaryPositions().get(key));</span>
<span class="nc" id="L3894">            }</span>
        }

<span class="nc" id="L3897">        return isInArc(src, facing, tPosV, arc);</span>
    }

    public static boolean isInArc(Coords src, int facing, Coords dest, int arc) {
<span class="nc" id="L3901">        Vector&lt;Coords&gt; destV = new Vector&lt;Coords&gt;();</span>
<span class="nc" id="L3902">        destV.add(dest);</span>
<span class="nc" id="L3903">        return isInArc(src, facing, destV, arc);</span>
    }

    /**
     * Returns true if the target is in the specified arc. Note: This has to
     * take vectors of coordinates to account for potential secondary positions
     *
     * @param src    the attack coordinates
     * @param facing the appropriate attacker sfacing
     * @param destV  A vector of target coordinates
     * @param arc    the arc
     */
    public static boolean isInArc(Coords src, int facing, Vector&lt;Coords&gt; destV,
                                  int arc) {
<span class="nc bnc" id="L3917" title="All 4 branches missed.">        if ((src == null) || (destV == null)) {</span>
<span class="nc" id="L3918">            return true;</span>
        }

        // Jay: I have to adjust this to take in vectors of coordinates to
        // account for secondary positions of the
        // target - I am fairly certain that secondary positions of the attacker
        // shouldn't matter because you don't get
        // to move the angle based on the secondary positions

        // if any of the destination coords are in the right place, then return
        // true
<span class="nc bnc" id="L3929" title="All 2 branches missed.">        for (Coords dest : destV) {</span>
            // calculate firing angle
<span class="nc" id="L3931">            int fa = src.degree(dest) - (facing * 60);</span>
<span class="nc bnc" id="L3932" title="All 2 branches missed.">            if (fa &lt; 0) {</span>
<span class="nc" id="L3933">                fa += 360;</span>
            }
            // is it in the specifed arc?
<span class="nc bnc" id="L3936" title="All 49 branches missed.">            switch (arc) {</span>
                case ARC_FORWARD:
<span class="nc bnc" id="L3938" title="All 4 branches missed.">                    if ((fa &gt;= 300) || (fa &lt;= 60)) {</span>
<span class="nc" id="L3939">                        return true;</span>
                    }
                    break;
                case Compute.ARC_RIGHTARM:
<span class="nc bnc" id="L3943" title="All 4 branches missed.">                    if ((fa &gt;= 300) || (fa &lt;= 120)) {</span>
<span class="nc" id="L3944">                        return true;</span>
                    }
                    break;
                case Compute.ARC_LEFTARM:
<span class="nc bnc" id="L3948" title="All 4 branches missed.">                    if ((fa &gt;= 240) || (fa &lt;= 60)) {</span>
<span class="nc" id="L3949">                        return true;</span>
                    }
                    break;
                case ARC_REAR:
<span class="nc bnc" id="L3953" title="All 4 branches missed.">                    if ((fa &gt; 120) &amp;&amp; (fa &lt; 240)) {</span>
<span class="nc" id="L3954">                        return true;</span>
                    }
                    break;
                case ARC_RIGHTSIDE:
<span class="nc bnc" id="L3958" title="All 4 branches missed.">                    if ((fa &gt; 60) &amp;&amp; (fa &lt;= 120)) {</span>
<span class="nc" id="L3959">                        return true;</span>
                    }
                    break;
                case ARC_LEFTSIDE:
<span class="nc bnc" id="L3963" title="All 4 branches missed.">                    if ((fa &lt; 300) &amp;&amp; (fa &gt;= 240)) {</span>
<span class="nc" id="L3964">                        return true;</span>
                    }
                    break;
                case ARC_MAINGUN:
<span class="nc bnc" id="L3968" title="All 4 branches missed.">                    if ((fa &gt;= 240) || (fa &lt;= 120)) {</span>
<span class="nc" id="L3969">                        return true;</span>
                    }
                    break;
                case ARC_360:
<span class="nc" id="L3973">                    return true;</span>
                case ARC_NORTH:
<span class="nc bnc" id="L3975" title="All 4 branches missed.">                    if ((fa &gt;= 270) || (fa &lt;= 30)) {</span>
<span class="nc" id="L3976">                        return true;</span>
                    }
                    break;
                case ARC_EAST:
<span class="nc bnc" id="L3980" title="All 4 branches missed.">                    if ((fa &gt;= 30) &amp;&amp; (fa &lt;= 150)) {</span>
<span class="nc" id="L3981">                        return true;</span>
                    }
                    break;
                case ARC_WEST:
<span class="nc bnc" id="L3985" title="All 4 branches missed.">                    if ((fa &gt;= 150) &amp;&amp; (fa &lt;= 270)) {</span>
<span class="nc" id="L3986">                        return true;</span>
                    }
                    break;
                case ARC_NOSE:
<span class="nc bnc" id="L3990" title="All 4 branches missed.">                    if ((fa &gt; 300) || (fa &lt; 60)) {</span>
<span class="nc" id="L3991">                        return true;</span>
                    }
                    break;
                case ARC_NOSE_WPL:
<span class="nc bnc" id="L3995" title="All 4 branches missed.">                    if ((fa &gt; 240) || (fa &lt; 120)) {</span>
<span class="nc" id="L3996">                        return true;</span>
                    }
                    break;
                case ARC_LWING:
<span class="nc bnc" id="L4000" title="All 4 branches missed.">                    if ((fa &gt; 300) || (fa &lt;= 0)) {</span>
<span class="nc" id="L4001">                        return true;</span>
                    }
                    break;
                case ARC_LWING_WPL:
<span class="nc bnc" id="L4005" title="All 4 branches missed.">                    if ((fa &gt; 240) || (fa &lt; 60)) {</span>
<span class="nc" id="L4006">                        return true;</span>
                    }
                    break;
                case ARC_RWING:
<span class="nc bnc" id="L4010" title="All 4 branches missed.">                    if ((fa &gt;= 0) &amp;&amp; (fa &lt; 60)) {</span>
<span class="nc" id="L4011">                        return true;</span>
                    }
                    break;
                case ARC_RWING_WPL:
<span class="nc bnc" id="L4015" title="All 4 branches missed.">                    if ((fa &gt; 300) || (fa &lt; 120)) {</span>
<span class="nc" id="L4016">                        return true;</span>
                    }
                    break;
                case ARC_LWINGA:
<span class="nc bnc" id="L4020" title="All 4 branches missed.">                    if ((fa &gt;= 180) &amp;&amp; (fa &lt; 240)) {</span>
<span class="nc" id="L4021">                        return true;</span>
                    }
                    break;
                case ARC_LWINGA_WPL:
<span class="nc bnc" id="L4025" title="All 4 branches missed.">                    if ((fa &gt; 120) &amp;&amp; (fa &lt; 300)) {</span>
<span class="nc" id="L4026">                        return true;</span>
                    }
                    break;
                case ARC_RWINGA:
<span class="nc bnc" id="L4030" title="All 4 branches missed.">                    if ((fa &gt; 120) &amp;&amp; (fa &lt;= 180)) {</span>
<span class="nc" id="L4031">                        return true;</span>
                    }
                    break;
                case ARC_RWINGA_WPL:
<span class="nc bnc" id="L4035" title="All 4 branches missed.">                    if ((fa &gt; 60) &amp;&amp; (fa &lt; 240)) {</span>
<span class="nc" id="L4036">                        return true;</span>
                    }
                    break;
                case ARC_AFT:
<span class="nc bnc" id="L4040" title="All 4 branches missed.">                    if ((fa &gt; 120) &amp;&amp; (fa &lt; 240)) {</span>
<span class="nc" id="L4041">                        return true;</span>
                    }
                    break;
                case ARC_AFT_WPL:
<span class="nc bnc" id="L4045" title="All 4 branches missed.">                    if ((fa &gt; 60) &amp;&amp; (fa &lt; 300)) {</span>
<span class="nc" id="L4046">                        return true;</span>
                    }
                    break;
                case ARC_LEFTSIDE_SPHERE:
<span class="nc bnc" id="L4050" title="All 4 branches missed.">                    if ((fa &gt; 240) || (fa &lt; 0)) {</span>
<span class="nc" id="L4051">                        return true;</span>
                    }
                    break;
                case ARC_LEFTSIDE_SPHERE_WPL:
<span class="nc bnc" id="L4055" title="All 4 branches missed.">                    if ((fa &gt; 180) || (fa &lt; 60)) {</span>
<span class="nc" id="L4056">                        return true;</span>
                    }
                    break;
                case ARC_RIGHTSIDE_SPHERE:
<span class="nc bnc" id="L4060" title="All 4 branches missed.">                    if ((fa &gt; 0) &amp;&amp; (fa &lt; 120)) {</span>
<span class="nc" id="L4061">                        return true;</span>
                    }
                    break;
                case ARC_RIGHTSIDE_SPHERE_WPL:
<span class="nc bnc" id="L4065" title="All 4 branches missed.">                    if ((fa &gt; 300) || (fa &lt; 180)) {</span>
<span class="nc" id="L4066">                        return true;</span>
                    }
                    break;
                case ARC_LEFTSIDEA_SPHERE:
<span class="nc bnc" id="L4070" title="All 4 branches missed.">                    if ((fa &gt; 180) &amp;&amp; (fa &lt; 300)) {</span>
<span class="nc" id="L4071">                        return true;</span>
                    }
                    break;
                case ARC_LEFTSIDEA_SPHERE_WPL:
<span class="nc bnc" id="L4075" title="All 4 branches missed.">                    if ((fa &gt; 120) &amp;&amp; (fa &lt; 360)) {</span>
<span class="nc" id="L4076">                        return true;</span>
                    }
                    break;
                case ARC_RIGHTSIDEA_SPHERE:
<span class="nc bnc" id="L4080" title="All 4 branches missed.">                    if ((fa &gt; 60) &amp;&amp; (fa &lt; 180)) {</span>
<span class="nc" id="L4081">                        return true;</span>
                    }
                    break;
                case ARC_RIGHTSIDEA_SPHERE_WPL:
<span class="nc bnc" id="L4085" title="All 4 branches missed.">                    if ((fa &gt; 0) &amp;&amp; (fa &lt; 240)) {</span>
<span class="nc" id="L4086">                        return true;</span>
                    }
                    break;
                case ARC_LEFT_BROADSIDE:
<span class="nc bnc" id="L4090" title="All 4 branches missed.">                    if ((fa &gt;= 240) &amp;&amp; (fa &lt;= 300)) {</span>
<span class="nc" id="L4091">                        return true;</span>
                    }
                    break;
                case ARC_LEFT_BROADSIDE_WPL:
<span class="nc bnc" id="L4095" title="All 4 branches missed.">                    if ((fa &gt; 180) &amp;&amp; (fa &lt;= 360)) {</span>
<span class="nc" id="L4096">                        return true;</span>
                    }
                    break;
                case ARC_RIGHT_BROADSIDE:
<span class="nc bnc" id="L4100" title="All 4 branches missed.">                    if ((fa &gt;= 60) &amp;&amp; (fa &lt;= 120)) {</span>
<span class="nc" id="L4101">                        return true;</span>
                    }
                    break;
                case ARC_RIGHT_BROADSIDE_WPL:
<span class="nc bnc" id="L4105" title="All 4 branches missed.">                    if ((fa &gt; 0) &amp;&amp; (fa &lt; 180)) {</span>
<span class="nc" id="L4106">                        return true;</span>
                    }
                    break;
                case ARC_LEFT_SPHERE_GROUND:
<span class="nc bnc" id="L4110" title="All 4 branches missed.">                    if ((fa &gt;= 180) &amp;&amp; (fa &lt; 360)) {</span>
<span class="nc" id="L4111">                        return true;</span>
                    }
                    break;
                case ARC_RIGHT_SPHERE_GROUND:
<span class="nc bnc" id="L4115" title="All 4 branches missed.">                    if ((fa &gt;= 0) &amp;&amp; (fa &lt; 180)) {</span>
<span class="nc" id="L4116">                        return true;</span>
                    }
                    break;
                case ARC_TURRET:
<span class="nc bnc" id="L4120" title="All 4 branches missed.">                    if ((fa &gt;= 330) || (fa &lt;= 30)) {</span>
<span class="nc" id="L4121">                        return true;</span>
                    }
                    break;
                case ARC_SPONSON_TURRET_LEFT:
                case ARC_PINTLE_TURRET_LEFT:
<span class="nc bnc" id="L4126" title="All 4 branches missed.">                    if ((fa &gt;= 180) || (fa == 0)) {</span>
<span class="nc" id="L4127">                        return true;</span>
                    }
                    break;
                case ARC_SPONSON_TURRET_RIGHT:
                case ARC_PINTLE_TURRET_RIGHT:
<span class="nc bnc" id="L4132" title="All 4 branches missed.">                    if ((fa &gt;= 0) &amp;&amp; (fa &lt;= 180)) {</span>
<span class="nc" id="L4133">                        return true;</span>
                    }
                    break;
                case ARC_PINTLE_TURRET_FRONT:
<span class="nc bnc" id="L4137" title="All 4 branches missed.">                    if ((fa &gt;= 270) || (fa &lt;= 90)) {</span>
<span class="nc" id="L4138">                        return true;</span>
                    }
                    break;
                case ARC_PINTLE_TURRET_REAR:
<span class="nc bnc" id="L4142" title="All 4 branches missed.">                    if ((fa &gt;= 90) &amp;&amp; (fa &lt;= 270)) {</span>
<span class="nc" id="L4143">                        return true;</span>
                    }
                    break;
                case ARC_VGL_FRONT:
<span class="nc bnc" id="L4147" title="All 4 branches missed.">                    return (fa &gt;= 270) || (fa &lt;= 90);</span>
                case ARC_VGL_RF:
<span class="nc bnc" id="L4149" title="All 4 branches missed.">                    return (fa &gt;= 330) || (fa &lt;= 150);</span>
                case ARC_VGL_RR:
<span class="nc bnc" id="L4151" title="All 4 branches missed.">                    return (fa &gt;= 30) &amp;&amp; (fa &lt;= 210);</span>
                case ARC_VGL_REAR:
<span class="nc bnc" id="L4153" title="All 4 branches missed.">                    return (fa &gt;= 90) &amp;&amp; (fa &lt;= 270);</span>
                case ARC_VGL_LR:
<span class="nc bnc" id="L4155" title="All 4 branches missed.">                    return (fa &gt;= 150) &amp;&amp; (fa &lt;= 330);</span>
                case ARC_VGL_LF:
<span class="nc bnc" id="L4157" title="All 4 branches missed.">                    return (fa &gt;= 210) || (fa &lt;= 30);</span>
            }
<span class="nc" id="L4159">        }</span>
        // if we got here then no matches
<span class="nc" id="L4161">        return false;</span>
    }

    /**
     * checks to see whether the target is within visual range of the entity,
     * but not necessarily LoS
     */
    public static boolean inVisualRange(IGame game, Entity ae, Targetable target) {
<span class="nc" id="L4169">        return inVisualRange(game, null, ae, target);</span>
    }

    /**
     * Determine whether the attacking entity is within visual range of the
     * target.  This requires line of sight effects to determine if there are
     * certain intervening obstructions, like smoke, that can reduce visual
     * range.  Since repeated LoSEffects computations can be expensive, it is
     * possible to pass in the LosEffects, since they are commonly already
     * computed when this method is called.
     *
     * @param game
     * @param los
     * @param ae
     * @param target
     * @return
     */
    public static boolean inVisualRange(IGame game, LosEffects los, Entity ae,
            Targetable target) {
        //Use firing solution if Advanced Sensors is on
<span class="nc bnc" id="L4189" title="All 2 branches missed.">        if (game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_STRATOPS_ADVANCED_SENSORS)</span>
<span class="nc bnc" id="L4190" title="All 2 branches missed.">                &amp;&amp; target.getTargetType() == Targetable.TYPE_ENTITY</span>
<span class="nc bnc" id="L4191" title="All 2 branches missed.">                &amp;&amp; game.getBoard().inSpace()) {</span>
<span class="nc" id="L4192">            Entity te = (Entity) target;</span>
<span class="nc" id="L4193">            return hasAnyFiringSolution(game, te.getId());</span>
        }
<span class="nc" id="L4195">        boolean teIlluminated = false;</span>
<span class="nc bnc" id="L4196" title="All 2 branches missed.">        if (target.getTargetType() == Targetable.TYPE_ENTITY) {</span>
<span class="nc" id="L4197">            Entity te = (Entity) target;</span>
<span class="nc" id="L4198">            teIlluminated = te.isIlluminated();</span>
<span class="nc bnc" id="L4199" title="All 2 branches missed.">            if (te.isOffBoard()) {</span>
<span class="nc" id="L4200">                return false;</span>
            }
        }

        // Target may be in an illuminated hex
<span class="nc bnc" id="L4205" title="All 2 branches missed.">        if (!teIlluminated) {</span>
<span class="nc" id="L4206">            int lightLvl = game.isPositionIlluminated(target.getPosition());</span>
<span class="nc bnc" id="L4207" title="All 2 branches missed.">            teIlluminated = lightLvl != Game.ILLUMINATED_NONE;</span>
        }

        // if either does not have a position then return false
<span class="nc bnc" id="L4211" title="All 4 branches missed.">        if ((ae.getPosition() == null) || (target.getPosition() == null)) {</span>
<span class="nc" id="L4212">            return false;</span>
        }

        // check visual range based on planetary conditions
<span class="nc bnc" id="L4216" title="All 2 branches missed.">        if (los == null) {</span>
<span class="nc" id="L4217">            los = LosEffects.calculateLos(game, ae.getId(), target);</span>
        }
<span class="nc" id="L4219">        int visualRange = getVisualRange(game, ae, los, teIlluminated);</span>

        //Check for factors that only apply to an entity target
<span class="nc" id="L4222">        Coords targetPos = target.getPosition();</span>
<span class="nc bnc" id="L4223" title="All 2 branches missed.">        if (target.getTargetType() == Targetable.TYPE_ENTITY) {</span>
<span class="nc" id="L4224">            Entity te = (Entity) target;</span>

            // check for camo and null sig on the target
<span class="nc bnc" id="L4227" title="All 2 branches missed.">            if (te.isVoidSigActive()) {</span>
<span class="nc" id="L4228">                visualRange = visualRange / 4;</span>
<span class="nc bnc" id="L4229" title="All 2 branches missed.">            } else if (te.hasWorkingMisc(MiscType.F_VISUAL_CAMO, -1)) {</span>
<span class="nc" id="L4230">                visualRange = visualRange / 2;</span>
<span class="nc bnc" id="L4231" title="All 2 branches missed.">            } else if (te.isChameleonShieldActive()) {</span>
<span class="nc" id="L4232">                visualRange = visualRange / 2;</span>
<span class="nc bnc" id="L4233" title="All 4 branches missed.">            } else if (te.isConventionalInfantry() &amp;&amp; ((Infantry) te).hasSneakCamo()) {</span>
<span class="nc" id="L4234">                visualRange = visualRange / 2;</span>
            }

            // Ground targets pick the closest path to Aeros (TW pg 107)
<span class="nc bnc" id="L4238" title="All 4 branches missed.">            if ((te.isAero()) &amp;&amp; isGroundToAir(ae, target)) {</span>
<span class="nc" id="L4239">                targetPos = Compute.getClosestFlightPath(ae.getId(),</span>
<span class="nc" id="L4240">                        ae.getPosition(), te);</span>
            }
            //Airborne aeros can only see ground targets they overfly, and only at Alt &lt;=8
<span class="nc bnc" id="L4243" title="All 2 branches missed.">            if (isAirToGround(ae, target)) {</span>
<span class="nc bnc" id="L4244" title="All 2 branches missed.">                if (ae.getAltitude() &gt; 8) {</span>
<span class="nc" id="L4245">                    return false;</span>
                }
<span class="nc bnc" id="L4247" title="All 2 branches missed.">                if (ae.passedOver(target)) {</span>
<span class="nc" id="L4248">                    return true;</span>
                } else {
<span class="nc" id="L4250">                    return false;</span>
                }
            }
        }

<span class="nc" id="L4255">        visualRange = Math.max(visualRange, 1);</span>
        int distance;
        // Ground distance
<span class="nc" id="L4258">        distance = ae.getPosition().distance(targetPos);</span>
        //Need to track difference in altitude, not just add altitude to the range
<span class="nc" id="L4260">        distance += Math.abs(2 * target.getAltitude() - 2 * ae.getAltitude());</span>
<span class="nc bnc" id="L4261" title="All 2 branches missed.">        return distance &lt;= visualRange;</span>

    }

    //Space Combat Detection stuff

    /**
     * Checks to see if an entity has already been detected by anyone
     * Used for sensor return icons on board
     *
     * @param game - the current game
     * @param targetId - the ID# of the target entity we're looking for
     */
    public static boolean isAnySensorContact(IGame game, int targetId) {
<span class="nc bnc" id="L4275" title="All 2 branches missed.">        for (Entity detector : game.getEntitiesVector()) {</span>
<span class="nc bnc" id="L4276" title="All 4 branches missed.">            if (detector.hasSensorContactFor(targetId) &amp;&amp; game.getEntity(targetId) != null) {</span>
<span class="nc" id="L4277">                game.getEntity(targetId).addBeenDetectedBy(detector.getOwner());</span>
<span class="nc" id="L4278">                return true;</span>
            }
<span class="nc" id="L4280">        }</span>
<span class="nc" id="L4281">        return false;</span>
    }

    /**
     * Checks to see if target entity has already appeared on @detector's sensors
     * Used with Naval C3 to determine if @detector can fire weapons at @target
     * @param detector - the entity making a sensor scan
     * @param targetId - the entity id of the scan target
     */
    public static boolean hasSensorContact(Entity detector, int targetId) {
<span class="nc" id="L4291">        return detector.hasSensorContactFor(targetId);</span>
    }

    /**
     * Checks to see if an entity is in anyone's firing solutions list
     * Used for visibility
     *
     * @param game - the current game
     * @param targetId - the ID # of the target we're firing at
     */
    public static boolean hasAnyFiringSolution(IGame game, int targetId) {
<span class="nc bnc" id="L4302" title="All 2 branches missed.">        for (Entity detector : game.getEntitiesVector()) {</span>
<span class="nc bnc" id="L4303" title="All 4 branches missed.">            if (detector.hasFiringSolutionFor(targetId) &amp;&amp; game.getEntity(targetId) != null) {</span>
<span class="nc" id="L4304">                game.getEntity(targetId).addBeenSeenBy(detector.getOwner());</span>
<span class="nc" id="L4305">                return true;</span>
            }
<span class="nc" id="L4307">        }</span>
<span class="nc" id="L4308">        return false;</span>
    }

    /**
     * Calculates the ECM effects in play between a detector and target pair
     *
     * @param game - the current game
     * @param ae - the entity making a sensor scan
     * @param target - the entity we're trying to spot
     * @return
     */
    private static int calcSpaceECM(IGame game, Entity ae,
            Targetable target) {
<span class="nc" id="L4321">        int mod = 0;</span>
<span class="nc" id="L4322">        int ecm = ComputeECM.getLargeCraftECM(ae, ae.getPosition(), target.getPosition());</span>
<span class="nc bnc" id="L4323" title="All 2 branches missed.">        if (!ae.isLargeCraft()) {</span>
<span class="nc" id="L4324">            ecm += ComputeECM.getSmallCraftECM(ae, ae.getPosition(), target.getPosition());</span>
        }
<span class="nc" id="L4326">        ecm = Math.min(4, ecm);</span>
<span class="nc" id="L4327">        int eccm = 0;</span>
<span class="nc bnc" id="L4328" title="All 2 branches missed.">        if (ae.isLargeCraft()) {</span>
<span class="nc" id="L4329">            eccm = ((Aero) ae).getECCMBonus();</span>
        }
<span class="nc bnc" id="L4331" title="All 2 branches missed.">        if (ecm &gt; 0) {</span>
<span class="nc" id="L4332">            mod += ecm;</span>
<span class="nc bnc" id="L4333" title="All 2 branches missed.">            if (eccm &gt; 0) {</span>
<span class="nc" id="L4334">                mod -= (Math.min(ecm, eccm));</span>
            }
        }
<span class="nc" id="L4337">        return mod;</span>
    }

    /**
     * Calculates the Sensor Shadow effect in play between a detector and target pair
     *
     * @param game - the current game
     * @param ae - the entity making a sensor scan
     * @param target - the entity we're trying to spot
     * @return
     */
    private static int calcSensorShadow(IGame game, Entity ae,
            Targetable target) {
<span class="nc" id="L4350">        int mod = 0;</span>
<span class="nc bnc" id="L4351" title="All 2 branches missed.">        if (target.getTargetType() != Targetable.TYPE_ENTITY) {</span>
<span class="nc" id="L4352">            return 0;</span>
        }
<span class="nc" id="L4354">        Entity te = (Entity) target;</span>
<span class="nc bnc" id="L4355" title="All 2 branches missed.">        for (Entity en : Compute.getAdjacentEntitiesAlongAttack(ae.getPosition(), target.getPosition(), game)) {</span>
<span class="nc bnc" id="L4356" title="All 8 branches missed.">            if (!en.isEnemyOf(te) &amp;&amp; en.isLargeCraft() &amp;&amp; !en.equals((Entity) te) &amp;&amp; ((en.getWeight() - te.getWeight()) &gt;= -100000.0)) {</span>
<span class="nc" id="L4357">                mod ++;</span>
<span class="nc" id="L4358">                break;</span>
            }
<span class="nc" id="L4360">        }</span>
<span class="nc bnc" id="L4361" title="All 2 branches missed.">        for (Entity en : game.getEntitiesVector(target.getPosition())) {</span>
<span class="nc bnc" id="L4362" title="All 8 branches missed.">            if (!en.isEnemyOf(te) &amp;&amp; en.isLargeCraft() &amp;&amp; !en.equals((Entity) ae) &amp;&amp; !en.equals((Entity) te)</span>
<span class="nc bnc" id="L4363" title="All 2 branches missed.">                    &amp;&amp; ((en.getWeight() - te.getWeight()) &gt;= -100000.0)) {</span>
<span class="nc" id="L4364">                mod ++;</span>
<span class="nc" id="L4365">                break;</span>
            }
<span class="nc" id="L4367">        }</span>
<span class="nc" id="L4368">        return mod;</span>
    }

    /**
     * Updates an entity's firingSolutions, removing any objects that no longer meet criteria for being
     * tracked as targets. Also, if the detecting entity no longer meets criteria for having firing solutions,
     * empty the list. We wouldn't want a dead ship to be providing NC3 data, now would we...
     */
    public static void updateFiringSolutions(IGame game, Entity detector) {
<span class="nc" id="L4377">        List&lt;Integer&gt; toRemove = new ArrayList&lt;Integer&gt;();</span>
        //Flush the detecting unit's firing solutions if any of these conditions applies
<span class="nc bnc" id="L4379" title="All 2 branches missed.">        if (detector.isDestroyed()</span>
<span class="nc bnc" id="L4380" title="All 2 branches missed.">                || detector.isDoomed()</span>
<span class="nc bnc" id="L4381" title="All 2 branches missed.">                || detector.getTransportId() != Entity.NONE</span>
<span class="nc bnc" id="L4382" title="All 2 branches missed.">                || detector.isPartOfFighterSquadron()</span>
<span class="nc bnc" id="L4383" title="All 2 branches missed.">                || detector.isOffBoard()</span>
<span class="nc bnc" id="L4384" title="All 2 branches missed.">                || detector.getPosition() == null) {</span>
<span class="nc" id="L4385">            detector.clearFiringSolutions();</span>
<span class="nc" id="L4386">            return;</span>
        }
<span class="nc bnc" id="L4388" title="All 2 branches missed.">        for (int id : detector.getFiringSolutions()) {</span>
<span class="nc" id="L4389">            Entity target = game.getEntity(id);</span>
            //The target should be removed if it's off the board for any of these reasons
<span class="nc bnc" id="L4391" title="All 2 branches missed.">            if (target == null</span>
<span class="nc bnc" id="L4392" title="All 2 branches missed.">                    || target.getPosition() == null</span>
<span class="nc bnc" id="L4393" title="All 2 branches missed.">                    || target.isDestroyed()</span>
<span class="nc bnc" id="L4394" title="All 2 branches missed.">                    || target.isDoomed()</span>
<span class="nc bnc" id="L4395" title="All 2 branches missed.">                    || target.getTransportId() != Entity.NONE</span>
<span class="nc bnc" id="L4396" title="All 2 branches missed.">                    || target.isPartOfFighterSquadron()</span>
<span class="nc bnc" id="L4397" title="All 2 branches missed.">                    || target.isOffBoard()) {</span>
<span class="nc" id="L4398">                toRemove.add(id);</span>
<span class="nc" id="L4399">                continue;</span>
            }
<span class="nc" id="L4401">            Coords targetPos = target.getPosition();</span>
<span class="nc" id="L4402">            int distance = detector.getPosition().distance(targetPos);</span>
            //Per SO p119, optical firing solutions are lost if the target moves beyond 1/10 max range
<span class="nc bnc" id="L4404" title="All 4 branches missed.">            if (detector.getActiveSensor().getType() == Sensor.TYPE_AERO_THERMAL</span>
                    &amp;&amp; distance &gt; Sensor.ASF_OPTICAL_FIRING_SOLUTION_RANGE) {
<span class="nc" id="L4406">                    toRemove.add(id);</span>
<span class="nc bnc" id="L4407" title="All 4 branches missed.">            } else if (detector.getActiveSensor().getType() == Sensor.TYPE_SPACECRAFT_THERMAL</span>
                    &amp;&amp; distance &gt; Sensor.LC_OPTICAL_FIRING_SOLUTION_RANGE) {
<span class="nc" id="L4409">                    toRemove.add(id);</span>
            //For ASF sensors, make sure we're using the space range of 555...
<span class="nc bnc" id="L4411" title="All 4 branches missed.">            } else if (detector.getActiveSensor().getType() == Sensor.TYPE_AERO_SENSOR</span>
                    &amp;&amp; distance &gt; Sensor.ASF_RADAR_MAX_RANGE) {
<span class="nc" id="L4413">                    toRemove.add(id);</span>
            } else {
                //Radar firing solutions are only lost if the target moves out of range
<span class="nc bnc" id="L4416" title="All 2 branches missed.">                if (distance &gt; detector.getActiveSensor().getRangeByBracket()) {</span>
<span class="nc" id="L4417">                    toRemove.add(id);</span>
                }
            }
<span class="nc" id="L4420">        }</span>
<span class="nc" id="L4421">        detector.removeFiringSolution(toRemove);</span>
<span class="nc" id="L4422">    }</span>

    /**
     * Updates an entity's sensorContacts, removing any objects that no longer meet criteria for being
     * tracked. Also, if the detecting entity no longer meets criteria for having sensor contacts,
     * empty the list. We wouldn't want a dead ship to be providing sensor data, now would we...
     */
    public static void updateSensorContacts(IGame game, Entity detector) {
<span class="nc" id="L4430">        List&lt;Integer&gt; toRemove = new ArrayList&lt;Integer&gt;();</span>
        //Flush the detecting unit's sensor contacts if any of these conditions applies
<span class="nc bnc" id="L4432" title="All 2 branches missed.">        if (detector.getPosition() == null</span>
<span class="nc bnc" id="L4433" title="All 2 branches missed.">                || detector.isDestroyed()</span>
<span class="nc bnc" id="L4434" title="All 2 branches missed.">                || detector.isDoomed()</span>
<span class="nc bnc" id="L4435" title="All 2 branches missed.">                || detector.getTransportId() != Entity.NONE</span>
<span class="nc bnc" id="L4436" title="All 2 branches missed.">                || detector.isPartOfFighterSquadron()</span>
<span class="nc bnc" id="L4437" title="All 2 branches missed.">                || detector.isOffBoard()) {</span>
<span class="nc" id="L4438">            detector.clearSensorContacts();</span>
<span class="nc" id="L4439">            return;</span>
        }
<span class="nc bnc" id="L4441" title="All 2 branches missed.">        for (int id : detector.getSensorContacts()) {</span>
<span class="nc" id="L4442">            Entity target = game.getEntity(id);</span>
            //The target should be removed if it's off the board for any of these reasons
<span class="nc bnc" id="L4444" title="All 2 branches missed.">            if (target == null</span>
<span class="nc bnc" id="L4445" title="All 2 branches missed.">                    || target.getPosition() == null</span>
<span class="nc bnc" id="L4446" title="All 2 branches missed.">                    || target.isDestroyed()</span>
<span class="nc bnc" id="L4447" title="All 2 branches missed.">                    || target.isDoomed()</span>
<span class="nc bnc" id="L4448" title="All 2 branches missed.">                    || target.getTransportId() != Entity.NONE</span>
<span class="nc bnc" id="L4449" title="All 2 branches missed.">                    || target.isPartOfFighterSquadron()</span>
<span class="nc bnc" id="L4450" title="All 2 branches missed.">                    || target.isOffBoard()) {</span>
<span class="nc" id="L4451">                toRemove.add(id);</span>
<span class="nc" id="L4452">                continue;</span>
            }
            //And now calculate whether or not the target has moved out of range. Per SO p117-119,
            //sensor contacts remain tracked on the plotting board until this occurs.
<span class="nc" id="L4456">            Coords targetPos = target.getPosition();</span>
<span class="nc" id="L4457">            int distance = detector.getPosition().distance(targetPos);</span>
<span class="nc bnc" id="L4458" title="All 2 branches missed.">            if (distance &gt; detector.getActiveSensor().getRangeByBracket()) {</span>
<span class="nc" id="L4459">                toRemove.add(id);</span>
            }
<span class="nc" id="L4461">        }</span>
<span class="nc" id="L4462">        detector.removeSensorContact(toRemove);</span>
<span class="nc" id="L4463">    }</span>


    /**
     *If the game is in space, &quot;visual range&quot; represents a firing solution as defined in SO starting on p117
     *Also, in most cases each target must be detected with sensors before it can be seen, so we need to make
     *sensor rolls for detection. This should only be used if Tacops sensor rules are in use.
     * This requires line of sight effects to determine if there are
     * certain intervening obstructions, like sensor shadows, asteroids and that sort of thing, that can reduce visual
     * range.  Since repeated LoSEffects computations can be expensive, it is
     * possible to pass in the LosEffects, since they are commonly already
     * computed when this method is called.
     *
     * @param game - the current game
     * @param ae - the entity making a sensor scan
     * @param target - the entity we're trying to spot
     * @return
     */

    public static boolean calcFiringSolution(IGame game, Entity ae,
            Targetable target) {
<span class="nc bnc" id="L4484" title="All 2 branches missed.">        if (target.getTargetType() == Targetable.TYPE_ENTITY) {</span>
<span class="nc" id="L4485">            Entity te = (Entity) target;</span>
<span class="nc bnc" id="L4486" title="All 2 branches missed.">            if (te.isOffBoard()) {</span>
<span class="nc" id="L4487">                return false;</span>
            }
        }

        //NPE check. Fighter squadrons don't start with sensors, but pick them up from the component fighters each round
<span class="nc bnc" id="L4492" title="All 2 branches missed.">        if (ae.getActiveSensor() == null) {</span>
<span class="nc" id="L4493">            return false;</span>
        }

        //ESM sensor can't produce a firing solution
<span class="nc bnc" id="L4497" title="All 2 branches missed.">        if (ae.getActiveSensor().getType() == Sensor.TYPE_SPACECRAFT_ESM) {</span>
<span class="nc" id="L4498">            return false;</span>
        }
<span class="nc" id="L4500">        Coords targetPos = target.getPosition();</span>
<span class="nc" id="L4501">        int distance = ae.getPosition().distance(targetPos);</span>
<span class="nc" id="L4502">        int roll = Compute.d6(2);</span>
<span class="nc" id="L4503">        int tn = ae.getCrew().getPiloting();</span>
<span class="nc" id="L4504">        int autoVisualRange = 1;</span>
<span class="nc" id="L4505">        int outOfVisualRange = (ae.getActiveSensor().getRangeByBracket());</span>
<span class="nc" id="L4506">        int rangeIncrement = (int) Math.ceil(outOfVisualRange / 10.0);</span>

        //A bit of a hack here. &quot;Aero Sensors&quot; return the ground range, because Sensor doesn't know about Game or Entity
        //to do otherwise. We need to use the space range instead.
<span class="nc bnc" id="L4510" title="All 2 branches missed.">        if (ae.getActiveSensor().getType() == Sensor.TYPE_AERO_SENSOR) {</span>
<span class="nc" id="L4511">            outOfVisualRange = Sensor.ASF_RADAR_MAX_RANGE;</span>
<span class="nc" id="L4512">            rangeIncrement = Sensor.ASF_RADAR_AUTOSPOT_RANGE;</span>
        }
        
<span class="nc bnc" id="L4515" title="All 2 branches missed.">        if (distance &gt; outOfVisualRange) {</span>
<span class="nc" id="L4516">            return false;</span>
        }

<span class="nc bnc" id="L4519" title="All 2 branches missed.">        if (ae instanceof Aero) {</span>
<span class="nc" id="L4520">            Aero aero = (Aero) ae;</span>
            //Account for sensor damage
<span class="nc bnc" id="L4522" title="All 2 branches missed.">            if (aero.isAeroSensorDestroyed()) {</span>
<span class="nc" id="L4523">                return false;</span>
            } else {
<span class="nc" id="L4525">                tn += aero.getSensorHits();</span>
            }
        }

        //Targets at 1/10 max range are automatically detected
<span class="nc bnc" id="L4530" title="All 2 branches missed.">        if (ae.getActiveSensor().getType() == Sensor.TYPE_AERO_SENSOR) {</span>
<span class="nc" id="L4531">            autoVisualRange = Sensor.ASF_RADAR_AUTOSPOT_RANGE;</span>
<span class="nc bnc" id="L4532" title="All 2 branches missed.">        } else if (ae.getActiveSensor().getType() == Sensor.TYPE_SPACECRAFT_RADAR) {</span>
<span class="nc" id="L4533">            autoVisualRange = Sensor.LC_RADAR_AUTOSPOT_RANGE;</span>
<span class="nc bnc" id="L4534" title="All 2 branches missed.">        } else if (ae.getActiveSensor().getType() == Sensor.TYPE_AERO_THERMAL) {</span>
<span class="nc" id="L4535">            autoVisualRange = Sensor.ASF_OPTICAL_FIRING_SOLUTION_RANGE;</span>
<span class="nc bnc" id="L4536" title="All 2 branches missed.">        } else if (ae.getActiveSensor().getType() == Sensor.TYPE_SPACECRAFT_THERMAL) {</span>
<span class="nc" id="L4537">            autoVisualRange = Sensor.LC_OPTICAL_FIRING_SOLUTION_RANGE;</span>
        }

<span class="nc bnc" id="L4540" title="All 2 branches missed.">        if (distance &lt;= autoVisualRange) {</span>
<span class="nc" id="L4541">            return true;</span>
        }

        //Apply Sensor Geek SPA, if present
<span class="nc bnc" id="L4545" title="All 2 branches missed.">        if (ae.hasAbility(OptionsConstants.UNOFF_SENSOR_GEEK)) {</span>
<span class="nc" id="L4546">            tn -= 2;</span>
        }

        //Otherwise, we add +1 to the tn for detection for each increment of the autovisualrange between attacker and target
<span class="nc" id="L4550">        tn += (distance / rangeIncrement);</span>

        // Apply ECM/ECCM effects
<span class="nc bnc" id="L4553" title="All 2 branches missed.">        if (game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_STRATOPS_ECM)) {</span>
<span class="nc" id="L4554">            tn += calcSpaceECM(game, ae, target);</span>
        }

        // Apply large craft sensor shadows
<span class="nc bnc" id="L4558" title="All 2 branches missed.">        if (game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_STRATOPS_SENSOR_SHADOW)) {</span>
<span class="nc" id="L4559">            tn += calcSensorShadow(game, ae, target);</span>
        }

        //Apply modifiers for attacker's equipment
        //-2 for a working Large NCSS
<span class="nc bnc" id="L4564" title="All 2 branches missed.">        if (ae.hasWorkingMisc(MiscType.F_LARGE_COMM_SCANNER_SUITE)) {</span>
<span class="nc" id="L4565">            tn -= 2;</span>
        }
        //-1 for a working Small NCSS
<span class="nc bnc" id="L4568" title="All 2 branches missed.">        if (ae.hasWorkingMisc(MiscType.F_SMALL_COMM_SCANNER_SUITE)) {</span>
<span class="nc" id="L4569">            tn -= 1;</span>
        }
        //-2 for any type of BAP or EW Equipment. ECM is already accounted for, so don't let the BAP check do that
<span class="nc bnc" id="L4572" title="All 2 branches missed.">        if (ae.hasWorkingMisc(MiscType.F_EW_EQUIPMENT)</span>
<span class="nc bnc" id="L4573" title="All 2 branches missed.">                || ae.hasBAP(false)) {</span>
<span class="nc" id="L4574">            tn -= 2;</span>
        }

        //Now, determine if we've detected the target this round
<span class="nc bnc" id="L4578" title="All 2 branches missed.">        return roll &gt;= tn;</span>
    }

    /**
     *Determines whether we have an &quot;object&quot; detection as defined in SO's Advanced Sensors rules starting on p117
     *
     * @param game - the current game
     * @param ae - the entity making a sensor scan
     * @param target - the entity we're trying to spot
     * @return
     */

    public static boolean calcSensorContact(IGame game, Entity ae,
            Targetable target) {

        //NPE check. Fighter squadrons don't start with sensors, but pick them up from the component fighters each round
<span class="nc bnc" id="L4594" title="All 2 branches missed.">        if (ae.getActiveSensor() == null) {</span>
<span class="nc" id="L4595">            return false;</span>
        }
<span class="nc" id="L4597">        Coords targetPos = target.getPosition();</span>
<span class="nc" id="L4598">        int distance = ae.getPosition().distance(targetPos);</span>
<span class="nc" id="L4599">        int roll = Compute.d6(2);</span>
<span class="nc" id="L4600">        int tn = ae.getCrew().getPiloting();</span>
<span class="nc" id="L4601">        int maxSensorRange = ae.getActiveSensor().getRangeByBracket();</span>
<span class="nc" id="L4602">        int rangeIncrement = (int) Math.ceil(maxSensorRange / 10.0);</span>

        //A bit of a hack here. &quot;Aero Sensors&quot; return the ground range, because Sensor doesn't know about Game or Entity
        //to do otherwise. We need to use the space range instead.
<span class="nc bnc" id="L4606" title="All 2 branches missed.">        if (ae.getActiveSensor().getType() == Sensor.TYPE_AERO_SENSOR) {</span>
<span class="nc" id="L4607">            maxSensorRange = Sensor.ASF_RADAR_MAX_RANGE;</span>
<span class="nc" id="L4608">            rangeIncrement = Sensor.ASF_RADAR_AUTOSPOT_RANGE;</span>
        }

<span class="nc bnc" id="L4611" title="All 2 branches missed.">        if (ae instanceof Aero) {</span>
<span class="nc" id="L4612">            Aero aero = (Aero) ae;</span>
            //Account for sensor damage
<span class="nc bnc" id="L4614" title="All 2 branches missed.">            if (aero.isAeroSensorDestroyed()) {</span>
<span class="nc" id="L4615">                return false;</span>
            } else {
<span class="nc" id="L4617">                tn += aero.getSensorHits();</span>
            }
        }

        //Apply modifiers for attacker's equipment
        //-2 for a working Large NCSS.  Triple the detection range.
<span class="nc bnc" id="L4623" title="All 2 branches missed.">        if (ae.hasWorkingMisc(MiscType.F_LARGE_COMM_SCANNER_SUITE)) {</span>
<span class="nc" id="L4624">            maxSensorRange *= 3;</span>
<span class="nc" id="L4625">            tn -= 2;</span>
        }
        //-1 for a working Small NCSS. Double the detection range.
<span class="nc bnc" id="L4628" title="All 2 branches missed.">        if (ae.hasWorkingMisc(MiscType.F_SMALL_COMM_SCANNER_SUITE)) {</span>
<span class="nc" id="L4629">            maxSensorRange *= 2;</span>
<span class="nc" id="L4630">            tn -= 1;</span>
        }
        //-2 for any type of BAP or EW Equipment. ECM is already accounted for, so don't let the BAP check do that
<span class="nc bnc" id="L4633" title="All 2 branches missed.">        if (ae.hasWorkingMisc(MiscType.F_EW_EQUIPMENT)</span>
<span class="nc bnc" id="L4634" title="All 2 branches missed.">                || ae.hasBAP(false)) {</span>
<span class="nc" id="L4635">            tn -= 2;</span>
        }

        //Military ESM automatically detects anyone using active sensors, which includes all telemissiles
<span class="nc bnc" id="L4639" title="All 4 branches missed.">        if (ae.getActiveSensor().getType() == Sensor.TYPE_SPACECRAFT_ESM &amp;&amp; target.getTargetType() == Targetable.TYPE_ENTITY) {</span>
<span class="nc" id="L4640">            Entity te = (Entity) target;</span>
<span class="nc bnc" id="L4641" title="All 2 branches missed.">            if (te.getActiveSensor().getType() == Sensor.TYPE_AERO_SENSOR</span>
<span class="nc bnc" id="L4642" title="All 4 branches missed.">                    || te.getActiveSensor().getType() == Sensor.TYPE_SPACECRAFT_RADAR</span>
                    || te instanceof TeleMissile) {
<span class="nc" id="L4644">                return true;</span>
            }
<span class="nc" id="L4646">            return false;</span>
        }

        //Can't detect anything beyond this distance
<span class="nc bnc" id="L4650" title="All 2 branches missed.">        if (distance &gt; maxSensorRange) {</span>
<span class="nc" id="L4651">            return false;</span>
        }

        //Apply Sensor Geek SPA, if present
<span class="nc bnc" id="L4655" title="All 2 branches missed.">        if (ae.hasAbility(OptionsConstants.UNOFF_SENSOR_GEEK)) {</span>
<span class="nc" id="L4656">            tn -= 2;</span>
        }

        //Otherwise, we add +1 to the tn for each 1/10 of the max sensor range (rounded up) between attacker and target
<span class="nc" id="L4660">        tn += (distance / rangeIncrement);</span>

        // Apply ECM/ECCM effects
<span class="nc bnc" id="L4663" title="All 2 branches missed.">        if (game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_STRATOPS_ECM)) {</span>
<span class="nc" id="L4664">            tn += calcSpaceECM(game, ae, target);</span>
        }

        // Apply large craft sensor shadows
<span class="nc bnc" id="L4668" title="All 2 branches missed.">        if (game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_STRATOPS_SENSOR_SHADOW)) {</span>
<span class="nc" id="L4669">            tn += calcSensorShadow(game, ae, target);</span>
        }

        //Now, determine if we've detected the target this round
<span class="nc bnc" id="L4673" title="All 2 branches missed.">        return roll &gt;= tn;</span>
    }

    public static int getVisualRange(IGame game, Entity ae, LosEffects los,
            boolean teIlluminated) {
<span class="nc" id="L4678">        int visualRange = game.getPlanetaryConditions().getVisualRange(ae,</span>
                teIlluminated);
<span class="nc" id="L4680">        visualRange -= los.getLightSmoke();</span>
<span class="nc" id="L4681">        visualRange -= 2 * los.getHeavySmoke();</span>
<span class="nc" id="L4682">        visualRange = Math.max(1, visualRange);</span>
<span class="nc" id="L4683">        return visualRange;</span>
    }

    /**
     * Checks to see whether the target is within sensor range (but not
     * necessarily LoS or visual range)
     *
     * @param allECMInfo A collection of ECMInfo for all entities, this value
     *                   can be null and it will be computed when it's
     *                   needed, however passing in the pre-computed
     *                   collection is much faster
     */
    public static boolean inSensorRange(IGame game, Entity ae,
            Targetable target, List&lt;ECMInfo&gt; allECMInfo) {
<span class="nc" id="L4697">        return inSensorRange(game, null, ae, target, allECMInfo);</span>
    }

    public static boolean inSensorRange(IGame game, LosEffects los, Entity ae,
            Targetable target, List&lt;ECMInfo&gt; allECMInfo) {
        // This is not applicable to objects on the same team.
<span class="nc bnc" id="L4703" title="All 2 branches missed.">        if(!target.isEnemyOf(ae)) {</span>
<span class="nc" id="L4704">            return false;</span>
        }

        //For Space games with this option, return something different
<span class="nc bnc" id="L4708" title="All 2 branches missed.">        if (game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_STRATOPS_ADVANCED_SENSORS)</span>
<span class="nc bnc" id="L4709" title="All 2 branches missed.">                &amp;&amp; target.getTargetType() == Targetable.TYPE_ENTITY</span>
<span class="nc bnc" id="L4710" title="All 2 branches missed.">                &amp;&amp; game.getBoard().inSpace()) {</span>
<span class="nc" id="L4711">            Entity te = (Entity) target;</span>
<span class="nc" id="L4712">            return hasSensorContact(ae, te.getId());</span>
        }

<span class="nc bnc" id="L4715" title="All 2 branches missed.">        if (!game.getOptions().booleanOption(OptionsConstants.ADVANCED_TACOPS_SENSORS)) {</span>
<span class="nc" id="L4716">            return false;</span>
        }

        // if either does not have a position then return false
<span class="nc bnc" id="L4720" title="All 4 branches missed.">        if ((ae.getPosition() == null) || (target.getPosition() == null)) {</span>
<span class="nc" id="L4721">            return false;</span>
        }

        // If we have no sensors then return false
<span class="nc bnc" id="L4725" title="All 2 branches missed.">        if (ae.getActiveSensor() == null) {</span>
<span class="nc" id="L4726">            return false;</span>
        }

<span class="nc" id="L4729">        int bracket = Compute.getSensorRangeBracket(ae, target, allECMInfo);</span>
<span class="nc" id="L4730">        int range = Compute.getSensorRangeByBracket(game, ae, target, los);</span>

<span class="nc" id="L4732">        int maxSensorRange = bracket * range;</span>
<span class="nc" id="L4733">        int minSensorRange = Math.max((bracket - 1) * range, 0);</span>
<span class="nc bnc" id="L4734" title="All 2 branches missed.">        if (game.getOptions().booleanOption(OptionsConstants.ADVANCED_INCLUSIVE_SENSOR_RANGE)) {</span>
<span class="nc" id="L4735">            minSensorRange = 0;</span>
        }

<span class="nc" id="L4738">        int distance = ae.getPosition().distance(target.getPosition());</span>

        //Aeros have to check visibility to ground targets for the closest point of approach along their flight path
        //Because the rules state &quot;within X hexes of the flight path&quot; we're using ground distance so altitude doesn't screw us up
<span class="nc bnc" id="L4742" title="All 4 branches missed.">        if (isAirToGround(ae, target) &amp;&amp; (target instanceof Entity)) {</span>
<span class="nc" id="L4743">            Entity te = (Entity) target;</span>
<span class="nc" id="L4744">            distance = te.getPosition().distance(</span>
<span class="nc" id="L4745">                    getClosestFlightPath(te.getId(),</span>
<span class="nc" id="L4746">                            te.getPosition(), (Entity) ae));</span>
<span class="nc bnc" id="L4747" title="All 4 branches missed.">            return (distance &gt; minSensorRange) &amp;&amp; (distance &lt;= maxSensorRange);</span>
        }
        //This didn't work right for Aeros. Should account for the difference in altitude, not just add the target's altitude to distance
<span class="nc" id="L4750">        distance += Math.abs(2 * target.getAltitude() - 2 * ae.getAltitude());</span>

        // if this is an air-to-air scan on the ground map, then divide distance by 16 to match weapon ranges
        // I purposely left this calculation out of visual spotting, so we should do some testing with this and
        // see if it's errata-worthy. The idea is that you'll boost sensor range to help find an enemy aero on the map
        // but still won't be able to see it and shoot at it beyond normal visual conditions.
<span class="nc bnc" id="L4756" title="All 4 branches missed.">        if (isAirToAir(ae, target) &amp;&amp; game.getBoard().onGround()) {</span>
<span class="nc" id="L4757">            distance = (int) Math.ceil(distance / 16.0);</span>
        }
<span class="nc bnc" id="L4759" title="All 4 branches missed.">        return (distance &gt; minSensorRange) &amp;&amp; (distance &lt;= maxSensorRange);</span>
    }

    /**
     * Checks to see if the target is visible to the unit, always considering
     * sensors.
     */
    public static boolean canSee(IGame game, Entity ae, Targetable target) {
<span class="nc" id="L4767">        return canSee(game, ae, target, true, null, null);</span>
    }

    /**
     * Checks to see if the target is visible to the unit, if the sensor flag
     * is true then sensors are checked as well.
     */
    public static boolean canSee(IGame game, Entity ae, Targetable target,
            boolean useSensors, LosEffects los, List&lt;ECMInfo&gt; allECMInfo) {

<span class="nc bnc" id="L4777" title="All 2 branches missed.">        if (!ae.getCrew().isActive()) {</span>
<span class="nc" id="L4778">            return false;</span>
        }
<span class="nc bnc" id="L4780" title="All 2 branches missed.">        if (target.isOffBoard()) {</span>
<span class="nc" id="L4781">            return false;</span>
        }

<span class="nc bnc" id="L4784" title="All 2 branches missed.">        if (los == null) {</span>
<span class="nc" id="L4785">            los = LosEffects.calculateLos(game, ae.getId(), target);</span>
        }
<span class="nc bnc" id="L4787" title="All 2 branches missed.">        boolean isVisible = los.canSee()</span>
<span class="nc bnc" id="L4788" title="All 2 branches missed.">                            &amp;&amp; Compute.inVisualRange(game, los, ae, target);</span>
<span class="nc bnc" id="L4789" title="All 2 branches missed.">        if (useSensors) {</span>
<span class="nc bnc" id="L4790" title="All 2 branches missed.">            isVisible = isVisible</span>
<span class="nc bnc" id="L4791" title="All 2 branches missed.">                    || Compute.inSensorRange(game, los, ae, target, allECMInfo);</span>
        }
<span class="nc" id="L4793">        return isVisible;</span>
    }

    /**
     * gets the sensor range bracket when detecting a particular type of target.
     * target may be null here, which gives you the bracket without target
     * entity modifiers
     *
     * @param allECMInfo A collection of ECMInfo for all entities, this value
     *                   can be null and it will be computed when it's
     *                   needed, however passing in the pre-computed
     *                   collection is much faster
     */
    public static int getSensorRangeBracket(Entity ae, Targetable target,
                                            List&lt;ECMInfo&gt; allECMInfo) {

<span class="nc" id="L4809">        Sensor sensor = ae.getActiveSensor();</span>
<span class="nc bnc" id="L4810" title="All 2 branches missed.">        if (null == sensor) {</span>
<span class="nc" id="L4811">            return 0;</span>
        }
        // only works for entities
<span class="nc" id="L4814">        Entity te = null;</span>
<span class="nc bnc" id="L4815" title="All 2 branches missed.">        if (null != target) {</span>
<span class="nc bnc" id="L4816" title="All 2 branches missed.">            if (target.getTargetType() != Targetable.TYPE_ENTITY) {</span>
<span class="nc" id="L4817">                return 0;</span>
            }
<span class="nc" id="L4819">            te = (Entity) target;</span>
        }

        // if this sensor is an active probe and it is critted, then no can see
<span class="nc bnc" id="L4823" title="All 4 branches missed.">        if (sensor.isBAP() &amp;&amp; !ae.hasBAP(false)) {</span>
<span class="nc" id="L4824">            return 0;</span>
        }

        //In space, sensors don't have brackets, so we should always return the range for bracket 1.
<span class="nc bnc" id="L4828" title="All 2 branches missed.">        if (ae.isSpaceborne()) {</span>
<span class="nc" id="L4829">            return Compute.getSensorBracket(7);</span>
        }

<span class="nc" id="L4832">        int check = ae.getSensorCheck();</span>
<span class="nc bnc" id="L4833" title="All 4 branches missed.">        if ((null != ae.getCrew()) &amp;&amp; ae.hasAbility(OptionsConstants.UNOFF_SENSOR_GEEK)) {</span>
<span class="nc" id="L4834">            check -= 2;</span>
        }
<span class="nc bnc" id="L4836" title="All 2 branches missed.">        if (null != te) {</span>
<span class="nc" id="L4837">            check += sensor.getModsForStealth(te);</span>
            // Metal Content...
<span class="nc bnc" id="L4839" title="All 2 branches missed.">            if (ae.getGame().getOptions().booleanOption(OptionsConstants.ADVANCED_METAL_CONTENT)) {</span>
<span class="nc" id="L4840">                check += sensor.getModForMetalContent(ae, te);</span>
            }
        }
        // ECM bubbles
<span class="nc" id="L4844">        check += sensor.getModForECM(ae, allECMInfo);</span>

<span class="nc" id="L4846">        return Compute.getSensorBracket(check);</span>
    }

    /**
     * returns the brackets for sensor checks
     */
    public static int getSensorBracket(int check) {
        // get the range bracket (0 - none; 1 - short; 2 - medium; 3 - long)
<span class="nc" id="L4854">        int bracket = 0;</span>
<span class="nc bnc" id="L4855" title="All 4 branches missed.">        if ((check == 7) || (check == 8)) {</span>
<span class="nc" id="L4856">            bracket = 1;</span>
        }
<span class="nc bnc" id="L4858" title="All 4 branches missed.">        if ((check == 5) || (check == 6)) {</span>
<span class="nc" id="L4859">            bracket = 2;</span>
        }
<span class="nc bnc" id="L4861" title="All 2 branches missed.">        if (check &lt; 5) {</span>
<span class="nc" id="L4862">            bracket = 3;</span>
        }
<span class="nc" id="L4864">        return bracket;</span>
    }

    /**
     * gets the size of the sensor range bracket when detecting a particular
     * type of target. target may be null here, which gives you the range
     * without target entity modifiers
     */
    public static int getSensorRangeByBracket(IGame game, Entity ae,
            Targetable target, LosEffects los) {
<span class="nc bnc" id="L4874" title="All 2 branches missed.">        if (los == null) {</span>
<span class="nc" id="L4875">            los = LosEffects.calculateLos(game, ae.getId(), target);</span>
        }
<span class="nc" id="L4877">        Sensor sensor = ae.getActiveSensor();</span>
<span class="nc bnc" id="L4878" title="All 2 branches missed.">        if (null == sensor) {</span>
<span class="nc" id="L4879">            return 0;</span>
        }
        // only works for entities
<span class="nc" id="L4882">        Entity te = null;</span>
<span class="nc bnc" id="L4883" title="All 2 branches missed.">        if (null != target) {</span>
<span class="nc bnc" id="L4884" title="All 2 branches missed.">            if (target.getTargetType() != Targetable.TYPE_ENTITY) {</span>
<span class="nc" id="L4885">                return 0;</span>
            }
<span class="nc" id="L4887">            te = (Entity) target;</span>
        }

        // if this sensor is an active probe and it is critted, then no can see
<span class="nc bnc" id="L4891" title="All 4 branches missed.">        if (sensor.isBAP() &amp;&amp; !ae.hasBAP(false)) {</span>
<span class="nc" id="L4892">            return 0;</span>
        }

        // if we are crossing water then only magscan will work unless we are a
        // naval vessel
<span class="nc bnc" id="L4897" title="All 4 branches missed.">        if ((null != te) &amp;&amp; los.isBlockedByWater()</span>
<span class="nc bnc" id="L4898" title="All 2 branches missed.">            &amp;&amp; (sensor.getType() != Sensor.TYPE_MEK_MAGSCAN)</span>
<span class="nc bnc" id="L4899" title="All 2 branches missed.">            &amp;&amp; (sensor.getType() != Sensor.TYPE_VEE_MAGSCAN)</span>
<span class="nc bnc" id="L4900" title="All 2 branches missed.">            &amp;&amp; (ae.getMovementMode() != EntityMovementMode.HYDROFOIL)</span>
<span class="nc bnc" id="L4901" title="All 2 branches missed.">            &amp;&amp; (ae.getMovementMode() != EntityMovementMode.NAVAL)) {</span>
<span class="nc" id="L4902">            return 0;</span>
        }

        // now get the range
<span class="nc" id="L4906">        int range = sensor.getRangeByBracket();</span>

        // adjust the range based on LOS and planetary conditions
<span class="nc" id="L4909">        range = sensor.adjustRange(range, game, los);</span>

        //If we're an airborne aero, sensor range is limited to within a few hexes of the flightline against ground targets
        //TO Dec 2017 Errata p17
<span class="nc bnc" id="L4913" title="All 6 branches missed.">        if (te != null &amp;&amp; ae.isAirborne() &amp;&amp; !te.isAirborne()) {</span>
            //Can't see anything if above Alt 8.
<span class="nc bnc" id="L4915" title="All 2 branches missed.">            if (ae.getAltitude() &gt; 8) {</span>
<span class="nc" id="L4916">                range = 0;</span>
<span class="nc bnc" id="L4917" title="All 2 branches missed.">            } else if (sensor.isBAP()) {</span>
            //Add 1 to range for active probe of any type
<span class="nc" id="L4919">                range = 2;</span>
            } else {
            //Basic sensor range listed in errata
<span class="nc" id="L4922">                range = 1;</span>
            }
<span class="nc" id="L4924">            return range;</span>
        }

        // now adjust for anything about the target entity (size, heat, etc)
<span class="nc bnc" id="L4928" title="All 2 branches missed.">        if (null != te) {</span>
<span class="nc" id="L4929">            range = sensor.entityAdjustments(range, te, game);</span>
        }

<span class="nc bnc" id="L4932" title="All 2 branches missed.">        if (range &lt; 0) {</span>
<span class="nc" id="L4933">            range = 0;</span>
        }

<span class="nc" id="L4936">        return range;</span>

    }

    public static int targetSideTable(Coords inPosition, Targetable target) {
<span class="nc" id="L4941">        return target.sideTable(inPosition);</span>
    }

    public static int targetSideTable(Entity attacker, Targetable target) {
<span class="nc" id="L4945">        return Compute</span>
<span class="nc" id="L4946">                .targetSideTable(attacker, target, CalledShot.CALLED_NONE);</span>
    }

    public static int targetSideTable(Entity attacker, Targetable target,
                                      int called) {
<span class="nc" id="L4951">        Coords attackPos = attacker.getPosition();</span>

<span class="nc" id="L4953">        Entity te = null;</span>
<span class="nc bnc" id="L4954" title="All 2 branches missed.">        if (target instanceof Entity) {</span>
<span class="nc" id="L4955">            te = (Entity) target;</span>
        }

<span class="nc" id="L4958">        boolean usePrior = false;</span>
        // aeros in the same hex need to adjust position to get side
        // table
<span class="nc bnc" id="L4961" title="All 2 branches missed.">        if (isAirToAir(attacker, target)</span>
<span class="nc bnc" id="L4962" title="All 2 branches missed.">            &amp;&amp; attackPos.equals(target.getPosition())</span>
<span class="nc bnc" id="L4963" title="All 4 branches missed.">            &amp;&amp; attacker.isAero() &amp;&amp; target.isAero()) {</span>
<span class="nc" id="L4964">            int moveSort = shouldMoveBackHex(attacker, (Entity)target);</span>
<span class="nc bnc" id="L4965" title="All 2 branches missed.">            if (moveSort &lt; 0) {</span>
<span class="nc" id="L4966">                attackPos = attacker.getPriorPosition();</span>
            }
<span class="nc bnc" id="L4968" title="All 2 branches missed.">            usePrior = moveSort &gt; 0;</span>
        }

        // if this is a air to ground attack, then attacker position is given by
        // the direction from which they entered the target hex
<span class="nc bnc" id="L4973" title="All 2 branches missed.">        if (isAirToGround(attacker, target)) {</span>
<span class="nc" id="L4974">            attackPos = attacker.passedThroughPrevious(target.getPosition());</span>
        }

<span class="nc bnc" id="L4977" title="All 4 branches missed.">        if (isGroundToAir(attacker, target) &amp;&amp; (null != te)) {</span>
<span class="nc" id="L4978">            int facing = Compute.getClosestFlightPathFacing(attacker.getId(),</span>
                    attackPos, te);
<span class="nc" id="L4980">            Coords pos = Compute.getClosestFlightPath(attacker.getId(),</span>
                    attackPos, te);
<span class="nc" id="L4982">            return te.sideTable(attackPos, usePrior, facing, pos);</span>
        }

<span class="nc bnc" id="L4985" title="All 4 branches missed.">        if ((null != te) &amp;&amp; (called == CalledShot.CALLED_LEFT)) {</span>
<span class="nc" id="L4986">            return te.sideTable(attackPos, usePrior, (te.getFacing() + 5) % 6);</span>
<span class="nc bnc" id="L4987" title="All 4 branches missed.">        } else if ((null != te) &amp;&amp; (called == CalledShot.CALLED_RIGHT)) {</span>
<span class="nc" id="L4988">            return te.sideTable(attackPos, usePrior, (te.getFacing() + 1) % 6);</span>
        }

<span class="nc" id="L4991">        return target.sideTable(attackPos, usePrior);</span>
    }


        /**
         * Compares the initiative of two aerospace units in the same hex to determine attack angle.
         * The attack angle is computed as if the unit with the higher initiative were in its previous hex.
         *
         * @param e1 The first &lt;code&gt;Entity&lt;/code&gt; to compare
         * @param e2 The second &lt;code&gt;Entity&lt;/code&gt; to compare
         * @return &lt; 0 if the first unit has a higher initiative, &gt; 0 if the second is higher,
         *         or 0 if one of the units is not an aerospace unit, does not have a valid position,
         *         or the two units are not in the same hex.
         */
    public static int shouldMoveBackHex(Entity e1, Entity e2) {
<span class="nc bnc" id="L5006" title="All 4 branches missed.">        if (null == e1.getPosition() || null == e2.getPosition()</span>
<span class="nc bnc" id="L5007" title="All 2 branches missed.">                || !e1.getPosition().equals(e2.getPosition())</span>
<span class="nc bnc" id="L5008" title="All 4 branches missed.">                || !e1.isAero() || !e2.isAero()) {</span>
<span class="nc" id="L5009">            return 0;</span>
        }

<span class="nc" id="L5012">        int retVal = e1.getUnitType() - e2.getUnitType();</span>
<span class="nc bnc" id="L5013" title="All 2 branches missed.">        if (retVal == 0) {</span>
<span class="nc" id="L5014">            retVal = ((IAero)e2).getCurrentVelocity() -</span>
<span class="nc" id="L5015">                    ((IAero)e1).getCurrentVelocity();</span>
        }
        // if all criteria are the same, select randomly
<span class="nc bnc" id="L5018" title="All 2 branches missed.">        if (retVal == 0) {</span>
<span class="nc bnc" id="L5019" title="All 2 branches missed.">            retVal = d6() &lt; 4? -1 : 1;</span>
        }
<span class="nc" id="L5021">        return retVal;</span>
    }

    /**
     * Maintain backwards compatability.
     *
     * @param missiles - the &lt;code&gt;int&lt;/code&gt; number of missiles in the pack.
     */
    public static int missilesHit(int missiles) {
<span class="nc" id="L5030">        return Compute.missilesHit(missiles, 0);</span>
    }

    /**
     * Maintain backwards compatability.
     *
     * @param missiles
     * @param nMod
     * @return
     */
    public static int missilesHit(int missiles, int nMod) {
<span class="nc" id="L5041">        return Compute.missilesHit(missiles, nMod, false);</span>
    }

    /**
     * Maintain backwards compatability.
     *
     * @param missiles
     * @param nMod
     * @param hotloaded
     * @return
     */
    public static int missilesHit(int missiles, int nMod, boolean hotloaded) {
<span class="nc" id="L5053">        return Compute.missilesHit(missiles, nMod, hotloaded, false, false);</span>
    }

    /**
     * Roll the number of missiles (or whatever) on the missile hit table, with
     * the specified mod to the roll.
     *
     * @param missiles    - the &lt;code&gt;int&lt;/code&gt; number of missiles in the pack.
     * @param nMod        - the &lt;code&gt;int&lt;/code&gt; modifier to the roll for number of
     *                    missiles that hit.
     * @param hotloaded   - roll 3d6 take worst 2
     * @param streak      - force a roll of 11 on the cluster table
     * @param advancedAMS - the roll can now go below 2, indicating no damage
     */
    public static int missilesHit(int missiles, int nMod, boolean hotloaded,
                                  boolean streak, boolean advancedAMS) {
<span class="nc" id="L5069">        int nRoll = Compute.d6(2);</span>

<span class="nc bnc" id="L5071" title="All 2 branches missed.">        if (hotloaded) {</span>
<span class="nc" id="L5072">            int roll1 = Compute.d6();</span>
<span class="nc" id="L5073">            int roll2 = Compute.d6();</span>
<span class="nc" id="L5074">            int roll3 = Compute.d6();</span>
<span class="nc" id="L5075">            int lowRoll1 = 0;</span>
<span class="nc" id="L5076">            int lowRoll2 = 0;</span>

<span class="nc bnc" id="L5078" title="All 4 branches missed.">            if ((roll1 &lt;= roll2) &amp;&amp; (roll1 &lt;= roll3)) {</span>
<span class="nc" id="L5079">                lowRoll1 = roll1;</span>
<span class="nc" id="L5080">                lowRoll2 = Math.min(roll2, roll3);</span>
<span class="nc bnc" id="L5081" title="All 4 branches missed.">            } else if ((roll2 &lt;= roll1) &amp;&amp; (roll2 &lt;= roll3)) {</span>
<span class="nc" id="L5082">                lowRoll1 = roll2;</span>
<span class="nc" id="L5083">                lowRoll2 = Math.min(roll1, roll3);</span>
<span class="nc bnc" id="L5084" title="All 4 branches missed.">            } else if ((roll3 &lt;= roll1) &amp;&amp; (roll3 &lt;= roll2)) {</span>
<span class="nc" id="L5085">                lowRoll1 = roll3;</span>
<span class="nc" id="L5086">                lowRoll2 = Math.min(roll2, roll1);</span>
            }
<span class="nc" id="L5088">            nRoll = lowRoll1 + lowRoll2;</span>
        }
<span class="nc bnc" id="L5090" title="All 2 branches missed.">        if (streak) {</span>
<span class="nc" id="L5091">            nRoll = 11;</span>
        }
<span class="nc" id="L5093">        nRoll += nMod;</span>
<span class="nc bnc" id="L5094" title="All 2 branches missed.">        if (!advancedAMS) {</span>
<span class="nc" id="L5095">            nRoll = Math.min(Math.max(nRoll, 2), 12);</span>
        } else {
<span class="nc" id="L5097">            nRoll = Math.min(nRoll, 12);</span>
        }
<span class="nc bnc" id="L5099" title="All 2 branches missed.">        if (nRoll &lt; 2) {</span>
<span class="nc" id="L5100">            return 0;</span>
        }

<span class="nc bnc" id="L5103" title="All 2 branches missed.">        for (int[] element : clusterHitsTable) {</span>
<span class="nc bnc" id="L5104" title="All 2 branches missed.">            if (element[0] == missiles) {</span>
<span class="nc" id="L5105">                return element[nRoll - 1];</span>
            }
        }
        // BA missiles may have larger number of missiles than max entry on the
        // table
        // if so, take largest, subtract value and try again
<span class="nc bnc" id="L5111" title="All 2 branches missed.">        for (int i = clusterHitsTable.length - 1; i &gt;= 0; i--) {</span>
<span class="nc bnc" id="L5112" title="All 2 branches missed.">            if (missiles &gt; clusterHitsTable[i][0]) {</span>
<span class="nc" id="L5113">                return clusterHitsTable[i][nRoll - 1]</span>
<span class="nc" id="L5114">                       + Compute.missilesHit(</span>
                        missiles - clusterHitsTable[i][0], nMod,
                        hotloaded, streak, advancedAMS);
            }
        }
<span class="nc" id="L5119">        throw new RuntimeException(</span>
                &quot;Could not find number of missiles in hit table&quot;);
    }

    public static int calculateClusterHitTableAmount(int roll, int rackSize) {
<span class="nc bnc" id="L5124" title="All 2 branches missed.">        for (int[] element : clusterHitsTable) {</span>
<span class="nc bnc" id="L5125" title="All 2 branches missed.">            if (element[0] == rackSize) {</span>
<span class="nc" id="L5126">                return element[roll - 1];</span>
            }
        }

<span class="nc" id="L5130">        return 0;</span>
    }

    /**
     * Returns the consciousness roll number
     *
     * @param hit - the &lt;code&gt;int&lt;/code&gt; number of the crew hit currently being
     *            rolled.
     * @return The &lt;code&gt;int&lt;/code&gt; number that must be rolled on 2d6 for the
     * crew to stay conscious.
     */
    public static int getConsciousnessNumber(int hit) {
<span class="nc bnc" id="L5142" title="All 7 branches missed.">        switch (hit) {</span>
            case 0:
<span class="nc" id="L5144">                return 2;</span>
            case 1:
<span class="nc" id="L5146">                return 3;</span>
            case 2:
<span class="nc" id="L5148">                return 5;</span>
            case 3:
<span class="nc" id="L5150">                return 7;</span>
            case 4:
<span class="nc" id="L5152">                return 10;</span>
            case 5:
<span class="nc" id="L5154">                return 11;</span>
            default:
<span class="nc" id="L5156">                return Integer.MAX_VALUE;</span>
        }
    }

    /**
     * Check for ferrous metal content in terrain on path from a to b return the
     * total content.
     */
    public static int getMetalInPath(Entity ae, Coords a, Coords b) {
        // If we're in space, or anything is null... get out.
<span class="nc bnc" id="L5166" title="All 6 branches missed.">        if ((ae == null) || (a == null) || (b == null)) {</span>
<span class="nc" id="L5167">            return 0;</span>
        }
<span class="nc" id="L5169">        IBoard board = ae.getGame().getBoard();</span>
<span class="nc bnc" id="L5170" title="All 2 branches missed.">        if (board.inSpace()) {</span>
<span class="nc" id="L5171">            return 0;</span>
        }

<span class="nc bnc" id="L5174" title="All 4 branches missed.">        if (!board.contains(a) || !board.contains(b)) {</span>
<span class="nc" id="L5175">            return 0;</span>
        }

        // get intervening Coords.
<span class="nc" id="L5179">        ArrayList&lt;Coords&gt; coords = Coords.intervening(a, b);</span>
        // loop through all intervening coords, check each if they are ECM
        // affected
<span class="nc" id="L5182">        int metalContent = 0;</span>
<span class="nc bnc" id="L5183" title="All 2 branches missed.">        for (Coords c : coords) {</span>
<span class="nc" id="L5184">            IHex hex = board.getHex(c);</span>
<span class="nc bnc" id="L5185" title="All 4 branches missed.">            if (hex != null &amp;&amp; hex.containsTerrain(Terrains.METAL_CONTENT)) {</span>
<span class="nc" id="L5186">                metalContent += hex.terrainLevel(Terrains.METAL_CONTENT);</span>
            }
<span class="nc" id="L5188">        }</span>
<span class="nc" id="L5189">        return metalContent;</span>
    }

    /**
     * Check for ECM bubbles in Ghost Target mode along the path from a to b and
     * return the highest target roll. -1 if no Ghost Targets
     */
    public static int getGhostTargetNumber(Entity ae, Coords a, Coords b) {
<span class="nc bnc" id="L5197" title="All 2 branches missed.">        if (ae.getGame().getBoard().inSpace()) {</span>
            // ghost targets don't work in space
<span class="nc" id="L5199">            return 0;</span>
        }
<span class="nc bnc" id="L5201" title="All 4 branches missed.">        if ((a == null) || (b == null)) {</span>
<span class="nc" id="L5202">            return 0;</span>
        }

        // Only grab enemies with active ECM
        // need to create two hashtables for ghost targeting, one with mods
        // and one with booleans indicating that this ghost target was
        // intersected
        // the keys will be the entity id
<span class="nc" id="L5210">        Hashtable&lt;Integer, Boolean&gt; hEnemyGTCrossed = new Hashtable&lt;Integer, Boolean&gt;();</span>
<span class="nc" id="L5211">        Hashtable&lt;Integer, Integer&gt; hEnemyGTMods = new Hashtable&lt;Integer, Integer&gt;();</span>
<span class="nc" id="L5212">        Vector&lt;Coords&gt; vEnemyECCMCoords = new Vector&lt;Coords&gt;(16);</span>
<span class="nc" id="L5213">        Vector&lt;Integer&gt; vEnemyECCMRanges = new Vector&lt;Integer&gt;(16);</span>
<span class="nc" id="L5214">        Vector&lt;Double&gt; vEnemyECCMStrengths = new Vector&lt;Double&gt;(16);</span>
<span class="nc" id="L5215">        Vector&lt;Coords&gt; vEnemyGTCoords = new Vector&lt;Coords&gt;(16);</span>
<span class="nc" id="L5216">        Vector&lt;Integer&gt; vEnemyGTRanges = new Vector&lt;Integer&gt;(16);</span>
<span class="nc" id="L5217">        Vector&lt;Integer&gt; vEnemyGTId = new Vector&lt;Integer&gt;(16);</span>
<span class="nc" id="L5218">        Vector&lt;Coords&gt; vFriendlyECMCoords = new Vector&lt;Coords&gt;(16);</span>
<span class="nc" id="L5219">        Vector&lt;Integer&gt; vFriendlyECMRanges = new Vector&lt;Integer&gt;(16);</span>
<span class="nc" id="L5220">        Vector&lt;Double&gt; vFriendlyECMStrengths = new Vector&lt;Double&gt;(16);</span>
<span class="nc bnc" id="L5221" title="All 2 branches missed.">        for (Entity ent : ae.getGame().getEntitiesVector()) {</span>
<span class="nc" id="L5222">            Coords entPos = ent.getPosition();</span>
<span class="nc bnc" id="L5223" title="All 6 branches missed.">            if (ent.isEnemyOf(ae) &amp;&amp; ent.hasGhostTargets(true)</span>
                &amp;&amp; (entPos != null)) {
<span class="nc" id="L5225">                vEnemyGTCoords.addElement(entPos);</span>
<span class="nc" id="L5226">                vEnemyGTRanges.addElement(ent.getECMRange());</span>
<span class="nc" id="L5227">                vEnemyGTId.addElement(ent.getId());</span>
<span class="nc" id="L5228">                hEnemyGTCrossed.put(ent.getId(), false);</span>
<span class="nc" id="L5229">                hEnemyGTMods.put(ent.getId(), ent.getGhostTargetRollMoS());</span>
            }
<span class="nc bnc" id="L5231" title="All 6 branches missed.">            if (ent.isEnemyOf(ae) &amp;&amp; ent.hasActiveECCM() &amp;&amp; (entPos != null)) {</span>
<span class="nc" id="L5232">                vEnemyECCMCoords.addElement(entPos);</span>
<span class="nc" id="L5233">                vEnemyECCMRanges.addElement(ent.getECMRange());</span>
<span class="nc" id="L5234">                vEnemyECCMStrengths.add(ent.getECCMStrength());</span>
            }
<span class="nc bnc" id="L5236" title="All 6 branches missed.">            if (!ent.isEnemyOf(ae) &amp;&amp; ent.hasActiveECM() &amp;&amp; (entPos != null)) {</span>
<span class="nc" id="L5237">                vFriendlyECMCoords.addElement(entPos);</span>
<span class="nc" id="L5238">                vFriendlyECMRanges.addElement(ent.getECMRange());</span>
<span class="nc" id="L5239">                vFriendlyECMStrengths.add(ent.getECMStrength());</span>
            }

            // Check the ECM effects of the entity's passengers.
<span class="nc bnc" id="L5243" title="All 2 branches missed.">            for (Entity other : ent.getLoadedUnits()) {</span>
<span class="nc bnc" id="L5244" title="All 6 branches missed.">                if (other.isEnemyOf(ae) &amp;&amp; other.hasGhostTargets(true)</span>
                    &amp;&amp; (entPos != null)) {
<span class="nc" id="L5246">                    vEnemyGTCoords.addElement(entPos);</span>
<span class="nc" id="L5247">                    vEnemyGTRanges.addElement(other.getECMRange());</span>
<span class="nc" id="L5248">                    vEnemyGTId.addElement(ent.getId());</span>
<span class="nc" id="L5249">                    hEnemyGTCrossed.put(ent.getId(), false);</span>
<span class="nc" id="L5250">                    hEnemyGTMods.put(ent.getId(), ent.getGhostTargetRollMoS());</span>
                }
<span class="nc bnc" id="L5252" title="All 6 branches missed.">                if (other.isEnemyOf(ae) &amp;&amp; other.hasActiveECCM()</span>
                    &amp;&amp; (entPos != null)) {
<span class="nc" id="L5254">                    vEnemyECCMCoords.addElement(entPos);</span>
<span class="nc" id="L5255">                    vEnemyECCMRanges</span>
<span class="nc" id="L5256">                            .addElement(other.getECMRange());</span>
<span class="nc" id="L5257">                    vEnemyECCMStrengths.add(ent.getECCMStrength());</span>
                }
<span class="nc bnc" id="L5259" title="All 6 branches missed.">                if (!other.isEnemyOf(ae) &amp;&amp; ent.hasActiveECM()</span>
                    &amp;&amp; (entPos != null)) {
<span class="nc" id="L5261">                    vFriendlyECMCoords.addElement(entPos);</span>
<span class="nc" id="L5262">                    vFriendlyECMRanges</span>
<span class="nc" id="L5263">                            .addElement(ent.getECMRange());</span>
<span class="nc" id="L5264">                    vFriendlyECMStrengths.add(ent.getECMStrength());</span>
                }
<span class="nc" id="L5266">            }</span>
<span class="nc" id="L5267">        }</span>

        // none? get out of here
<span class="nc bnc" id="L5270" title="All 2 branches missed.">        if (vEnemyGTCoords.size() == 0) {</span>
<span class="nc" id="L5271">            return -1;</span>
        }

        // get intervening Coords.
<span class="nc" id="L5275">        ArrayList&lt;Coords&gt; coords = Coords.intervening(a, b);</span>
        // loop through all intervening coords, if they are not ecm'ed by
        // friendlys then add any Ghost Targets
        // to the hashlist
        // According to the rules clarification below ECM cancels Ghost Targets
        // http://www.classicbattletech.com/forums/index.php/topic,66035.new.html#new
<span class="nc bnc" id="L5281" title="All 2 branches missed.">        for (Coords c : coords) {</span>
            // &gt;0: in friendly ECM
            // &lt;=0: not in friendly ECM
<span class="nc" id="L5284">            int ecmStatus = 0;</span>
            // first, add 1 for each friendly ECM that affects us
<span class="nc" id="L5286">            Enumeration&lt;Integer&gt; ranges = vFriendlyECMRanges.elements();</span>
<span class="nc" id="L5287">            Enumeration&lt;Double&gt; strengths = vFriendlyECMStrengths.elements();</span>
<span class="nc bnc" id="L5288" title="All 2 branches missed.">            for (Coords friendlyECMCoords : vFriendlyECMCoords) {</span>
<span class="nc" id="L5289">                int range = ranges.nextElement().intValue();</span>
<span class="nc" id="L5290">                int nDist = c.distance(friendlyECMCoords);</span>
<span class="nc" id="L5291">                double strength = strengths.nextElement().doubleValue();</span>
<span class="nc bnc" id="L5292" title="All 2 branches missed.">                if (nDist &lt;= range) {</span>
<span class="nc" id="L5293">                    ecmStatus += strength;</span>
                }
<span class="nc" id="L5295">            }</span>
            // now, subtract one for each enemy ECCM
<span class="nc" id="L5297">            ranges = vEnemyECCMRanges.elements();</span>
<span class="nc" id="L5298">            strengths = vEnemyECCMStrengths.elements();</span>
<span class="nc bnc" id="L5299" title="All 2 branches missed.">            for (Coords enemyECCMCoords : vEnemyECCMCoords) {</span>
<span class="nc" id="L5300">                int range = ranges.nextElement().intValue();</span>
<span class="nc" id="L5301">                int nDist = c.distance(enemyECCMCoords);</span>
<span class="nc" id="L5302">                double strength = strengths.nextElement().doubleValue();</span>
<span class="nc bnc" id="L5303" title="All 2 branches missed.">                if (nDist &lt;= range) {</span>
<span class="nc" id="L5304">                    ecmStatus -= strength;</span>
                }
<span class="nc" id="L5306">            }</span>

<span class="nc bnc" id="L5308" title="All 2 branches missed.">            if (ecmStatus &lt; 1) {</span>
                // find any new Ghost Targets that we have crossed
<span class="nc" id="L5310">                ranges = vEnemyGTRanges.elements();</span>
<span class="nc" id="L5311">                Enumeration&lt;Integer&gt; ids = vEnemyGTId.elements();</span>
<span class="nc bnc" id="L5312" title="All 2 branches missed.">                for (Coords enemyGTCoords : vEnemyGTCoords) {</span>
<span class="nc" id="L5313">                    int range = ranges.nextElement().intValue();</span>
<span class="nc" id="L5314">                    int id = ids.nextElement().intValue();</span>
<span class="nc" id="L5315">                    int nDist = c.distance(enemyGTCoords);</span>
<span class="nc bnc" id="L5316" title="All 4 branches missed.">                    if ((nDist &lt;= range) &amp;&amp; !hEnemyGTCrossed.get(id)) {</span>
<span class="nc" id="L5317">                        hEnemyGTCrossed.put(id, true);</span>
                    }
<span class="nc" id="L5319">                }</span>
            }
<span class="nc" id="L5321">        }</span>

        // ok so now we have a hashtable that tells us which Ghost Targets have
        // been crossed
        // lets loop through that and identify the highest bonus and count the
        // total number crossed
<span class="nc" id="L5327">        int totalGT = -1;</span>
<span class="nc" id="L5328">        int highestMod = -1;</span>
<span class="nc" id="L5329">        Enumeration&lt;Integer&gt; ids = hEnemyGTCrossed.keys();</span>
<span class="nc bnc" id="L5330" title="All 2 branches missed.">        while (ids.hasMoreElements()) {</span>
<span class="nc" id="L5331">            int id = ids.nextElement();</span>
<span class="nc bnc" id="L5332" title="All 2 branches missed.">            if (hEnemyGTCrossed.get(id)) {</span>
<span class="nc" id="L5333">                totalGT++;</span>
<span class="nc bnc" id="L5334" title="All 2 branches missed.">                if (hEnemyGTMods.get(id) &gt; highestMod) {</span>
<span class="nc" id="L5335">                    highestMod = hEnemyGTMods.get(id);</span>
                }
            }
<span class="nc" id="L5338">        }</span>

        // according to the following rules clarification, this should be maxed
        // out at +4
        // http://www.classicbattletech.com/forums/index.php?topic=66036.0
<span class="nc" id="L5343">        return Math.min(4, highestMod + totalGT);</span>
    }

    /**
     * Get the base to-hit number of a space bomb attack by the given attacker
     * upon the given defender
     *
     * @param attacker - the &lt;code&gt;Entity&lt;/code&gt; conducting the leg attack.
     * @param defender - the &lt;code&gt;Entity&lt;/code&gt; being attacked.
     * @return The base &lt;code&gt;ToHitData&lt;/code&gt; of the attack.
     */
    public static ToHitData getSpaceBombBaseToHit(Entity attacker,
                                                  Entity defender, IGame game) {
<span class="nc" id="L5356">        int base = TargetRoll.IMPOSSIBLE;</span>
<span class="nc" id="L5357">        StringBuffer reason = new StringBuffer();</span>

<span class="nc bnc" id="L5359" title="All 2 branches missed.">        if (!attacker.isAero()) {</span>
<span class="nc" id="L5360">            return new ToHitData(base, &quot;attacker is not an Aero&quot;);</span>
        }

<span class="nc" id="L5363">        IAero a = (IAero) attacker;</span>

        // the fighters nose must be aligned with its direction of travel
<span class="nc" id="L5366">        boolean rightFacing = false;</span>
        // using normal movement, I think this means that the last move can't be
        // a turn
<span class="nc bnc" id="L5369" title="All 2 branches missed.">        if (!game.useVectorMove()) {</span>
<span class="nc" id="L5370">            rightFacing = true;</span>
        }
        // for advanced movement, it must be aligned with largest vector
<span class="nc bnc" id="L5373" title="All 2 branches missed.">        if (game.useVectorMove()) {</span>
<span class="nc bnc" id="L5374" title="All 2 branches missed.">            for (int h : attacker.getHeading()) {</span>
<span class="nc bnc" id="L5375" title="All 2 branches missed.">                if (h == attacker.facing) {</span>
<span class="nc" id="L5376">                    rightFacing = true;</span>
<span class="nc" id="L5377">                    break;</span>
                }
<span class="nc" id="L5379">            }</span>
        }

<span class="nc" id="L5382">        boolean canTarget = false;</span>
<span class="nc" id="L5383">        Coords attackCoords = null;</span>
<span class="nc bnc" id="L5384" title="All 2 branches missed.">        for (Coords c : attacker.getPassedThrough()) {</span>
<span class="nc bnc" id="L5385" title="All 2 branches missed.">            for (Entity target : game.getEntitiesVector(c)) {</span>
<span class="nc bnc" id="L5386" title="All 2 branches missed.">                if (target.getId() == defender.getId()) {</span>
<span class="nc" id="L5387">                    canTarget = true;</span>
                }
<span class="nc" id="L5389">            }</span>
<span class="nc bnc" id="L5390" title="All 2 branches missed.">            if (canTarget) {</span>
<span class="nc" id="L5391">                break;</span>
            }
<span class="nc" id="L5393">            attackCoords = c;</span>
<span class="nc" id="L5394">        }</span>
<span class="nc bnc" id="L5395" title="All 2 branches missed.">        if (null == attackCoords) {</span>
<span class="nc" id="L5396">            attackCoords = attacker.getPosition();</span>
        }

        // must be in control
<span class="nc bnc" id="L5400" title="All 2 branches missed.">        if (a.isOutControlTotal()) {</span>
<span class="nc" id="L5401">            reason.append(&quot;the attacker is out of control&quot;);</span>
<span class="nc bnc" id="L5402" title="All 2 branches missed.">        } else if (attacker.getBombs(AmmoType.F_SPACE_BOMB).size() &lt; 1) {</span>
<span class="nc" id="L5403">            reason.append(&quot;the attacker has no useable bombs&quot;);</span>
<span class="nc bnc" id="L5404" title="All 2 branches missed.">        } else if (!rightFacing) {</span>
<span class="nc" id="L5405">            reason.append(&quot;the attacker is not facing the direction of travel&quot;);</span>
        }
        // attacker and defender must both be in space hex
<span class="nc" id="L5408">        else if (!game.getBoard().getHex(attacker.getPosition())</span>
<span class="nc bnc" id="L5409" title="All 2 branches missed.">                      .containsTerrain(Terrains.SPACE)) {</span>
<span class="nc" id="L5410">            reason.append(&quot;attacker not in space hex&quot;);</span>
<span class="nc" id="L5411">        } else if (!game.getBoard().getHex(defender.getPosition())</span>
<span class="nc bnc" id="L5412" title="All 2 branches missed.">                        .containsTerrain(Terrains.SPACE)) {</span>
<span class="nc" id="L5413">            reason.append(&quot;defender not in space hex&quot;);</span>
<span class="nc bnc" id="L5414" title="All 2 branches missed.">        } else if (!canTarget) {</span>
<span class="nc" id="L5415">            reason.append(&quot;defender is not in hex passed through by attacker this turn&quot;);</span>
        }
        // the defender must weight 10000+ tons
<span class="nc bnc" id="L5418" title="All 2 branches missed.">        else if (defender.weight &lt; 10000) {</span>
<span class="nc" id="L5419">            reason.append(&quot;the defender weighs less than 10,000 tons&quot;);</span>
        }

        // ok if we are still alive then lets calculate the tohit
        else {
<span class="nc" id="L5424">            base = attacker.getCrew().getGunnery();</span>
<span class="nc" id="L5425">            reason.append(&quot;base&quot;);</span>
        }

<span class="nc" id="L5428">        ToHitData toHit = new ToHitData(base, reason.toString(),</span>
<span class="nc" id="L5429">                                        ToHitData.HIT_NORMAL, defender.sideTable(attackCoords));</span>

<span class="nc" id="L5431">        toHit.addModifier(+4, &quot;space bomb attack&quot;);</span>
<span class="nc bnc" id="L5432" title="All 2 branches missed.">        if (attacker.mpUsed &gt; 0) {</span>
<span class="nc" id="L5433">            toHit.addModifier(attacker.mpUsed, &quot;attacker thrust&quot;);</span>
        }
<span class="nc bnc" id="L5435" title="All 2 branches missed.">        if (defender.mpUsed &gt; 0) {</span>
<span class="nc" id="L5436">            toHit.addModifier(defender.mpUsed, &quot;defender thrust&quot;);</span>
        }
<span class="nc bnc" id="L5438" title="All 4 branches missed.">        if ((defender instanceof SpaceStation) || (defender.getWalkMP() == 0)) {</span>
<span class="nc" id="L5439">            toHit.addModifier(-4, &quot;immobile&quot;);</span>
        }
<span class="nc bnc" id="L5441" title="All 2 branches missed.">        if (defender.weight &lt; 100000) {</span>
<span class="nc" id="L5442">            int penalty = (int) Math.ceil((100000 - defender.weight) / 10000);</span>
<span class="nc" id="L5443">            toHit.addModifier(penalty, &quot;defender weight&quot;);</span>
        }

<span class="nc" id="L5446">        return toHit;</span>
    }

    /**
     * This assembles attack roll modifiers for infantry swarm and leg attacks.
     */
    private static ToHitData getAntiMechMods(ToHitData data, Infantry attacker,
                                             Entity defender) {
<span class="nc bnc" id="L5454" title="All 2 branches missed.">        if (attacker == null) {</span>
<span class="nc" id="L5455">            data.addModifier(TargetRoll.IMPOSSIBLE, &quot;Unknown attacker&quot;);</span>
<span class="nc" id="L5456">            return data;</span>
        }
<span class="nc bnc" id="L5458" title="All 2 branches missed.">        if (defender == null) {</span>
<span class="nc" id="L5459">            data.addModifier(TargetRoll.IMPOSSIBLE, &quot;Unknown defender&quot;);</span>
<span class="nc" id="L5460">            return data;</span>
        }

<span class="nc bnc" id="L5463" title="All 2 branches missed.">        if (attacker instanceof BattleArmor) {</span>
            // Battle Armor units can't do an AM Attack if they're burdened.
<span class="nc bnc" id="L5465" title="All 2 branches missed.">            if (((BattleArmor) attacker).isBurdened()) {</span>
<span class="nc" id="L5466">                data.addModifier(TargetRoll.IMPOSSIBLE,</span>
                                 &quot;Launcher not jettisoned.&quot;);
<span class="nc" id="L5468">                return data;</span>
            }
            // BA units that jumped using mechanical jump boosters can't attack
<span class="nc bnc" id="L5471" title="All 2 branches missed.">            if (attacker.hasWorkingMisc(MiscType.F_MECHANICAL_JUMP_BOOSTER)</span>
                // we used a mechanical jump booster for jumping only if we
                // don't have normal JJs, or if we are underwater-capable
                // because we underwatercapable BAs can only jump via
                // mechanical jump boosters
                // otherwise, normal JJs give the same MP and do not have
                // this restriction
<span class="nc bnc" id="L5478" title="All 2 branches missed.">                &amp;&amp; ((attacker.getOriginalJumpMP() == 0) || (attacker</span>
<span class="nc bnc" id="L5479" title="All 4 branches missed.">                                                                    .getMovementMode() == EntityMovementMode.INF_UMU))</span>
                &amp;&amp; (attacker.moved == EntityMovementType.MOVE_JUMP)) {
<span class="nc" id="L5481">                data.addModifier(</span>
                        TargetRoll.IMPOSSIBLE,
                        &quot;can't jump using mechanical jump booster and anti-mech attack in the same turn&quot;);
<span class="nc" id="L5484">                return data;</span>
            }
        } else {
            // Infantry can't have encumbering armor
<span class="nc bnc" id="L5488" title="All 2 branches missed.">            if (attacker.isArmorEncumbering()) {</span>
<span class="nc" id="L5489">                data.addModifier(TargetRoll.IMPOSSIBLE,</span>
                                 &quot;can't engage in anti-mek attacks with encumbering armor.&quot;);
<span class="nc" id="L5491">                return data;</span>
            }
        }

        // Can't target a transported entity.
<span class="nc bnc" id="L5496" title="All 2 branches missed.">        if (Entity.NONE != defender.getTransportId()) {</span>
<span class="nc" id="L5497">            data.addModifier(TargetRoll.IMPOSSIBLE, &quot;Target is a passenger.&quot;);</span>
<span class="nc" id="L5498">            return data;</span>
        }

<span class="nc bnc" id="L5501" title="All 2 branches missed.">        if (defender.isMakingDfa()) {</span>
<span class="nc" id="L5502">            data.addModifier(TargetRoll.IMPOSSIBLE, &quot;Target is making a DFA.&quot;);</span>
<span class="nc" id="L5503">            return data;</span>
        }

        // Already conducting a swarm attack.
<span class="nc bnc" id="L5507" title="All 2 branches missed.">        if (Entity.NONE != attacker.getSwarmTargetId()) {</span>
<span class="nc" id="L5508">            data.addModifier(TargetRoll.IMPOSSIBLE,</span>
                             &quot;Attacker is currently swarming.&quot;);
<span class="nc" id="L5510">            return data;</span>
        }
        
<span class="nc bnc" id="L5513" title="All 2 branches missed.">        if (defender.isAirborneVTOLorWIGE()) {</span>
<span class="nc" id="L5514">            data.addModifier(TargetRoll.IMPOSSIBLE, &quot;Cannot target airborne unit.&quot;);</span>
<span class="nc" id="L5515">            return data;</span>
        }

<span class="nc bnc" id="L5518" title="All 4 branches missed.">        if ((defender instanceof Mech) &amp;&amp; ((Mech) defender).isIndustrial()) {</span>
<span class="nc" id="L5519">            data.addModifier(-1, &quot;targeting industrial mech&quot;);</span>
        }

        // protected/exposed actuator quirk may adjust target roll
<span class="nc bnc" id="L5523" title="All 2 branches missed.">        if (defender.hasQuirk(OptionsConstants.QUIRK_POS_PRO_ACTUATOR)) {</span>
<span class="nc" id="L5524">            data.addModifier(+1, &quot;protected actuators&quot;);</span>
        }
<span class="nc bnc" id="L5526" title="All 2 branches missed.">        if (defender.hasQuirk(OptionsConstants.QUIRK_NEG_EXP_ACTUATOR)) {</span>
<span class="nc" id="L5527">            data.addModifier(-1, &quot;exposed actuators&quot;);</span>
        }

        // MD Infantry with grappler/magnets get bonus
<span class="nc bnc" id="L5531" title="All 2 branches missed.">        if (attacker.hasAbility(OptionsConstants.MD_PL_ENHANCED)) {</span>
<span class="nc" id="L5532">            data.addModifier(-2, &quot;MD Grapple/Magnet&quot;);</span>
        }

        // swarm/leg attacks take target movement mods into account
<span class="nc" id="L5536">        data.append(getTargetMovementModifier(attacker.getGame(), defender.getTargetId()));</span>
        
<span class="nc" id="L5538">        return data;</span>
    }

    /**
     * Get the base to-hit number of a Leg Attack by the given attacker upon the
     * given defender
     *
     * @param attacker - the &lt;code&gt;Entity&lt;/code&gt; conducting the leg attack.
     * @param defender - the &lt;code&gt;Entity&lt;/code&gt; being attacked.
     * @return The base &lt;code&gt;ToHitData&lt;/code&gt; of the attack.
     */
    public static ToHitData getLegAttackBaseToHit(Entity attacker,
            Entity defender, IGame game) {
<span class="nc" id="L5551">        String reason = &quot;Non Infantry not allowed to do AM attacks.&quot;;</span>
<span class="nc" id="L5552">        ToHitData toReturn = null;</span>
<span class="nc" id="L5553">        boolean alreadyPerformingOther = false;</span>
<span class="nc" id="L5554">        for (Enumeration&lt;EntityAction&gt; actions = game.getActions(); actions</span>
<span class="nc bnc" id="L5555" title="All 2 branches missed.">                .hasMoreElements(); ) {</span>
<span class="nc" id="L5556">            EntityAction ea = actions.nextElement();</span>
<span class="nc bnc" id="L5557" title="All 2 branches missed.">            if (ea instanceof WeaponAttackAction) {</span>
<span class="nc" id="L5558">                WeaponAttackAction waa = (WeaponAttackAction) ea;</span>
<span class="nc" id="L5559">                Entity waaAE = waa.getEntity(game);</span>
<span class="nc bnc" id="L5560" title="All 4 branches missed.">                if ((waaAE != null) &amp;&amp; waaAE.equals(attacker)) {</span>
                    // impossible if already doing a swarm attack
<span class="nc" id="L5562">                    if (waa.getEntity(game).getEquipment(waa.getWeaponId())</span>
<span class="nc" id="L5563">                           .getType().getInternalName()</span>
<span class="nc bnc" id="L5564" title="All 2 branches missed.">                           .equals(Infantry.SWARM_MEK)) {</span>
<span class="nc" id="L5565">                        alreadyPerformingOther = true;</span>

                    }
                }
            }
<span class="nc" id="L5570">        }</span>

<span class="nc bnc" id="L5572" title="All 2 branches missed.">        if (alreadyPerformingOther) {</span>
<span class="nc" id="L5573">            reason = &quot;already performing a swarm attack&quot;;</span>
        }
        // Can only attack a Mek's legs.
<span class="nc bnc" id="L5576" title="All 2 branches missed.">        else if (!(defender instanceof Mech)) {</span>
<span class="nc" id="L5577">            reason = &quot;Defender is not a Mech.&quot;;</span>
        }

        // Can't attack if flying
<span class="nc bnc" id="L5581" title="All 2 branches missed.">        else if (attacker.getElevation() &gt; defender.getElevation()) {</span>
<span class="nc" id="L5582">            reason = &quot;Cannot do leg attack while flying.&quot;;</span>
        }

        // Handle BattleArmor attackers.
<span class="nc bnc" id="L5586" title="All 2 branches missed.">        else if (attacker instanceof BattleArmor) {</span>
<span class="nc" id="L5587">            BattleArmor inf = (BattleArmor) attacker;</span>
<span class="nc" id="L5588">            toReturn = new ToHitData(inf.getCrew().getPiloting(),</span>
                    &quot;anti-mech skill&quot;, ToHitData.HIT_KICK, ToHitData.SIDE_FRONT);
<span class="nc" id="L5590">            int men = inf.getShootingStrength();</span>
<span class="nc" id="L5591">            int modifier = TargetRoll.IMPOSSIBLE;</span>
<span class="nc bnc" id="L5592" title="All 2 branches missed.">            if (men &gt;= 4) {</span>
<span class="nc" id="L5593">                modifier = 0;</span>
<span class="nc bnc" id="L5594" title="All 2 branches missed.">            } else if (men &gt;= 3) {</span>
<span class="nc" id="L5595">                modifier = 2;</span>
<span class="nc bnc" id="L5596" title="All 2 branches missed.">            } else if (men &gt;= 2) {</span>
<span class="nc" id="L5597">                modifier = 5;</span>
<span class="nc bnc" id="L5598" title="All 2 branches missed.">            } else if (men &gt;= 1) {</span>
<span class="nc" id="L5599">                modifier = 7;</span>
            }
<span class="nc" id="L5601">            toReturn.addModifier(modifier, men + &quot; trooper(s) active&quot;);</span>
<span class="nc bnc" id="L5602" title="All 2 branches missed.">        } else if (attacker instanceof Infantry) {</span>
            // Non-BattleArmor infantry need many more men.
<span class="nc" id="L5604">            Infantry inf = (Infantry) attacker;</span>
<span class="nc" id="L5605">            toReturn = new ToHitData(inf.getCrew().getPiloting(),</span>
                    &quot;anti-mech skill&quot;, ToHitData.HIT_KICK, ToHitData.SIDE_FRONT);
<span class="nc" id="L5607">            int men = inf.getShootingStrength();</span>
<span class="nc" id="L5608">            int modifier = TargetRoll.IMPOSSIBLE;</span>
<span class="nc bnc" id="L5609" title="All 2 branches missed.">            if (men &gt;= 22) {</span>
<span class="nc" id="L5610">                modifier = 0;</span>
<span class="nc bnc" id="L5611" title="All 2 branches missed.">            } else if (men &gt;= 16) {</span>
<span class="nc" id="L5612">                modifier = 2;</span>
<span class="nc bnc" id="L5613" title="All 2 branches missed.">            } else if (men &gt;= 10) {</span>
<span class="nc" id="L5614">                modifier = 5;</span>
<span class="nc bnc" id="L5615" title="All 2 branches missed.">            } else if (men &gt;= 5) {</span>
<span class="nc" id="L5616">                modifier = 7;</span>
            }
<span class="nc" id="L5618">            toReturn.addModifier(modifier, men + &quot; trooper(s) active&quot;);</span>
        }

<span class="nc bnc" id="L5621" title="All 4 branches missed.">        if (defender instanceof Mech &amp;&amp; ((Mech)defender).hasTracks()) {</span>
<span class="nc" id="L5622">            toReturn.addModifier(-2, &quot;has tracks&quot;);</span>
        }

        // If the swarm is impossible, ToHitData wasn't created
<span class="nc bnc" id="L5626" title="All 2 branches missed.">        if (toReturn == null) {</span>
<span class="nc" id="L5627">            toReturn = new ToHitData(TargetRoll.IMPOSSIBLE, reason.toString(),</span>
                    ToHitData.HIT_KICK, ToHitData.SIDE_FRONT);
        }
<span class="nc bnc" id="L5630" title="All 2 branches missed.">        if (toReturn.getValue() == TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5631">            return toReturn;</span>
        }
<span class="nc" id="L5633">        toReturn = Compute.getAntiMechMods(toReturn, (Infantry) attacker,</span>
                defender);
<span class="nc" id="L5635">        return toReturn;</span>
    }

    /**
     * Get the base to-hit number of a Swarm Mek by the given attacker upon the
     * given defender.
     *
     * @param attacker - the &lt;code&gt;Entity&lt;/code&gt; swarming.
     * @param defender - the &lt;code&gt;Entity&lt;/code&gt; being swarmed.
     * @return The base &lt;code&gt;ToHitData&lt;/code&gt; of the mek.
     */
    public static ToHitData getSwarmMekBaseToHit(Entity attacker,
            Entity defender, IGame game) {
<span class="nc" id="L5648">        ToHitData toReturn = null;</span>
<span class="nc" id="L5649">        String reason = &quot;Non Infantry not allowed to do AM attacks.&quot;;</span>

<span class="nc" id="L5651">        boolean alreadyPerformingOther = false;</span>
<span class="nc" id="L5652">        for (Enumeration&lt;EntityAction&gt; actions = game.getActions(); actions</span>
<span class="nc bnc" id="L5653" title="All 2 branches missed.">                .hasMoreElements(); ) {</span>
<span class="nc" id="L5654">            EntityAction ea = actions.nextElement();</span>
<span class="nc bnc" id="L5655" title="All 2 branches missed.">            if (ea instanceof WeaponAttackAction) {</span>
<span class="nc" id="L5656">                WeaponAttackAction waa = (WeaponAttackAction) ea;</span>
<span class="nc" id="L5657">                Entity waaAE = waa.getEntity(game);</span>
<span class="nc bnc" id="L5658" title="All 4 branches missed.">                if ((waaAE != null) &amp;&amp; waaAE.equals(attacker)) {</span>
                    // impossible if already doing a swarm attack
<span class="nc" id="L5660">                    if (waa.getEntity(game).getEquipment(waa.getWeaponId())</span>
<span class="nc" id="L5661">                           .getType().getInternalName()</span>
<span class="nc bnc" id="L5662" title="All 2 branches missed.">                           .equals(Infantry.LEG_ATTACK)) {</span>
<span class="nc" id="L5663">                        alreadyPerformingOther = true;</span>

                    }
                }
            }
<span class="nc" id="L5668">        }</span>
<span class="nc bnc" id="L5669" title="All 2 branches missed.">        if (alreadyPerformingOther) {</span>
<span class="nc" id="L5670">            reason = &quot;attacker is already performing a leg attack&quot;;</span>
        }
        // Can only swarm a Mek.
<span class="nc bnc" id="L5673" title="All 4 branches missed.">        else if (!(defender instanceof Mech) &amp;&amp; !(defender instanceof Tank)) {</span>
<span class="nc" id="L5674">            reason = &quot;Defender is not a Mech or vehicle.&quot;;</span>
        }
        // Can't swarm a friendly Mek. See
        // http://www.classicbattletech.com/w3t/showflat
        // .php?Cat=&amp;Board=ask&amp;Number=632321&amp;page=0&amp;view=collapsed&amp;sb=5&amp;o=0&amp;fpart=
<span class="nc bnc" id="L5679" title="All 2 branches missed.">        else if (!attacker.isEnemyOf(defender)</span>
<span class="nc" id="L5680">                 &amp;&amp; !attacker.getGame().getOptions()</span>
<span class="nc bnc" id="L5681" title="All 2 branches missed.">                             .booleanOption(OptionsConstants.BASE_FRIENDLY_FIRE)) {</span>
<span class="nc" id="L5682">            reason = &quot;Can only swarm an enemy.&quot;;</span>
        }
        // target is already swarmed
<span class="nc bnc" id="L5685" title="All 2 branches missed.">        else if (defender.getSwarmAttackerId() != Entity.NONE) {</span>
<span class="nc" id="L5686">            reason = &quot;Only one swarm allowed at a time.&quot;;</span>
        }
        // Handle BattleArmor attackers.
<span class="nc bnc" id="L5689" title="All 2 branches missed.">        else if (attacker instanceof BattleArmor) {</span>
<span class="nc" id="L5690">            BattleArmor inf = (BattleArmor) attacker;</span>
<span class="nc" id="L5691">            toReturn = new ToHitData(inf.getCrew().getPiloting(), &quot;anti-mech skill&quot;);</span>
<span class="nc" id="L5692">            int men = inf.getShootingStrength();</span>
<span class="nc" id="L5693">            int modifier = TargetRoll.IMPOSSIBLE;</span>
<span class="nc bnc" id="L5694" title="All 2 branches missed.">            if (men &gt;= 4) {</span>
<span class="nc" id="L5695">                modifier = 2;</span>
<span class="nc bnc" id="L5696" title="All 2 branches missed.">            } else if (men &gt;= 1) {</span>
<span class="nc" id="L5697">                modifier = 5;</span>
            }
<span class="nc" id="L5699">            toReturn.addModifier(modifier, men + &quot; trooper(s) active&quot;);</span>
<span class="nc" id="L5700">        }</span>
        // Non-BattleArmor infantry need many more men.
<span class="nc bnc" id="L5702" title="All 2 branches missed.">        else if (attacker instanceof Infantry) {</span>
<span class="nc" id="L5703">            Infantry inf = (Infantry) attacker;</span>
<span class="nc" id="L5704">            toReturn = new ToHitData(inf.getCrew().getPiloting(), &quot;anti-mech skill&quot;);</span>
<span class="nc" id="L5705">            int men = inf.getShootingStrength();</span>
<span class="nc" id="L5706">            int modifier = TargetRoll.IMPOSSIBLE;</span>
<span class="nc bnc" id="L5707" title="All 2 branches missed.">            if (men &gt;= 22) {</span>
<span class="nc" id="L5708">                modifier = 2;</span>
<span class="nc bnc" id="L5709" title="All 2 branches missed.">            } else if (men &gt;= 16) {</span>
<span class="nc" id="L5710">                modifier = 5;</span>
            }
<span class="nc" id="L5712">            toReturn.addModifier(modifier, men + &quot; trooper(s) active&quot;);</span>
        }
        // If the swarm is impossible, ToHitData wasn't created
<span class="nc bnc" id="L5715" title="All 2 branches missed.">        if (toReturn == null) {</span>
<span class="nc" id="L5716">            toReturn = new ToHitData(TargetRoll.IMPOSSIBLE, reason.toString());</span>
        }
<span class="nc bnc" id="L5718" title="All 2 branches missed.">        if (toReturn.getValue() == TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5719">            return toReturn;</span>
        }
<span class="nc" id="L5721">        toReturn = Compute.getAntiMechMods(toReturn, (Infantry) attacker,</span>
                                           defender);

        // If the attacker has assault claws, give a -1 modifier.
        // We can stop looking when we find our first match.
<span class="nc bnc" id="L5726" title="All 2 branches missed.">        for (Mounted mount : attacker.getMisc()) {</span>
<span class="nc" id="L5727">            EquipmentType equip = mount.getType();</span>
<span class="nc bnc" id="L5728" title="All 2 branches missed.">            if (equip.hasFlag(MiscType.F_MAGNET_CLAW)) {</span>
<span class="nc" id="L5729">                toReturn.addModifier(-1, &quot;attacker has magnetic claws&quot;);</span>
<span class="nc" id="L5730">                break;</span>
            }
<span class="nc" id="L5732">        }</span>
<span class="nc" id="L5733">        return toReturn;</span>
    }

    public static boolean canPhysicalTarget(IGame game, int entityId,
                                            Targetable target) {

<span class="nc" id="L5739">        if (PunchAttackAction.toHit(game, entityId, target,</span>
<span class="nc bnc" id="L5740" title="All 2 branches missed.">                                    PunchAttackAction.LEFT, false).getValue() != TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5741">            return true;</span>
        }

<span class="nc" id="L5744">        if (PunchAttackAction.toHit(game, entityId, target,</span>
<span class="nc bnc" id="L5745" title="All 2 branches missed.">                                    PunchAttackAction.RIGHT, false).getValue() != TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5746">            return true;</span>
        }

<span class="nc" id="L5749">        if (KickAttackAction.toHit(game, entityId, target,</span>
<span class="nc bnc" id="L5750" title="All 2 branches missed.">                                   KickAttackAction.LEFT).getValue() != TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5751">            return true;</span>
        }

<span class="nc" id="L5754">        if (KickAttackAction.toHit(game, entityId, target,</span>
<span class="nc bnc" id="L5755" title="All 2 branches missed.">                                   KickAttackAction.RIGHT).getValue() != TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5756">            return true;</span>
        }

<span class="nc bnc" id="L5759" title="All 2 branches missed.">        if ((game.getEntity(entityId) instanceof QuadMech)</span>
<span class="nc" id="L5760">            &amp;&amp; ((KickAttackAction.toHit(game, entityId, target,</span>
<span class="nc bnc" id="L5761" title="All 2 branches missed.">                                        KickAttackAction.LEFTMULE).getValue() != TargetRoll.IMPOSSIBLE) ||</span>
                (KickAttackAction
<span class="nc" id="L5763">                         .toHit(game, entityId, target,</span>
<span class="nc bnc" id="L5764" title="All 2 branches missed.">                                KickAttackAction.RIGHTMULE).getValue() != TargetRoll.IMPOSSIBLE))) {</span>
<span class="nc" id="L5765">            return true;</span>
        }

<span class="nc" id="L5768">        if (BrushOffAttackAction.toHit(game, entityId, target,</span>
<span class="nc bnc" id="L5769" title="All 2 branches missed.">                                       BrushOffAttackAction.LEFT).getValue() != TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5770">            return true;</span>
        }

<span class="nc" id="L5773">        if (BrushOffAttackAction.toHit(game, entityId, target,</span>
<span class="nc bnc" id="L5774" title="All 2 branches missed.">                                       BrushOffAttackAction.RIGHT).getValue() != TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5775">            return true;</span>
        }

<span class="nc bnc" id="L5778" title="All 2 branches missed.">        if (new ThrashAttackAction(entityId, target).toHit(game).getValue() != TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5779">            return true;</span>
        }

<span class="nc" id="L5782">        if (ProtomechPhysicalAttackAction.toHit(game, entityId, target)</span>
<span class="nc bnc" id="L5783" title="All 2 branches missed.">                                         .getValue() != TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5784">            return true;</span>
        }

<span class="nc bnc" id="L5787" title="All 2 branches missed.">        if (PushAttackAction.toHit(game, entityId, target).getValue() != TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5788">            return true;</span>
        }

<span class="nc bnc" id="L5791" title="All 2 branches missed.">        if (LayExplosivesAttackAction.toHit(game, entityId, target).getValue() != TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5792">            return true;</span>
        }

<span class="nc bnc" id="L5795" title="All 2 branches missed.">        if (TripAttackAction.toHit(game, entityId, target).getValue() != TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5796">            return true;</span>
        }

<span class="nc bnc" id="L5799" title="All 2 branches missed.">        if (GrappleAttackAction.toHit(game, entityId, target).getValue() != TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5800">            return true;</span>
        }

<span class="nc bnc" id="L5803" title="All 2 branches missed.">        if (BreakGrappleAttackAction.toHit(game, entityId, target).getValue() != TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5804">            return true;</span>
        }

<span class="nc bnc" id="L5807" title="All 2 branches missed.">        for (Mounted club : game.getEntity(entityId).getClubs()) {</span>
<span class="nc bnc" id="L5808" title="All 2 branches missed.">            if (null != club) {</span>
<span class="nc" id="L5809">                if (ClubAttackAction.toHit(game, entityId, target, club,</span>
<span class="nc bnc" id="L5810" title="All 2 branches missed.">                                           ToHitData.HIT_NORMAL, false).getValue() != TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5811">                    return true;</span>
                }
            }
<span class="nc" id="L5814">        }</span>

<span class="nc" id="L5816">        if (JumpJetAttackAction.toHit(game, entityId, target,</span>
<span class="nc bnc" id="L5817" title="All 2 branches missed.">                                      JumpJetAttackAction.BOTH).getValue() != TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5818">            return true;</span>
        }
<span class="nc" id="L5820">        if (JumpJetAttackAction.toHit(game, entityId, target,</span>
<span class="nc bnc" id="L5821" title="All 2 branches missed.">                                      JumpJetAttackAction.LEFT).getValue() != TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5822">            return true;</span>
        }
<span class="nc" id="L5824">        if (JumpJetAttackAction.toHit(game, entityId, target,</span>
<span class="nc bnc" id="L5825" title="All 2 branches missed.">                                      JumpJetAttackAction.RIGHT).getValue() != TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5826">            return true;</span>
        }

<span class="nc bnc" id="L5829" title="All 2 branches missed.">        if (BAVibroClawAttackAction.toHit(game, entityId, target).getValue() != TargetRoll.IMPOSSIBLE) {</span>
<span class="nc" id="L5830">            return true;</span>
        }

<span class="nc" id="L5833">        return false;</span>
    }

    /**
     * Can movement between the two coordinates be on pavement (which includes
     * roads and bridges)? If so it will override prohibited terrain, it may
     * change movement costs, and it may lead to skids.
     *
     * @param game     - the &lt;code&gt;IGame&lt;/code&gt; object.
     * @param src      - the &lt;code&gt;Coords&lt;/code&gt; being left.
     * @param dest     - the &lt;code&gt;Coords&lt;/code&gt; being entered.
     * @param moveStep
     * @return &lt;code&gt;true&lt;/code&gt; if movement between &lt;code&gt;src&lt;/code&gt; and
     * &lt;code&gt;dest&lt;/code&gt; can be on pavement; &lt;code&gt;false&lt;/code&gt;
     * otherwise.
     */
    public static boolean canMoveOnPavement(IGame game, Coords src,
            Coords dest, MoveStep moveStep) {
<span class="nc" id="L5851">        final IHex srcHex = game.getBoard().getHex(src);</span>
<span class="nc" id="L5852">        final IHex destHex = game.getBoard().getHex(dest);</span>
<span class="nc" id="L5853">        final int src2destDir = src.direction(dest);</span>
<span class="nc" id="L5854">        final int dest2srcDir = (src2destDir + 3) % 6;</span>
<span class="nc" id="L5855">        boolean result = false;</span>

        // Jumping shouldn't be considered to be moving on pavement
<span class="nc bnc" id="L5858" title="All 2 branches missed.">        if (moveStep.isJumping()) {</span>
<span class="nc" id="L5859">            return false;</span>
        }

        // We may be moving in the same hex.
<span class="nc bnc" id="L5863" title="All 2 branches missed.">        if (src.equals(dest)</span>
<span class="nc bnc" id="L5864" title="All 2 branches missed.">                &amp;&amp; (srcHex.containsTerrain(Terrains.PAVEMENT)</span>
<span class="nc bnc" id="L5865" title="All 2 branches missed.">                        || srcHex.containsTerrain(Terrains.ROAD) || srcHex</span>
<span class="nc bnc" id="L5866" title="All 2 branches missed.">                            .containsTerrain(Terrains.BRIDGE))) {</span>
<span class="nc" id="L5867">            result = true;</span>
        }
        // If the source is a pavement hex, then see if the destination
        // hex is also a pavement hex or has a road or bridge that exits
        // into the source hex and the entity is climbing onto the bridge.
<span class="nc bnc" id="L5872" title="All 2 branches missed.">        else if (srcHex.containsTerrain(Terrains.PAVEMENT)</span>
<span class="nc bnc" id="L5873" title="All 2 branches missed.">                &amp;&amp; (destHex.containsTerrain(Terrains.PAVEMENT)</span>
<span class="nc bnc" id="L5874" title="All 2 branches missed.">                        || destHex.containsTerrainExit(Terrains.ROAD,</span>
<span class="nc bnc" id="L5875" title="All 2 branches missed.">                                dest2srcDir) || (destHex.containsTerrainExit(</span>
<span class="nc bnc" id="L5876" title="All 2 branches missed.">                        Terrains.BRIDGE, dest2srcDir) &amp;&amp; moveStep.climbMode()))) {</span>
<span class="nc" id="L5877">            result = true;</span>
        }
        // See if the source hex has a road or bridge (and the entity is on the
        // bridge) that exits into the destination hex, and the dest hex has
        // pavement or a corresponding exit to the src hex
<span class="nc bnc" id="L5882" title="All 2 branches missed.">        else if ((srcHex.containsTerrainExit(Terrains.ROAD, src2destDir) || (srcHex</span>
<span class="nc bnc" id="L5883" title="All 2 branches missed.">                .containsTerrainExit(Terrains.BRIDGE, src2destDir) &amp;&amp; (moveStep.getElevation() == srcHex</span>
<span class="nc bnc" id="L5884" title="All 2 branches missed.">                .terrainLevel(Terrains.BRIDGE_ELEV))))</span>
<span class="nc bnc" id="L5885" title="All 2 branches missed.">                &amp;&amp; (destHex.containsTerrainExit(Terrains.ROAD, dest2srcDir)</span>
<span class="nc bnc" id="L5886" title="All 2 branches missed.">                        || (destHex.containsTerrainExit(Terrains.BRIDGE,</span>
<span class="nc bnc" id="L5887" title="All 2 branches missed.">                                dest2srcDir) &amp;&amp; moveStep.climbMode()) || destHex</span>
<span class="nc bnc" id="L5888" title="All 2 branches missed.">                            .containsTerrain(Terrains.PAVEMENT))) {</span>
<span class="nc" id="L5889">            result = true;</span>
        }

<span class="nc" id="L5892">        return result;</span>
    }

    /**
     * Determines whether the attacker and the target are in the same building.
     *
     * @return true if the target can and does occupy the same building, false
     *         otherwise.
     */
    public static boolean isInSameBuilding(IGame game, Entity attacker,
            Targetable target) {
<span class="nc bnc" id="L5903" title="All 2 branches missed.">        if (!(target instanceof Entity)) {</span>
<span class="nc" id="L5904">            return false;</span>
        }
<span class="nc" id="L5906">        Entity targetEntity = (Entity) target;</span>
<span class="nc bnc" id="L5907" title="All 2 branches missed.">        if (!Compute.isInBuilding(game, attacker)</span>
<span class="nc bnc" id="L5908" title="All 2 branches missed.">                || !Compute.isInBuilding(game, targetEntity)) {</span>
<span class="nc" id="L5909">            return false;</span>
        }

<span class="nc" id="L5912">        Building attkBldg = game.getBoard().getBuildingAt(</span>
<span class="nc" id="L5913">                attacker.getPosition());</span>
<span class="nc" id="L5914">        Building targBldg = game.getBoard().getBuildingAt(target.getPosition());</span>

<span class="nc" id="L5916">        return attkBldg.equals(targBldg);</span>
    }

    /**
     * Determine if the given unit is inside of a building at the given
     * coordinates.
     *
     * @param game   - the &lt;code&gt;IGame&lt;/code&gt; object. This value may be
     *               &lt;code&gt;null&lt;/code&gt;.
     * @param entity - the &lt;code&gt;Entity&lt;/code&gt; to be checked. This value may be
     *               &lt;code&gt;null&lt;/code&gt;.
     * @return &lt;code&gt;true&lt;/code&gt; if the entity is inside of the building at
     * those coordinates. &lt;code&gt;false&lt;/code&gt; if there is no building at
     * those coordinates or if the entity is on the roof or in the air
     * above the building, or if any input argument is &lt;code&gt;null&lt;/code&gt;
     * .
     */
    public static boolean isInBuilding(IGame game, Entity entity) {

        // No game, no building.
<span class="pc bpc" id="L5936" title="1 of 2 branches missed.">        if (game == null) {</span>
<span class="nc" id="L5937">            return false;</span>
        }

        // Null entities can't be in a building.
<span class="pc bpc" id="L5941" title="1 of 2 branches missed.">        if (entity == null) {</span>
<span class="nc" id="L5942">            return false;</span>
        }

        // Call the version of the function that requires coordinates.
<span class="fc" id="L5946">        return Compute.isInBuilding(game, entity, entity.getPosition());</span>
    }

    /**
     * Determine if the given unit is inside of a building at the given
     * coordinates.
     *
     * @param game   - the &lt;code&gt;IGame&lt;/code&gt; object. This value may be
     *               &lt;code&gt;null&lt;/code&gt;.
     * @param entity - the &lt;code&gt;Entity&lt;/code&gt; to be checked. This value may be
     *               &lt;code&gt;null&lt;/code&gt;.
     * @param coords - the &lt;code&gt;Coords&lt;/code&gt; of the building hex. This value may
     *               be &lt;code&gt;null&lt;/code&gt;.
     * @return &lt;code&gt;true&lt;/code&gt; if the entity is inside of the building at
     * those coordinates. &lt;code&gt;false&lt;/code&gt; if there is no building at
     * those coordinates or if the entity is on the roof or in the air
     * above the building, or if any input argument is &lt;code&gt;null&lt;/code&gt;
     * .
     */
    public static boolean isInBuilding(IGame game, Entity entity, Coords coords) {

        // No game, no building.
<span class="pc bpc" id="L5968" title="1 of 2 branches missed.">        if (game == null) {</span>
<span class="nc" id="L5969">            return false;</span>
        }

        // Null entities can't be in a building.
<span class="pc bpc" id="L5973" title="1 of 2 branches missed.">        if (entity == null) {</span>
<span class="nc" id="L5974">            return false;</span>
        }

        // Null coordinates can't have buildings.
<span class="fc bfc" id="L5978" title="All 2 branches covered.">        if (coords == null) {</span>
<span class="fc" id="L5979">            return false;</span>
        }

        // Get the Hex at those coordinates.

<span class="fc" id="L5984">        return Compute.isInBuilding(game, entity.getElevation(), coords);</span>
    }

    public static boolean isInBuilding(IGame game, int entityElev, Coords coords) {

        // Get the Hex at those coordinates.
<span class="fc" id="L5990">        final IHex curHex = game.getBoard().getHex(coords);</span>

<span class="pc bpc" id="L5992" title="1 of 2 branches missed.">        if (curHex == null) {</span>
            // probably off board artillery or reinforcement
<span class="nc" id="L5994">            return false;</span>
        }

        // The entity can't be inside of a building that isn't there.
<span class="fc bfc" id="L5998" title="All 2 branches covered.">        if (!curHex.containsTerrain(Terrains.BLDG_ELEV)) {</span>
<span class="fc" id="L5999">            return false;</span>
        }

        // The entity can't be inside of a building that isn't there.
<span class="pc bpc" id="L6003" title="1 of 2 branches missed.">        if (!curHex.containsTerrain(Terrains.BUILDING)) {</span>
<span class="nc" id="L6004">            return false;</span>
        }

        // Get the elevations occupied by the building.
<span class="fc" id="L6008">        int bldgHeight = curHex.terrainLevel(Terrains.BLDG_ELEV);</span>
<span class="fc" id="L6009">        int basement = 0;</span>
<span class="pc bpc" id="L6010" title="1 of 2 branches missed.">        if (curHex.containsTerrain(Terrains.BLDG_BASEMENT_TYPE)) {</span>
<span class="nc" id="L6011">            basement = BasementType.getType(</span>
<span class="nc" id="L6012">                    curHex.terrainLevel(Terrains.BLDG_BASEMENT_TYPE))</span>
<span class="nc" id="L6013">                                   .getDepth();</span>
        }

        // Return true if the entity is in the range of building elevations.
<span class="pc bpc" id="L6017" title="2 of 4 branches missed.">        if ((entityElev &gt;= (-basement)) &amp;&amp; (entityElev &lt; (bldgHeight))) {</span>
<span class="fc" id="L6018">            return true;</span>
        }

        // Entity is not *inside* of the building.
<span class="nc" id="L6022">        return false;</span>
    }

    /**
     * Scatter from hex according to dive bombing rules (based on MoF),
     * TW pg 246.  The scatter can happen in any direction.
     *
     * @param coords The &lt;code&gt;Coords&lt;/code&gt; to scatter from
     * @param moF The margin of failure, which deterimines scatter distance
     * @return the &lt;code&gt;Coords&lt;/code&gt; scattered to and distance (moF)
     */
    public static Coords scatterDiveBombs(Coords coords, int moF) {
<span class="nc" id="L6034">        return Compute.scatter(coords, moF);</span>
    }

    /**
     * Scatter from hex according to altitude bombing rules (based on MoF),
     * TW pg 246.  The scatter only happens in the &quot;front&quot; three facings.
     *
     * @param coords The &lt;code&gt;Coords&lt;/code&gt; to scatter from
     * @param facing
     * @return the &lt;code&gt;Coords&lt;/code&gt; scattered to and distance (moF)
     */
    public static Coords scatterAltitudeBombs(Coords coords, int facing) {
<span class="nc" id="L6046">        int dir = 0;</span>
<span class="nc" id="L6047">        int scatterDirection = Compute.d6(1);</span>
<span class="nc bnc" id="L6048" title="All 4 branches missed.">        switch (scatterDirection) {</span>
            case 1:
            case 2:
<span class="nc" id="L6051">                dir = (facing - 1) % 6;</span>
<span class="nc" id="L6052">                break;</span>
            case 3:
            case 4:
<span class="nc" id="L6055">                dir = facing;</span>
<span class="nc" id="L6056">                break;</span>
            case 5:
            case 6:
<span class="nc" id="L6059">                dir = (facing + 1) % 6;</span>
                break;
        }
<span class="nc" id="L6062">        int dist = Compute.d6(1);</span>
<span class="nc" id="L6063">        return coords.translated(dir, dist);</span>
    }

    /**
     * scatter from hex according to direct fire artillery rules (based on MoF)
     *
     * @param coords The &lt;code&gt;Coords&lt;/code&gt; to scatter from
     * @param moF The margin of failure, which deterimines scatter distance
     * @return the &lt;code&gt;Coords&lt;/code&gt; scattered to
     */
    public static Coords scatterDirectArty(Coords coords, int moF) {
<span class="nc" id="L6074">        return Compute.scatter(coords, moF);</span>
    }

    /**
     * scatter from a hex according, roll d6 to choose scatter direction
     *
     * @param coords The &lt;code&gt;Coords&lt;/code&gt; to scatter from
     * @param margin the &lt;code&gt;int&lt;/code&gt; margin of failure, scatter distance will
     *               be the margin of failure
     * @return the &lt;code&gt;Coords&lt;/code&gt; scattered to
     */
    public static Coords scatter(Coords coords, int margin) {
<span class="nc" id="L6086">        int scatterDirection = Compute.d6(1) - 1;</span>
<span class="nc" id="L6087">        return coords.translated(scatterDirection, margin);</span>
    }

    /**
     * scatter from hex according to atmospheric drop rules d6 for direction,
     * 1d6 per point of MOF
     *
     * @param coords The &lt;code&gt;Coords&lt;/code&gt; to scatter from
     * @param margin the &lt;code&gt;int&lt;/code&gt; margin of failure
     * @return the &lt;code&gt;Coords&lt;/code&gt; scattered to
     */
    public static Coords scatterAssaultDrop(Coords coords, int margin) {
<span class="nc" id="L6099">        int scatterDirection = Compute.d6(1) - 1;</span>
<span class="nc" id="L6100">        int distance = Compute.d6(margin);</span>
<span class="nc" id="L6101">        return coords.translated(scatterDirection, distance);</span>
    }

    /**
     * Gets a new target for a flight of swarm missiles that was just shot at an
     * entity and has missiles left
     *
     * @param game
     * @param aeId     The attacking &lt;code&gt;Entity&lt;/code&gt;
     * @param coords
     * @param weaponId The &lt;code&gt;int&lt;/code&gt; ID of the launcher used to fire this
     *                 volley
     * @return the new target &lt;code&gt;Entity&lt;/code&gt;. May return null if no new
     * target available
     */
    public static Entity getSwarmMissileTarget(IGame game, int aeId,
                                               Coords coords, int weaponId) {
<span class="nc" id="L6118">        Entity tempEntity = null;</span>
        // first, check the hex of the original target
<span class="nc" id="L6120">        Iterator&lt;Entity&gt; entities = game.getEntities(coords);</span>
<span class="nc" id="L6121">        Vector&lt;Entity&gt; possibleTargets = new Vector&lt;Entity&gt;();</span>
<span class="nc bnc" id="L6122" title="All 2 branches missed.">        while (entities.hasNext()) {</span>
<span class="nc" id="L6123">            tempEntity = entities.next();</span>
<span class="nc bnc" id="L6124" title="All 2 branches missed.">            if (!tempEntity.getTargetedBySwarm(aeId, weaponId)) {</span>
                // we found a target
<span class="nc" id="L6126">                possibleTargets.add(tempEntity);</span>
            }
        }
        // if there is at least one target, get a random one of them
<span class="nc bnc" id="L6130" title="All 2 branches missed.">        if (!possibleTargets.isEmpty()) {</span>
<span class="nc" id="L6131">            return possibleTargets</span>
<span class="nc" id="L6132">                    .get(Compute.randomInt(possibleTargets.size()));</span>
        }
        // loop through adjacent hexes
<span class="nc bnc" id="L6135" title="All 2 branches missed.">        for (int dir = 0; dir &lt;= 5; dir++) {</span>
<span class="nc" id="L6136">            Coords tempcoords = coords.translated(dir);</span>
<span class="nc bnc" id="L6137" title="All 2 branches missed.">            if (!game.getBoard().contains(tempcoords)) {</span>
<span class="nc" id="L6138">                continue;</span>
            }
<span class="nc bnc" id="L6140" title="All 2 branches missed.">            if (coords.equals(tempcoords)) {</span>
<span class="nc" id="L6141">                continue;</span>
            }
<span class="nc" id="L6143">            entities = game.getEntities(tempcoords);</span>
<span class="nc bnc" id="L6144" title="All 2 branches missed.">            if (entities.hasNext()) {</span>
<span class="nc" id="L6145">                tempEntity = entities.next();</span>
<span class="nc bnc" id="L6146" title="All 2 branches missed.">                if (!tempEntity.getTargetedBySwarm(aeId, weaponId)) {</span>
                    // we found a target
<span class="nc" id="L6148">                    possibleTargets.add(tempEntity);</span>
                }
            }
        }
        // if there is at least one target, get a random one of them
<span class="nc bnc" id="L6153" title="All 2 branches missed.">        if (!possibleTargets.isEmpty()) {</span>
<span class="nc" id="L6154">            return possibleTargets</span>
<span class="nc" id="L6155">                    .get(Compute.randomInt(possibleTargets.size()));</span>
        }
<span class="nc" id="L6157">        return null;</span>
    }

    /**
     * Gets a new target hex for a flight of smoke missiles fired at a hex, if
     * there are remaining missiles.
     */

    /**
     * * STUFF FOR VECTOR MOVEMENT CALCULATIONS **
     */
    public static Coords getFinalPosition(Coords curpos, int[] v) {

<span class="nc bnc" id="L6170" title="All 4 branches missed.">        if ((v == null) || (v.length != 6)) {</span>
<span class="nc" id="L6171">            return curpos;</span>
        }

        // step through each vector and move the direction indicated
<span class="nc" id="L6175">        int thrust = 0;</span>
<span class="nc" id="L6176">        Coords endpos = curpos;</span>
<span class="nc bnc" id="L6177" title="All 2 branches missed.">        for (int dir = 0; dir &lt; 6; dir++) {</span>
<span class="nc" id="L6178">            thrust = v[dir];</span>
<span class="nc bnc" id="L6179" title="All 2 branches missed.">            while (thrust &gt; 0) {</span>
<span class="nc" id="L6180">                endpos = endpos.translated(dir);</span>
<span class="nc" id="L6181">                thrust--;</span>
            }
        }

<span class="nc" id="L6185">        return endpos;</span>
    }

    /**
     * method to change a set of active vectors for a one-point thrust
     * expenditure in the giving facing
     *
     * @param v
     * @param facing
     * @return
     */
    public static int[] changeVectors(int[] v, int facing) {

<span class="nc bnc" id="L6198" title="All 4 branches missed.">        if ((v == null) || (v.length != 6)) {</span>
<span class="nc" id="L6199">            return v;</span>
        }

        // first look at opposing vectors
<span class="nc" id="L6203">        int oppv = facing + 3;</span>
<span class="nc bnc" id="L6204" title="All 2 branches missed.">        if (oppv &gt; 5) {</span>
<span class="nc" id="L6205">            oppv -= 6;</span>
        }
        // is this vector active
<span class="nc bnc" id="L6208" title="All 2 branches missed.">        if (v[oppv] &gt; 0) {</span>
            // then decrement it by one and return
<span class="nc" id="L6210">            v[oppv]--;</span>
<span class="nc" id="L6211">            return v;</span>
        }

        // now check oblique vectors
<span class="nc" id="L6215">        int oblv1 = facing + 2;</span>
<span class="nc bnc" id="L6216" title="All 2 branches missed.">        if (oblv1 &gt; 5) {</span>
<span class="nc" id="L6217">            oblv1 -= 6;</span>
        }
<span class="nc" id="L6219">        int oblv2 = facing - 2;</span>
<span class="nc bnc" id="L6220" title="All 2 branches missed.">        if (oblv2 &lt; 0) {</span>
<span class="nc" id="L6221">            oblv2 += 6;</span>
        }

        // check both of these and if either is active
        // deal with it and then return
<span class="nc bnc" id="L6226" title="All 4 branches missed.">        if ((v[oblv1] &gt; 0) || (v[oblv2] &gt; 0)) {</span>

<span class="nc" id="L6228">            int newface = facing + 1;</span>
<span class="nc bnc" id="L6229" title="All 2 branches missed.">            if (newface &gt; 5) {</span>
<span class="nc" id="L6230">                newface = 0;</span>
            }
<span class="nc bnc" id="L6232" title="All 2 branches missed.">            if (v[oblv1] &gt; 0) {</span>
<span class="nc" id="L6233">                v[oblv1]--;</span>
<span class="nc" id="L6234">                v[newface]++;</span>
            }

<span class="nc" id="L6237">            newface = facing - 1;</span>
<span class="nc bnc" id="L6238" title="All 2 branches missed.">            if (newface &lt; 0) {</span>
<span class="nc" id="L6239">                newface = 5;</span>
            }
<span class="nc bnc" id="L6241" title="All 2 branches missed.">            if (v[oblv2] &gt; 0) {</span>
<span class="nc" id="L6242">                v[oblv2]--;</span>
<span class="nc" id="L6243">                v[newface]++;</span>
            }
<span class="nc" id="L6245">            return v;</span>
        }

        // if nothing was found, then just increase velocity in this vector
<span class="nc" id="L6249">        v[facing]++;</span>
<span class="nc" id="L6250">        return v;</span>
    }

    /**
     * compare two vectors and determine if they are the same
     *
     * @param v1
     * @param v2
     * @return
     */
    public static boolean sameVectors(int[] v1, int[] v2) {

<span class="nc bnc" id="L6262" title="All 2 branches missed.">        for (int i = 0; i &lt; 6; i++) {</span>
<span class="nc bnc" id="L6263" title="All 2 branches missed.">            if (v1[i] != v2[i]) {</span>
<span class="nc" id="L6264">                return false;</span>
            }
        }

<span class="nc" id="L6268">        return true;</span>
    }

    /**
     * Get the net velocity of two aeros for ramming attacks
     */
    public static int getNetVelocity(Coords src, Entity te, int avel, int tvel) {
<span class="nc" id="L6275">        int angle = te.sideTableRam(src);</span>

<span class="nc bnc" id="L6277" title="All 5 branches missed.">        switch (angle) {</span>
            case Aero.RAM_TOWARD_DIR:
<span class="nc" id="L6279">                return Math.max(avel + tvel, 1);</span>
            case Aero.RAM_TOWARD_OBL:
<span class="nc" id="L6281">                return Math.max(avel + (tvel / 2), 1);</span>
            case Aero.RAM_AWAY_OBL:
<span class="nc" id="L6283">                return Math.max(avel - (tvel / 2), 1);</span>
            case Aero.RAM_AWAY_DIR:
<span class="nc" id="L6285">                return Math.max(avel - tvel, 1);</span>
        }
<span class="nc" id="L6287">        return 0;</span>
    }

    /**
     * Returns how much damage a weapon will do against against a BattleArmor
     * target if the BattleArmor vs BattleArmor rules on TO pg 109 are in
     * effect.
     *
     * @param damage     Original weapon damage
     * @param damageType The damage type for BA vs BA damage
     * @param target     The target, used for ensuring the target BA isn't
     *                   fire resistant
     * @return
     */
    public static int directBlowBADamage(double damage, int damageType,
                                         BattleArmor target) {
<span class="nc bnc" id="L6303" title="All 4 branches missed.">        switch (damageType) {</span>
            case WeaponType.WEAPON_BURST_1D6:
<span class="nc" id="L6305">                damage = Compute.d6();</span>
<span class="nc" id="L6306">                break;</span>
            case WeaponType.WEAPON_BURST_3D6:
<span class="nc" id="L6308">                damage = Compute.d6(3);</span>
<span class="nc" id="L6309">                break;</span>
            case WeaponType.WEAPON_PLASMA:
                // If the target is fire-resistant BA, damage is normal
<span class="nc bnc" id="L6312" title="All 2 branches missed.">                if (!target.isFireResistant()) {</span>
<span class="nc" id="L6313">                    damage = 1 + Compute.d6(1);</span>
                }
                break;
        }
<span class="nc" id="L6317">        damage = Math.ceil(damage);</span>
<span class="nc" id="L6318">        return (int) damage;</span>
    }

    /**
     * Used to get a human-readable string that represents the passed damage
     * type.
     *
     * @param damageType
     * @return
     */
    public static String getDamageTypeString(int damageType) {
<span class="nc bnc" id="L6329" title="All 5 branches missed.">        switch (damageType) {</span>
            case WeaponType.WEAPON_DIRECT_FIRE:
<span class="nc" id="L6331">                return Messages.getString(&quot;WeaponType.DirectFire&quot;);</span>
            case WeaponType.WEAPON_CLUSTER_BALLISTIC:
<span class="nc" id="L6333">                return Messages.getString(&quot;WeaponType.BallisticCluster&quot;);</span>
            case WeaponType.WEAPON_PULSE:
<span class="nc" id="L6335">                return Messages.getString(&quot;WeaponType.Pulse&quot;);</span>
            case WeaponType.WEAPON_CLUSTER_MISSILE:
            case WeaponType.WEAPON_CLUSTER_MISSILE_1D6:
            case WeaponType.WEAPON_CLUSTER_MISSILE_2D6:
            case WeaponType.WEAPON_CLUSTER_MISSILE_3D6:
<span class="nc" id="L6340">                return Messages.getString(&quot;WeaponType.Missile&quot;);</span>
            case WeaponType.WEAPON_BURST_HALFD6:
            case WeaponType.WEAPON_BURST_1D6:
            case WeaponType.WEAPON_BURST_2D6:
            case WeaponType.WEAPON_BURST_3D6:
            case WeaponType.WEAPON_BURST_4D6:
            case WeaponType.WEAPON_BURST_5D6:
            case WeaponType.WEAPON_BURST_6D6:
            case WeaponType.WEAPON_BURST_7D6:
            default:
<span class="nc" id="L6350">                return Messages.getString(&quot;WeaponType.Burst&quot;);</span>
        }
    }

    public static int directBlowInfantryDamage(double damage, int mos,
            int damageType, boolean isNonInfantryAgainstMechanized,
            boolean isAttackThruBuilding) {
<span class="nc" id="L6357">        return directBlowInfantryDamage(damage, mos, damageType,</span>
                isNonInfantryAgainstMechanized, isAttackThruBuilding,
                Entity.NONE, null);
    }

    /**
     * Method replicates the Non-Conventional Damage against Infantry damage
     * table as well as shifting for direct blows. also adjust for non-infantry
     * damaging mechanized infantry
     *
     * @param damage
     * @param mos
     * @param damageType
     * @return
     */
    public static int directBlowInfantryDamage(double damage, int mos,
            int damageType, boolean isNonInfantryAgainstMechanized,
            boolean isAttackThruBuilding, int attackerId, Vector&lt;Report&gt; vReport) {

<span class="nc" id="L6376">        int origDamageType = damageType;</span>
<span class="nc" id="L6377">        damageType += mos;</span>
<span class="nc" id="L6378">        double origDamage = damage;</span>
<span class="nc bnc" id="L6379" title="All 16 branches missed.">        switch (damageType) {</span>
            case WeaponType.WEAPON_DIRECT_FIRE:
<span class="nc" id="L6381">                damage /= 10;</span>
<span class="nc" id="L6382">                break;</span>
            case WeaponType.WEAPON_CLUSTER_BALLISTIC:
<span class="nc" id="L6384">                damage /= 10;</span>
<span class="nc" id="L6385">                damage++;</span>
<span class="nc" id="L6386">                break;</span>
            case WeaponType.WEAPON_PULSE:
<span class="nc" id="L6388">                damage /= 10;</span>
<span class="nc" id="L6389">                damage += 2;</span>
<span class="nc" id="L6390">                break;</span>
            case WeaponType.WEAPON_CLUSTER_MISSILE:
<span class="nc" id="L6392">                damage /= 5;</span>
<span class="nc" id="L6393">                break;</span>
            case WeaponType.WEAPON_CLUSTER_MISSILE_1D6:
<span class="nc" id="L6395">                damage /= 5;</span>
<span class="nc" id="L6396">                damage += Compute.d6();</span>
<span class="nc" id="L6397">                break;</span>
            case WeaponType.WEAPON_CLUSTER_MISSILE_2D6:
<span class="nc" id="L6399">                damage /= 5;</span>
<span class="nc" id="L6400">                damage += Compute.d6(2);</span>
<span class="nc" id="L6401">                break;</span>
            case WeaponType.WEAPON_CLUSTER_MISSILE_3D6:
<span class="nc" id="L6403">                damage /= 5;</span>
<span class="nc" id="L6404">                damage += Compute.d6(3);</span>
<span class="nc" id="L6405">                break;</span>
            case WeaponType.WEAPON_BURST_HALFD6:
<span class="nc" id="L6407">                damage = Compute.d6() / 2.0;</span>
<span class="nc bnc" id="L6408" title="All 2 branches missed.">                if (isAttackThruBuilding) {</span>
<span class="nc" id="L6409">                    damage *= 0.5;</span>
                }
                break;
            case WeaponType.WEAPON_BURST_1D6:
<span class="nc" id="L6413">                damage = Compute.d6();</span>
<span class="nc bnc" id="L6414" title="All 2 branches missed.">                if (isAttackThruBuilding) {</span>
<span class="nc" id="L6415">                    damage *= 0.5;</span>
                }
                break;
            case WeaponType.WEAPON_BURST_2D6:
<span class="nc" id="L6419">                damage = Compute.d6(2);</span>
<span class="nc bnc" id="L6420" title="All 2 branches missed.">                if (isAttackThruBuilding) {</span>
<span class="nc" id="L6421">                    damage *= 0.5;</span>
                }
                break;
            case WeaponType.WEAPON_BURST_3D6:
<span class="nc" id="L6425">                damage = Compute.d6(3);</span>
<span class="nc bnc" id="L6426" title="All 2 branches missed.">                if (isAttackThruBuilding) {</span>
<span class="nc" id="L6427">                    damage *= 0.5;</span>
                }
                break;
            case WeaponType.WEAPON_BURST_4D6:
<span class="nc" id="L6431">                damage = Compute.d6(4);</span>
<span class="nc bnc" id="L6432" title="All 2 branches missed.">                if (isAttackThruBuilding) {</span>
<span class="nc" id="L6433">                    damage *= 0.5;</span>
                }
                break;
            case WeaponType.WEAPON_BURST_5D6:
<span class="nc" id="L6437">                damage = Compute.d6(5);</span>
<span class="nc bnc" id="L6438" title="All 2 branches missed.">                if (isAttackThruBuilding) {</span>
<span class="nc" id="L6439">                    damage *= 0.5;</span>
                }
                break;
            case WeaponType.WEAPON_BURST_6D6:
<span class="nc" id="L6443">                damage = Compute.d6(6);</span>
<span class="nc bnc" id="L6444" title="All 2 branches missed.">                if (isAttackThruBuilding) {</span>
<span class="nc" id="L6445">                    damage *= 0.5;</span>
                }
                break;
            case WeaponType.WEAPON_BURST_7D6:
<span class="nc" id="L6449">                damage = Compute.d6(7);</span>
<span class="nc bnc" id="L6450" title="All 2 branches missed.">                if (isAttackThruBuilding) {</span>
<span class="nc" id="L6451">                    damage *= 0.5;</span>
                }
                break;
        }
<span class="nc" id="L6455">        damage = Math.ceil(damage);</span>

        // according to the following ruling, the half damage that mechanized
        // inf get against burst fire should trump the double damage they get
        // from non-infantry rather than cancel it out
        // http://bg.battletech.com/forums/index.php/topic,23928.0.html
<span class="nc bnc" id="L6461" title="All 2 branches missed.">        if (isNonInfantryAgainstMechanized) {</span>
<span class="nc bnc" id="L6462" title="All 2 branches missed.">            if (damageType &lt; WeaponType.WEAPON_BURST_HALFD6) {</span>
<span class="nc" id="L6463">                damage *= 2;</span>
            } else {
<span class="nc" id="L6465">                damage /= 2;</span>
            }
        }

<span class="nc bnc" id="L6469" title="All 2 branches missed.">        if (vReport != null) {</span>
<span class="nc" id="L6470">            Report r = new Report();</span>
<span class="nc" id="L6471">            r.subject = attackerId;</span>
<span class="nc" id="L6472">            r.indent(2);</span>

<span class="nc" id="L6474">            r.add(getDamageTypeString(origDamageType));</span>
<span class="nc bnc" id="L6475" title="All 2 branches missed.">            if (origDamageType != damageType) {</span>
<span class="nc bnc" id="L6476" title="All 2 branches missed.">                if (isAttackThruBuilding) {</span>
<span class="nc" id="L6477">                    r.messageId = 9973;</span>
                } else {
<span class="nc" id="L6479">                    r.messageId = 9972;</span>
                }
<span class="nc" id="L6481">                r.add(getDamageTypeString(damageType));</span>
<span class="nc bnc" id="L6482" title="All 2 branches missed.">            } else if (isAttackThruBuilding) {</span>
<span class="nc" id="L6483">                r.messageId = 9971;</span>
            } else {
<span class="nc" id="L6485">                r.messageId = 9970;</span>
            }

<span class="nc" id="L6488">            r.add((int)origDamage);</span>
<span class="nc" id="L6489">            r.add((int)damage);</span>
<span class="nc" id="L6490">            vReport.addElement(r);</span>
        }
<span class="nc" id="L6492">        return (int) damage;</span>
    }


    /**
     * Method computes how much damage a dial down weapon has done
     *
     * @param weapon
     * @param wtype
     * @returnnew damage
     */
    public static int dialDownDamage(Mounted weapon, WeaponType wtype) {
<span class="nc" id="L6504">        return Compute.dialDownDamage(weapon, wtype, 1);</span>
    }

    /**
     * Method computes how much damage a dial down weapon has done
     *
     * @param weapon
     * @param wtype
     * @param range
     * @return new damage
     */
    public static int dialDownDamage(Mounted weapon, WeaponType wtype, int range) {
<span class="nc" id="L6516">        int toReturn = wtype.getDamage(range);</span>

<span class="nc bnc" id="L6518" title="All 2 branches missed.">        if (!wtype.hasModes()) {</span>
<span class="nc" id="L6519">            return toReturn;</span>
        }

<span class="nc" id="L6522">        String damage = weapon.curMode().getName();</span>

        // Vehicle flamers have damage and heat modes so lets make sure this is
        // an actual dial down Damage.
<span class="nc bnc" id="L6526" title="All 2 branches missed.">        if ((damage.trim().toLowerCase().indexOf(&quot;damage&quot;) == 0)</span>
<span class="nc bnc" id="L6527" title="All 2 branches missed.">            &amp;&amp; (damage.trim().length() &gt; 6)) {</span>
<span class="nc" id="L6528">            toReturn = Integer.parseInt(damage.substring(6).trim());</span>
        }

<span class="nc" id="L6531">        return Math.min(wtype.getDamage(range), toReturn);</span>

    }

    /**
     * Method computes how much heat a dial down weapon generates
     *
     * @param weapon
     * @param wtype
     * @return Heat, minimum of 1;
     */
    public static int dialDownHeat(Mounted weapon, WeaponType wtype) {
<span class="nc" id="L6543">        return Compute.dialDownHeat(weapon, wtype, 1);</span>
    }

    /**
     * Method computes how much heat a dial down weapon generates
     *
     * @param weapon
     * @param wtype
     * @param range
     * @return Heat, minimum of 1;
     */
    public static int dialDownHeat(Mounted weapon, WeaponType wtype, int range) {
<span class="nc" id="L6555">        int toReturn = wtype.getHeat();</span>

<span class="nc bnc" id="L6557" title="All 2 branches missed.">        if (!wtype.hasModes()) {</span>
<span class="nc" id="L6558">            return toReturn;</span>
        }

<span class="nc" id="L6561">        int damage = wtype.getDamage(range);</span>
<span class="nc" id="L6562">        int newDamage = Compute.dialDownDamage(weapon, wtype, range);</span>

<span class="nc" id="L6564">        toReturn = Math.max(1,</span>
<span class="nc" id="L6565">                            wtype.getHeat() - Math.max(0, damage - newDamage));</span>
<span class="nc" id="L6566">        return toReturn;</span>

    }

    /**
     * @param aPos - attacking entity
     * @param tPos - targeted entity
     * @return a vector of all the entities that are adjacent to the targeted
     * entity and would fall along the angle of attack
     */
    public static ArrayList&lt;Entity&gt; getAdjacentEntitiesAlongAttack(Coords aPos,
                                                                   Coords tPos, IGame game) {
<span class="nc" id="L6578">        ArrayList&lt;Entity&gt; entities = new ArrayList&lt;Entity&gt;();</span>
<span class="nc" id="L6579">        ArrayList&lt;Coords&gt; coords = Coords.intervening(aPos, tPos);</span>
        // loop through all intervening coords
<span class="nc bnc" id="L6581" title="All 2 branches missed.">        for (Coords c : coords) {</span>
            // must be adjacent to the target
<span class="nc bnc" id="L6583" title="All 4 branches missed.">            if ((c.distance(tPos) &gt; 1) || c.equals(tPos)) {</span>
<span class="nc" id="L6584">                continue;</span>
            }
            // now lets add all the entities here
<span class="nc bnc" id="L6587" title="All 2 branches missed.">            for (Entity en : game.getEntitiesVector(c)) {</span>
<span class="nc" id="L6588">                entities.add(en);</span>
<span class="nc" id="L6589">            }</span>
<span class="nc" id="L6590">        }</span>
<span class="nc" id="L6591">        return entities;</span>
    }

    public static boolean isInUrbanEnvironment(IGame game, Coords unitPOS) {
<span class="nc" id="L6595">        IHex unitHex = game.getBoard().getHex(unitPOS);</span>

<span class="nc bnc" id="L6597" title="All 2 branches missed.">        if (unitHex.containsTerrain(Terrains.PAVEMENT)</span>
<span class="nc bnc" id="L6598" title="All 2 branches missed.">                || unitHex.containsTerrain(Terrains.BUILDING)</span>
<span class="nc bnc" id="L6599" title="All 2 branches missed.">                || unitHex.containsTerrain(Terrains.RUBBLE)) {</span>
<span class="nc" id="L6600">            return true;</span>
        }

        // loop through adjacent hexes
<span class="nc bnc" id="L6604" title="All 2 branches missed.">        for (int dir = 0; dir &lt;= 5; dir++) {</span>
<span class="nc" id="L6605">            Coords adjCoords = unitPOS.translated(dir);</span>
<span class="nc" id="L6606">            IHex adjHex = game.getBoard().getHex(adjCoords);</span>

<span class="nc bnc" id="L6608" title="All 2 branches missed.">            if (!game.getBoard().contains(adjCoords)) {</span>
<span class="nc" id="L6609">                continue;</span>
            }
<span class="nc bnc" id="L6611" title="All 2 branches missed.">            if (unitPOS.equals(adjCoords)) {</span>
<span class="nc" id="L6612">                continue;</span>
            }

            // hex pavement or building?
<span class="nc bnc" id="L6616" title="All 2 branches missed.">            if (adjHex.containsTerrain(Terrains.PAVEMENT)</span>
<span class="nc bnc" id="L6617" title="All 2 branches missed.">                    || adjHex.containsTerrain(Terrains.BUILDING)</span>
<span class="nc bnc" id="L6618" title="All 2 branches missed.">                    || adjHex.containsTerrain(Terrains.RUBBLE)) {</span>
<span class="nc" id="L6619">                return true;</span>
            }
        }
<span class="nc" id="L6622">        return false;</span>
    }

    public static boolean isAirToGround(Entity attacker, Targetable target) {
<span class="pc bpc" id="L6626" title="2 of 4 branches missed.">        if ((attacker == null) || (target == null)) {</span>
<span class="nc" id="L6627">            return false;</span>
        }

        //Artillery attacks need to return differently, since none of the usual air to ground modifiers apply to them
<span class="pc bpc" id="L6631" title="1 of 2 branches missed.">        if (target.getTargetType() == Targetable.TYPE_HEX_ARTILLERY) {</span>
<span class="nc" id="L6632">            return false;</span>
        }

<span class="pc bpc" id="L6635" title="1 of 2 branches missed.">        if (attacker.isSpaceborne()) {</span>
<span class="nc" id="L6636">            return false;</span>
        }
        // According to errata, VTOL and WiGes are considered ground targets
<span class="pc bpc" id="L6639" title="5 of 6 branches missed.">        return attacker.isAirborne() &amp;&amp; !target.isAirborne() &amp;&amp; attacker.isAero();</span>

    }

    public static boolean isAirToAir(Entity attacker, Targetable target) {
<span class="nc bnc" id="L6644" title="All 4 branches missed.">        if ((attacker == null) || (target == null)) {</span>
<span class="nc" id="L6645">            return false;</span>
        }
        // According to errata, VTOL and WiGes are considered ground targets
<span class="nc bnc" id="L6648" title="All 4 branches missed.">        return attacker.isAirborne() &amp;&amp; target.isAirborne();</span>
    }

    public static boolean isGroundToAir(Entity attacker, Targetable target) {
<span class="pc bpc" id="L6652" title="2 of 4 branches missed.">        if ((attacker == null) || (target == null)) {</span>
<span class="nc" id="L6653">            return false;</span>
        }
<span class="pc bpc" id="L6655" title="2 of 4 branches missed.">        return !attacker.isAirborne() &amp;&amp; target.isAirborne();</span>
    }

    public static boolean isGroundToGround(Entity attacker, Targetable target) {
<span class="nc bnc" id="L6659" title="All 4 branches missed.">        if ((attacker == null) || (target == null)) {</span>
<span class="nc" id="L6660">            return false;</span>
        }
<span class="nc bnc" id="L6662" title="All 4 branches missed.">        return !attacker.isAirborne() &amp;&amp; !target.isAirborne();</span>
    }

    /**
     * This is a homebrew function partially drawn from pg. 40-1 of AT2R that
     * allows units that flee the field for any reason to return after a certain
     * number of rounds It can potentially be expanded to include other
     * conditions
     *
     * @param en
     * @return number of rounds until return (-1 if never)
     */
    public static int roundsUntilReturn(IGame game, Entity en) {

<span class="nc bnc" id="L6676" title="All 2 branches missed.">        if (!en.isAero()) {</span>
<span class="nc" id="L6677">            return -1;</span>
        }

<span class="nc bnc" id="L6680" title="All 2 branches missed.">        if (!game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_RETURN_FLYOVER)) {</span>
<span class="nc" id="L6681">            return -1;</span>
        }

<span class="nc" id="L6684">        IAero a = (IAero) en;</span>

        // the table in AT2R is backwards, it should take longer to return if
        // your velocity is higher
<span class="nc" id="L6688">        int turns = 1 + (int) Math.ceil(a.getCurrentVelocity() / 4.0);</span>

        // OOC units should take longer, how about two extra turns?
<span class="nc bnc" id="L6691" title="All 2 branches missed.">        if (a.isOutControlTotal()) {</span>
<span class="nc" id="L6692">            turns += 2;</span>
        }
<span class="nc" id="L6694">        return turns;</span>
    }

    public static boolean inDeadZone(IGame game, Entity ae, Targetable target) {
<span class="nc bnc" id="L6698" title="All 2 branches missed.">        if (ae.isSpaceborne()) {</span>
<span class="nc" id="L6699">            return false;</span>
        }
        // Account for &quot;dead zones&quot; between Aeros at different altitudes
<span class="nc bnc" id="L6702" title="All 2 branches missed.">        if (Compute.isAirToAir(ae, target)) {</span>
<span class="nc" id="L6703">            int distance = Compute.effectiveDistance(game, ae, target,</span>
<span class="nc" id="L6704">                                                     target.isAirborneVTOLorWIGE());</span>
<span class="nc" id="L6705">            int aAlt = ae.getAltitude();</span>
<span class="nc" id="L6706">            int tAlt = target.getAltitude();</span>
<span class="nc bnc" id="L6707" title="All 2 branches missed.">            if (target.isAirborneVTOLorWIGE()) {</span>
<span class="nc" id="L6708">                tAlt++;</span>
            }
<span class="nc" id="L6710">            int altDiff = Math.abs(aAlt - tAlt);</span>
<span class="nc bnc" id="L6711" title="All 2 branches missed.">            if (altDiff &gt;= (distance - altDiff)) {</span>
<span class="nc" id="L6712">                return true;</span>
            }
        }
<span class="nc" id="L6715">        return false;</span>
    }

    public static ArrayList&lt;Coords&gt; getAcceptableUnloadPositions(
            List&lt;Coords&gt; ring, Entity unit, IGame game, int elev) {

<span class="nc" id="L6721">        ArrayList&lt;Coords&gt; acceptable = new ArrayList&lt;Coords&gt;();</span>

<span class="nc bnc" id="L6723" title="All 2 branches missed.">        for (Coords pos : ring) {</span>
<span class="nc" id="L6724">            IHex hex = game.getBoard().getHex(pos);</span>
<span class="nc bnc" id="L6725" title="All 2 branches missed.">            if (null == hex) {</span>
<span class="nc" id="L6726">                continue;</span>
            }
            // no stacking violations, no prohibited terrain, and within 2
            // elevations

<span class="nc bnc" id="L6731" title="All 2 branches missed.">            if (!unit.isLocationProhibited(pos)</span>
<span class="nc bnc" id="L6732" title="All 2 branches missed.">                &amp;&amp; (null == stackingViolation(game, unit.getId(), pos))</span>
<span class="nc bnc" id="L6733" title="All 2 branches missed.">                &amp;&amp; (Math.abs(hex.getLevel() - elev) &lt; 3)) {</span>
<span class="nc" id="L6734">                acceptable.add(pos);</span>
            }
<span class="nc" id="L6736">        }</span>
<span class="nc" id="L6737">        return acceptable;</span>
    }

    /**
     * Builds a list of all adjacent units that can load the given Entity.
     * @param en   The entity to load
     * @param pos  The coordinates of the hex to load from
     * @param elev The absolute elevation of the unit at the point of loading (surface
     *             of the hex + elevation over the surface)
     * @param game The game object
     * @return     All adjacent units that can mount the Entity
     */
    public static List&lt;Entity&gt; getMountableUnits(Entity en, Coords pos, int elev, IGame game) {
<span class="nc" id="L6750">        List&lt;Entity&gt; mountable = new ArrayList&lt;&gt;();</span>
        // Expanded to include trains

        // the rules don't say that the unit must be facing loader
        // so lets take the ring
<span class="nc bnc" id="L6755" title="All 2 branches missed.">        for (Coords c : pos.allAdjacent()) {</span>
<span class="nc" id="L6756">            IHex hex = game.getBoard().getHex(c);</span>
<span class="nc bnc" id="L6757" title="All 2 branches missed.">            if (null == hex) {</span>
<span class="nc" id="L6758">                continue;</span>
            }
<span class="nc bnc" id="L6760" title="All 2 branches missed.">            for (Entity other : game.getEntitiesVector(c)) {</span>
                // Is the other unit friendly and not the current entity?
<span class="nc bnc" id="L6762" title="All 2 branches missed.">                if ((en.getOwner().equals(other.getOwner()) || (en.getOwner()</span>
<span class="nc bnc" id="L6763" title="All 2 branches missed.">                                                                  .getTeam() == other.getOwner().getTeam()))</span>
<span class="nc bnc" id="L6764" title="All 4 branches missed.">                    &amp;&amp; !en.equals(other)</span>
<span class="nc bnc" id="L6765" title="All 4 branches missed.">                    &amp;&amp; ((other instanceof SmallCraft) || other.getTowing() != Entity.NONE || other.getTowedBy() != Entity.NONE)</span>
<span class="nc bnc" id="L6766" title="All 2 branches missed.">                    &amp;&amp; other.canLoad(en)</span>
<span class="nc bnc" id="L6767" title="All 2 branches missed.">                    &amp;&amp; !other.isAirborne()</span>
<span class="nc bnc" id="L6768" title="All 2 branches missed.">                    &amp;&amp; (Math.abs((hex.surface() + other.getElevation())</span>
<span class="nc bnc" id="L6769" title="All 2 branches missed.">                                 - elev) &lt; 3) &amp;&amp; !mountable.contains(other)) {</span>
<span class="nc" id="L6770">                    mountable.add(other);</span>
                }
<span class="nc" id="L6772">            }</span>
<span class="nc" id="L6773">        }</span>

<span class="nc" id="L6775">        return mountable;</span>

    }

    public static boolean allowAimedShotWith(Mounted weapon, int aimingMode) {
<span class="nc" id="L6780">        WeaponType wtype = (WeaponType) weapon.getType();</span>
<span class="nc" id="L6781">        boolean isWeaponInfantry = wtype.hasFlag(WeaponType.F_INFANTRY);</span>
<span class="nc bnc" id="L6782" title="All 4 branches missed.">        boolean usesAmmo = (wtype.getAmmoType() != AmmoType.T_NA)</span>
                           &amp;&amp; !isWeaponInfantry;
<span class="nc bnc" id="L6784" title="All 2 branches missed.">        Mounted ammo = usesAmmo ? weapon.getLinked() : null;</span>
<span class="nc bnc" id="L6785" title="All 2 branches missed.">        AmmoType atype = ammo == null ? null : (AmmoType) ammo.getType();</span>

        // Leg and swarm attacks can't be aimed.
<span class="nc bnc" id="L6788" title="All 2 branches missed.">        if (wtype.getInternalName().equals(Infantry.LEG_ATTACK)</span>
<span class="nc bnc" id="L6789" title="All 2 branches missed.">            || wtype.getInternalName().equals(Infantry.SWARM_MEK)) {</span>
<span class="nc" id="L6790">            return false;</span>
        }
<span class="nc bnc" id="L6792" title="All 4 branches missed.">        switch (aimingMode) {</span>
            case (IAimingModes.AIM_MODE_NONE):
<span class="nc" id="L6794">                return false;</span>
            case (IAimingModes.AIM_MODE_IMMOBILE):
<span class="nc bnc" id="L6796" title="All 2 branches missed.">                if (weapon.getCurrentShots() &gt; 1) {</span>
<span class="nc" id="L6797">                    return false;</span>
                }
<span class="nc bnc" id="L6799" title="All 2 branches missed.">                if (atype == null) {</span>
<span class="nc" id="L6800">                    break;</span>
                }
<span class="nc bnc" id="L6802" title="All 2 branches missed.">                switch (atype.getAmmoType()) {</span>
                    case AmmoType.T_SRM_STREAK:
                    case AmmoType.T_LRM_STREAK:
                    case AmmoType.T_LRM:
                    case AmmoType.T_LRM_IMP:
                    case AmmoType.T_LRM_TORPEDO:
                    case AmmoType.T_SRM:
                    case AmmoType.T_SRM_IMP:
                    case AmmoType.T_SRM_TORPEDO:
                    case AmmoType.T_MRM:
                    case AmmoType.T_NARC:
                    case AmmoType.T_INARC:
                    case AmmoType.T_AMS:
                    case AmmoType.T_ARROW_IV:
                    case AmmoType.T_LONG_TOM:
                    case AmmoType.T_SNIPER:
                    case AmmoType.T_THUMPER:
                    case AmmoType.T_SRM_ADVANCED:
                    case AmmoType.T_LRM_TORPEDO_COMBO:
                    case AmmoType.T_ATM:
                    case AmmoType.T_IATM:
                    case AmmoType.T_MML:
                    case AmmoType.T_EXLRM:
                    case AmmoType.T_NLRM:
                    case AmmoType.T_TBOLT_5:
                    case AmmoType.T_TBOLT_10:
                    case AmmoType.T_TBOLT_15:
                    case AmmoType.T_TBOLT_20:
                    case AmmoType.T_PXLRM:
                    case AmmoType.T_HSRM:
                    case AmmoType.T_MRM_STREAK:
                    case AmmoType.T_HAG:
                    case AmmoType.T_ROCKET_LAUNCHER:
<span class="nc" id="L6835">                        return false;</span>
                }
<span class="nc bnc" id="L6837" title="All 2 branches missed.">                if (((atype.getAmmoType() == AmmoType.T_AC_LBX_THB)</span>
<span class="nc bnc" id="L6838" title="All 2 branches missed.">                     || (atype.getAmmoType() == AmmoType.T_AC_LBX)</span>
<span class="nc bnc" id="L6839" title="All 2 branches missed.">                     || (atype.getAmmoType() == AmmoType.T_SBGAUSS))</span>
<span class="nc bnc" id="L6840" title="All 2 branches missed.">                    &amp;&amp; (atype.getMunitionType() == AmmoType.M_CLUSTER)) {</span>
<span class="nc" id="L6841">                    return false;</span>
                }
                // Flak Ammo can't make aimed shots
<span class="nc bnc" id="L6844" title="All 2 branches missed.">                if (((atype.getAmmoType() == AmmoType.T_AC)</span>
<span class="nc bnc" id="L6845" title="All 2 branches missed.">                     || (atype.getAmmoType() == AmmoType.T_AC_ULTRA)</span>
<span class="nc bnc" id="L6846" title="All 2 branches missed.">                     || (atype.getAmmoType() == AmmoType.T_AC_ULTRA_THB))</span>
<span class="nc bnc" id="L6847" title="All 2 branches missed.">                    &amp;&amp; (atype.getMunitionType() == AmmoType.M_FLAK)) {</span>
<span class="nc" id="L6848">                    return false;</span>
                }

                break;
            case (IAimingModes.AIM_MODE_TARG_COMP):
<span class="nc bnc" id="L6853" title="All 2 branches missed.">                if (!wtype.hasFlag(WeaponType.F_DIRECT_FIRE)</span>
<span class="nc bnc" id="L6854" title="All 4 branches missed.">                    || wtype.hasFlag(WeaponType.F_PULSE)</span>
                    || (wtype instanceof HAGWeapon)) {
<span class="nc" id="L6856">                    return false;</span>
                }
<span class="nc bnc" id="L6858" title="All 2 branches missed.">                if (weapon.getCurrentShots() &gt; 1) {</span>
<span class="nc" id="L6859">                    return false;</span>
                }

<span class="nc bnc" id="L6862" title="All 2 branches missed.">                if ((atype != null)</span>
<span class="nc bnc" id="L6863" title="All 2 branches missed.">                    &amp;&amp; ((atype.getAmmoType() == AmmoType.T_AC_LBX_THB)</span>
<span class="nc bnc" id="L6864" title="All 2 branches missed.">                        || (atype.getAmmoType() == AmmoType.T_AC_LBX)</span>
<span class="nc bnc" id="L6865" title="All 2 branches missed.">                        || (atype.getAmmoType() == AmmoType.T_SBGAUSS))</span>
<span class="nc bnc" id="L6866" title="All 2 branches missed.">                    &amp;&amp; (atype.getMunitionType() == AmmoType.M_CLUSTER)) {</span>
<span class="nc" id="L6867">                    return false;</span>
                }

                // Flak Ammo can't make aimed shots
<span class="nc bnc" id="L6871" title="All 2 branches missed.">                if ((atype != null)</span>
<span class="nc bnc" id="L6872" title="All 2 branches missed.">                    &amp;&amp; ((atype.getAmmoType() == AmmoType.T_AC)</span>
<span class="nc bnc" id="L6873" title="All 2 branches missed.">                        || (atype.getAmmoType() == AmmoType.T_AC_ULTRA)</span>
<span class="nc bnc" id="L6874" title="All 2 branches missed.">                        || (atype.getAmmoType() == AmmoType.T_AC_ULTRA_THB))</span>
<span class="nc bnc" id="L6875" title="All 2 branches missed.">                    &amp;&amp; (atype.getMunitionType() == AmmoType.M_FLAK)) {</span>
<span class="nc" id="L6876">                    return false;</span>
                }
                break;
        }
<span class="nc" id="L6880">        return true;</span>
    }

    // Taken from MekHQ, assumptions are whatever Taharqa made for there - Dylan
    public static int getTotalGunnerNeeds(Entity entity) {
<span class="pc bpc" id="L6885" title="2 of 4 branches missed.">        if (entity instanceof SmallCraft || entity instanceof Jumpship) {</span>
<span class="fc" id="L6886">            int nStandardW = 0;</span>
<span class="fc" id="L6887">            int nCapitalW = 0;</span>
<span class="pc bpc" id="L6888" title="1 of 2 branches missed.">            for (Mounted m : entity.getTotalWeaponList()) {</span>
<span class="nc" id="L6889">                EquipmentType type = m.getType();</span>
<span class="nc bnc" id="L6890" title="All 2 branches missed.">                if (type instanceof BayWeapon) {</span>
<span class="nc" id="L6891">                    continue;</span>
                }
<span class="nc bnc" id="L6893" title="All 2 branches missed.">                if (type instanceof WeaponType) {</span>
<span class="nc bnc" id="L6894" title="All 2 branches missed.">                    if (((WeaponType) type).isCapital()) {</span>
<span class="nc" id="L6895">                        nCapitalW++;</span>
                    } else {
<span class="nc" id="L6897">                        nStandardW++;</span>
                    }
                }
<span class="nc" id="L6900">            }</span>
<span class="fc" id="L6901">            return nCapitalW + (int) Math.ceil(nStandardW / 6.0);</span>
<span class="nc bnc" id="L6902" title="All 2 branches missed.">        } else if (entity.isSupportVehicle()) {</span>
<span class="nc" id="L6903">            return getSupportVehicleGunnerNeeds(entity);</span>
<span class="nc bnc" id="L6904" title="All 2 branches missed.">        } else if (entity instanceof Tank) {</span>
<span class="nc" id="L6905">            return (getFullCrewSize(entity) - 1);</span>
<span class="nc bnc" id="L6906" title="All 2 branches missed.">        } else if (entity instanceof Infantry) {</span>
<span class="nc" id="L6907">            return getFullCrewSize(entity);</span>
<span class="nc bnc" id="L6908" title="All 2 branches missed.">        } else if (entity.getCrew().getCrewType().getGunnerPos() &gt; 0) {</span>
            //Tripod, QuadVee, or dual cockpit
<span class="nc" id="L6910">            return 1;</span>
        }
<span class="nc" id="L6912">        return 0;</span>
    }

    // Taken from MekHQ, assumptions are whatever Taharqa made for there - Dylan
    public static int getAeroCrewNeeds(Entity entity) {
<span class="pc bpc" id="L6917" title="1 of 2 branches missed.">        if (entity instanceof Dropship) {</span>
<span class="nc bnc" id="L6918" title="All 2 branches missed.">            if (((Dropship) entity).isMilitary()) {</span>
<span class="nc" id="L6919">                return 4 + (int) Math.ceil(entity.getWeight() / 5000.0);</span>
            } else {
<span class="nc" id="L6921">                return 3 + (int) Math.ceil(entity.getWeight() / 5000.0);</span>
            }
<span class="pc bpc" id="L6923" title="1 of 2 branches missed.">        } else if (entity instanceof SmallCraft) {</span>
<span class="nc" id="L6924">            return getTotalDriverNeeds(entity);</span>
<span class="pc bpc" id="L6925" title="2 of 4 branches missed.">        } else if (entity instanceof Warship || entity instanceof SpaceStation) {</span>
<span class="nc" id="L6926">            return 45 + (int) Math.ceil(entity.getWeight() / 5000.0);</span>
<span class="pc bpc" id="L6927" title="1 of 2 branches missed.">        } else if (entity instanceof Jumpship) {</span>
<span class="fc" id="L6928">            return 6 + (int) Math.ceil(entity.getWeight() / 20000.0);</span>
        }
<span class="nc" id="L6930">        return 0;</span>
    }

    /**
     * Calculates the base crew requirements for support vehicles.
     *
     * @param entity The support vehicle
     * @return       The minimum base crew
     */
    public static int getSVBaseCrewNeeds(Entity entity) {
<span class="nc bnc" id="L6940" title="All 4 branches missed.">        if (entity.isTrailer() &amp;&amp; (entity.getEngine().getEngineType() == Engine.NONE)) {</span>
<span class="nc" id="L6941">            return 0;</span>
        }
<span class="nc bnc" id="L6943" title="All 2 branches missed.">        final boolean naval = entity.getMovementMode().equals(EntityMovementMode.NAVAL)</span>
<span class="nc bnc" id="L6944" title="All 2 branches missed.">                || entity.getMovementMode().equals(EntityMovementMode.HYDROFOIL)</span>
<span class="nc bnc" id="L6945" title="All 2 branches missed.">                || entity.getMovementMode().equals(EntityMovementMode.SUBMARINE);</span>
        int crew;
<span class="nc bnc" id="L6947" title="All 2 branches missed.">        if (entity.getWeightClass() == EntityWeightClass.WEIGHT_SMALL_SUPPORT) {</span>
<span class="nc" id="L6948">            crew = 1;</span>
<span class="nc bnc" id="L6949" title="All 2 branches missed.">        } else if (entity.getWeightClass() == EntityWeightClass.WEIGHT_MEDIUM_SUPPORT) {</span>
<span class="nc bnc" id="L6950" title="All 4 branches missed.">            if (naval || entity.getMovementMode().equals(EntityMovementMode.AIRSHIP)) {</span>
<span class="nc" id="L6951">                crew = 4;</span>
            } else {
<span class="nc" id="L6953">                crew = 2;</span>
            }
        } else {
<span class="nc" id="L6956">            crew = 3;</span>
<span class="nc bnc" id="L6957" title="All 2 branches missed.">            if (naval) {</span>
<span class="nc" id="L6958">                crew += (int) Math.ceil(entity.getWeight() / 5000);</span>
<span class="nc bnc" id="L6959" title="All 2 branches missed.">            } else if (entity.getMovementMode().equals(EntityMovementMode.AIRSHIP)) {</span>
<span class="nc" id="L6960">                crew += (int) Math.ceil(entity.getWeight() / 500);</span>
            }
        }
<span class="nc" id="L6963">        return crew;</span>
    }

    /**
     * Calculates number of gunners required for a support vehicle. See TM, 131.
     *
     * @param entity The support vehicle
     * @return       The number of gunners required.
     */
    public static int getSupportVehicleGunnerNeeds(Entity entity) {
<span class="nc" id="L6973">        final boolean advFireCon = entity.hasMisc(MiscType.F_ADVANCED_FIRECONTROL);</span>
<span class="nc bnc" id="L6974" title="All 4 branches missed.">        final boolean basicFireCon = !advFireCon &amp;&amp; entity.hasMisc(MiscType.F_BASIC_FIRECONTROL);</span>
<span class="nc bnc" id="L6975" title="All 2 branches missed.">        if (entity.getWeightClass() == EntityWeightClass.WEIGHT_SMALL_SUPPORT) {</span>
<span class="nc bnc" id="L6976" title="All 4 branches missed.">            if (!advFireCon &amp;&amp; !basicFireCon) {</span>
                // No fire control requires one gunner per weapon.
<span class="nc" id="L6978">                return entity.getWeaponList().size();</span>
            } else {
                // Otherwise we require one gunner per facing, with turrets and pintle mounts counting
                // as separate facings
<span class="nc" id="L6982">                Set&lt;Integer&gt; facings = new HashSet&lt;&gt;();</span>
<span class="nc" id="L6983">                int pintles = 0;</span>
<span class="nc bnc" id="L6984" title="All 2 branches missed.">                for (Mounted m : entity.getWeaponList()) {</span>
<span class="nc bnc" id="L6985" title="All 2 branches missed.">                    if (m.isPintleTurretMounted()) {</span>
<span class="nc" id="L6986">                        pintles++;</span>
                    } else {
<span class="nc" id="L6988">                        facings.add(m.getLocation());</span>
                    }
<span class="nc" id="L6990">                }</span>
<span class="nc bnc" id="L6991" title="All 2 branches missed.">                if (advFireCon) {</span>
                    // Advanced fire control lets the driver count as a gunner, so one fewer dedicated gunners is needed.
<span class="nc" id="L6993">                    return Math.max(0, pintles + facings.size() - 1);</span>
                } else {
<span class="nc" id="L6995">                    return pintles + facings.size();</span>
                }
            }
        } else {
            // Medium and large support vehicle gunner requirements are based on weapon tonnage
<span class="nc bnc" id="L7000" title="All 2 branches missed.">            double tonnage = entity.getWeaponList().stream().filter(m -&gt; !m.getType().hasFlag(WeaponType.F_AMS))</span>
<span class="nc" id="L7001">                    .mapToDouble(m -&gt; m.getTonnage()).sum();</span>
<span class="nc bnc" id="L7002" title="All 2 branches missed.">            if (advFireCon) {</span>
<span class="nc bnc" id="L7003" title="All 2 branches missed.">                if (entity.getStructuralTechRating() == ITechnology.RATING_F) {</span>
<span class="nc" id="L7004">                    return (int) Math.ceil(tonnage / 6.0);</span>
<span class="nc bnc" id="L7005" title="All 2 branches missed.">                } else if (entity.getStructuralTechRating() == ITechnology.RATING_E) {</span>
<span class="nc" id="L7006">                    return (int) Math.ceil(tonnage / 5.0);</span>
                }
<span class="nc" id="L7008">                return (int) Math.ceil(tonnage / 4.0);</span>
<span class="nc bnc" id="L7009" title="All 2 branches missed.">            } else if (basicFireCon) {</span>
<span class="nc" id="L7010">                return (int) Math.ceil(tonnage / 3.0);</span>
            } else {
<span class="nc" id="L7012">                return (int) Math.ceil(tonnage / 2.0);</span>
            }
        }
    }

    /**
     * Calculates addiontal crew required by support vehicles and advanced aerospace vessels
     * for certain misc equipment.
     *
     * @param entity The unit
     * @return       The number of additional crew required
     */
    public static int getAdditionalNonGunner(Entity entity) {
<span class="nc" id="L7025">        int crew = 0;</span>
<span class="nc bnc" id="L7026" title="All 2 branches missed.">        for (Mounted m : entity.getMisc()) {</span>
<span class="nc bnc" id="L7027" title="All 2 branches missed.">            if (m.getType().hasFlag(MiscType.F_COMMUNICATIONS)) {</span>
<span class="nc" id="L7028">                crew += (int) m.getTonnage();</span>
<span class="nc bnc" id="L7029" title="All 2 branches missed.">            } else if (m.getType().hasFlag(MiscType.F_FIELD_KITCHEN)) {</span>
<span class="nc" id="L7030">                crew += 3;</span>
<span class="nc bnc" id="L7031" title="All 2 branches missed.">            } else if (m.getType().hasFlag(MiscType.F_MOBILE_FIELD_BASE)) {</span>
<span class="nc" id="L7032">                crew += 5;</span>
<span class="nc bnc" id="L7033" title="All 2 branches missed.">            } else if (m.getType().hasFlag(MiscType.F_MASH)) {</span>
<span class="nc" id="L7034">                crew += 5 * (int) m.getSize();</span>
            }
<span class="nc" id="L7036">        }</span>
<span class="nc" id="L7037">        return crew;</span>
    }

    // Taken from MekHQ, assumptions are whatever Taharqa made for there - Dylan
    public static int getFullCrewSize(Entity entity) {
<span class="pc bpc" id="L7042" title="1 of 2 branches missed.">        if (entity.isSupportVehicle()) {</span>
<span class="nc" id="L7043">            int crew = getSVBaseCrewNeeds(entity) + getSupportVehicleGunnerNeeds(entity)</span>
<span class="nc" id="L7044">                    + getAdditionalNonGunner(entity);</span>
<span class="nc bnc" id="L7045" title="All 2 branches missed.">            if (crew &lt; 4) {</span>
<span class="nc" id="L7046">                return crew;</span>
            }
<span class="nc" id="L7048">            return crew + (int) Math.ceil(crew / 6.0);</span>
<span class="pc bpc" id="L7049" title="1 of 2 branches missed.">        } else if (entity instanceof Tank) {</span>
<span class="nc" id="L7050">            return (int) Math.ceil(entity.getWeight() / 15.0) + ((Tank) entity).getExtraCrewSeats();</span>
<span class="pc bpc" id="L7051" title="1 of 2 branches missed.">        } else if (entity instanceof BattleArmor) {</span>
<span class="nc" id="L7052">            int ntroopers = 0;</span>
<span class="nc bnc" id="L7053" title="All 2 branches missed.">            for (int trooper = 1; trooper &lt; entity.locations(); trooper++) {</span>
                //less than zero means the suit is destroyed
<span class="nc bnc" id="L7055" title="All 2 branches missed.">                if (entity.getInternal(trooper) &gt;= 0) {</span>
                    //Also, if any modular equipment is missing, then we will consider this
                    //unit to be inoperable and will not allow it to load soldiers. This is because
                    //we have no mechanism in MM to handle BA where some suits have the equipment
                    //and others do not
<span class="nc" id="L7060">                    boolean useSuit = true;</span>
<span class="nc bnc" id="L7061" title="All 2 branches missed.">                    for(Mounted m : entity.getEquipment()) {</span>
<span class="nc bnc" id="L7062" title="All 2 branches missed.">                        if(m.isMissingForTrooper(trooper)) {</span>
<span class="nc" id="L7063">                            useSuit = false;</span>
<span class="nc" id="L7064">                            break;</span>
                        }
<span class="nc" id="L7066">                    }</span>
<span class="nc bnc" id="L7067" title="All 2 branches missed.">                    if(useSuit) {</span>
<span class="nc" id="L7068">                        ntroopers++;</span>
                    }
                }
            }
<span class="nc" id="L7072">            return ntroopers;</span>
<span class="pc bpc" id="L7073" title="1 of 2 branches missed.">        } else if (entity instanceof Infantry) {</span>
<span class="nc" id="L7074">            return ((Infantry) entity).getSquadN() * ((Infantry) entity).getSquadSize();</span>
<span class="pc bpc" id="L7075" title="1 of 4 branches missed.">        } else if (entity instanceof Jumpship || entity instanceof SmallCraft) {</span>
<span class="fc" id="L7076">            return getAeroCrewNeeds(entity) + getTotalGunnerNeeds(entity);</span>
        } else {
<span class="fc" id="L7078">            return 1;</span>
        }
    }

    // Taken from MekHQ, assumptions are whatever Taharqa made for there - Dylan
    public static int getTotalDriverNeeds(Entity entity) {
        //Fix for MHQ Bug #3. Space stations have as much need for pilots as jumpships do.
<span class="nc bnc" id="L7085" title="All 2 branches missed.">        if (entity instanceof SpaceStation) {</span>
<span class="nc" id="L7086">            return 2;</span>
        }
<span class="nc bnc" id="L7088" title="All 4 branches missed.">        if (entity instanceof SmallCraft || entity instanceof Jumpship) {</span>
            //its not at all clear how many pilots dropships and jumpships
            //should have, but the old BattleSpace book suggests they should
            //be able to get by with 2. For warships, lets go with 2 per shift
            // so 6.
<span class="nc bnc" id="L7093" title="All 2 branches missed.">            if (entity instanceof Warship) {</span>
<span class="nc" id="L7094">                return 6;</span>
            }
<span class="nc bnc" id="L7096" title="All 2 branches missed.">            if (entity instanceof SmallCraft) {</span>
<span class="nc" id="L7097">                return 3;</span>
            }
<span class="nc" id="L7099">            return 2;</span>
        }
<span class="nc bnc" id="L7101" title="All 2 branches missed.">        if (entity.getCrew().getCrewType() == CrewType.COMMAND_CONSOLE) {</span>
<span class="nc" id="L7102">            return 2;</span>
        }
<span class="nc bnc" id="L7104" title="All 8 branches missed.">        if (entity instanceof Mech || entity instanceof Tank || entity instanceof Aero || entity instanceof Protomech) {</span>
            //only one driver please
<span class="nc" id="L7106">            return 1;</span>
<span class="nc bnc" id="L7107" title="All 2 branches missed.">        } else if (entity instanceof Infantry) {</span>
<span class="nc" id="L7108">            return getFullCrewSize(entity);</span>
        }
<span class="nc" id="L7110">        return 0;</span>
    }
    
    /**
     * Should we treat this entity, in its current state, as if it is a spheroid unit
     * flying in atmosphere?
     */
    public static boolean useSpheroidAtmosphere(IGame game, Entity en) {
<span class="nc bnc" id="L7118" title="All 2 branches missed.">        if (!en.isAero()) {</span>
<span class="nc" id="L7119">            return false;</span>
        }
        // are we in space?
<span class="nc bnc" id="L7122" title="All 2 branches missed.">        if (game.getBoard().inSpace()) {</span>
<span class="nc" id="L7123">            return false;</span>
        }
        // aerodyne's will operate like spheroids in vacuum
<span class="nc bnc" id="L7126" title="All 2 branches missed.">        if (!((IAero) en).isSpheroid()</span>
<span class="nc bnc" id="L7127" title="All 2 branches missed.">                &amp;&amp; !game.getPlanetaryConditions().isVacuum()) {</span>
<span class="nc" id="L7128">            return false;</span>
        }
        // are we in atmosphere?
<span class="nc" id="L7131">        return en.isAirborne();</span>
    }

} // End public class Compute
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.4.201905082037</span></div></body></html>