<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FighterSquadron.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">megamek</a> &gt; <a href="index.source.html" class="el_package">megamek.common</a> &gt; <span class="el_source">FighterSquadron.java</span></div><h1>FighterSquadron.java</h1><pre class="source lang-java linenums">/*
 * MegaAero - Copyright (C) 2007 Jay Lawson This program is free software; you
 * can redistribute it and/or modify it under the terms of the GNU General
 * Public License as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 */
package megamek.common;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.Vector;
import java.util.function.Predicate;
import java.util.stream.Collectors;

import megamek.common.IGame.Phase;
import megamek.common.options.OptionsConstants;

/**
 * @author Jay Lawson Fighter squadrons are basically &quot;containers&quot; for a bunch
 *         of fighters.
 */
public class FighterSquadron extends Aero {
    private static final long serialVersionUID = 3491212296982370726L;

    public static final int MAX_SIZE = 6;
    // Value is arbitrary, but StratOps shows up to 10 so we'll use that as an
    // alternate MAX_SIZE when using
    // the option for larger squadrons
    public static final int ALTERNATE_MAX_SIZE = 10;

<span class="nc bnc" id="L42" title="All 4 branches missed.">    private static final Predicate&lt;Entity&gt; ACTIVE_CHECK = ent -&gt; !(ent.isDestroyed() || ent.isDoomed());</span>
    
<span class="nc" id="L44">    private Vector&lt;Integer&gt; fighters = new Vector&lt;&gt;();</span>

    // fighter squadrons need to keep track of heat capacity apart from their
    // fighters
<span class="nc" id="L48">    private int heatcap = 0;</span>
<span class="nc" id="L49">    private int heatcapNoRHS = 0;</span>

    public FighterSquadron() {
<span class="nc" id="L52">        super();</span>
<span class="nc" id="L53">        setChassis(&quot;Squadron&quot;);</span>
<span class="nc" id="L54">        setModel(&quot;&quot;);</span>
<span class="nc" id="L55">    }</span>

    /**
     * construct fighter squadron with a specific name
     */
    public FighterSquadron(String name) {
<span class="nc" id="L61">        super();</span>
<span class="nc" id="L62">        setChassis(name.trim() + &quot; Squadron&quot;);</span>
<span class="nc" id="L63">        setModel(&quot;&quot;);</span>
<span class="nc" id="L64">    }</span>

    /*
     * (non-Javadoc)
     * 
     * @see megamek.common.Aero#getCost(boolean)
     */
    @Override
    public double getCost(boolean ignoreAmmo) {
<span class="nc" id="L73">        return fighters.stream()</span>
<span class="nc" id="L74">                .mapToDouble(fid -&gt; game.getEntity(fid).getCost(ignoreAmmo))</span>
<span class="nc" id="L75">                .sum();</span>
    }

    /**
     * overrides the default {@link Entity#isCapitalFighter()} with true
     */
    @Override
    public boolean isCapitalFighter() {
<span class="nc" id="L83">        return true;</span>
    }

    @Override
    public int get0SI() {
<span class="nc" id="L88">        return fighters.stream().map(fid -&gt; game.getEntity(fid))</span>
<span class="nc" id="L89">            .filter(ACTIVE_CHECK).mapToInt(ent -&gt; ((IAero)ent).get0SI()).min().orElse(0);</span>
    }

    @Override
    public int getSI() {
<span class="nc" id="L94">        return fighters.stream().map(fid -&gt; game.getEntity(fid))</span>
<span class="nc" id="L95">            .filter(ACTIVE_CHECK).mapToInt(ent -&gt; ((IAero)ent).getSI()).min().orElse(0);</span>
    }

    @Override
    public int getTotalArmor() {
<span class="nc" id="L100">        return fighters.stream()</span>
<span class="nc" id="L101">                .mapToInt(fid -&gt; ((IAero)game.getEntity(fid)).getCapArmor())</span>
<span class="nc" id="L102">                .sum();</span>
    }

    @Override
    public int getTotalOArmor() {
<span class="nc" id="L107">        return fighters.stream()</span>
<span class="nc" id="L108">                .mapToInt(fid -&gt; ((IAero) game.getEntity(fid)).getCap0Armor())</span>
<span class="nc" id="L109">                .sum();</span>
    }
    
    /*
     * Per SO, fighter squadrons can't actually be crippled
     * Individual crippled fighters should be detached and sent home, but it isn't required by the rules
     * @see megamek.common.Aero#isCrippled()
     */
    @Override
    public boolean isCrippled(boolean checkCrew) {
<span class="nc" id="L119">        return false;</span>
    }

    /**
     * Returns the percent of the armor remaining
     */
    @Override
    public double getArmorRemainingPercent() {
<span class="nc bnc" id="L127" title="All 2 branches missed.">        if (getTotalOArmor() == 0) {</span>
<span class="nc" id="L128">            return IArmorState.ARMOR_NA;</span>
        }
<span class="nc" id="L130">        return ((double) getTotalArmor() / (double) getTotalOArmor());</span>
    }

    @Override
    public int getWalkMP(boolean gravity, boolean ignoreheat,
            boolean ignoremodulararmor) {
<span class="nc" id="L136">        return fighters.stream().map(fid -&gt; game.getEntity(fid))</span>
<span class="nc" id="L137">                .filter(ACTIVE_CHECK)</span>
<span class="nc" id="L138">                .mapToInt(ent -&gt; ent.getWalkMP(gravity, ignoreheat)).min()</span>
<span class="nc" id="L139">                .orElse(0);</span>
    }
    
    @Override
    public int getCurrentThrust() {
<span class="nc" id="L144">        return fighters.stream().map(fid -&gt; game.getEntity(fid))</span>
<span class="nc" id="L145">                .filter(ACTIVE_CHECK)</span>
<span class="nc" id="L146">                .mapToInt(ent -&gt; ((IAero) ent).getCurrentThrust()).min()</span>
<span class="nc" id="L147">                .orElse(0);</span>
    }

    @Override
    public int getFuel() {
<span class="nc" id="L152">        return fighters.stream().map(fid -&gt; game.getEntity(fid))</span>
<span class="nc" id="L153">            .filter(ACTIVE_CHECK).mapToInt(ent -&gt; ((IAero)ent).getFuel()).min().orElse(0);</span>
    }
    
    @Override
    public int getCurrentFuel() {
<span class="nc" id="L158">        return fighters.stream().map(fid -&gt; game.getEntity(fid))</span>
<span class="nc" id="L159">            .filter(ACTIVE_CHECK).mapToInt(ent -&gt; ((IAero)ent).getCurrentFuel()).min().orElse(0);</span>
    }

    /*
     * Squadrons have an SI for PSR purposes, but don't take SI damage. This should return 100%.
     */
    @Override
    public double getInternalRemainingPercent() {
<span class="nc" id="L167">        return 1.0;</span>
    }

    @Override
    public boolean hasTargComp() {
<span class="nc" id="L172">        List&lt;Entity&gt; activeFighters = getActiveSubEntities()</span>
<span class="nc" id="L173">                .orElse(Collections.emptyList());</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">        if (activeFighters.isEmpty()) {</span>
<span class="nc" id="L175">            return false;</span>
        }
<span class="nc" id="L177">        int nTC = activeFighters.stream()</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">                .mapToInt(ent -&gt; ent.hasTargComp() ? 1 : 0).sum();</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">        return (nTC * 1.0 / activeFighters.size() &gt;= 0.5);</span>
    }

    @Override
    public boolean hasActiveECM() {
<span class="nc" id="L184">        if (!game.getOptions()</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">                .booleanOption(OptionsConstants.ADVAERORULES_STRATOPS_ECM)</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">                || !game.getBoard().inSpace()) {</span>
<span class="nc" id="L187">            return super.hasActiveECM();</span>
        }
<span class="nc" id="L189">        return fighters.stream().map(fid -&gt; game.getEntity(fid))</span>
<span class="nc" id="L190">                .filter(ACTIVE_CHECK).anyMatch(Entity::hasActiveECM);</span>
    }

    /**
     * Do units loaded onto this entity still have active ECM/ECCM/etc.?
     */
    @Override
    public boolean loadedUnitsHaveActiveECM() {
<span class="nc" id="L198">        return true;</span>
    }

    @Override
    public PilotingRollData addEntityBonuses(PilotingRollData prd) {

        // movement effects
        // some question as to whether &quot;above safe thrust&quot; applies to thrust or
        // velocity
        // I will treat it as thrust until it is resolved
<span class="nc bnc" id="L208" title="All 2 branches missed.">        if (moved == EntityMovementType.MOVE_OVER_THRUST) {</span>
<span class="nc" id="L209">            prd.addModifier(+1, &quot;Used more than safe thrust&quot;);</span>
        }
<span class="nc" id="L211">        int vel = getCurrentVelocity();</span>
<span class="nc" id="L212">        int vmod = vel - (2 * getWalkMP());</span>
<span class="nc bnc" id="L213" title="All 4 branches missed.">        if (!getGame().getBoard().inSpace() &amp;&amp; (vmod &gt; 0)) {</span>
<span class="nc" id="L214">            prd.addModifier(vmod, &quot;Velocity greater than 2x safe thrust&quot;);</span>
        }

        // add in atmospheric effects later
<span class="nc" id="L218">        int atmoCond = game.getPlanetaryConditions().getAtmosphere();</span>
<span class="nc bnc" id="L219" title="All 4 branches missed.">        if (!(game.getBoard().inSpace() || atmoCond == PlanetaryConditions.ATMO_VACUUM)) {</span>
<span class="nc" id="L220">            prd.addModifier(+2, &quot;Atmospheric operations&quot;);</span>

<span class="nc" id="L222">            prd.addModifier(-1, &quot;fighter/small craft&quot;);</span>
        }

        // according to personal communication with Welshman, the normal crit
        // penalties are added up across the fighter squadron
<span class="nc" id="L227">        fighters.stream().map(fid -&gt; game.getEntity(fid))</span>
<span class="nc" id="L228">            .filter(ACTIVE_CHECK).map(ent -&gt; (IAero)ent).forEachOrdered(</span>
            ent -&gt; {
<span class="nc" id="L230">                int avihits = ent.getAvionicsHits();</span>
<span class="nc bnc" id="L231" title="All 4 branches missed.">                if ((avihits &gt; 0) &amp;&amp; (avihits &lt; 3)) {</span>
<span class="nc" id="L232">                    prd.addModifier(avihits, &quot;Avionics Damage&quot;);</span>
<span class="nc bnc" id="L233" title="All 2 branches missed.">                } else if (avihits &gt;= 3) {</span>
                    // this should probably be replaced with some kind of AVI_DESTROYED boolean
<span class="nc" id="L235">                    prd.addModifier(5, &quot;Avionics Destroyed&quot;);</span>
                }

                // life support (only applicable to non-ASFs)
<span class="nc bnc" id="L239" title="All 2 branches missed.">                if(!ent.hasLifeSupport()) {</span>
<span class="nc" id="L240">                    prd.addModifier(2, &quot;No life support&quot;);</span>
                }

<span class="nc bnc" id="L243" title="All 2 branches missed.">                if(((Entity)ent).hasModularArmor()) {</span>
<span class="nc" id="L244">                    prd.addModifier(1, &quot;Modular Armor&quot;);</span>
                }
<span class="nc" id="L246">            });</span>
<span class="nc" id="L247">        return prd;</span>
    }

    @Override
    public int getClusterMods() {
<span class="nc" id="L252">        return fighters.stream().map(fid -&gt; game.getEntity(fid))</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">            .filter(ACTIVE_CHECK).filter(ent -&gt; (((IAero)ent).getFCSHits() &lt;= 2))</span>
<span class="nc" id="L254">            .mapToInt(ent -&gt; ((IAero)ent).getClusterMods()).sum();</span>
    }

    @Override
    public int calculateBattleValue(boolean ignoreC3, boolean ignorePilot) {
<span class="nc bnc" id="L259" title="All 2 branches missed.">        if (useManualBV) {</span>
<span class="nc" id="L260">            return manualBV;</span>
        }

<span class="nc" id="L263">        int bv = 0;</span>
        
        // We'll just add up the BV of all non-destroyed fighters in the squadron.
<span class="nc bnc" id="L266" title="All 2 branches missed.">        for (Integer fid : fighters) {</span>
<span class="nc" id="L267">            final Entity fighter = game.getEntity(fid);</span>
<span class="nc bnc" id="L268" title="All 6 branches missed.">            if ((null != fighter) &amp;&amp; !fighter.isDoomed() &amp;&amp; !fighter.isDestroyed()) {</span>
<span class="nc" id="L269">                bv += fighter.calculateBattleValue(ignoreC3, ignorePilot);</span>
            }
<span class="nc" id="L271">        }</span>

<span class="nc" id="L273">        return bv;</span>
    }

    /*
     * (non-Javadoc)
     * 
     * @see megamek.common.Aero#calculateBattleValue()
     */
    @Override
    public int calculateBattleValue() {
<span class="nc bnc" id="L283" title="All 2 branches missed.">        if (useManualBV) {</span>
<span class="nc" id="L284">            return manualBV;</span>
        }
<span class="nc" id="L286">        return calculateBattleValue(false, false);</span>
    }

    @Override
    public int getHeatSinks() {
<span class="nc" id="L291">        return fighters.stream().map(fid -&gt; game.getEntity(fid))</span>
<span class="nc" id="L292">            .filter(ACTIVE_CHECK).mapToInt(ent -&gt; ((IAero)ent).getHeatSinks()).sum();</span>
    }
    
    @Override
    public int getHeatCapacity(boolean includeRadicalHeatSink){
<span class="nc bnc" id="L297" title="All 2 branches missed.">        if (includeRadicalHeatSink){</span>
<span class="nc" id="L298">            return heatcap;</span>
        } else {
<span class="nc" id="L300">            return heatcapNoRHS;</span>
        }
    }

    public void resetHeatCapacity() {
<span class="nc" id="L305">        List&lt;Entity&gt; activeFighters = fighters.stream()</span>
<span class="nc" id="L306">                .map(fid -&gt; game.getEntity(fid)).filter(ACTIVE_CHECK)</span>
<span class="nc" id="L307">                .collect(Collectors.toList());</span>
<span class="nc" id="L308">        heatcap = activeFighters.stream()</span>
<span class="nc" id="L309">                .mapToInt(ent -&gt; ent.getHeatCapacity(true)).sum();</span>
<span class="nc" id="L310">        heatcapNoRHS = activeFighters.stream()</span>
<span class="nc" id="L311">                .mapToInt(ent -&gt; ent.getHeatCapacity(false)).sum();</span>
<span class="nc" id="L312">    }</span>

    @Override
    public double getWeight() {
<span class="nc" id="L316">        return fighters.stream().map(fid -&gt; game.getEntity(fid))</span>
<span class="nc" id="L317">            .filter(ACTIVE_CHECK).mapToDouble(ent -&gt; ent.getWeight()).sum();</span>
    }

    public double getAveWeight() {
<span class="nc" id="L321">        List&lt;Entity&gt; activeFighters = getActiveSubEntities()</span>
<span class="nc" id="L322">                .orElse(Collections.emptyList());</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">        return activeFighters.isEmpty() ? Double.NaN</span>
<span class="nc" id="L324">                : (getWeight() / activeFighters.size());</span>
    }

    /***
     * rather than keeping track of weapons on each fighter, every new round
     * just collect the current weapon groups by cycling through each fighter
     * and then create a new weaponGroupList. This will be trickier in terms of
     * using and keeping track of ammo, which is necessary in case squadron
     * splits, but should work otherwise
     */

    /**
     * Fighter Squadron units can only get hit in undestroyed fighters.
     */
    @Override
    public HitData rollHitLocation(int table, int side, int aimedLocation, int aimingMode, int cover) {
        // Create a list of the indices of all the active fighters, which serves as the list of valid hit locations
<span class="nc" id="L341">        List&lt;Integer&gt; indices = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L342" title="All 2 branches missed.">        for (int i = 0; i &lt; fighters.size(); i++) {</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">            if (ACTIVE_CHECK.test(game.getEntity(fighters.get(i)))) {</span>
<span class="nc" id="L344">                indices.add(i);</span>
            }
        }
        // If this squadron is doomed or is of size 1 then just return the first
        // one
<span class="nc bnc" id="L349" title="All 4 branches missed.">        if (isDoomed() || indices.isEmpty()) {</span>
<span class="nc" id="L350">            return new HitData(0);</span>
        }

        // Pick a random number between 0 and the number of fighters in the
        // squadron.
<span class="nc" id="L355">        int hit = indices.get(Compute.randomInt(indices.size()));</span>
<span class="nc" id="L356">        return new HitData(hit);</span>
    }

    @Override
    public HitData rollHitLocation(int table, int side) {
<span class="nc" id="L361">        return rollHitLocation(table, side, LOC_NONE, IAimingModes.AIM_MODE_NONE, LosEffects.COVER_NONE);</span>
    }

    @Override
    public void newRound(int roundNumber) {
<span class="nc" id="L366">        super.newRound(roundNumber);</span>
<span class="nc" id="L367">        updateWeaponGroups();</span>
<span class="nc" id="L368">        updateSensors();</span>
<span class="nc" id="L369">        loadAllWeapons();</span>
<span class="nc" id="L370">        updateSkills();</span>
<span class="nc" id="L371">        resetHeatCapacity();</span>
<span class="nc" id="L372">    }</span>
    
    /**
     * Update sensors. Use the active sensor of the first fighter in the squadron that hasn't taken 3 sensor hits
     * BAPs don't count as active sensors in space, but they do make detection rolls easier
     */
    public void updateSensors() {
<span class="nc bnc" id="L379" title="All 2 branches missed.">        if (getActiveSensor() == null) {</span>
<span class="nc bnc" id="L380" title="All 2 branches missed.">            for (Integer fId : fighters) {</span>
<span class="nc" id="L381">                Entity entity = game.getEntity(fId);</span>
<span class="nc" id="L382">                Aero fighter = (Aero) entity;</span>
<span class="nc bnc" id="L383" title="All 2 branches missed.">                if (fighter.getSensorHits() &gt; 2) {</span>
                    // Sensors destroyed. Check the next fighter
<span class="nc" id="L385">                    continue;</span>
                }
<span class="nc bnc" id="L387" title="All 2 branches missed.">                if (fighter.getActiveSensor().isBAP()) {</span>
                    //BAP active. Check the next fighter
<span class="nc" id="L389">                    continue;</span>
                }
<span class="nc bnc" id="L391" title="All 2 branches missed.">                if (fighter.getActiveSensor() != null) {</span>
<span class="nc bnc" id="L392" title="All 2 branches missed.">                    for (Sensor sensor : fighter.getSensors()) {</span>
<span class="nc" id="L393">                        getSensors().add(sensor);</span>
<span class="nc" id="L394">                    }</span>
<span class="nc" id="L395">                    setNextSensor(getSensors().firstElement());</span>
<span class="nc" id="L396">                    break;</span>
                }            
<span class="nc" id="L398">            }</span>
        }
<span class="nc" id="L400">    }</span>

    /**
     * instead of trying to track the individual units weapons, just recompile
     * the weapon groups for this squadron each round
     */
    @Override
    public void updateWeaponGroups() {
        // first we need to reset all the weapons in our existing mounts to zero
        // until proven otherwise
<span class="nc" id="L410">        Set&lt;String&gt; set = weaponGroups.keySet();</span>
<span class="nc" id="L411">        Iterator&lt;String&gt; iter = set.iterator();</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">        while (iter.hasNext()) {</span>
<span class="nc" id="L413">            String key = iter.next();</span>
<span class="nc" id="L414">            this.getEquipment(weaponGroups.get(key)).setNWeapons(0);</span>
<span class="nc" id="L415">        }</span>
        // now collect a hash of all the same weapons in each location by id
<span class="nc" id="L417">        Map&lt;String, Integer&gt; groups = new HashMap&lt;String, Integer&gt;();</span>
<span class="nc bnc" id="L418" title="All 2 branches missed.">        for (Integer fId : fighters) {</span>
<span class="nc" id="L419">            Entity entity = game.getEntity(fId);</span>
<span class="nc" id="L420">            IAero fighter = (IAero) entity;</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">            if (fighter.getFCSHits() &gt; 2) {</span>
                // can't fire with no more FCS
<span class="nc" id="L423">                continue;</span>
            }
<span class="nc bnc" id="L425" title="All 2 branches missed.">            for (Mounted mounted : entity.getWeaponGroupList()) {</span>
<span class="nc bnc" id="L426" title="All 4 branches missed.">                if (mounted.isHit() || mounted.isDestroyed()) {</span>
<span class="nc" id="L427">                    continue;</span>
                }
<span class="nc" id="L429">                int loc = mounted.getLocation();</span>
<span class="nc bnc" id="L430" title="All 2 branches missed.">                if (entity instanceof LandAirMech) {</span>
<span class="nc" id="L431">                    loc = LandAirMech.getAeroLocation(loc);</span>
                }
<span class="nc" id="L433">                String key = mounted.getType().getInternalName() + &quot;:&quot; + loc;</span>
<span class="nc bnc" id="L434" title="All 2 branches missed.">                if (null == groups.get(key)) {</span>
<span class="nc" id="L435">                    groups.put(key, mounted.getNWeapons());</span>
<span class="nc bnc" id="L436" title="All 2 branches missed.">                } else if (!mounted.getType().hasFlag(WeaponType.F_SPACE_BOMB)) {</span>
<span class="nc" id="L437">                    groups.put(key, groups.get(key) + mounted.getNWeapons());</span>
                }
<span class="nc" id="L439">            }</span>
<span class="nc" id="L440">        }</span>
        // now we just need to traverse the hash and either update our existing
        // equipment or add new ones if there is none
<span class="nc" id="L443">        Set&lt;String&gt; newSet = groups.keySet();</span>
<span class="nc" id="L444">        Iterator&lt;String&gt; newIter = newSet.iterator();</span>
<span class="nc bnc" id="L445" title="All 2 branches missed.">        while (newIter.hasNext()) {</span>
<span class="nc" id="L446">            String key = newIter.next();</span>
<span class="nc bnc" id="L447" title="All 2 branches missed.">            if (null != weaponGroups.get(key)) {</span>
                // then this equipment is already loaded, so we just need to
                // correctly update the number of weapons
<span class="nc" id="L450">                this.getEquipment(weaponGroups.get(key)).setNWeapons(groups.get(key));</span>
            } else {
                // need to add a new weapon
<span class="nc" id="L453">                String name = key.split(&quot;:&quot;)[0];</span>
<span class="nc" id="L454">                int loc = Integer.parseInt(key.split(&quot;:&quot;)[1]);</span>
<span class="nc" id="L455">                EquipmentType etype = EquipmentType.get(name);</span>
                Mounted newmount;
<span class="nc bnc" id="L457" title="All 2 branches missed.">                if (etype != null) {</span>
                    try {
<span class="nc" id="L459">                        newmount = addWeaponGroup(etype, loc);</span>
<span class="nc" id="L460">                        newmount.setNWeapons(groups.get(key));</span>
<span class="nc" id="L461">                        weaponGroups.put(key, getEquipmentNum(newmount));</span>
<span class="nc" id="L462">                    } catch (LocationFullException ex) {</span>
<span class="nc" id="L463">                        System.out.println(&quot;Unable to compile weapon groups&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L464">                        ex.printStackTrace();</span>
<span class="nc" id="L465">                        return;</span>
<span class="nc" id="L466">                    }</span>
<span class="nc bnc" id="L467" title="All 2 branches missed.">                } else if (name != &quot;0&quot;) {</span>
<span class="nc" id="L468">                    addFailedEquipment(name);</span>
                }
            }
<span class="nc" id="L471">        }</span>
        // make sure to set all the UACs and RACs to rapid fire
<span class="nc" id="L473">        setRapidFire();</span>
<span class="nc" id="L474">    }</span>

    /**
     * When fighters are removed it is necessary to unlink all ammo to the
     * squadron's weapons and reload it to ensure that ammo from the removed
     * fighter does not remain linked
     */
    // TODO: Evaluate for removal
    @SuppressWarnings(&quot;unused&quot;)
    private void reloadAllWeapons() {
<span class="nc bnc" id="L484" title="All 2 branches missed.">        for (Mounted weapon : getTotalWeaponList()) {</span>
<span class="nc bnc" id="L485" title="All 4 branches missed.">            if ((((WeaponType) weapon.getType()).getAmmoType() != AmmoType.T_NA) &amp;&amp; (null != weapon.getLinked())</span>
<span class="nc bnc" id="L486" title="All 2 branches missed.">                    &amp;&amp; (weapon.getLinked().getType() instanceof AmmoType)) {</span>
<span class="nc" id="L487">                weapon.unlink();</span>
            }
<span class="nc" id="L489">        }</span>
<span class="nc" id="L490">    }</span>

    /**
     * update the skills for this squadron
     */
    public void updateSkills() {
<span class="nc" id="L496">        List&lt;Entity&gt; activeFighters = getActiveSubEntities().orElse(Collections.emptyList());</span>
<span class="nc bnc" id="L497" title="All 2 branches missed.">        if(activeFighters.isEmpty()) {</span>
<span class="nc" id="L498">            return;</span>
        }
<span class="nc" id="L500">        int pilotingTotal = 0;</span>
<span class="nc" id="L501">        int gunneryTotal = 0;</span>
<span class="nc" id="L502">        int gunneryLTotal = 0;</span>
<span class="nc" id="L503">        int gunneryMTotal = 0;</span>
<span class="nc" id="L504">        int gunneryBTotal = 0;</span>
<span class="nc bnc" id="L505" title="All 2 branches missed.">        for(Entity fighter : activeFighters) {</span>
<span class="nc" id="L506">            pilotingTotal += fighter.getCrew().getPiloting();</span>
<span class="nc" id="L507">            gunneryTotal += fighter.getCrew().getGunnery();</span>
<span class="nc bnc" id="L508" title="All 2 branches missed.">            if (fighter.getGame().getOptions().booleanOption(OptionsConstants.RPG_RPG_GUNNERY)) {</span>
<span class="nc" id="L509">                gunneryLTotal += fighter.getCrew().getGunneryL();</span>
<span class="nc" id="L510">                gunneryMTotal += fighter.getCrew().getGunneryM();</span>
<span class="nc" id="L511">                gunneryBTotal += fighter.getCrew().getGunneryB();</span>
            } else {
<span class="nc" id="L513">                gunneryLTotal = gunneryTotal;</span>
<span class="nc" id="L514">                gunneryMTotal = gunneryTotal;</span>
<span class="nc" id="L515">                gunneryBTotal = gunneryTotal;</span>
            }
<span class="nc" id="L517">        }</span>
<span class="nc" id="L518">        getCrew().setPiloting(pilotingTotal / activeFighters.size(), 0);</span>
<span class="nc" id="L519">        getCrew().setGunnery(gunneryTotal / activeFighters.size(), 0);</span>
<span class="nc" id="L520">        getCrew().setGunneryL(gunneryLTotal / activeFighters.size(), 0);</span>
<span class="nc" id="L521">        getCrew().setGunneryM(gunneryMTotal / activeFighters.size(), 0);</span>
<span class="nc" id="L522">        getCrew().setGunneryB(gunneryBTotal / activeFighters.size(), 0);</span>
<span class="nc" id="L523">    }</span>

    @Override
    public ArrayList&lt;Mounted&gt; getAmmo() {
<span class="nc" id="L527">        ArrayList&lt;Mounted&gt; allAmmo = new ArrayList&lt;Mounted&gt;();</span>
<span class="nc bnc" id="L528" title="All 2 branches missed.">        for (Integer fId : fighters) {</span>
<span class="nc" id="L529">            Entity fighter = game.getEntity(fId);</span>
<span class="nc" id="L530">            allAmmo.addAll(fighter.getAmmo());</span>
<span class="nc" id="L531">        }</span>
<span class="nc" id="L532">        return allAmmo;</span>
    }

    @Override
    public void useFuel(int fuel) {
<span class="nc bnc" id="L537" title="All 2 branches missed.">        for (Integer fId : fighters) {</span>
<span class="nc" id="L538">            IAero fighter = (IAero) game.getEntity(fId);</span>
<span class="nc" id="L539">            fighter.useFuel(fuel);</span>
<span class="nc" id="L540">        }</span>
<span class="nc" id="L541">    }</span>

    @Override
    public void autoSetMaxBombPoints() {
<span class="nc" id="L545">        maxBombPoints = Integer.MAX_VALUE;</span>
<span class="nc bnc" id="L546" title="All 2 branches missed.">        for (Integer fId : fighters) {</span>
<span class="nc" id="L547">            Entity fighter = game.getEntity(fId);</span>
<span class="nc" id="L548">            int currBombPoints = (int) Math.round(fighter.getWeight() / 5);</span>
<span class="nc" id="L549">            maxBombPoints = Math.min(maxBombPoints, currBombPoints);</span>
<span class="nc" id="L550">        }</span>
<span class="nc" id="L551">    }</span>

    @Override
    public void setBombChoices(int[] bc) {
        // Set the bombs for the squadron
<span class="nc bnc" id="L556" title="All 2 branches missed.">        if (bc.length == bombChoices.length) {</span>
<span class="nc" id="L557">            bombChoices = bc;</span>
        }
        // Update each fighter in the squadron
<span class="nc bnc" id="L560" title="All 2 branches missed.">        for (Integer fId : fighters) {</span>
<span class="nc" id="L561">            IBomber fighter = (IBomber) game.getEntity(fId);</span>
<span class="nc" id="L562">            fighter.setBombChoices(bc);</span>
<span class="nc" id="L563">        }</span>
<span class="nc" id="L564">    }</span>

    /**
     * Produce an int array of the number of bombs of each type based on the
     * current bomblist. Since this is a FighterSquadron, these numbers
     * represent the number of bombs in a salvo. That is, it is a count of the
     * number of fighters in the squadron that have a bomb of the particular
     * type mounted.
     *
     * @return
     */
    @Override
    public int[] getBombLoadout() {
<span class="nc" id="L577">        int[] loadout = new int[BombType.B_NUM];</span>
<span class="nc bnc" id="L578" title="All 2 branches missed.">        for (Integer fId : fighters) {</span>
<span class="nc" id="L579">            Entity fighter = (Entity) game.getEntity(fId);</span>
<span class="nc bnc" id="L580" title="All 2 branches missed.">            for (Mounted m : fighter.getBombs()) {</span>
<span class="nc" id="L581">                loadout[((BombType) m.getType()).getBombType()]++;</span>
<span class="nc" id="L582">            }</span>
<span class="nc" id="L583">        }</span>
<span class="nc" id="L584">        return loadout;</span>
    }

    @Override
    public void applyBombs() {
        // Make sure all of the aeros have their bombs applied, otherwise
        // problems
        // once the bombs are applied, the choices are cleared, so it's not an
        // issue if the bombs are applied twice for an Aero
<span class="nc bnc" id="L593" title="All 2 branches missed.">        for (Integer fId : fighters) {</span>
<span class="nc" id="L594">            IBomber fighter = (IBomber) game.getEntity(fId);</span>
<span class="nc" id="L595">            fighter.applyBombs();</span>
<span class="nc" id="L596">        }</span>
<span class="nc" id="L597">        computeSquadronBombLoadout();</span>
<span class="nc" id="L598">    }</span>

    /**
     * This method looks at the bombs equipped on all the fighters in the
     * squadron and determines what possible bombing attacks the squadrons
     * can make.
     * 
     * TODO: Make this into a generic &quot;clean up bomb loadout&quot; method
     */
    public void computeSquadronBombLoadout() {
        // Remove any currently equipped bombs
<span class="nc bnc" id="L609" title="All 2 branches missed.">        for (Mounted bomb : bombList) {</span>
<span class="nc" id="L610">            equipmentList.remove(bomb);</span>
<span class="nc" id="L611">        }</span>
<span class="nc" id="L612">        bombList.clear();</span>

        // Find out what bombs everyone has
<span class="nc bnc" id="L615" title="All 2 branches missed.">        for (int btype = 0; btype &lt; BombType.B_NUM; btype++) {</span>
            // This is smallest number of such a bomb
<span class="nc" id="L617">            int maxBombCount = 0;</span>
<span class="nc bnc" id="L618" title="All 2 branches missed.">            for (Integer fId : fighters) {</span>
<span class="nc" id="L619">                int bombCount = 0;</span>
<span class="nc" id="L620">                Entity fighter = game.getEntity(fId);</span>
<span class="nc bnc" id="L621" title="All 2 branches missed.">                for (Mounted m : fighter.getBombs()) {</span>
<span class="nc bnc" id="L622" title="All 2 branches missed.">                    if (((BombType) m.getType()).getBombType() == btype) {</span>
<span class="nc" id="L623">                        bombCount++;</span>
                    }
<span class="nc" id="L625">                }</span>
<span class="nc" id="L626">                maxBombCount = Math.max(bombCount, maxBombCount);</span>
<span class="nc" id="L627">            }</span>
<span class="nc" id="L628">            bombChoices[btype] = maxBombCount;</span>
        }

        // Now that we know our bomb choices, load 'em
<span class="nc" id="L632">        int gameTL = TechConstants.getSimpleLevel(game.getOptions().stringOption(&quot;techlevel&quot;));</span>
<span class="nc bnc" id="L633" title="All 2 branches missed.">        for (int type = 0; type &lt; BombType.B_NUM; type++) {</span>
<span class="nc bnc" id="L634" title="All 2 branches missed.">            for (int i = 0; i &lt; bombChoices[type]; i++) {</span>
<span class="nc bnc" id="L635" title="All 2 branches missed.">                if ((type == BombType.B_ALAMO)</span>
<span class="nc bnc" id="L636" title="All 2 branches missed.">                        &amp;&amp; !game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_AT2_NUKES)) {</span>
<span class="nc" id="L637">                    continue;</span>
                }
<span class="nc bnc" id="L639" title="All 4 branches missed.">                if ((type &gt; BombType.B_TAG) &amp;&amp; (gameTL &lt; TechConstants.T_SIMPLE_ADVANCED)) {</span>
<span class="nc" id="L640">                    continue;</span>
                }

                // some bombs need an associated weapon and if so
                // they need a weapon for each bomb
<span class="nc bnc" id="L645" title="All 6 branches missed.">                if ((null != BombType.getBombWeaponName(type)) &amp;&amp; (type != BombType.B_ARROW)</span>
                        &amp;&amp; (type != BombType.B_HOMING)) {
                    try {
<span class="nc" id="L648">                        addBomb(EquipmentType.get(BombType.getBombWeaponName(type)), LOC_NOSE);</span>
<span class="nc" id="L649">                    } catch (LocationFullException ex) {</span>
                        // throw new LocationFullException(ex.getMessage());
<span class="nc" id="L651">                    }</span>
                }
                // If the bomb was added as a weapon, don't add the ammo
                // The ammo will end up never getting removed from the squadron
                // because it doesn't count as a weapon.
<span class="nc bnc" id="L656" title="All 4 branches missed.">                if ((type != BombType.B_TAG) &amp;&amp; (null == BombType.getBombWeaponName(type))) {</span>
                    try {
<span class="nc" id="L658">                        addEquipment(EquipmentType.get(BombType.getBombInternalName(type)), LOC_NOSE, false);</span>
<span class="nc" id="L659">                    } catch (LocationFullException ex) {</span>
                        // throw new LocationFullException(ex.getMessage());
<span class="nc" id="L661">                    }</span>
                }
            }
            // Clear out the bomb choice once the bombs are loaded
<span class="nc" id="L665">            bombChoices[type] = 0;</span>
        }
        // add the space bomb attack
<span class="nc bnc" id="L668" title="All 2 branches missed.">        if (game.getOptions().booleanOption(OptionsConstants.ADVAERORULES_STRATOPS_SPACE_BOMB)</span>
<span class="nc bnc" id="L669" title="All 4 branches missed.">                &amp;&amp; game.getBoard().inSpace() &amp;&amp; (getBombs(AmmoType.F_SPACE_BOMB).size() &gt; 0)) {</span>
            try {
<span class="nc" id="L671">                addEquipment(EquipmentType.get(SPACE_BOMB_ATTACK), LOC_NOSE, false);</span>
<span class="nc" id="L672">            } catch (LocationFullException ex) {</span>
                // throw new LocationFullException(ex.getMessage());
<span class="nc" id="L674">            }</span>
        }
<span class="nc bnc" id="L676" title="All 4 branches missed.">        if (!game.getBoard().inSpace() &amp;&amp; (getBombs(AmmoType.F_GROUND_BOMB).size() &gt; 0)) {</span>
            try {
<span class="nc" id="L678">                addEquipment(EquipmentType.get(DIVE_BOMB_ATTACK), LOC_NOSE, false);</span>
<span class="nc" id="L679">            } catch (LocationFullException ex) {</span>
                // throw new LocationFullException(ex.getMessage());
<span class="nc" id="L681">            }</span>
<span class="nc bnc" id="L682" title="All 2 branches missed.">            for (int i = 0; i &lt; Math.min(10, getBombs(AmmoType.F_GROUND_BOMB).size()); i++) {</span>
                try {
<span class="nc" id="L684">                    addEquipment(EquipmentType.get(ALT_BOMB_ATTACK), LOC_NOSE, false);</span>
<span class="nc" id="L685">                } catch (LocationFullException ex) {</span>
                    // throw new LocationFullException(ex.getMessage());
<span class="nc" id="L687">                }</span>
            }
        }

<span class="nc" id="L691">        updateWeaponGroups();</span>
<span class="nc" id="L692">        loadAllWeapons();</span>
<span class="nc" id="L693">    }</span>

    /*
     * Determine MAX_SIZE based on game options
     */
    public int getMaxSize() {
<span class="nc bnc" id="L699" title="All 2 branches missed.">        if (game.getOptions().booleanOption(</span>
                OptionsConstants.ADVAERORULES_ALLOW_LARGE_SQUADRONS)) {
<span class="nc" id="L701">            return ALTERNATE_MAX_SIZE;</span>
        }
<span class="nc" id="L703">        return MAX_SIZE;</span>
    }

    /*
     * The transporter functions
     */

    /**
     * Determines if this object can accept the given unit. The unit may not be
     * of the appropriate type or there may be no room for the unit.
     *
     * @param unit
     *            - the &lt;code&gt;Entity&lt;/code&gt; to be loaded.
     * @return &lt;code&gt;true&lt;/code&gt; if the unit can be loaded, &lt;code&gt;false&lt;/code&gt;
     *         otherwise.
     */
    @Override
    public boolean canLoad(Entity unit, boolean checkFalse) {
        // We must have enough space for the new fighter.
<span class="nc bnc" id="L722" title="All 6 branches missed.">        if(!unit.isEnemyOf(this) &amp;&amp; unit.isFighter() &amp;&amp; (fighters.size() &lt; getMaxSize())) {</span>
<span class="nc" id="L723">            return true;</span>
        }
        // fighter squadrons can also load other fighter squadrons provided
        // there is enough space
        // and the loadee is not empty
<span class="nc bnc" id="L728" title="All 2 branches missed.">        if ((unit instanceof FighterSquadron)</span>
<span class="nc bnc" id="L729" title="All 2 branches missed.">                &amp;&amp; !unit.isEnemyOf(this)</span>
<span class="nc bnc" id="L730" title="All 2 branches missed.">                &amp;&amp; (getId() != unit.getId())</span>
<span class="nc bnc" id="L731" title="All 2 branches missed.">                &amp;&amp; (((FighterSquadron) unit).fighters.size() &gt; 0)</span>
<span class="nc bnc" id="L732" title="All 2 branches missed.">                &amp;&amp; ((fighters.size() + ((FighterSquadron) unit).fighters.size()) &lt;= getMaxSize())) {</span>
<span class="nc" id="L733">            return true;</span>
        }

<span class="nc" id="L736">        return false;</span>
    }

    /**
     * Load the given unit.
     *
     * @param unit
     *            - the &lt;code&gt;Entity&lt;/code&gt; to be loaded.
     * @exception -
     *                If the unit can't be loaded, an
     *                &lt;code&gt;IllegalArgumentException&lt;/code&gt; exception will be
     *                thrown.
     */
    @Override
    public void load(Entity unit, boolean checkFalse) throws IllegalArgumentException {
        // If we can't load the unit, throw an exception.
<span class="nc bnc" id="L752" title="All 2 branches missed.">        if (!canLoad(unit)) {</span>
<span class="nc" id="L753">            throw new IllegalArgumentException(&quot;Can not load &quot; + unit.getShortName() + &quot; into this squadron. &quot;);</span>
        }
        // if this is a fighter squadron then we actually need to load the
        // individual units
<span class="nc bnc" id="L757" title="All 2 branches missed.">        if (unit instanceof FighterSquadron) {</span>
<span class="nc" id="L758">            fighters.addAll(((FighterSquadron) unit).fighters);</span>
        } else {
            // Add the unit to our squadron.
<span class="nc" id="L761">            fighters.addElement(unit.getId());</span>
        }
<span class="nc bnc" id="L763" title="All 2 branches missed.">        if (game.getPhase() != Phase.PHASE_LOUNGE) {</span>
<span class="nc" id="L764">            computeSquadronBombLoadout();</span>
            // updateWeaponGroups() and loadAllWeapons() are called in
            // computeSquadronBombLoadout()
        } else {
<span class="nc" id="L768">            updateWeaponGroups();</span>
<span class="nc" id="L769">            loadAllWeapons();</span>
        }
<span class="nc" id="L771">        updateSkills();</span>
<span class="nc" id="L772">    }</span>

    /**
     * We need to override this function to make sure the proper load method
     * gets called in some cases, but Squadrons can't have bays, so we can just
     * ignore the bay number.
     */
    @Override
    public void load(Entity unit, boolean checkFalse, int bayNumber) {
<span class="nc" id="L781">        load(unit, checkFalse);</span>
<span class="nc" id="L782">    }</span>

    /**
     * Unload the given unit. TODO: need to strip out ammo
     *
     * @param unit
     *            - the &lt;code&gt;Entity&lt;/code&gt; to be unloaded.
     * @return &lt;code&gt;true&lt;/code&gt; if the unit was contained in this space,
     *         &lt;code&gt;false&lt;/code&gt; otherwise.
     */
    @Override
    public boolean unload(Entity unit) {
        // Remove the unit if we are carrying it.
<span class="nc" id="L795">        boolean success = fighters.removeElement(unit.getId());</span>
<span class="nc bnc" id="L796" title="All 2 branches missed.">        if (game.getPhase() != Phase.PHASE_LOUNGE) {</span>
<span class="nc" id="L797">            computeSquadronBombLoadout();</span>
            // updateWeaponGroups() and loadAllWeapons() are called in
            // computeSquadronBombLoadout()
        } else {
<span class="nc" id="L801">            updateWeaponGroups();</span>
<span class="nc" id="L802">            loadAllWeapons();</span>
        }
<span class="nc" id="L804">        updateSkills();</span>
<span class="nc" id="L805">        return success;</span>
    }

    /**
     * Get a &lt;code&gt;List&lt;/code&gt; of the units currently loaded into this payload.
     *
     * @return A &lt;code&gt;List&lt;/code&gt; of loaded &lt;code&gt;Entity&lt;/code&gt; units. This
     *         list will never be &lt;code&gt;null&lt;/code&gt;, but it may be empty. The
     *         returned &lt;code&gt;List&lt;/code&gt; is independant from the under- lying
     *         data structure; modifying one does not affect the other.
     */
    @Override
    public Vector&lt;Entity&gt; getLoadedUnits() {
<span class="nc" id="L818">        return fighters.stream().map(fid -&gt; game.getEntity(fid))</span>
<span class="nc" id="L819">            .collect(Collectors.toCollection(Vector::new));</span>
    }

    /**
     * Return a string that identifies the unused capacity of this transporter.
     *
     * @return A &lt;code&gt;String&lt;/code&gt; meant for a human.
     */
    @Override
    public String getUnusedString() {
<span class="nc" id="L829">        return &quot; - &quot; + (getMaxSize() - fighters.size()) + &quot; units&quot;;</span>
    }

    @Override
    public double getUnused() {
<span class="nc" id="L834">        return getMaxSize() - fighters.size();</span>
    }

    /**
     * Returns the current amount of cargo space for an entity of the given
     * type.
     * 
     * @param e
     *            An entity that defines the unit class
     * @return The number of units of the given type that can be loaded in this
     *         Entity
     * 
     *         TODO: Fix this so we can't actually &quot;load&quot; warships or
     *         tele-operated missiles into fighter squadrons ...
     */
    @Override
    public double getUnused(Entity e) {
<span class="nc bnc" id="L851" title="All 2 branches missed.">        if (e.isFighter()) {</span>
<span class="nc" id="L852">            return getUnused();</span>
        } else {
<span class="nc" id="L854">            return 0;</span>
        }
    }

    /**
     * Determine if transported units prevent a weapon in the given location
     * from firing.
     *
     * @param loc
     *            - the &lt;code&gt;int&lt;/code&gt; location attempting to fire.
     * @param isRear
     *            - a &lt;code&gt;boolean&lt;/code&gt; value stating if the given location
     *            is rear facing; if &lt;code&gt;false&lt;/code&gt;, the location is front
     *            facing.
     * @return &lt;code&gt;true&lt;/code&gt; if a transported unit is in the way,
     *         &lt;code&gt;false&lt;/code&gt; if the weapon can fire.
     */
    @Override
    public boolean isWeaponBlockedAt(int loc, boolean isRear) {
<span class="nc" id="L873">        return false;</span>
    }

    /**
     * If a unit is being transported on the outside of the transporter, it can
     * suffer damage when the transporter is hit by an attack. Currently, no
     * more than one unit can be at any single location; that same unit can be
     * &quot;spread&quot; over multiple locations.
     *
     * @param loc
     *            - the &lt;code&gt;int&lt;/code&gt; location hit by attack.
     * @param isRear
     *            - a &lt;code&gt;boolean&lt;/code&gt; value stating if the given location
     *            is rear facing; if &lt;code&gt;false&lt;/code&gt;, the location is front
     *            facing.
     * @return The &lt;code&gt;Entity&lt;/code&gt; being transported on the outside at that
     *         location. This value will be &lt;code&gt;null&lt;/code&gt; if no unit is
     *         transported on the outside at that location.
     */
    @Override
    public Entity getExteriorUnitAt(int loc, boolean isRear) {
<span class="nc" id="L894">        return null;</span>
    }

    @Override
    public int getCargoMpReduction(Entity carrier) {
<span class="nc" id="L899">        return 0;</span>
    }

    @Override
    public long getEntityType() {
<span class="nc" id="L904">        return Entity.ETYPE_AERO | Entity.ETYPE_FIGHTER_SQUADRON;</span>
    }

    @Override
    public Engine getEngine() {
<span class="nc" id="L909">        return null;</span>
    }
    
    @Override
    public boolean hasEngine() {
<span class="nc" id="L914">        return false;</span>
    }

    /**
     * Get the movement mode of the entity, based on consensus.
     */
    @Override
    public EntityMovementMode getMovementMode() {
<span class="nc bnc" id="L922" title="All 2 branches missed.">        if (fighters.size() &lt; 1) {</span>
<span class="nc" id="L923">            return EntityMovementMode.NONE;</span>
        }
<span class="nc" id="L925">        EntityMovementMode moveMode = game.getEntity(fighters.get(0)).getMovementMode();</span>
<span class="nc bnc" id="L926" title="All 2 branches missed.">        for (Integer fId : fighters) {</span>
<span class="nc" id="L927">            Entity fighter = game.getEntity(fId);</span>
<span class="nc bnc" id="L928" title="All 2 branches missed.">            if (moveMode != fighter.getMovementMode()) {</span>
<span class="nc" id="L929">                System.out.println(&quot;Error: Fighter squadron movement mode &quot; + &quot;doesn't agree!&quot;);</span>
<span class="nc" id="L930">                return EntityMovementMode.NONE;</span>
            }
<span class="nc" id="L932">        }</span>
<span class="nc" id="L933">        return moveMode;</span>
    }
    
    @Override
    public Optional&lt;List&lt;Entity&gt;&gt; getSubEntities() {
<span class="nc" id="L938">        return Optional.of(fighters.stream().map(fid -&gt; game.getEntity(fid))</span>
<span class="nc" id="L939">            .collect(Collectors.toList()));</span>
    }
    
    @Override
    public Optional&lt;List&lt;Entity&gt;&gt; getActiveSubEntities() {
<span class="nc" id="L944">        return Optional.of(fighters.stream().map(fid -&gt; game.getEntity(fid))</span>
<span class="nc" id="L945">            .filter(ACTIVE_CHECK)</span>
<span class="nc" id="L946">            .collect(Collectors.toList()));</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.4.201905082037</span></div></body></html>