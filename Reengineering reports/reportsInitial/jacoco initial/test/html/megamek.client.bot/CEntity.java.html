<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CEntity.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">megamek</a> &gt; <a href="index.source.html" class="el_package">megamek.client.bot</a> &gt; <span class="el_source">CEntity.java</span></div><h1>CEntity.java</h1><pre class="source lang-java linenums">/*
 * MegaMek -
 * Copyright (C) 2000,2001,2002,2003,2004,2005 Ben Mazur (bmazur@sev.org)
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the Free
 * Software Foundation; either version 2 of the License, or (at your option)
 * any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
 * more details.
 */
package megamek.client.bot;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

import megamek.client.Client;
import megamek.client.ui.SharedUtility;
import megamek.common.AmmoType;
import megamek.common.BattleArmor;
import megamek.common.Compute;
import megamek.common.Coords;
import megamek.common.Entity;
import megamek.common.GunEmplacement;
import megamek.common.Infantry;
import megamek.common.Mech;
import megamek.common.MiscType;
import megamek.common.Mounted;
import megamek.common.MovePath;
import megamek.common.MovePath.MoveStepType;
import megamek.common.Protomech;
import megamek.common.Tank;
import megamek.common.Terrains;
import megamek.common.ToHitData;
import megamek.common.WeaponType;
import megamek.common.options.OptionsConstants;
import megamek.common.weapons.gaussrifles.ISImpHGaussRifle;
import megamek.common.weapons.infantry.InfantryWeapon;
import megamek.common.weapons.lasers.VariableSpeedPulseLaserWeapon;
import megamek.common.weapons.ppc.ISSnubNosePPC;

public class CEntity {

    static class Table extends HashMap&lt;Integer, CEntity&gt; {

        /**
         *
         */
        private static final long serialVersionUID = 6437109733397107056L;
        private TestBot tb;

<span class="nc" id="L58">        public Table(TestBot tb) {</span>
<span class="nc" id="L59">            this.tb = tb;</span>
<span class="nc" id="L60">        }</span>

        public void put(CEntity es) {
<span class="nc" id="L63">            this.put(es.getKey(), es);</span>
<span class="nc" id="L64">        }</span>

        public CEntity get(Entity es) {
<span class="nc" id="L67">            CEntity result = null;</span>
<span class="nc bnc" id="L68" title="All 2 branches missed.">            if ((result = super.get(Integer.valueOf(es.getId()))) == null) {</span>
<span class="nc" id="L69">                result = new CEntity(es, tb);</span>
<span class="nc" id="L70">                this.put(result);</span>
            }
<span class="nc" id="L72">            return result;</span>
        }

        public CEntity get(int id) {
<span class="nc" id="L76">            return get(Integer.valueOf(id));</span>
        }
    }

    // Armor values based on [ToHitData.SIDE_XXX][location static int]
    // Locations are as defined in static variables in various unit type classes
    // Values are the odds (out of 1.00) of rolling that location on the to-hit
    // table

    // Tank armor is either the side hit or the turret
<span class="nc" id="L86">    static final double TANK_ARMOR[][] = { { 0, 1.0, 0, 0, 0 },</span>
            { 0, 0, 0, 0, 1.0 }, { 0, 0, 0, 1.0, 0 }, { 0, 0, 1.0, 0, 0 } };
<span class="nc" id="L88">    static final double TANK_WT_ARMOR[][] = {</span>
            { 0, 31.0 / 36, 0, 0, 0, 5.0 / 36 },
            { 0, 0, 0, 0, 31.0 / 36, 5.0 / 36 },
            { 0, 0, 0, 31.0 / 36, 0, 5.0 / 36 },
            { 0, 0, 31.0 / 36, 0, 0, 5.0 / 36 } };

    // Infantry don't have a facing. In fact, they don't have armor...
<span class="nc" id="L95">    static final double INFANTRY_ARMOR[][] = { { 1.0 }, { 1.0 }, { 1.0 },</span>
            { 1.0 } };

    // Battle armor units have multiple suits
<span class="nc" id="L99">    static final double ISBA_ARMOR[][] = { { 0.25, 0.25, 0.25, 0.25 },</span>
            { 0.25, 0.25, 0.25, 0.25 }, { 0.25, 0.25, 0.25, 0.25 },
            { 0.25, 0.25, 0.25, 0.25 } };
<span class="nc" id="L102">    static final double CLBA_ARMOR[][] = { { 0.2, 0.2, 0.2, 0.2, 0.2 },</span>
            { 0.2, 0.2, 0.2, 0.2, 0.2 }, { 0.2, 0.2, 0.2, 0.2, 0.2 },
            { 0.2, 0.2, 0.2, 0.2, 0.2 } };
<span class="nc" id="L105">    static final double PROTOMECH_ARMOR[][] = {</span>
            { 1.0 / 31, 16.0 / 31, 3.0 / 31, 3.0 / 31, 8.0 / 31 },
            { 1.0 / 31, 16.0 / 31, 3.0 / 31, 3.0 / 31, 8.0 / 31 },
            { 1.0 / 31, 16.0 / 31, 3.0 / 31, 3.0 / 31, 8.0 / 31 },
            { 1.0 / 31, 16.0 / 31, 3.0 / 31, 3.0 / 31, 8.0 / 31 } };
<span class="nc" id="L110">    static final double PROTOMECH_MG_ARMOR[][] = {</span>
            { 1.0 / 32, 16.0 / 32, 3.0 / 32, 3.0 / 32, 8.0 / 32, 1.0 / 32 },
            { 1.0 / 31, 16.0 / 32, 3.0 / 32, 3.0 / 32, 8.0 / 32, 1.0 / 32 },
            { 1.0 / 31, 16.0 / 32, 3.0 / 32, 3.0 / 32, 8.0 / 32, 1.0 / 32 },
            { 1.0 / 31, 16.0 / 32, 3.0 / 32, 3.0 / 32, 8.0 / 32, 1.0 / 32 } };
<span class="nc" id="L115">    static final double MECH_ARMOR[][] = {</span>
            { 1.0 / 36, 7.0 / 36, 6.0 / 36, 6.0 / 36, 4.0 / 36, 4.0 / 36,
                    4.0 / 36, 4.0 / 36 },
            { 1.0 / 36, 7.0 / 36, 6.0 / 36, 6.0 / 36, 4.0 / 36, 4.0 / 36,
                    4.0 / 36, 4.0 / 36 },
            { 1.0 / 36, 6.0 / 36, 4.0 / 36, 7.0 / 36, 2.0 / 36, 6.0 / 36,
                    2.0 / 36, 8.0 / 36 },
            { 1.0 / 36, 6.0 / 36, 7.0 / 36, 4.0 / 36, 6.0 / 36, 2.0 / 36,
                    8.0 / 36, 2.0 / 36 } };
<span class="nc" id="L124">    static final double GUN_EMPLACEMENT_ARMOR[][] = { { 1.0 / 4, 0, 0, 0 },</span>
            { 1.0 / 4, 0, 0, 0 }, { 1.0 / 4, 0, 0, 0 }, { 1.0 / 4, 0, 0, 0 } };
<span class="nc" id="L126">    static final double GUN_EMPLACEMENT_TURRET_ARMOR[][] = {</span>
            { 1.0 / 3, 0, 0, 0, 5.0 / 36 }, { 1.0 / 3, 0, 0, 0, 5.0 / 36 },
            { 1.0 / 3, 0, 0, 0, 5.0 / 36 }, { 1.0 / 3, 0, 0, 0, 5.0 / 36 } };

    public static final int MAX_RANGE = 36; // Updated to reflect longer ranges
    // of level 2 equipment
    public static final int MIN_BRACKET = 6;

    public static final int OVERHEAT_NONE = 0;
    public static final int OVERHEAT_LOW = 1;
    public static final int OVERHEAT_HIGH = 2;

    public static final int RANGE_SHORT = 0;
    public static final int RANGE_MEDIUM = 1;
    public static final int RANGE_LONG = 2;
    public static final int RANGE_ALL = 3;

    public static final int FIRST_ARC = 0;
    public static final int LAST_PRIMARY_ARC = 3;
    public static final int LAST_ARC = 5;

    public static final int TT = 4;

    public static final int LEFT_LEG = 0;
    public static final int RIGHT_LEG = 1;

    // Weighted averages of the cluster hits table. Note the actual
    // table does skip entries from 31 through 39.
<span class="nc" id="L154">    private static final double[] hits_by_racksize = { 0.0, 1.0, 1.58, 2.0,</span>
            2.63, 3.17, 4.0, 4.49, 4.98, 5.47, 6.31, 7.23, 8.14, 8.59, 9.04,
            9.5, 10.1, 10.8, 11.42, 12.1, 12.7, 13.6, 14.4, 15.7, 16.3, 16.6,
            17.4, 17.6, 17.9, 18.7, 19.0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 25.4 };

    Entity entity;
    MoveOption current;
    MoveOption last; // set only after movement

    private MoveOption.Table moves;
<span class="nc" id="L164">    MoveOption.Table pass = new MoveOption.Table();</span>
    public int runMP;
    public int jumpMP;
    // For MASC/supercharger useage. Set to true if failure is bad.
<span class="nc" id="L168">    public boolean masc_threat = false;</span>

<span class="nc" id="L170">    boolean isPhysicalTarget = false;</span>

    // Current heat status of the unit
<span class="nc" id="L173">    int overheat = OVERHEAT_NONE;</span>
    // Weapons heat for ideal range bracket
<span class="nc" id="L175">    int heat_at_range = 0;</span>
    // Heat for each range bracket
<span class="nc" id="L177">    int heat_estimates[] = new int[4];</span>

    // Index of the ideal engagement range from range_damages
<span class="nc" id="L180">    int range = RANGE_ALL;</span>
<span class="nc" id="L181">    int long_range = 0;</span>
    // Damage at short/medium/long/all(?) ranges
<span class="nc" id="L183">    double range_damages[] = new double[4];</span>
<span class="nc" id="L184">    int rd_bracket = 0;</span>

<span class="nc" id="L186">    double base_psr_odds = 1.0;</span>

<span class="nc" id="L188">    boolean hasTakenDamage = false;</span>
<span class="nc" id="L189">    public Strategy strategy = new Strategy();</span>

    // A subjective measure of the armor quality indexed by ToHitData
    // location static variables (front, rear, left, right)
<span class="nc" id="L193">    double[] armor_health = { 0, 0, 0, 0, 0, 0, 0, 0 };</span>
<span class="nc" id="L194">    double[] armor_percent = { 0, 0, 0, 0, 0, 0, 0, 0 };</span>
    // Armor averaged over all locations
    // TODO: replace with array, one element per arc
<span class="nc" id="L197">    double avg_armor = 0;</span>
    // Average internal structure
    // TODO: replace with array, one element per arc
<span class="nc" id="L200">    double avg_iarmor = 0;</span>

    // used to determine the utility of combining attacks
<span class="nc" id="L203">    double[] expected_damage = { 0, 0, 0, 0, 0, 0, 0, 0 };</span>
<span class="nc" id="L204">    double[] possible_damage = { 0, 0, 0, 0, 0, 0, 0, 0 };</span>

<span class="nc" id="L206">    double[] leg_health = { 0, 0 };</span>

<span class="nc" id="L208">    double overall_armor_percent = 0.0;</span>
<span class="nc" id="L209">    double[][] damages = new double[6][MAX_RANGE];</span>

    // the battle value of the unit
    int bv;

    // relative position in the enemy array
    int enemy_num;

    private TestBot tb;

<span class="nc" id="L219">    boolean engaged = false; // am i fighting</span>
<span class="nc" id="L220">    boolean moved = false;</span>
<span class="nc" id="L221">    boolean justMoved = false;</span>

    // TSM equipped Mechs work better at 9+ heat, so flag if mounted
<span class="nc" id="L224">    boolean tsm_offset = false;</span>

<span class="nc" id="L226">    int[] minRangeMods = new int[MIN_BRACKET + 1];</span>

<span class="nc" id="L228">    public CEntity(Entity en, TestBot tb) {</span>
<span class="nc" id="L229">        entity = en;</span>
<span class="nc" id="L230">        this.tb = tb;</span>
<span class="nc" id="L231">        reset();</span>
<span class="nc" id="L232">    }</span>

    public Entity getEntity() {
<span class="nc" id="L235">        return entity;</span>
    }

    public boolean canMove() {
<span class="nc bnc" id="L239" title="All 2 branches missed.">        return (entity.isSelectableThisTurn()</span>
<span class="nc bnc" id="L240" title="All 4 branches missed.">                &amp;&amp; !(entity.isProne() &amp;&amp; (base_psr_odds &lt; .2)) &amp;&amp; !entity</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">                    .isImmobile());</span>
    }

    public boolean justMoved() {
<span class="nc bnc" id="L245" title="All 6 branches missed.">        return (!moved &amp;&amp; !entity.isSelectableThisTurn()) || justMoved;</span>
    }

    public void reset() {
<span class="nc" id="L249">        entity = tb.getGame().getEntity(entity.getId()); // fresh entity</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">        for (int a = FIRST_ARC; a &lt;= LAST_ARC; a++) {</span>
<span class="nc" id="L251">            Arrays.fill(damages[a], 0);</span>
        }
<span class="nc" id="L253">        characterize();</span>
<span class="nc" id="L254">        resetPossibleDamage();</span>
<span class="nc" id="L255">        moves = null;</span>
<span class="nc" id="L256">        hasTakenDamage = false;</span>
<span class="nc" id="L257">        Arrays.fill(expected_damage, 0);</span>
<span class="nc" id="L258">        engaged = false;</span>
<span class="nc" id="L259">        moved = false;</span>
<span class="nc" id="L260">        isPhysicalTarget = false;</span>
<span class="nc" id="L261">    }</span>

    public void refresh() {
<span class="nc" id="L264">        entity = tb.getGame().getEntity(entity.getId());</span>
<span class="nc bnc" id="L265" title="All 2 branches missed.">        if (justMoved()) {</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">            for (int a = FIRST_ARC; a &lt;= LAST_ARC; a++) {</span>
<span class="nc" id="L267">                Arrays.fill(damages[a], 0);</span>
            }
<span class="nc" id="L269">            characterize();</span>
<span class="nc" id="L270">            resetPossibleDamage();</span>
        }
<span class="nc" id="L272">    }</span>

    public void resetPossibleDamage() {
<span class="nc" id="L275">        Arrays.fill(possible_damage, 0);</span>
<span class="nc" id="L276">    }</span>

    /**
     * Simplifies the many game stats into something that can be quickly
     * calculated into a units combat effectiveness. The concept is similar to
     * creating BattleForce stats.
     */

    public void characterize() {
<span class="nc" id="L285">        entity = tb.getGame().getEntity(entity.getId());</span>
<span class="nc" id="L286">        current = new MoveOption(tb.getGame(), this);</span>
<span class="nc" id="L287">        bv = entity.calculateBattleValue();</span>

        // Make a guess as to whether MASC should be turned on or off
        // TODO: Link this to a Bot configuration file
<span class="nc" id="L291">        runMP = entity.getRunMP();</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">        if (entity instanceof Mech) {</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">            if (((Mech) entity).hasMASC()) {</span>
<span class="nc bnc" id="L294" title="All 2 branches missed.">                if (((Mech) entity).getMASCTarget() &lt;= (5 + Compute.randomInt(6))) {</span>
<span class="nc" id="L295">                    masc_threat = false;</span>
                } else {
<span class="nc" id="L297">                    masc_threat = true;</span>
<span class="nc" id="L298">                    runMP = entity.getRunMPwithoutMASC();</span>
                }
            } else {

                // If this is a Mech equipped with TSM, push for the sweet
                // spot at 9 heat
<span class="nc bnc" id="L304" title="All 2 branches missed.">                if (((Mech) entity).hasTSM()) {</span>
<span class="nc" id="L305">                    tsm_offset = true;</span>
                }

            }
        }
<span class="nc" id="L310">        jumpMP = entity.getJumpMP();</span>

<span class="nc" id="L312">        overall_armor_percent = entity.getArmorRemainingPercent();</span>
<span class="nc" id="L313">        base_psr_odds = Compute.oddsAbove(entity.getBasePilotingRoll()</span>
<span class="nc" id="L314">                .getValue(), entity.hasAbility(OptionsConstants.PILOT_APTITUDE_PILOTING)) / 100;</span>

        // Heat characterisation - how badly will a Mech overheat this round
<span class="nc" id="L317">        int heat_capacity = entity.getHeatCapacity();</span>
<span class="nc" id="L318">        int heat = entity.heat;</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">        if (entity instanceof Mech) {</span>

            // Include heat from active stealth armor systems
<span class="nc bnc" id="L322" title="All 4 branches missed.">            if (entity.isStealthActive() || entity.isNullSigActive()</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">                    || entity.isVoidSigActive()) {</span>
<span class="nc" id="L324">                heat += 10;</span>
            }

<span class="nc bnc" id="L327" title="All 2 branches missed.">            if (entity.isChameleonShieldActive()) {</span>
<span class="nc" id="L328">                heat += 6;</span>
            }

            // Infernos no longer track heat over multiple rounds

            // Include heat from engine hits
<span class="nc" id="L334">            heat += entity.getEngineCritHeat();</span>

            // Include heat for standing in a fire
<span class="nc bnc" id="L337" title="All 2 branches missed.">            if (entity.getPosition() != null) {</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">                if (tb.getGame().getBoard().getHex(entity.getPosition()) != null) {</span>
<span class="nc" id="L339">                    if (tb.getGame().getBoard().getHex(entity.getPosition())</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">                            .containsTerrain(Terrains.FIRE)</span>
<span class="nc" id="L341">                            &amp;&amp; (tb.getGame().getBoard().getHex(entity.getPosition())</span>
<span class="nc bnc" id="L342" title="All 2 branches missed.">                                    .getFireTurn() &gt; 0)) {</span>
<span class="nc" id="L343">                        heat += 5;</span>
                    }
                }
            }

            // Include heat from ambient temperature
<span class="nc" id="L349">            heat += tb.getGame().getPlanetaryConditions().getTemperatureDifference(</span>
                    50, -30);
        }

        // Offensive characterisation - damage potentials

<span class="nc" id="L355">        ArrayList&lt;Mounted&gt; ammo_list = entity.getAmmo();</span>

<span class="nc" id="L357">        double overall_damage[][] = new double[6][MAX_RANGE];</span>
<span class="nc" id="L358">        double cur_weapon_damage[] = new double[MAX_RANGE];</span>

<span class="nc" id="L360">        ArrayList&lt;Integer&gt; cur_weapon_arcs = new ArrayList&lt;Integer&gt;();</span>
<span class="nc" id="L361">        int overall_heat[][] = new int[6][MAX_RANGE];</span>
<span class="nc" id="L362">        int cur_weapon_heat, weapons_count = 0;</span>
        int cur_weapon_arc;

        // Mainly for BA and conventional infantry support
<span class="nc" id="L366">        int number_of_shooters = 1;</span>

<span class="nc" id="L368">        boolean ammo_ranges[] = { false, false, false };</span>

<span class="nc" id="L370">        int gunnery = entity.getCrew().getGunnery();</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">        if (entity.getTaserFeedBackRounds() &gt; 0) {</span>
<span class="nc" id="L372">            gunnery += 1;</span>
        }

        // Most units, including BA, are equipped with conventional weapons
<span class="nc bnc" id="L376" title="All 2 branches missed.">        if (!entity.isConventionalInfantry()) {</span>

<span class="nc bnc" id="L378" title="All 2 branches missed.">            if (entity instanceof BattleArmor) {</span>
<span class="nc" id="L379">                number_of_shooters = ((BattleArmor) entity)</span>
<span class="nc" id="L380">                        .getShootingStrength();</span>
            }

            // Physical attacks - punch and/or kicking for Mechs
<span class="nc bnc" id="L384" title="All 2 branches missed.">            if (entity instanceof Mech) {</span>

                // Base damage, adjusted for odds of hitting
<span class="nc bnc" id="L387" title="All 2 branches missed.">                cur_weapon_damage[1] = (tsm_offset ? 1.0 : 0.5)</span>
<span class="nc" id="L388">                        * (entity.getWeight() / 10)</span>
<span class="nc" id="L389">                        * (Compute.oddsAbove(entity.getCrew().getPiloting(),</span>
<span class="nc" id="L390">                                             entity.hasAbility(OptionsConstants.PILOT_APTITUDE_PILOTING)) / 100);</span>

                // Either a kick or double-punch to the front
<span class="nc" id="L393">                overall_damage[Compute.ARC_FORWARD][1] = 2.0 * cur_weapon_damage[1];</span>

                // If the Mech can flip arms, don't consider arm arcs
<span class="nc bnc" id="L396" title="All 2 branches missed.">                if (!((Mech) entity).canFlipArms()) {</span>
<span class="nc" id="L397">                    overall_damage[Compute.ARC_LEFTARM][1] = cur_weapon_damage[1];</span>
<span class="nc" id="L398">                    overall_damage[Compute.ARC_RIGHTARM][1] = cur_weapon_damage[1];</span>
                }
            }

            // Physical attacks - vibroclaws for BA
<span class="nc bnc" id="L403" title="All 2 branches missed.">            if (entity instanceof BattleArmor) {</span>

<span class="nc" id="L405">                overall_damage[Compute.ARC_360][0] = (hits_by_racksize[number_of_shooters]</span>
<span class="nc" id="L406">                        * ((BattleArmor) entity).getVibroClaws()</span>
<span class="nc" id="L407">                        * Compute.oddsAbove(gunnery,</span>
<span class="nc" id="L408">                                            entity.hasAbility(OptionsConstants.PILOT_APTITUDE_GUNNERY))) / 100.0;</span>
            }

            // Iterate over each weapon, calculating average damage
            // for each weapon, over each hex of range
<span class="nc bnc" id="L413" title="All 2 branches missed.">            for (Mounted cur_weapon : entity.getWeaponList()) {</span>

<span class="nc" id="L415">                WeaponType weapon = (WeaponType) cur_weapon.getType();</span>
<span class="nc" id="L416">                int cur_weapon_id = entity.getEquipmentNum(cur_weapon);</span>

                // Don't count weapons that are destroyed/jammed or are out
                // of ammo
<span class="nc bnc" id="L420" title="All 2 branches missed.">                if (!cur_weapon.canFire()</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">                        || cur_weapon.isJammed()</span>
<span class="nc bnc" id="L422" title="All 2 branches missed.">                        || ((cur_weapon.getLinked() == null) &amp;&amp; (weapon</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">                                .getAmmoType() != AmmoType.T_NA))) {</span>
<span class="nc" id="L424">                    continue;</span>
                }

                // Anti-Mech attacks are difficult to set up and have bad
                // odds most of the time. This means they have little
                // strategic impact.
<span class="nc bnc" id="L430" title="All 2 branches missed.">                if (weapon.getInternalName().equals(Infantry.SWARM_MEK)</span>
<span class="nc bnc" id="L431" title="All 2 branches missed.">                        || weapon.getInternalName().equals(Infantry.LEG_ATTACK)</span>
<span class="nc bnc" id="L432" title="All 2 branches missed.">                        || weapon.getInternalName().equals(Infantry.SWARM_MEK)</span>
<span class="nc bnc" id="L433" title="All 2 branches missed.">                        || weapon.getInternalName().equals(Infantry.STOP_SWARM)) {</span>
<span class="nc" id="L434">                    continue;</span>
                }

                // Get basic stats for the current weapon
<span class="nc" id="L438">                cur_weapon_arc = entity.getWeaponArc(cur_weapon_id);</span>
<span class="nc" id="L439">                cur_weapon_arcs = getWeaponArcs(cur_weapon_arc,</span>
<span class="nc" id="L440">                        entity.isSecondaryArcWeapon(cur_weapon_id));</span>
<span class="nc" id="L441">                cur_weapon_heat = cur_weapon.getCurrentHeat();</span>

                // Get the damage the weapon will do at each range bracket.
                // This includes average cluster hits but not to-hit averages.
<span class="nc" id="L445">                ammo_ranges = getAmmoRanges(weapon, ammo_list);</span>
<span class="nc" id="L446">                cur_weapon_damage = getRawDamage(cur_weapon, ammo_ranges);</span>

<span class="nc" id="L448">                boolean aptGunnery = entity.hasAbility(OptionsConstants.PILOT_APTITUDE_PILOTING);</span>

                // Apply to-hit modifiers to the damage values
<span class="nc" id="L451">                cur_weapon_damage = getExpectedDamage(weapon, gunnery,</span>
                                                      cur_weapon_damage, ammo_ranges, aptGunnery);

                // If the heat generated by the weapon is a significant
                // portion of the Mechs remaining heatsink capacity, it needs
                // to do some significant damage before being counted. Under
                // most circumstances this will only happen if the Mech is
                // seriously overheating.

<span class="nc bnc" id="L460" title="All 2 branches missed.">                if (entity instanceof Mech) {</span>

<span class="nc" id="L462">                    int overheat = (cur_weapon_heat + heat)</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">                            - (heat_capacity + (tsm_offset ? 9 : 4));</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">                    if (overheat &gt; 0) {</span>

<span class="nc bnc" id="L466" title="All 2 branches missed.">                        for (int i = 0; i &lt; cur_weapon_damage.length; i++) {</span>
<span class="nc bnc" id="L467" title="All 2 branches missed.">                            if (cur_weapon_damage[i] &lt; overheat) {</span>
<span class="nc" id="L468">                                cur_weapon_damage[i] = 0.0;</span>
                            }
                        }

                    }

                }

                // Only BA can fire into their own hex
<span class="nc bnc" id="L477" title="All 2 branches missed.">                if (!(entity instanceof BattleArmor)) {</span>
<span class="nc" id="L478">                    cur_weapon_damage[0] = 0.0;</span>
                }

                // Increment the total weapons count if the weapon was
                // allocated to the forward arc. No point counting weapons
                // that don't get used much.
<span class="nc bnc" id="L484" title="All 2 branches missed.">                if (cur_weapon_arcs.contains(Compute.ARC_FORWARD)) {</span>
<span class="nc" id="L485">                    weapons_count++;</span>
                }

<span class="nc" id="L488">                int weapon_min_range = weapon.getMinimumRange();</span>

                // Add the final damage and heat values into the overall damage
                // array for the appropriate arcs
<span class="nc bnc" id="L492" title="All 2 branches missed.">                for (int i = 0; i &lt; cur_weapon_damage.length; i++) {</span>

                    // Skip any range where no damage is done
<span class="nc bnc" id="L495" title="All 2 branches missed.">                    if (cur_weapon_damage[i] == 0.0) {</span>
<span class="nc" id="L496">                        continue;</span>
                    }

                    // Adjust weapon damage by the number of shooters. This
                    // normally applies only to Battle Armor.
<span class="nc bnc" id="L501" title="All 2 branches missed.">                    if (number_of_shooters &gt; 1) {</span>
<span class="nc" id="L502">                        cur_weapon_damage[i] *= hits_by_racksize[number_of_shooters];</span>
                    }

<span class="nc bnc" id="L505" title="All 2 branches missed.">                    for (int firing_arc : cur_weapon_arcs) {</span>

                        // Some error control to catch non-standard arcs
<span class="nc bnc" id="L508" title="All 2 branches missed.">                        if (firing_arc &gt; LAST_ARC) {</span>
<span class="nc" id="L509">                            continue;</span>
                        }

<span class="nc" id="L512">                        overall_damage[firing_arc][i] += cur_weapon_damage[i];</span>

                        // Only Mechs need track heat. The heat values will
                        // be used to derate damage at each hex of range.
<span class="nc bnc" id="L516" title="All 4 branches missed.">                        if ((entity instanceof Mech)</span>
                                &amp;&amp; (overall_damage[firing_arc][i] &gt; 0)) {
<span class="nc" id="L518">                            overall_heat[firing_arc][i] += cur_weapon_heat;</span>
                        }

                        // Track minimum range modifiers for weapons that
                        // fire into the forward arc
<span class="nc bnc" id="L523" title="All 6 branches missed.">                        if ((firing_arc == Compute.ARC_FORWARD)</span>
                                &amp;&amp; (i &lt;= weapon_min_range)
                                &amp;&amp; (i &lt; minRangeMods.length)) {
<span class="nc" id="L526">                            minRangeMods[i] += (1 + weapon_min_range) - i;</span>
                        }

<span class="nc" id="L529">                    }</span>

                }

                // Next weapon
<span class="nc" id="L534">            }</span>

        } else {

            // Conventional infantry use infantry weapons, which require
            // special handling

<span class="nc" id="L541">            number_of_shooters = ((Infantry) entity).getShootingStrength();</span>

<span class="nc" id="L543">            cur_weapon_damage = getExpectedDamage((Infantry) entity, gunnery);</span>

            // Add the current damage values into the overall damage array for
            // the 360 degree arc. Adjust for number of troopers hitting.
<span class="nc bnc" id="L547" title="All 2 branches missed.">            for (int i = 0; i &lt; cur_weapon_damage.length; i++) {</span>
<span class="nc" id="L548">                overall_damage[Compute.ARC_360][i] += cur_weapon_damage[i];</span>
<span class="nc" id="L549">                overall_damage[Compute.ARC_360][i] *= hits_by_racksize[number_of_shooters];</span>
            }

            // Check for field guns
<span class="nc bnc" id="L553" title="All 2 branches missed.">            for (Mounted cur_weapon : entity.getWeaponList()) {</span>

<span class="nc" id="L555">                WeaponType weapon = (WeaponType) cur_weapon.getType();</span>

<span class="nc bnc" id="L557" title="All 2 branches missed.">                if (cur_weapon.getLocation() != Infantry.LOC_FIELD_GUNS) {</span>
<span class="nc" id="L558">                    continue;</span>
                }

                // Don't count weapons that are destroyed/jammed or are out
                // of ammo
<span class="nc bnc" id="L563" title="All 2 branches missed.">                if (!cur_weapon.canFire()</span>
<span class="nc bnc" id="L564" title="All 2 branches missed.">                        || cur_weapon.isJammed()</span>
<span class="nc bnc" id="L565" title="All 2 branches missed.">                        || ((cur_weapon.getLinked() == null) &amp;&amp; (weapon</span>
<span class="nc bnc" id="L566" title="All 2 branches missed.">                                .getAmmoType() != AmmoType.T_NA))) {</span>
<span class="nc" id="L567">                    continue;</span>
                }

<span class="nc" id="L570">                boolean aptGunnery = entity.hasAbility(OptionsConstants.PILOT_APTITUDE_PILOTING);</span>

<span class="nc" id="L572">                cur_weapon_damage = CEntity.getRawDamage(cur_weapon, null);</span>
<span class="nc" id="L573">                cur_weapon_damage = CEntity.getExpectedDamage(weapon, gunnery,</span>
                                                              cur_weapon_damage, ammo_ranges, aptGunnery);

                // Push the field gun damages into the overall damage array
<span class="nc bnc" id="L577" title="All 2 branches missed.">                for (int i = 0; i &lt; cur_weapon_damage.length; i++) {</span>

                    // Skip 0-damage entries
<span class="nc bnc" id="L580" title="All 2 branches missed.">                    if (cur_weapon_damage[i] == 0) {</span>
<span class="nc" id="L581">                        continue;</span>
                    }

<span class="nc" id="L584">                    overall_damage[Compute.ARC_360][i] += cur_weapon_damage[i];</span>
                }
<span class="nc" id="L586">            }</span>

            // Copy the total damage into each arc
<span class="nc bnc" id="L589" title="All 2 branches missed.">            for (int cur_arc = FIRST_ARC + 1; cur_arc &lt;= LAST_ARC; cur_arc++) {</span>
<span class="nc" id="L590">                overall_damage[cur_arc] = overall_damage[Compute.ARC_360];</span>
            }

        }

        // Push the accumulated damages into the CEntity array
<span class="nc bnc" id="L596" title="All 2 branches missed.">        for (int cur_arc = FIRST_ARC; cur_arc &lt;= LAST_ARC; cur_arc++) {</span>

            // For each hex
<span class="nc bnc" id="L599" title="All 2 branches missed.">            for (int cur_range = 0; cur_range &lt; MAX_RANGE; cur_range++) {</span>

                // If no damage, then skip the calculations
<span class="nc bnc" id="L602" title="All 2 branches missed.">                if (overall_damage[cur_arc][cur_range] == 0.0) {</span>
<span class="nc" id="L603">                    continue;</span>
                }

                // If the weapons heat and the miscellaneous heat is more than
                // the Mech can sink, lower the damage proportionally e.g.
                // (sink capacity + buffer) / (weapon heat + base heat)
<span class="nc bnc" id="L609" title="All 2 branches missed.">                if ((entity instanceof Mech)</span>
                        &amp;&amp; ((overall_heat[cur_arc][cur_range] + heat) &gt; (heat_capacity
<span class="nc bnc" id="L611" title="All 4 branches missed.">                                + (tsm_offset ? 9 : 4)))) {</span>
<span class="nc bnc" id="L612" title="All 2 branches missed.">                    overall_damage[cur_arc][cur_range] *= (heat_capacity + (tsm_offset ? 9</span>
<span class="nc" id="L613">                            : 4));</span>
<span class="nc" id="L614">                    overall_damage[cur_arc][cur_range] /= (overall_heat[cur_arc][cur_range] + heat);</span>
                }

<span class="nc" id="L617">                damages[cur_arc][cur_range] = overall_damage[cur_arc][cur_range];</span>

                // Next hex
            }

            // Next arc
        }

        // Average out the minimum range modifiers
<span class="nc bnc" id="L626" title="All 2 branches missed.">        for (int cur_range = 1; cur_range &lt; minRangeMods.length; cur_range++) {</span>
<span class="nc bnc" id="L627" title="All 2 branches missed.">            if (weapons_count &gt; 0) {</span>
<span class="nc" id="L628">                minRangeMods[cur_range] = (int) Math</span>
<span class="nc" id="L629">                        .round(((double) minRangeMods[cur_range])</span>
                                / (double) weapons_count);
            }
        }

        // Change the damage from a per-hex array to a single &quot;weapon&quot;
        // with short/medium/long ranges. For now, just do the forward
        // arc.
<span class="nc" id="L637">        computeRange(Compute.ARC_FORWARD, overall_heat);</span>

        // Overheating will be based on the optimum firing range
<span class="nc" id="L640">        heat = (heat + heat_at_range) - heat_capacity;</span>

<span class="nc bnc" id="L642" title="All 2 branches missed.">        if (heat &lt;= 4) {</span>
<span class="nc" id="L643">            overheat = OVERHEAT_NONE;</span>
        }
<span class="nc bnc" id="L645" title="All 2 branches missed.">        if (heat &gt; 4) {</span>
<span class="nc" id="L646">            overheat = OVERHEAT_LOW;</span>
        }
<span class="nc bnc" id="L648" title="All 6 branches missed.">        if ((heat &gt; 9) &amp; !tsm_offset) {</span>
<span class="nc" id="L649">            overheat = OVERHEAT_HIGH;</span>
        }
<span class="nc bnc" id="L651" title="All 4 branches missed.">        if ((heat &gt; 12) &amp; tsm_offset) {</span>
<span class="nc" id="L652">            overheat = OVERHEAT_HIGH;</span>
        }

        // Defensive characterization - protection values

<span class="nc" id="L657">        double max = 1.0;</span>

        // Initialize armor values
<span class="nc" id="L660">        double armor[][] = MECH_ARMOR;</span>

<span class="nc bnc" id="L662" title="All 2 branches missed.">        if (entity instanceof Tank) {</span>
<span class="nc bnc" id="L663" title="All 2 branches missed.">            if (((Tank) entity).hasNoTurret()) {</span>
<span class="nc" id="L664">                armor = TANK_ARMOR;</span>
            } else {
<span class="nc" id="L666">                armor = TANK_WT_ARMOR;</span>
            }
        }

<span class="nc bnc" id="L670" title="All 2 branches missed.">        if (entity instanceof Infantry) {</span>
<span class="nc bnc" id="L671" title="All 2 branches missed.">            if (entity.isConventionalInfantry()) {</span>
<span class="nc" id="L672">                armor = INFANTRY_ARMOR;</span>
            } else {
<span class="nc bnc" id="L674" title="All 2 branches missed.">                if (entity.isClan()) {</span>
<span class="nc" id="L675">                    armor = CLBA_ARMOR;</span>
                } else {
<span class="nc" id="L677">                    armor = ISBA_ARMOR;</span>
                }
            }
        }

<span class="nc bnc" id="L682" title="All 2 branches missed.">        if (entity instanceof Protomech) {</span>
<span class="nc bnc" id="L683" title="All 2 branches missed.">            if (((Protomech) entity).hasMainGun()) {</span>
<span class="nc" id="L684">                armor = PROTOMECH_MG_ARMOR;</span>
            } else {
<span class="nc" id="L686">                armor = PROTOMECH_ARMOR;</span>
            }
        }

<span class="nc bnc" id="L690" title="All 2 branches missed.">        if (entity instanceof GunEmplacement) {</span>
<span class="nc bnc" id="L691" title="All 2 branches missed.">            armor = ((GunEmplacement) entity).isTurret() ? GUN_EMPLACEMENT_TURRET_ARMOR</span>
<span class="nc" id="L692">                    : GUN_EMPLACEMENT_ARMOR;</span>
        }

        // Arcs for the outside loop are those used for incoming damage:
        // front, rear, left, right as per static variables in ToHitData
<span class="nc bnc" id="L697" title="All 2 branches missed.">        for (int arc = FIRST_ARC; arc &lt;= LAST_PRIMARY_ARC; arc++) {</span>
<span class="nc" id="L698">            armor_health[arc] = 0.0;</span>
            // &quot;i&quot; is a location index. It matches the location static variables
            // for each sub-entity type (Mech, Tank, etc)
<span class="nc bnc" id="L701" title="All 2 branches missed.">            for (int i = 0; i &lt; armor[arc].length; i++) {</span>
<span class="nc bnc" id="L702" title="All 2 branches missed.">                armor_health[arc] += armor[arc][i]</span>
<span class="nc" id="L703">                        * getArmorValue(i, arc == ToHitData.SIDE_REAR);</span>
            }

            // ProtoMechs have a &quot;near miss&quot; location that isn't accounted for
            // in
            // the hit-table-probability array. Rolling 3 or 11 on 2d6 is 4/36.

<span class="nc bnc" id="L710" title="All 2 branches missed.">            if (entity instanceof Protomech) {</span>
<span class="nc" id="L711">                armor_health[arc] *= 1.22;</span>
            }
<span class="nc" id="L713">            max = Math.max(armor_health[arc], max);</span>
<span class="nc" id="L714">            armor_percent[arc] = armor_health[arc] / max;</span>
        }

        // Calculate an average armor value for the entire entity
        // TODO: Change to array, with an entry for each arc
<span class="nc" id="L719">        avg_armor = (armor_health[0] + armor_health[1] + armor_health[2] + armor_health[3]) / 4;</span>

        // Calculate average internal structure across the unit
        // Default to Mech unit, which has 7 locations plus the head (ignored
        // due to low
        // hit probability and low standard IS)
<span class="nc" id="L725">        avg_iarmor = entity.getTotalInternal() / 7.0;</span>

<span class="nc bnc" id="L727" title="All 2 branches missed.">        if (entity instanceof Infantry) {</span>
<span class="nc bnc" id="L728" title="All 2 branches missed.">            avg_iarmor = entity instanceof BattleArmor ? ((BattleArmor) entity)</span>
<span class="nc" id="L729">                    .getShootingStrength() : 1.0;</span>
        }
<span class="nc bnc" id="L731" title="All 2 branches missed.">        if (entity instanceof Tank) {</span>
<span class="nc" id="L732">            avg_iarmor = entity.getTotalInternal()</span>
<span class="nc bnc" id="L733" title="All 2 branches missed.">                    / (((Tank) entity).hasNoTurret() ? 4.0 : 5.0);</span>
        }
<span class="nc bnc" id="L735" title="All 2 branches missed.">        if (entity instanceof Protomech) {</span>
<span class="nc" id="L736">            avg_iarmor = entity.getTotalInternal()</span>
<span class="nc bnc" id="L737" title="All 2 branches missed.">                    / (((Protomech) entity).hasMainGun() ? 5.0 : 6.0);</span>
        }
<span class="nc bnc" id="L739" title="All 2 branches missed.">        if (entity instanceof GunEmplacement) {</span>
<span class="nc" id="L740">            avg_iarmor = 1.0;</span>
        }

<span class="nc" id="L743">    }</span>

    /**
     * Weapons mounted in one arc can be applied over several depending on the
     * type of unit due to torso or turret twisting
     *
     * @param mounted_arc
     *            arc for weapon
     * @param is_secondary
     *            true if weapon can fire into another arc
     * @return ArrayList of Compute.ARC_XXX integers
     */
    private ArrayList&lt;Integer&gt; getWeaponArcs(int mounted_arc,
            boolean is_secondary) {

<span class="nc" id="L758">        ArrayList&lt;Integer&gt; arc_list = new ArrayList&lt;Integer&gt;(1);</span>

        // Weapons which can fire in any direction
<span class="nc bnc" id="L761" title="All 6 branches missed.">        if ((mounted_arc == Compute.ARC_360)</span>
                || (mounted_arc == Compute.ARC_MAINGUN)
                || (mounted_arc == Compute.ARC_TURRET)) {
<span class="nc bnc" id="L764" title="All 2 branches missed.">            for (int i = FIRST_ARC; i &lt;= LAST_ARC; i++) {</span>
<span class="nc" id="L765">                arc_list.add(i);</span>
            }
        } else {

<span class="nc" id="L769">            arc_list.add(mounted_arc);</span>

            // If the weapon can be applied to a secondary arc, add it there
            // as well
<span class="nc bnc" id="L773" title="All 2 branches missed.">            if (is_secondary) {</span>

<span class="nc bnc" id="L775" title="All 2 branches missed.">                if (mounted_arc == Compute.ARC_FORWARD) {</span>

                    // Mech torso twist
<span class="nc" id="L778">                    arc_list.add(Compute.ARC_LEFTARM);</span>
<span class="nc" id="L779">                    arc_list.add(Compute.ARC_RIGHTARM);</span>

                    // Vehicle turrets
<span class="nc bnc" id="L782" title="All 2 branches missed.">                    if (entity instanceof Tank) {</span>
<span class="nc" id="L783">                        arc_list.add(Compute.ARC_360);</span>
                    }

                }

                // Left arm fires into the front and left side,
                // right arm to the front and right. If the arms
                // can flip, they both go to the rear as well.
<span class="nc bnc" id="L791" title="All 4 branches missed.">                if ((mounted_arc == Compute.ARC_LEFTARM)</span>
                        || (mounted_arc == Compute.ARC_RIGHTARM)) {

<span class="nc" id="L794">                    arc_list.add(Compute.ARC_FORWARD);</span>
<span class="nc bnc" id="L795" title="All 4 branches missed.">                    if ((entity instanceof Mech) &amp;&amp; entity.canFlipArms()) {</span>
<span class="nc" id="L796">                        arc_list.add(Compute.ARC_REAR);</span>
                    }

                }

            }

        }

<span class="nc" id="L805">        return arc_list;</span>
    }

    /**
     * Fills the CEntity damage and range brackets, plus the preferred range and
     * the heat for that range.
     *
     * @param arc
     *            Compute.ARC index for main damage array
     * @param est_heat
     *            Estimated heat of unit for each hex of range
     */
    private void computeRange(int arc, int[][] est_heat) {

<span class="nc" id="L819">        double damage_by_bracket[] = { 0.0, 0.0, 0.0, 0.0 };</span>
<span class="nc" id="L820">        double heat_by_bracket[] = { 0, 0, 0, 0 };</span>

<span class="nc" id="L822">        long_range = MAX_RANGE - 1;</span>
        int bracket_start, bracket_end;

        // Get the longest range and use it to calculate an average range
        // bracket. Extreme range is used when estimating damage but only
        // the official &quot;long&quot; range is kept.
        // TODO: add some math to account for non-linear brackets
<span class="nc bnc" id="L829" title="All 4 branches missed.">        while ((damages[arc][long_range] == 0.0) &amp;&amp; (long_range &gt;= 4)) {</span>
<span class="nc" id="L830">            long_range--;</span>
        }

<span class="nc" id="L833">        rd_bracket = long_range / 4;</span>
<span class="nc" id="L834">        long_range = 3 * rd_bracket;</span>
<span class="nc" id="L835">        bracket_start = 0;</span>
<span class="nc" id="L836">        bracket_end = rd_bracket;</span>

        // For each range bracket
<span class="nc bnc" id="L839" title="All 2 branches missed.">        for (int cur_bracket = RANGE_SHORT; cur_bracket &lt;= RANGE_LONG; cur_bracket++) {</span>

            // Get the start and end ranges. Allocate any leftover hexes to
            // to the end of the long range bracket.
<span class="nc bnc" id="L843" title="All 4 branches missed.">            switch (cur_bracket) {</span>
                case RANGE_SHORT:
<span class="nc bnc" id="L845" title="All 2 branches missed.">                    bracket_start = (entity instanceof Infantry ? 0 : 1);</span>
<span class="nc" id="L846">                    bracket_end = rd_bracket;</span>
<span class="nc" id="L847">                    break;</span>
                case RANGE_MEDIUM:
<span class="nc" id="L849">                    bracket_start = rd_bracket + 1;</span>
<span class="nc" id="L850">                    bracket_end = 2 * rd_bracket;</span>
<span class="nc" id="L851">                    break;</span>
                case RANGE_LONG:
<span class="nc" id="L853">                    bracket_start = (2 * rd_bracket) + 1;</span>
<span class="nc" id="L854">                    bracket_end = Math.min(long_range, MAX_RANGE - 1);</span>
                    break;
            }

            // For each hex in the current bracket
<span class="nc bnc" id="L859" title="All 2 branches missed.">            for (int cur_range = bracket_start; cur_range &lt;= bracket_end; cur_range++) {</span>

                // Add up the damage and heat estimates
<span class="nc" id="L862">                damage_by_bracket[cur_bracket] += damages[arc][cur_range];</span>
<span class="nc" id="L863">                damage_by_bracket[RANGE_ALL] += damages[arc][cur_range];</span>

<span class="nc" id="L865">                heat_by_bracket[cur_bracket] += est_heat[arc][cur_range];</span>
<span class="nc" id="L866">                heat_by_bracket[RANGE_ALL] += est_heat[arc][cur_range];</span>

                // Next hex
            }

            // Next range bracket
        }

        // Average out the damage and heat value totals over the number of
        // hexes for the range bracket
<span class="nc bnc" id="L876" title="All 2 branches missed.">        for (int cur_range = RANGE_SHORT; cur_range &lt;= RANGE_LONG; cur_range++) {</span>
<span class="nc bnc" id="L877" title="All 4 branches missed.">            if ((damages[arc][0] != 0.0) &amp;&amp; (cur_range == RANGE_SHORT)) {</span>
<span class="nc" id="L878">                damage_by_bracket[cur_range] /= (rd_bracket + 1);</span>
<span class="nc" id="L879">                heat_by_bracket[cur_range] /= (rd_bracket + 1);</span>
            } else {
<span class="nc" id="L881">                damage_by_bracket[cur_range] /= rd_bracket;</span>
<span class="nc" id="L882">                heat_by_bracket[cur_range] /= rd_bracket;</span>
            }

        }
<span class="nc" id="L886">        damage_by_bracket[RANGE_ALL] /= long_range;</span>
<span class="nc" id="L887">        heat_by_bracket[RANGE_ALL] /= long_range;</span>

        // Push the average damage and heat values to the CEntity arrays
<span class="nc" id="L890">        range_damages = damage_by_bracket;</span>
<span class="nc bnc" id="L891" title="All 2 branches missed.">        for (int cur_bracket = RANGE_SHORT; cur_bracket &lt;= RANGE_ALL; cur_bracket++) {</span>
<span class="nc" id="L892">            heat_estimates[cur_bracket] = (int) heat_by_bracket[cur_bracket];</span>
        }

        // Pick the best range, which will likely be &quot;short&quot; due to short
        // range secondary weapons and better to-hit modifiers
<span class="nc" id="L897">        range = RANGE_SHORT;</span>
<span class="nc bnc" id="L898" title="All 2 branches missed.">        for (int cur_bracket = RANGE_SHORT; cur_bracket &lt;= RANGE_ALL; cur_bracket++) {</span>
<span class="nc bnc" id="L899" title="All 2 branches missed.">            if (range_damages[cur_bracket] &gt; range_damages[range]) {</span>
<span class="nc" id="L900">                range = cur_bracket;</span>
            }
        }

        // Get the weapons heat for the optimum range
<span class="nc" id="L905">        heat_at_range = heat_estimates[range];</span>

<span class="nc" id="L907">    }</span>

    /**
     * Fills range damage values for short, medium, long, and all, plus sets the
     * range bracket for the entity, which is 1/3 of long range or 1/4 extreme
     * range. The arc argument follows Compute.ARC_XXX format.
     */
    public void computeRange(int arc, boolean aptGunnery) {

<span class="nc" id="L916">        double optimizer[] = { 0, 0, 0, 0 };</span>

<span class="nc" id="L918">        Arrays.fill(range_damages, 0);</span>

        // Create short, medium, and long range values for each arc

<span class="nc" id="L922">        rd_bracket = long_range / 4;</span>

<span class="nc bnc" id="L924" title="All 4 branches missed.">        for (int range_walk = (entity instanceof Infantry ? 0 : 1); range_walk &lt; long_range; range_walk++) {</span>
<span class="nc bnc" id="L925" title="All 2 branches missed.">            if (range_walk &lt;= rd_bracket) {</span>
<span class="nc" id="L926">                optimizer[RANGE_SHORT] += damages[arc][range_walk];</span>
<span class="nc" id="L927">                range_damages[RANGE_SHORT] += damages[arc][range_walk];</span>
            }
<span class="nc bnc" id="L929" title="All 6 branches missed.">            if ((range_walk &gt; rd_bracket) &amp; (range_walk &lt;= (2 * rd_bracket))) {</span>
<span class="nc" id="L930">                optimizer[RANGE_MEDIUM] += getModifiedDamage(arc, range_walk, -2, aptGunnery);</span>
<span class="nc" id="L931">                range_damages[RANGE_MEDIUM] += damages[arc][range_walk];</span>
            }
<span class="nc bnc" id="L933" title="All 6 branches missed.">            if ((range_walk &gt; (2 * rd_bracket)) &amp; (range_walk &lt;= (3 * rd_bracket))) {</span>
<span class="nc" id="L934">                optimizer[RANGE_LONG] += getModifiedDamage(arc, range_walk, -4, aptGunnery);</span>
<span class="nc" id="L935">                range_damages[RANGE_LONG] += damages[arc][range_walk];</span>
            }
<span class="nc" id="L937">            range_damages[RANGE_ALL] += damages[arc][range_walk];</span>
        }

<span class="nc bnc" id="L940" title="All 2 branches missed.">        if (rd_bracket &gt; 0) {</span>
<span class="nc" id="L941">            range_damages[RANGE_SHORT] /= rd_bracket;</span>
<span class="nc" id="L942">            optimizer[RANGE_SHORT] /= rd_bracket;</span>
<span class="nc" id="L943">            range_damages[RANGE_MEDIUM] /= rd_bracket;</span>
<span class="nc" id="L944">            optimizer[RANGE_MEDIUM] /= rd_bracket;</span>
<span class="nc" id="L945">            range_damages[RANGE_LONG] /= rd_bracket;</span>
<span class="nc" id="L946">            optimizer[RANGE_LONG] /= rd_bracket;</span>
<span class="nc" id="L947">            range_damages[RANGE_ALL] /= (rd_bracket * 3);</span>
        } else {
<span class="nc" id="L949">            range_damages[RANGE_SHORT] = damages[arc][0];</span>
<span class="nc" id="L950">            optimizer[RANGE_SHORT] = damages[arc][0];</span>
<span class="nc" id="L951">            range_damages[RANGE_MEDIUM] = damages[arc][0];</span>
<span class="nc" id="L952">            optimizer[RANGE_MEDIUM] = damages[arc][0];</span>
<span class="nc" id="L953">            range_damages[RANGE_LONG] = damages[arc][0];</span>
<span class="nc" id="L954">            optimizer[RANGE_LONG] = damages[arc][0];</span>
<span class="nc" id="L955">            range_damages[RANGE_ALL] = damages[arc][0];</span>
        }

        // Now determine the preferred range. Use damage values based on no
        // range modifiers, but retain the range-based damage values for
        // further use.

<span class="nc" id="L962">        int best_range = RANGE_ALL;</span>

<span class="nc bnc" id="L964" title="All 2 branches missed.">        for (range = RANGE_SHORT; range &lt;= RANGE_LONG; range++) {</span>
<span class="nc bnc" id="L965" title="All 2 branches missed.">            if (optimizer[range] &gt; optimizer[best_range]) {</span>
<span class="nc" id="L966">                best_range = range;</span>
            }
        }
<span class="nc" id="L969">        range = best_range;</span>
<span class="nc" id="L970">    }</span>

    /**
     * Returns the value of the armor in the indicated location. Conventional
     * infantry and battle armor behave differently than other units. Armor is
     * in integer units.
     */
    protected int getArmorValue(int loc, boolean rear) {
<span class="nc" id="L978">        int result = entity.getArmor(loc, rear);</span>

        // Conventional infantry don't have armor (yet), so use the number of
        // troopers
        // TODO: This will probably need some revamping when Total Warfare is
        // released.
<span class="nc bnc" id="L984" title="All 2 branches missed.">        if (entity.isConventionalInfantry()) {</span>
<span class="nc" id="L985">            result = ((Infantry) entity).getShootingStrength();</span>
        }

        // Battle armor has armor per trooper; treat each trooper as a
        // &quot;location&quot;
<span class="nc bnc" id="L990" title="All 2 branches missed.">        if (entity instanceof BattleArmor) {</span>
<span class="nc" id="L991">            result = ((BattleArmor) entity).getArmor(loc, false);</span>
        }

<span class="nc bnc" id="L994" title="All 2 branches missed.">        if (result &lt;= 0) {</span>
<span class="nc" id="L995">            result = 0;</span>
        }

<span class="nc" id="L998">        return result;</span>
    }

    /**
     * The utility of something done against me. -- uses the arcs defined by
     * ToHitData (FRONT, REAR, LEFT, RIGHT). Takes a damage value and adjusts it
     * based on the characterized entities armor/internal values in that arc.
     * Also adjusts based on the strategy module being used by this entity.
     */
    public double getThreatUtility(double threat, int arc) {
<span class="nc" id="L1008">        double t1 = threat;</span>
<span class="nc" id="L1009">        double t2 = threat;</span>
        // relative bonus for weak side
<span class="nc bnc" id="L1011" title="All 2 branches missed.">        if (armor_percent[arc] &lt; .75) {</span>
<span class="nc" id="L1012">            t1 *= 1.1;</span>
<span class="nc bnc" id="L1013" title="All 2 branches missed.">        } else if (armor_percent[arc] &lt; .5) {</span>
<span class="nc" id="L1014">            t1 *= 1.3;</span>
<span class="nc bnc" id="L1015" title="All 2 branches missed.">        } else if (armor_percent[arc] &lt; .25) {</span>
<span class="nc" id="L1016">            t1 *= 1.5;</span>
        }
<span class="nc" id="L1018">        t1 *= strategy.target;</span>

        // absolute bonus for damage that is likely to do critical
<span class="nc bnc" id="L1021" title="All 2 branches missed.">        if ((t2 + expected_damage[arc]) &gt; armor_health[arc]) {</span>

            // expected_damage[] is set on the fly; it tracks damage
            // the entity expects to take
<span class="nc bnc" id="L1025" title="All 2 branches missed.">            if ((((t2 + expected_damage[0] + expected_damage[1]</span>
                    + expected_damage[2] + expected_damage[3]) &gt; (3 * (avg_armor + avg_iarmor))) || (entity
<span class="nc bnc" id="L1027" title="All 6 branches missed.">                    .isProne() &amp;&amp; (base_psr_odds &lt; .1) &amp;&amp; !entity.isImmobile()))) { // If</span>
                                                                                    // I
                // have
                // more
                // friends,
                // this
                // isn't
                // so
                // bad
<span class="nc bnc" id="L1036" title="All 2 branches missed.">                if (entity.isEnemyOf(tb.getEntitiesOwned().get(0))) {</span>
<span class="nc" id="L1037">                    return Math.sqrt(t2) * strategy.target;</span>
                }
            }
<span class="nc" id="L1040">            t2 *= 1.5; // Damage that penetrates armor is bad for me</span>
            // Even if damage doesn't penetrate, some damage to this arc isn't
            // that great
<span class="nc bnc" id="L1043" title="All 2 branches missed.">        } else if (expected_damage[arc] &gt; 0) {</span>
<span class="nc" id="L1044">            t2 *= 1.3;</span>

            // Even if this arc is still good, taking additional damage isn't a
            // good thing
<span class="nc bnc" id="L1048" title="All 2 branches missed.">        } else if (hasTakenDamage) {</span>
<span class="nc" id="L1049">            t2 *= 1.1;</span>
        }

        // Return the worst case, either massive damage or penetration to
        // internals

<span class="nc" id="L1055">        return Math.max(t1, t2);</span>
    }

    public Integer getKey() {
<span class="nc" id="L1059">        return Integer.valueOf(entity.getId());</span>
    }

    public MoveOption.Table getAllMoves(Client client) {
<span class="nc bnc" id="L1063" title="All 2 branches missed.">        if (moves == null) {</span>
<span class="nc" id="L1064">            moves = calculateMoveOptions(current, client);</span>
        }
<span class="nc" id="L1066">        return moves;</span>
    }

    /**
     * From the current state, explore based upon an implementation of
     * Dijkstra's algorithm.
     */
    protected MoveOption.Table calculateMoveOptions(MoveOption base,
            Client client) {
        // New array of movement options
<span class="nc" id="L1076">        ArrayList&lt;MoveOption&gt; possible = new ArrayList&lt;MoveOption&gt;();</span>
<span class="nc" id="L1077">        MoveOption.Table discovered = new MoveOption.Table();</span>

        // Add the seed for jumping if allowed
<span class="nc bnc" id="L1080" title="All 2 branches missed.">        if (entity.getJumpMPWithTerrain() &gt; 0) {</span>
<span class="nc" id="L1081">            possible.add((base.clone()).addStep(MoveStepType.START_JUMP));</span>
        }

<span class="nc" id="L1084">        possible.add(base); // Add the base movement option to the arraylist of</span>
        // possibles
<span class="nc" id="L1086">        discovered.put(base); // Add the base movement option to the movement</span>
        // option table

<span class="nc bnc" id="L1089" title="All 2 branches missed.">        while (possible.size() &gt; 0) { // Keep going until the arraylist is</span>
            // empty (why?)

            // Get the first movement option, while stripping it from the
            // arraylist
<span class="nc" id="L1094">            MoveOption min = possible.remove(0);</span>
<span class="nc" id="L1095">            Iterator&lt;MovePath&gt; adjacent = min.getNextMoves(true, true)</span>
<span class="nc" id="L1096">                    .iterator();</span>
<span class="nc bnc" id="L1097" title="All 2 branches missed.">            while (adjacent.hasNext()) {</span>
<span class="nc" id="L1098">                MoveOption next = (MoveOption) adjacent.next();</span>
<span class="nc bnc" id="L1099" title="All 4 branches missed.">                if ((entity instanceof Mech) &amp;&amp; (((Mech) entity).countBadLegs() &gt;= 1)</span>
<span class="nc bnc" id="L1100" title="All 2 branches missed.">                        &amp;&amp; (((Mech) entity).isLocationBad(Mech.LOC_LARM) &amp;&amp; ((Mech) entity)</span>
<span class="nc bnc" id="L1101" title="All 2 branches missed.">                                .isLocationBad(Mech.LOC_RARM))) {</span>
<span class="nc" id="L1102">                    MoveOption eject = next.clone();</span>
<span class="nc" id="L1103">                    eject.addStep(MoveStepType.EJECT);</span>
<span class="nc" id="L1104">                    discovered.put(eject.clone());</span>
                }
<span class="nc bnc" id="L1106" title="All 4 branches missed.">                if (next.changeToPhysical() &amp;&amp; next.isMoveLegal()) {</span>
<span class="nc" id="L1107">                    discovered.put(next);</span>
<span class="nc bnc" id="L1108" title="All 2 branches missed.">                } else if (next.isMoveLegal()) {</span>
                    // relax edges;
<span class="nc bnc" id="L1110" title="All 2 branches missed.">                    if ((discovered.get(next) == null)</span>
<span class="nc" id="L1111">                            || (next.getDistUtility() &lt; discovered.get(next)</span>
<span class="nc bnc" id="L1112" title="All 2 branches missed.">                                    .getDistUtility())) {</span>
<span class="nc" id="L1113">                        discovered.put(next);</span>
<span class="nc bnc" id="L1114" title="All 2 branches missed.">                        if (next.isJumping()) {</span>
<span class="nc" id="L1115">                            MoveOption left = next.clone();</span>
<span class="nc" id="L1116">                            MoveOption right = next.clone();</span>
                            // Think about skipping this for infantry, which
                            // have no facing
<span class="nc bnc" id="L1119" title="All 2 branches missed.">                            for (int turn = 0; turn &lt; 2; turn++) {</span>
<span class="nc" id="L1120">                                left.addStep(MoveStepType.TURN_LEFT);</span>
<span class="nc" id="L1121">                                right.addStep(MoveStepType.TURN_RIGHT);</span>
<span class="nc" id="L1122">                                discovered.put((left.clone()));</span>
<span class="nc" id="L1123">                                discovered.put((right.clone()));</span>
                            }
                            // Accounts for a 180 degree turn
<span class="nc" id="L1126">                            right.addStep(MoveStepType.TURN_RIGHT);</span>
<span class="nc" id="L1127">                            discovered.put(right);</span>
                        }
<span class="nc" id="L1129">                        int index = Collections.&lt;MoveOption&gt; binarySearch(</span>
                                possible, next, MoveOption.DISTANCE_COMPARATOR);
<span class="nc bnc" id="L1131" title="All 2 branches missed.">                        if (index &lt; 0) {</span>
<span class="nc" id="L1132">                            index = -index - 1;</span>
                        }
<span class="nc" id="L1134">                        possible.add(index, next);</span>
                    }
                }
<span class="nc" id="L1137">            }</span>
<span class="nc" id="L1138">        }</span>
        // Final check for illegal and extra weighting for heat
<span class="nc" id="L1140">        for (Iterator&lt;MoveOption&gt; i = discovered.values().iterator(); i</span>
<span class="nc bnc" id="L1141" title="All 2 branches missed.">                .hasNext();) {</span>
<span class="nc" id="L1142">            MoveOption next = i.next();</span>
<span class="nc" id="L1143">            next.clipToPossible();</span>
<span class="nc bnc" id="L1144" title="All 2 branches missed.">            if (!next.isMoveLegal()) {</span>
<span class="nc" id="L1145">                i.remove();</span>
            }
<span class="nc bnc" id="L1147" title="All 2 branches missed.">            if (entity.heat &gt; 4) {</span>
<span class="nc" id="L1148">                next.movement_threat += (bv / 1000)</span>
<span class="nc" id="L1149">                        * next.getMovementheatBuildup();</span>
<span class="nc bnc" id="L1150" title="All 2 branches missed.">                if (entity.heat &gt; 7) {</span>
<span class="nc" id="L1151">                    next.movement_threat += (bv / 500)</span>
<span class="nc" id="L1152">                            * next.getMovementheatBuildup();</span>
                }
<span class="nc bnc" id="L1154" title="All 2 branches missed.">                if (tsm_offset) {</span>
<span class="nc bnc" id="L1155" title="All 2 branches missed.">                    if (entity.heat == 9) {</span>
<span class="nc" id="L1156">                        next.movement_threat -= (bv / 100)</span>
<span class="nc" id="L1157">                                * next.getMovementheatBuildup();</span>
                    }
<span class="nc bnc" id="L1159" title="All 4 branches missed.">                    if ((entity.heat &lt; 12) &amp;&amp; (entity.heat &gt; 9)) {</span>
<span class="nc" id="L1160">                        next.movement_threat -= (bv / 500)</span>
<span class="nc" id="L1161">                                * next.getMovementheatBuildup();</span>
                    }
                }
<span class="nc bnc" id="L1164" title="All 2 branches missed.">                if (entity.heat &gt; 12) {</span>
<span class="nc" id="L1165">                    next.movement_threat += (bv / 100)</span>
<span class="nc" id="L1166">                            * next.getMovementheatBuildup();</span>
                }
            }
<span class="nc" id="L1169">            String pilotChecks = SharedUtility.doPSRCheck(next);</span>
<span class="nc bnc" id="L1170" title="All 2 branches missed.">            if (pilotChecks.length() &gt; 0) {</span>
<span class="nc" id="L1171">                next.inDanger = true;</span>
            }
<span class="nc" id="L1173">        }</span>
<span class="nc" id="L1174">        return discovered;</span>
    }

    /**
     * find all moves that get into dest
     */
    public ArrayList&lt;MoveOption&gt; findMoves(Coords dest, Client client) {
<span class="nc" id="L1181">        ArrayList&lt;MoveOption&gt; result = new ArrayList&lt;MoveOption&gt;();</span>
<span class="nc bnc" id="L1182" title="All 2 branches missed.">        for (int i = 0; i &lt; 6; i++) {</span>
<span class="nc bnc" id="L1183" title="All 2 branches missed.">            for (int j = 1; j &lt; 2; j++) {</span>
<span class="nc" id="L1184">                MoveOption.Key key = new MoveOption.Key(dest, i, j);</span>
<span class="nc" id="L1185">                MoveOption es = null;</span>
<span class="nc bnc" id="L1186" title="All 2 branches missed.">                if ((es = getAllMoves(client).get(key)) != null) {</span>
<span class="nc" id="L1187">                    result.add(es);</span>
                }
            }
        }
<span class="nc" id="L1191">        return result;</span>
    }

    /**
     * Returns an estimate of damage given the range to the target and a
     * modifier to the to-hit number. An approximation of the original to-hit
     * odds is extracted from the damage at that range leaving the damage that
     * is (hopefully) close to the original value. New odds are generated based
     * on the units gunnery skill and the modifier and factored back into the
     * returned damage value.
     */
    public double getModifiedDamage(int arc, int a_range, int modifier, boolean aptGunnery) {
<span class="nc bnc" id="L1203" title="All 2 branches missed.">        if (a_range &gt;= MAX_RANGE) {</span>
<span class="nc" id="L1204">            return 0.0;</span>
        }
<span class="nc" id="L1206">        double damage = damages[arc][a_range];</span>

        // Use pilots gunnery skill, not the piloting skill...
<span class="nc" id="L1209">        int base = entity.getCrew().getGunnery();</span>
<span class="nc bnc" id="L1210" title="All 2 branches missed.">        if (entity.getTaserFeedBackRounds() &gt; 0) {</span>
<span class="nc" id="L1211">            base += 1;</span>
        }
<span class="nc" id="L1213">        int dist_mod = 0;</span>

        // Check range brackets based on defined maximum possible
        // range of weapon
<span class="nc" id="L1217">        double range_bracket = long_range / 4.0;</span>

        // Inside minimum range, penalties must be observed
<span class="nc bnc" id="L1220" title="All 2 branches missed.">        if (a_range &lt;= MIN_BRACKET) {</span>
<span class="nc" id="L1221">            dist_mod += minRangeMods[a_range];</span>
        }

        // Medium range is +2
<span class="nc bnc" id="L1225" title="All 2 branches missed.">        if (a_range &gt; range_bracket) {</span>
<span class="nc" id="L1226">            dist_mod += 2;</span>
        }

        // Long range is another +2 (i.e. +4)
<span class="nc bnc" id="L1230" title="All 2 branches missed.">        if (a_range &gt; (2 * range_bracket)) {</span>
<span class="nc" id="L1231">            dist_mod += 2;</span>
        }

        // Anything past 3 &quot;range brackets&quot; is extreme range +8,
        // or +4 on top of previous modifiers
<span class="nc bnc" id="L1236" title="All 2 branches missed.">        if (a_range &gt; (3 * range_bracket)) {</span>
<span class="nc" id="L1237">            dist_mod += 4;</span>
        }

<span class="nc bnc" id="L1240" title="All 6 branches missed.">        if (((base + dist_mod + modifier) &gt; tb.ignore)</span>
                | ((base + dist_mod + modifier) &gt; 12)) {
<span class="nc" id="L1242">            return 0.0;</span>
        }
<span class="nc bnc" id="L1244" title="All 2 branches missed.">        if ((base + dist_mod + modifier) == tb.ignore) {</span>
<span class="nc" id="L1245">            damage *= 0.5;</span>
        }

        // Factor out the to-hit odds and re-factor in new odds with the passed
        // modifier
<span class="nc" id="L1250">        double old_odds = Compute.oddsAbove(base + dist_mod, aptGunnery) / 100;</span>
<span class="nc" id="L1251">        double new_odds = Compute.oddsAbove(dist_mod + modifier + base, aptGunnery) / 100;</span>

<span class="nc" id="L1253">        return (new_odds * damage) / old_odds;</span>
    }

    /**
     * Generates an approximation of damage done at each of the major range
     * brackets, including minimum range. Also handles weapons with damage and
     * range that varies by ammo type. Adds line to debug log for any variable
     * damage weapons that aren't handled.
     *
     * @param weapon
     * @param applicable_ranges
     *            only counts for MMLs and ATMs
     * @return 4-element array with min/short/medium/long range damage
     */

    private static double[] getRawDamage(Mounted weapon,
            boolean[] applicable_ranges) {
<span class="nc" id="L1270">        WeaponType wt = (WeaponType) weapon.getType();</span>
        Mounted linked_guidance;

<span class="nc" id="L1273">        double damage_value = wt.getDamage();</span>
<span class="nc" id="L1274">        double[] raw_damage_array = { damage_value, damage_value, damage_value,</span>
                damage_value };

<span class="nc" id="L1277">        int rack_size = 1;</span>

<span class="nc" id="L1279">        boolean use_table = false;</span>

        // Some weapons use the cluster hits table:
        // - non-Thunderbolt missiles
        // - LBX cannons are assumed to have cluster ammo
        // - Ultra cannons as two-shot, rotary cannons as 4-shot
        // - HAGs

<span class="nc bnc" id="L1287" title="All 2 branches missed.">        if (wt.hasFlag(WeaponType.F_MISSILE)</span>
<span class="nc bnc" id="L1288" title="All 2 branches missed.">                &amp;&amp; ((wt.getAmmoType() != AmmoType.T_TBOLT_5)</span>
<span class="nc bnc" id="L1289" title="All 2 branches missed.">                        || (wt.getAmmoType() != AmmoType.T_TBOLT_10)</span>
<span class="nc bnc" id="L1290" title="All 2 branches missed.">                        || (wt.getAmmoType() != AmmoType.T_TBOLT_15) || (wt</span>
<span class="nc bnc" id="L1291" title="All 2 branches missed.">                        .getAmmoType() != AmmoType.T_TBOLT_20))) {</span>
<span class="nc" id="L1292">            use_table = true;</span>
<span class="nc" id="L1293">            rack_size = wt.getRackSize();</span>
        }

<span class="nc bnc" id="L1296" title="All 2 branches missed.">        if ((wt.getAmmoType() == AmmoType.T_AC_LBX)</span>
<span class="nc bnc" id="L1297" title="All 2 branches missed.">                || (wt.getAmmoType() == AmmoType.T_AC_LBX_THB)</span>
<span class="nc bnc" id="L1298" title="All 2 branches missed.">                || (wt.getAmmoType() == AmmoType.T_HAG)) {</span>
<span class="nc" id="L1299">            use_table = true;</span>
<span class="nc" id="L1300">            rack_size = wt.getRackSize();</span>
        }

<span class="nc bnc" id="L1303" title="All 2 branches missed.">        if ((wt.getAmmoType() == AmmoType.T_AC_ULTRA)</span>
<span class="nc bnc" id="L1304" title="All 2 branches missed.">                || (wt.getAmmoType() == AmmoType.T_AC_ULTRA_THB)) {</span>
<span class="nc" id="L1305">            use_table = true;</span>
<span class="nc" id="L1306">            rack_size = 2;</span>
        }

<span class="nc bnc" id="L1309" title="All 2 branches missed.">        if ((wt.getAmmoType() == AmmoType.T_AC_ROTARY)) {</span>
<span class="nc" id="L1310">            use_table = true;</span>
<span class="nc" id="L1311">            rack_size = 4;</span>
        }

<span class="nc bnc" id="L1314" title="All 2 branches missed.">        if (use_table == true) {</span>

<span class="nc" id="L1316">            int linked_ammo = wt.getAmmoType();</span>

            // MMLs and ATMS change damage and range by ammo type,
            // which is going to require some serious gymnastics

            // ATMs, which include built-in Artemis
<span class="nc bnc" id="L1322" title="All 2 branches missed.">            if (linked_ammo == AmmoType.T_ATM) {</span>

<span class="nc" id="L1324">                damage_value = hits_by_racksize[rack_size] * 1.2;</span>

                // Use ER ammo damage as a default
<span class="nc bnc" id="L1327" title="All 2 branches missed.">                for (int i = 0; i &lt; raw_damage_array.length; i++) {</span>
<span class="nc" id="L1328">                    raw_damage_array[i] = damage_value;</span>
                }

                // All three types: use ER ranges, with HE for &quot;short&quot; range,
                // std for &quot;medium&quot; range, and ER for &quot;long&quot; range damages
<span class="nc bnc" id="L1333" title="All 6 branches missed.">                if (applicable_ranges[0] &amp;&amp; applicable_ranges[1]</span>
                        &amp;&amp; applicable_ranges[2]) {
<span class="nc" id="L1335">                    raw_damage_array[0] *= 3.0;</span>
<span class="nc" id="L1336">                    raw_damage_array[1] *= 3.0;</span>
<span class="nc" id="L1337">                    raw_damage_array[2] *= 2.0;</span>
                }

                // HE only
<span class="nc bnc" id="L1341" title="All 6 branches missed.">                if (applicable_ranges[0] &amp;&amp; !applicable_ranges[1]</span>
                        &amp;&amp; !applicable_ranges[2]) {
<span class="nc bnc" id="L1343" title="All 2 branches missed.">                    for (int i = 0; i &lt; raw_damage_array.length; i++) {</span>
<span class="nc" id="L1344">                        raw_damage_array[i] *= 3.0;</span>
                    }
                }

                // Standard only
<span class="nc bnc" id="L1349" title="All 6 branches missed.">                if (!applicable_ranges[0] &amp;&amp; applicable_ranges[1]</span>
                        &amp;&amp; !applicable_ranges[2]) {
<span class="nc bnc" id="L1351" title="All 2 branches missed.">                    for (int i = 0; i &lt; raw_damage_array.length; i++) {</span>
<span class="nc" id="L1352">                        raw_damage_array[i] *= 2.0;</span>
                    }
                }

                // HE and standard only: use std ranges, with HE for the
                // &quot;short&quot; range damage
<span class="nc bnc" id="L1358" title="All 6 branches missed.">                if (applicable_ranges[0] &amp;&amp; applicable_ranges[1]</span>
                        &amp;&amp; !applicable_ranges[2]) {

<span class="nc" id="L1361">                    raw_damage_array[0] *= 3.0;</span>
<span class="nc" id="L1362">                    raw_damage_array[1] *= 3.0;</span>
<span class="nc" id="L1363">                    raw_damage_array[2] *= 3.0;</span>
<span class="nc" id="L1364">                    raw_damage_array[3] *= 2.0;</span>

                }

                // HE and ER only: use ER ranges, with HE for the
                // &quot;short&quot; range damage
<span class="nc bnc" id="L1370" title="All 6 branches missed.">                if (applicable_ranges[0] &amp;&amp; !applicable_ranges[1]</span>
                        &amp;&amp; applicable_ranges[2]) {

<span class="nc" id="L1373">                    raw_damage_array[0] *= 3.0;</span>
<span class="nc" id="L1374">                    raw_damage_array[1] *= 3.0;</span>
<span class="nc" id="L1375">                    raw_damage_array[2] *= 1.0;</span>
<span class="nc" id="L1376">                    raw_damage_array[3] *= 1.0;</span>

                }

                // Standard and ER only: use ER ranges, with std for &quot;short&quot;
                // and &quot;medium&quot; range damage
<span class="nc bnc" id="L1382" title="All 6 branches missed.">                if (!applicable_ranges[0] &amp;&amp; applicable_ranges[1]</span>
                        &amp;&amp; applicable_ranges[2]) {

<span class="nc" id="L1385">                    raw_damage_array[0] *= 2.0;</span>
<span class="nc" id="L1386">                    raw_damage_array[1] *= 2.0;</span>
<span class="nc" id="L1387">                    raw_damage_array[2] *= 2.0;</span>
<span class="nc" id="L1388">                    raw_damage_array[3] *= 1.0;</span>

                }

            }

            // MMLs, which may have Artemis
<span class="nc bnc" id="L1395" title="All 2 branches missed.">            if (linked_ammo == AmmoType.T_MML) {</span>

<span class="nc" id="L1397">                damage_value = hits_by_racksize[rack_size];</span>
<span class="nc" id="L1398">                linked_guidance = weapon.getLinkedBy();</span>
<span class="nc bnc" id="L1399" title="All 4 branches missed.">                if ((linked_guidance != null) &amp;&amp; !linked_guidance.isDestroyed()</span>
<span class="nc bnc" id="L1400" title="All 2 branches missed.">                        &amp;&amp; !linked_guidance.isMissing()</span>
<span class="nc bnc" id="L1401" title="All 2 branches missed.">                        &amp;&amp; !linked_guidance.isBreached()</span>
<span class="nc bnc" id="L1402" title="All 2 branches missed.">                        &amp;&amp; (linked_guidance.getType() instanceof MiscType)) {</span>

<span class="nc bnc" id="L1404" title="All 2 branches missed.">                    if (linked_guidance.getType().hasFlag(MiscType.F_ARTEMIS)) {</span>
<span class="nc" id="L1405">                        damage_value *= 1.2;</span>
                    }

                }

                // Use LRM damage as a default
<span class="nc bnc" id="L1411" title="All 2 branches missed.">                for (int i = 0; i &lt; raw_damage_array.length; i++) {</span>
<span class="nc" id="L1412">                    raw_damage_array[i] = damage_value;</span>
                }

                // If SRM ammo is available, use it for short and medium range
<span class="nc bnc" id="L1416" title="All 2 branches missed.">                if (applicable_ranges[0]) {</span>

<span class="nc" id="L1418">                    raw_damage_array[0] *= 2.0;</span>
<span class="nc" id="L1419">                    raw_damage_array[1] *= 2.0;</span>
<span class="nc" id="L1420">                    raw_damage_array[2] *= 2.0;</span>

                    // If LRM ammo is not available, use SRM for long range too
<span class="nc bnc" id="L1423" title="All 2 branches missed.">                    if (!applicable_ranges[2]) {</span>
<span class="nc" id="L1424">                        raw_damage_array[3] *= 2.0;</span>
                    }

                }

            }

            // LRMs, SRMs, which may have Artemis
<span class="nc bnc" id="L1432" title="All 8 branches missed.">            if ((linked_ammo == AmmoType.T_SRM)</span>
                    || (linked_ammo == AmmoType.T_SRM_IMP) 
                    || (linked_ammo == AmmoType.T_LRM_IMP)
                    || (linked_ammo == AmmoType.T_LRM)) {

<span class="nc" id="L1437">                damage_value = hits_by_racksize[rack_size];</span>
<span class="nc" id="L1438">                linked_guidance = weapon.getLinkedBy();</span>
<span class="nc bnc" id="L1439" title="All 4 branches missed.">                if ((linked_guidance != null) &amp;&amp; !linked_guidance.isDestroyed()</span>
<span class="nc bnc" id="L1440" title="All 2 branches missed.">                        &amp;&amp; !linked_guidance.isMissing()</span>
<span class="nc bnc" id="L1441" title="All 2 branches missed.">                        &amp;&amp; !linked_guidance.isBreached()</span>
<span class="nc bnc" id="L1442" title="All 2 branches missed.">                        &amp;&amp; (linked_guidance.getType() instanceof MiscType)) {</span>

<span class="nc bnc" id="L1444" title="All 2 branches missed.">                    if (linked_guidance.getType().hasFlag(MiscType.F_ARTEMIS)) {</span>
<span class="nc" id="L1445">                        damage_value *= 1.2;</span>
                    } else {
<span class="nc bnc" id="L1447" title="All 2 branches missed.">                        if (linked_guidance.getType().hasFlag(</span>
                                MiscType.F_ARTEMIS_V)) {
<span class="nc" id="L1449">                            damage_value *= 1.4;</span>
                        }
                    }

                }

<span class="nc bnc" id="L1455" title="All 4 branches missed.">                if ((linked_ammo == AmmoType.T_SRM) || (linked_ammo == AmmoType.T_SRM_IMP)) {</span>
<span class="nc" id="L1456">                    damage_value *= 2.0;</span>
                }

<span class="nc bnc" id="L1459" title="All 2 branches missed.">                for (int i = 0; i &lt; raw_damage_array.length; i++) {</span>
<span class="nc" id="L1460">                    raw_damage_array[i] = damage_value;</span>
                }

            }

            // MRMs, which may have Apollo
<span class="nc bnc" id="L1466" title="All 2 branches missed.">            if (linked_ammo == AmmoType.T_MRM) {</span>

<span class="nc" id="L1468">                damage_value = hits_by_racksize[rack_size];</span>
<span class="nc" id="L1469">                linked_guidance = weapon.getLinkedBy();</span>
<span class="nc bnc" id="L1470" title="All 4 branches missed.">                if ((linked_guidance != null) &amp;&amp; !linked_guidance.isDestroyed()</span>
<span class="nc bnc" id="L1471" title="All 2 branches missed.">                        &amp;&amp; !linked_guidance.isMissing()</span>
<span class="nc bnc" id="L1472" title="All 2 branches missed.">                        &amp;&amp; !linked_guidance.isBreached()</span>
<span class="nc bnc" id="L1473" title="All 2 branches missed.">                        &amp;&amp; (linked_guidance.getType() instanceof MiscType)) {</span>
<span class="nc" id="L1474">                    damage_value *= 0.9;</span>
                }

<span class="nc bnc" id="L1477" title="All 2 branches missed.">                for (int i = 0; i &lt; raw_damage_array.length; i++) {</span>
<span class="nc" id="L1478">                    raw_damage_array[i] = damage_value;</span>
                }

            }

            // Streak SRMs and LRMs use full rack size
<span class="nc bnc" id="L1484" title="All 2 branches missed.">            if (linked_ammo == AmmoType.T_SRM_STREAK) {</span>

<span class="nc" id="L1486">                damage_value = rack_size * 2.0;</span>

<span class="nc bnc" id="L1488" title="All 2 branches missed.">                for (int i = 0; i &lt; raw_damage_array.length; i++) {</span>
<span class="nc" id="L1489">                    raw_damage_array[i] = damage_value;</span>
                }

            }
<span class="nc bnc" id="L1493" title="All 2 branches missed.">            if (linked_ammo == AmmoType.T_LRM_STREAK) {</span>
<span class="nc" id="L1494">                damage_value = rack_size;</span>

<span class="nc bnc" id="L1496" title="All 2 branches missed.">                for (int i = 0; i &lt; raw_damage_array.length; i++) {</span>
<span class="nc" id="L1497">                    raw_damage_array[i] = damage_value;</span>
                }
            }

            // HAGs get a bonus at short range and a penalty at long range
<span class="nc bnc" id="L1502" title="All 2 branches missed.">            if (linked_ammo == AmmoType.T_HAG) {</span>
<span class="nc" id="L1503">                damage_value = hits_by_racksize[rack_size];</span>
<span class="nc" id="L1504">                raw_damage_array[0] = damage_value * 1.2;</span>
<span class="nc" id="L1505">                raw_damage_array[1] = damage_value * 1.2;</span>
<span class="nc" id="L1506">                raw_damage_array[2] = damage_value;</span>
<span class="nc" id="L1507">                raw_damage_array[3] = damage_value * 0.8;</span>
            }

            // LBX cannons are assumed to be firing cluster rounds.
            // TODO: extend ammo bin check from MMLs &amp; ATMs
<span class="nc bnc" id="L1512" title="All 4 branches missed.">            if ((linked_ammo == AmmoType.T_AC_LBX)</span>
                    || (linked_ammo == AmmoType.T_AC_LBX_THB)) {
<span class="nc" id="L1514">                damage_value = hits_by_racksize[rack_size];</span>

<span class="nc bnc" id="L1516" title="All 2 branches missed.">                for (int i = 0; i &lt; raw_damage_array.length; i++) {</span>
<span class="nc" id="L1517">                    raw_damage_array[i] = damage_value;</span>
                }
            }

            // Ultra and rotary cannons return damage values properly

<span class="nc bnc" id="L1523" title="All 6 branches missed.">            if ((linked_ammo == AmmoType.T_AC_ULTRA)</span>
                    || (linked_ammo == AmmoType.T_AC_ULTRA_THB)
                    || (linked_ammo == AmmoType.T_AC_ROTARY)) {

<span class="nc" id="L1527">                damage_value *= hits_by_racksize[rack_size];</span>

<span class="nc bnc" id="L1529" title="All 2 branches missed.">                for (int i = 0; i &lt; raw_damage_array.length; i++) {</span>
<span class="nc" id="L1530">                    raw_damage_array[i] = damage_value;</span>
                }
            }

<span class="nc" id="L1534">        } else {</span>

            // Heavy Gauss, Snubnose PPC, variable speed lasers change
            // damage with range
<span class="nc bnc" id="L1538" title="All 6 branches missed.">            if ((wt instanceof ISImpHGaussRifle) || (wt instanceof ISSnubNosePPC)</span>
                    || (wt instanceof VariableSpeedPulseLaserWeapon)) {
<span class="nc" id="L1540">                raw_damage_array[0] = wt.getDamage(wt.getShortRange());</span>
<span class="nc" id="L1541">                raw_damage_array[1] = wt.getDamage(wt.getShortRange());</span>
<span class="nc" id="L1542">                raw_damage_array[2] = wt.getDamage(wt.getMediumRange());</span>
<span class="nc" id="L1543">                raw_damage_array[3] = wt.getDamage(wt.getLongRange());</span>
            }

            // IS plasma rifle
<span class="nc bnc" id="L1547" title="All 2 branches missed.">            if (wt.getInternalName().equals(&quot;ISPlasmaRifle&quot;)) {</span>

<span class="nc" id="L1549">                damage_value = 12.0;</span>

<span class="nc bnc" id="L1551" title="All 2 branches missed.">                for (int i = 0; i &lt; raw_damage_array.length; i++) {</span>
<span class="nc" id="L1552">                    raw_damage_array[i] = damage_value;</span>
                }

            }

            // Clan plasma cannon
<span class="nc bnc" id="L1558" title="All 2 branches missed.">            if (wt.getInternalName().equals(&quot;CLPlasmaCannon&quot;)) {</span>

<span class="nc" id="L1560">                damage_value = 10.5;</span>

<span class="nc bnc" id="L1562" title="All 2 branches missed.">                for (int i = 0; i &lt; raw_damage_array.length; i++) {</span>
<span class="nc" id="L1563">                    raw_damage_array[i] = damage_value;</span>
                }

            }

            // Thunderbolt missiles are half damage inside minimum range
<span class="nc bnc" id="L1569" title="All 2 branches missed.">            if ((wt.getAmmoType() == AmmoType.T_TBOLT_5)</span>
<span class="nc bnc" id="L1570" title="All 2 branches missed.">                    || (wt.getAmmoType() == AmmoType.T_TBOLT_10)</span>
<span class="nc bnc" id="L1571" title="All 2 branches missed.">                    || (wt.getAmmoType() == AmmoType.T_TBOLT_15)</span>
<span class="nc bnc" id="L1572" title="All 2 branches missed.">                    || (wt.getAmmoType() == AmmoType.T_TBOLT_20)) {</span>

<span class="nc bnc" id="L1574" title="All 2 branches missed.">                for (int i = 0; i &lt; raw_damage_array.length; i++) {</span>
<span class="nc" id="L1575">                    raw_damage_array[i] = damage_value;</span>
                }
<span class="nc" id="L1577">                raw_damage_array[0] = damage_value / 2.0;</span>

            }

        }

        // Zero damage is acceptable, but negative damage means
        // something is wrong (typically a variable damage weapon
        // hasn't been handled). Push a line to the log file
        // to help developers and reset the damage value.

<span class="nc bnc" id="L1588" title="All 8 branches missed.">        if ((raw_damage_array[0] &lt; 0) || (raw_damage_array[1] &lt; 0)</span>
                || (raw_damage_array[2] &lt; 0) || (raw_damage_array[3] &lt; 0)) {

<span class="nc" id="L1591">            System.out</span>
<span class="nc" id="L1592">                    .println(&quot;Weapons characterization: negative damage for weapon &quot;</span>
<span class="nc" id="L1593">                            + weapon.getName() + &quot;.&quot;);</span>

<span class="nc" id="L1595">            raw_damage_array[0] = 1.0;</span>
<span class="nc" id="L1596">            raw_damage_array[1] = 1.0;</span>
<span class="nc" id="L1597">            raw_damage_array[2] = 1.0;</span>
<span class="nc" id="L1598">            raw_damage_array[3] = 1.0;</span>

        }

<span class="nc" id="L1602">        return raw_damage_array;</span>
    }

    /**
     * Certain weapons, mostly ATMs and MMLs, can change both range and damage
     * based on what ammo is selected. This will go through the ammo bins that
     * are applicable to the specified weapon and set flags based on whether the
     * ammo is short, medium, or long range. ATMs can set all three; MMLs can
     * only set short and long range flags.
     *
     * @param weapon
     *            weapon being checked
     * @param ammo_list
     *            ArrayList of Mounted returned by Entity.getAmmo()
     * @return 3-element array indicating short/medium/long ranges available
     */

    private static boolean[] getAmmoRanges(WeaponType weapon,
            ArrayList&lt;Mounted&gt; ammo_list) {

<span class="nc" id="L1622">        AmmoType bin_type = new AmmoType();</span>
<span class="nc" id="L1623">        int ammo_filter = weapon.getAmmoType();</span>

        // Short, medium, and long range, respectively
<span class="nc" id="L1626">        boolean[] range_flags = { false, false, false };</span>

        // Filter for ATM and MML only. Add more weapons as needed.
<span class="nc bnc" id="L1629" title="All 4 branches missed.">        if ((ammo_filter != AmmoType.T_ATM) &amp;&amp; (ammo_filter != AmmoType.T_MML)) {</span>
<span class="nc" id="L1630">            return range_flags;</span>
        }

        // For each ammo bin
<span class="nc bnc" id="L1634" title="All 2 branches missed.">        for (Mounted ammo_bin : ammo_list) {</span>

            // If all types are accounted for, no point in checking anything
            // else
<span class="nc bnc" id="L1638" title="All 14 branches missed.">            if (((ammo_filter == AmmoType.T_MML) &amp;&amp; range_flags[0] &amp;&amp; range_flags[2])</span>
                    || ((ammo_filter == AmmoType.T_ATM) &amp;&amp; range_flags[0]
                            &amp;&amp; range_flags[1] &amp;&amp; range_flags[2])) {
<span class="nc" id="L1641">                return range_flags;</span>
            }

            // If the bin isn't empty, isn't destroyed, and isn't breached
<span class="nc bnc" id="L1645" title="All 2 branches missed.">            if (ammo_bin.isAmmoUsable()) {</span>

                // If the bin is the correct type for the weapon, and has the
                // proper rack size
<span class="nc" id="L1649">                bin_type = (AmmoType) ammo_bin.getType();</span>
<span class="nc bnc" id="L1650" title="All 2 branches missed.">                if ((bin_type.getAmmoType() == ammo_filter)</span>
<span class="nc bnc" id="L1651" title="All 2 branches missed.">                        &amp;&amp; (bin_type.getRackSize() == weapon.getRackSize())) {</span>

                    // If the weapon is an ATM
<span class="nc bnc" id="L1654" title="All 2 branches missed.">                    if (ammo_filter == AmmoType.T_ATM) {</span>

<span class="nc bnc" id="L1656" title="All 2 branches missed.">                        if (bin_type.getMunitionType() == AmmoType.M_HIGH_EXPLOSIVE) {</span>
<span class="nc" id="L1657">                            range_flags[0] = true;</span>
                        } else {
<span class="nc bnc" id="L1659" title="All 2 branches missed.">                            if (bin_type.getMunitionType() == AmmoType.M_EXTENDED_RANGE) {</span>
<span class="nc" id="L1660">                                range_flags[2] = true;</span>
                            } else {
<span class="nc" id="L1662">                                range_flags[1] = true;</span>
                            }
                        }

                    }

                    // If the weapon is an MML
<span class="nc bnc" id="L1669" title="All 2 branches missed.">                    if (ammo_filter == AmmoType.T_MML) {</span>

                        // Really hate to depend on string comparisons but
                        // nothing else is available
<span class="nc bnc" id="L1673" title="All 2 branches missed.">                        if (bin_type.getShortName().contains(&quot;SRM&quot;)) {</span>
<span class="nc" id="L1674">                            range_flags[0] = true;</span>
                        } else {
<span class="nc bnc" id="L1676" title="All 2 branches missed.">                            if (bin_type.getShortName().contains(&quot;LRM&quot;)</span>
<span class="nc bnc" id="L1677" title="All 2 branches missed.">                                    &amp;&amp; !AmmoType.canDeliverMinefield(bin_type)) {</span>
<span class="nc" id="L1678">                                range_flags[2] = true;</span>
                            }
                        }

                    }

                }

            }

            // Next bin
<span class="nc" id="L1689">        }</span>

<span class="nc" id="L1691">        return range_flags;</span>
    }

    /**
     * Applies to-hit odds for a weapon at each range to raw damage numbers.
     * This provides an estimate of damage under average circumstances.
     *
     * @param weapon
     *            weapon being checked
     * @param gunskill
     *            Gunnery skill of attacker
     * @param raw_damage
     *            damage for min/short/medium/long range
     * @param ammo_ranges
     *            flags for short/medium/long range ammo available
     * @return array with the estimated damage values at each range
     */

    private static double[] getExpectedDamage(WeaponType weapon, int gunskill,
                                              double[] raw_damage, boolean[] ammo_ranges, boolean aptGunnery) {

        // Preset the modified damages
<span class="nc" id="L1713">        double[] modified_damages = new double[MAX_RANGE];</span>

        // Grab the weapon ranges here, outside the range loop
<span class="nc" id="L1716">        int[] range_brackets = new int[5];</span>
<span class="nc" id="L1717">        range_brackets[RANGE_SHORT] = weapon.getShortRange();</span>
<span class="nc" id="L1718">        range_brackets[RANGE_MEDIUM] = weapon.getMediumRange();</span>
<span class="nc" id="L1719">        range_brackets[RANGE_LONG] = weapon.getLongRange();</span>
<span class="nc" id="L1720">        range_brackets[3] = weapon.getExtremeRange();</span>
<span class="nc" id="L1721">        range_brackets[4] = weapon.getMinimumRange();</span>

        // ATM ranges depend on ammo types available. Use the longest range
        // ammo available.
        // TODO: figure out how to get ranges directly from ATM ammo
<span class="nc bnc" id="L1726" title="All 2 branches missed.">        if (weapon.getAmmoType() == AmmoType.T_ATM) {</span>
<span class="nc bnc" id="L1727" title="All 2 branches missed.">            if (ammo_ranges[2]) {</span>

<span class="nc" id="L1729">                range_brackets[RANGE_SHORT] = 9;</span>
<span class="nc" id="L1730">                range_brackets[RANGE_MEDIUM] = 18;</span>
<span class="nc" id="L1731">                range_brackets[RANGE_LONG] = 27;</span>
<span class="nc" id="L1732">                range_brackets[3] = Math.min(36, MAX_RANGE);</span>
<span class="nc bnc" id="L1733" title="All 2 branches missed.">                range_brackets[4] = ammo_ranges[0] ? -1 : 4;</span>

            } else {
<span class="nc bnc" id="L1736" title="All 2 branches missed.">                if (ammo_ranges[1]) {</span>

<span class="nc" id="L1738">                    range_brackets[RANGE_SHORT] = 5;</span>
<span class="nc" id="L1739">                    range_brackets[RANGE_MEDIUM] = 10;</span>
<span class="nc" id="L1740">                    range_brackets[RANGE_LONG] = 15;</span>
<span class="nc" id="L1741">                    range_brackets[3] = 20;</span>
<span class="nc bnc" id="L1742" title="All 2 branches missed.">                    range_brackets[4] = ammo_ranges[0] ? -1 : 4;</span>

                } else {

<span class="nc" id="L1746">                    range_brackets[RANGE_SHORT] = 3;</span>
<span class="nc" id="L1747">                    range_brackets[RANGE_MEDIUM] = 6;</span>
<span class="nc" id="L1748">                    range_brackets[RANGE_LONG] = 9;</span>
<span class="nc" id="L1749">                    range_brackets[3] = 12;</span>
<span class="nc" id="L1750">                    range_brackets[4] = -1;</span>

                }
            }
        }

        // MML ranges depend on ammo types available
        // TODO: figure out how to get ranges directly from MML ammo
<span class="nc bnc" id="L1758" title="All 2 branches missed.">        if (weapon.getAmmoType() == AmmoType.T_MML) {</span>
<span class="nc bnc" id="L1759" title="All 2 branches missed.">            if (ammo_ranges[2]) {</span>

                // If LRM ammo is available, use LRM ranges. If SRM ammo
                // is also available it will be used at short range.
<span class="nc" id="L1763">                range_brackets[RANGE_SHORT] = 7;</span>
<span class="nc" id="L1764">                range_brackets[RANGE_MEDIUM] = 14;</span>
<span class="nc" id="L1765">                range_brackets[RANGE_LONG] = 21;</span>
<span class="nc" id="L1766">                range_brackets[3] = 28;</span>
<span class="nc bnc" id="L1767" title="All 2 branches missed.">                range_brackets[4] = ammo_ranges[0] ? -1 : 6;</span>

            } else {
<span class="nc bnc" id="L1770" title="All 2 branches missed.">                if (ammo_ranges[0]) {</span>

                    // If only SRM ammo is available, use SRM ranges
<span class="nc" id="L1773">                    range_brackets[RANGE_SHORT] = 3;</span>
<span class="nc" id="L1774">                    range_brackets[RANGE_MEDIUM] = 6;</span>
<span class="nc" id="L1775">                    range_brackets[RANGE_LONG] = 9;</span>
<span class="nc" id="L1776">                    range_brackets[3] = 12;</span>
<span class="nc" id="L1777">                    range_brackets[4] = -1;</span>

                }
            }
        }

        int total_mod;
<span class="nc" id="L1784">        int weapon_mod = weapon.getToHitModifier();</span>

        // Consider LBX cannons to always be firing cluster rounds
<span class="nc bnc" id="L1787" title="All 2 branches missed.">        if ((weapon.getAmmoType() == AmmoType.T_AC_LBX)</span>
<span class="nc bnc" id="L1788" title="All 2 branches missed.">                || (weapon.getAmmoType() == AmmoType.T_AC_LBX_THB)) {</span>
<span class="nc" id="L1789">            weapon_mod = -1;</span>
        }

        // For each hex of range out to extreme range or the extent of the
        // range array
<span class="nc" id="L1794">        for (int cur_range = 0; (cur_range &lt; MAX_RANGE)</span>
<span class="nc bnc" id="L1795" title="All 4 branches missed.">                &amp;&amp; (cur_range &lt;= range_brackets[3]); cur_range++) {</span>

            // Calculate the total to-hit modifier using the units
            // gunnery skill, the current range, and any weapon-specific
            // modifiers
<span class="nc" id="L1800">            total_mod = gunskill + weapon_mod;</span>
<span class="nc bnc" id="L1801" title="All 2 branches missed.">            if (cur_range &gt; range_brackets[4]) {</span>

<span class="nc bnc" id="L1803" title="All 2 branches missed.">                if (cur_range &gt; range_brackets[RANGE_SHORT]) {</span>
<span class="nc" id="L1804">                    total_mod += 2;</span>
                }
<span class="nc bnc" id="L1806" title="All 2 branches missed.">                if (cur_range &gt; range_brackets[RANGE_MEDIUM]) {</span>
<span class="nc" id="L1807">                    total_mod += 2;</span>
                }
<span class="nc bnc" id="L1809" title="All 2 branches missed.">                if (cur_range &gt; range_brackets[RANGE_LONG]) {</span>
<span class="nc" id="L1810">                    total_mod += 4;</span>
                }

            } else {

                // Inside minimum range
<span class="nc" id="L1816">                total_mod += (1 + range_brackets[4]) - cur_range;</span>
            }

            // Find the odds of hitting a target and apply them to the raw
            // damage
<span class="nc bnc" id="L1821" title="All 2 branches missed.">            if (cur_range &lt;= range_brackets[RANGE_SHORT]) {</span>
<span class="nc bnc" id="L1822" title="All 2 branches missed.">                if (cur_range &gt; range_brackets[4]) {</span>
<span class="nc" id="L1823">                    modified_damages[cur_range] = (raw_damage[1]</span>
<span class="nc" id="L1824">                                                   * Compute.oddsAbove(total_mod, aptGunnery)) / 100;</span>
                } else {
<span class="nc" id="L1826">                    modified_damages[cur_range] = (raw_damage[0]</span>
<span class="nc" id="L1827">                                                   * Compute.oddsAbove(total_mod, aptGunnery)) / 100;</span>
                }
            }
<span class="nc bnc" id="L1830" title="All 2 branches missed.">            if (cur_range &gt; range_brackets[RANGE_SHORT]) {</span>
<span class="nc" id="L1831">                modified_damages[cur_range] = (raw_damage[2]</span>
<span class="nc" id="L1832">                                               * Compute.oddsAbove(total_mod, aptGunnery)) / 100;</span>
            }
<span class="nc bnc" id="L1834" title="All 2 branches missed.">            if (cur_range &gt; range_brackets[RANGE_MEDIUM]) {</span>
<span class="nc" id="L1835">                modified_damages[cur_range] = (raw_damage[3]</span>
<span class="nc" id="L1836">                                               * Compute.oddsAbove(total_mod, aptGunnery)) / 100;</span>
            }

        }

<span class="nc" id="L1841">        return modified_damages;</span>
    }

    /**
     * Applies to-hit odds for a conventional infantry unit at each range to raw
     * damage numbers. This provides an estimate of damage under average
     * circumstances.
     *
     * @param attacker
     *            Infantry unit
     * @param gunskill
     * @return
     */
    private static double[] getExpectedDamage(Infantry attacker, int gunskill) {

<span class="nc" id="L1856">        InfantryWeapon primary_weapon = attacker.getPrimaryWeapon();</span>
<span class="nc" id="L1857">        InfantryWeapon secondary_weapon = attacker.getSecondaryWeapon();</span>

        // Preset the modified damages
<span class="nc" id="L1860">        double raw_damage = 0.0;</span>
<span class="nc" id="L1861">        double[] modified_damages = new double[MAX_RANGE];</span>

        // Base range for conventional infantry weapons
<span class="nc" id="L1864">        int base_range = 0;</span>
        int total_mod;

        // Unarmed infantry unit doesn't do any damage
<span class="nc bnc" id="L1868" title="All 2 branches missed.">        if (null == primary_weapon) {</span>
<span class="nc" id="L1869">            return modified_damages;</span>
        }

        // Base damage for a single trooper. Number of troopers will be
        // accounted for later.
<span class="nc" id="L1874">        raw_damage = attacker.getDamagePerTrooper();</span>

        // If there are two secondary weapons per squad then use that weapons
        // range. Otherwise use the primary weapons range.
<span class="nc bnc" id="L1878" title="All 4 branches missed.">        if ((null != secondary_weapon) &amp;&amp; (attacker.getSecondaryN() &gt;= 2)) {</span>
<span class="nc" id="L1879">            base_range = secondary_weapon.getInfantryRange();</span>
        } else {
<span class="nc" id="L1881">            base_range = primary_weapon.getInfantryRange();</span>
        }
<span class="nc" id="L1883">        for (int cur_range = 0; (cur_range &lt; MAX_RANGE)</span>
<span class="nc bnc" id="L1884" title="All 4 branches missed.">                &amp;&amp; (cur_range &lt;= (base_range * 4)); cur_range++) {</span>

            // Range modifiers are a little screwey. This is just a rough
            // estimate.
<span class="nc" id="L1888">            total_mod = gunskill;</span>
<span class="nc bnc" id="L1889" title="All 2 branches missed.">            if (cur_range == 0) {</span>
<span class="nc bnc" id="L1890" title="All 4 branches missed.">                if ((base_range &gt; 0) &amp;&amp; (base_range &lt;= 4)) {</span>
<span class="nc" id="L1891">                    total_mod -= 2;</span>
                }
<span class="nc bnc" id="L1893" title="All 4 branches missed.">                if ((base_range &gt; 0) &amp;&amp; (base_range &gt; 4)) {</span>
<span class="nc" id="L1894">                    total_mod -= 1;</span>
                }
            }
<span class="nc bnc" id="L1897" title="All 2 branches missed.">            if (cur_range &gt; base_range) {</span>
<span class="nc" id="L1898">                total_mod += 2;</span>
            }
<span class="nc bnc" id="L1900" title="All 2 branches missed.">            if (cur_range &gt; (base_range * 2)) {</span>
<span class="nc" id="L1901">                total_mod += 2;</span>
            }
<span class="nc bnc" id="L1903" title="All 2 branches missed.">            if (cur_range &gt; (base_range * 3)) {</span>
<span class="nc" id="L1904">                total_mod += 4;</span>
            }

<span class="nc" id="L1907">            boolean aptGunnery = attacker.hasAbility(OptionsConstants.PILOT_APTITUDE_GUNNERY);</span>
<span class="nc" id="L1908">            modified_damages[cur_range] = (raw_damage</span>
<span class="nc" id="L1909">                                           * Compute.oddsAbove(total_mod, aptGunnery)) / 100.0;</span>

        }

<span class="nc" id="L1913">        return modified_damages;</span>
    }

    public static int getFiringAngle(final Coords dest, int dest_facing,
            final Coords src) {
<span class="nc" id="L1918">        int fa = dest.degree(src) - ((dest_facing % 6) * 60);</span>
<span class="nc bnc" id="L1919" title="All 2 branches missed.">        if (fa &lt; 0) {</span>
<span class="nc" id="L1920">            fa += 360;</span>
<span class="nc bnc" id="L1921" title="All 2 branches missed.">        } else if (fa &gt;= 360) {</span>
<span class="nc" id="L1922">            fa -= 360;</span>
        }
<span class="nc" id="L1924">        return fa;</span>
    }

    public static int getThreatHitArc(Coords dest, int dest_facing, Coords src) {
<span class="nc" id="L1928">        int fa = getFiringAngle(dest, dest_facing, src);</span>
<span class="nc bnc" id="L1929" title="All 4 branches missed.">        if ((fa &gt;= 300) || (fa &lt;= 60)) {</span>
<span class="nc" id="L1930">            return ToHitData.SIDE_FRONT;</span>
        }
<span class="nc bnc" id="L1932" title="All 4 branches missed.">        if ((fa &gt;= 60) &amp;&amp; (fa &lt;= 120)) {</span>
<span class="nc" id="L1933">            return ToHitData.SIDE_RIGHT;</span>
        }
<span class="nc bnc" id="L1935" title="All 4 branches missed.">        if ((fa &gt;= 240) &amp;&amp; (fa &lt;= 300)) {</span>
<span class="nc" id="L1936">            return ToHitData.SIDE_LEFT;</span>
        }
<span class="nc" id="L1938">        return ToHitData.SIDE_REAR;</span>
    }

    public static int firingArcToHitArc(int arc) {
<span class="nc bnc" id="L1942" title="All 7 branches missed.">        switch (arc) {</span>
            case Compute.ARC_FORWARD:
<span class="nc" id="L1944">                return ToHitData.SIDE_FRONT;</span>
            case Compute.ARC_LEFTARM:
<span class="nc" id="L1946">                return ToHitData.SIDE_LEFT;</span>
            case Compute.ARC_RIGHTARM:
<span class="nc" id="L1948">                return ToHitData.SIDE_RIGHT;</span>
            case Compute.ARC_REAR:
<span class="nc" id="L1950">                return ToHitData.SIDE_REAR;</span>
            case Compute.ARC_LEFTSIDE:
<span class="nc" id="L1952">                return ToHitData.SIDE_LEFT;</span>
            case Compute.ARC_RIGHTSIDE:
<span class="nc" id="L1954">                return ToHitData.SIDE_RIGHT;</span>
        }
<span class="nc" id="L1956">        return 0;</span>
    }

    @Override
    public boolean equals(Object obj) {
<span class="nc bnc" id="L1961" title="All 2 branches missed.">        if (obj instanceof Entity) {</span>
<span class="nc bnc" id="L1962" title="All 2 branches missed.">            return ((Entity)obj).getId() == entity.getId();</span>
        }
<span class="nc bnc" id="L1964" title="All 2 branches missed.">        if (obj instanceof CEntity) {</span>
<span class="nc bnc" id="L1965" title="All 2 branches missed.">            return ((CEntity)obj).entity.getId() == entity.getId();</span>
        }
<span class="nc" id="L1967">        return false;</span>
    }

    @Override
    public int hashCode() {
<span class="nc" id="L1972">        return entity.getId();</span>
    }

    public TestBot getTb() {
<span class="nc" id="L1976">        return tb;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.4.201905082037</span></div></body></html>