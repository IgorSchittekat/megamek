<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>IAero.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">megamek</a> &gt; <a href="index.source.html" class="el_package">megamek.common</a> &gt; <span class="el_source">IAero.java</span></div><h1>IAero.java</h1><pre class="source lang-java linenums">/*
* MegaMek -
* Copyright (C) 2017 The MegaMek Team
*
* This program is free software; you can redistribute it and/or modify it under
* the terms of the GNU General Public License as published by the Free Software
* Foundation; either version 2 of the License, or (at your option) any later
* version.
*
* This program is distributed in the hope that it will be useful, but WITHOUT
* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
* details.
*/

package megamek.common;

import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.Vector;

import megamek.common.MovePath.MoveStepType;

/**
 * Methods shared by Aero and LandAirMech
 *
 * @author Neoancient
 *
 */
public interface IAero {

    int getCurrentThrust();

    int getCurrentVelocity();

    void setCurrentVelocity(int velocity);

    int getNextVelocity();

    void setNextVelocity(int velocity);

    int getCurrentVelocityActual();

    boolean isVSTOL();

    boolean isSTOL();

    boolean isSpheroid();

    boolean isAirborne();

    boolean isSpaceborne();

    boolean isRolled();

    void setRolled(boolean roll);

    boolean isOutControlTotal();

    boolean isOutControl();

    void setOutControl(boolean ocontrol);

    boolean isOutCtrlHeat();

    void setOutCtrlHeat(boolean octrlheat);

    boolean isRandomMove();

    void setRandomMove(boolean randmove);

    boolean didAccLast();

    void setAccLast(boolean b);

    boolean didFailManeuver();

    void setFailedManeuver(boolean b);

    void setAccDecNow(boolean b);

    boolean didAccDecNow();

    int getStraightMoves();

    void setStraightMoves(int straightMoves);

    int getAltLoss();

    void setAltLoss(int i);

    void resetAltLoss();

    int getAltLossThisRound();

    void setAltLossThisRound(int i);

    public void resetAltLossThisRound();

    int getNoseArmor();

    void setSI(int si);

    int getSI();

    int get0SI();

    int getAvionicsHits();

    int getSensorHits();

    int getFCSHits();

    int getLandingGearPartialRepairs();

    int getAvionicsMisreplaced();

    int getAvionicsMisrepaired();

    default int getClusterMods() {
<span class="nc" id="L123">        return -1 * (getFCSHits() + getSensorHits());</span>
    }

    boolean hasLifeSupport();

    void setGearHit(boolean hit);

    int getLandingGearMod(boolean vTakeoff);

    int getLeftThrustHits();

    int getRightThrustHits();

    int getThresh(int loc);

    boolean wasCritThresh();

    void setCritThresh(boolean b);

    int getFuel();

    void setFuel(int gas);

    int getCurrentFuel();

    void setCurrentFuel(int gas);

    double getFuelPointsPerTon();

    // Capital fighters
    int getCapArmor();

    void setCapArmor(int i);

    int getCap0Armor();

    int getFatalThresh();

    int getCurrentDamage();

    void setCurrentDamage(int i);

    int getHeatSinks();

    void doDisbandDamage();

    void autoSetCapArmor();

    void autoSetFatalThresh();

    /**
     * Iterate through current weapons and count the number in each capital
     * fighter location.
     *
     * @return A map with keys in the format &quot;weaponName:loc&quot;, with the number
     *         of weapons of that type in that location as the value.
     */
    Map&lt;String, Integer&gt; groupWeaponsByLocation();

    Map&lt;String, Integer&gt; getWeaponGroups();

    /**
     * Refresh the capital fighter weapons groups.
     */
    default void updateWeaponGroups() {
        // first we need to reset all the weapons in our existing mounts to zero
        // until proven otherwise
<span class="nc" id="L190">        Set&lt;String&gt; set = getWeaponGroups().keySet();</span>
<span class="nc" id="L191">        Iterator&lt;String&gt; iter = set.iterator();</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">        while (iter.hasNext()) {</span>
<span class="nc" id="L193">            String key = iter.next();</span>
<span class="nc" id="L194">            ((Entity) this).getEquipment(getWeaponGroups().get(key)).setNWeapons(0);</span>
<span class="nc" id="L195">        }</span>
        // now collect a hash of all the same weapons in each location by id
<span class="nc" id="L197">        Map&lt;String, Integer&gt; groups = groupWeaponsByLocation();</span>
        // now we just need to traverse the hash and either update our existing
        // equipment or add new ones if there is none
<span class="nc" id="L200">        Set&lt;String&gt; newSet = groups.keySet();</span>
<span class="nc" id="L201">        Iterator&lt;String&gt; newIter = newSet.iterator();</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">        while (newIter.hasNext()) {</span>
<span class="nc" id="L203">            String key = newIter.next();</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">            if (null != getWeaponGroups().get(key)) {</span>
                // then this equipment is already loaded, so we just need to
                // correctly update the number of weapons
<span class="nc" id="L207">                ((Entity) this).getEquipment(getWeaponGroups().get(key)).setNWeapons(groups.get(key));</span>
            } else {
                // need to add a new weapon
<span class="nc" id="L210">                String name = key.split(&quot;:&quot;)[0];</span>
<span class="nc" id="L211">                int loc = Integer.parseInt(key.split(&quot;:&quot;)[1]);</span>
<span class="nc" id="L212">                EquipmentType etype = EquipmentType.get(name);</span>
                Mounted newmount;
<span class="nc bnc" id="L214" title="All 2 branches missed.">                if (etype != null) {</span>
                    try {
<span class="nc" id="L216">                        newmount = ((Entity) this).addWeaponGroup(etype, loc);</span>
<span class="nc" id="L217">                        newmount.setNWeapons(groups.get(key));</span>
<span class="nc" id="L218">                        getWeaponGroups().put(key, ((Entity) this).getEquipmentNum(newmount));</span>
<span class="nc" id="L219">                    } catch (LocationFullException ex) {</span>
<span class="nc" id="L220">                        System.out.println(&quot;Unable to compile weapon groups&quot;); //$NON-NLS-1$</span>
<span class="nc" id="L221">                        ex.printStackTrace();</span>
<span class="nc" id="L222">                        return;</span>
<span class="nc" id="L223">                    }</span>
<span class="nc bnc" id="L224" title="All 2 branches missed.">                } else if (name != &quot;0&quot;) {</span>
<span class="nc" id="L225">                    ((Entity) this).addFailedEquipment(name);</span>
                }
            }
<span class="nc" id="L228">        }</span>
<span class="nc" id="L229">    }</span>

    /**
     * Set number of fuel points based on fuel tonnage.
     *
     * @param fuelTons
     *            The number of tons of fuel
     */
    void setFuelTonnage(double fuelTons);

    /**
     * Gets the fuel for this Aero in terms of tonnage.
     *
     * @return The number of tons of fuel on this Aero.
     */
    double getFuelTonnage();

    /*
     * Default methods that are implemented the same for Aero and LandAirMech
     */

    default PilotingRollData checkThrustSI(int thrust, EntityMovementType overallMoveType) {
<span class="nc" id="L251">        PilotingRollData roll = ((Entity) this).getBasePilotingRoll(overallMoveType);</span>

<span class="nc bnc" id="L253" title="All 2 branches missed.">        if (thrust &gt; getSI()) {</span>
            // append the reason modifier
<span class="nc" id="L255">            roll.append(new PilotingRollData(((Entity) this).getId(), thrust - getSI(),</span>
                    &quot;Thrust exceeds current SI in a single hex&quot;));
        } else {
<span class="nc" id="L258">            roll.addModifier(TargetRoll.CHECK_FALSE, &quot;Check false: Entity is not exceeding SI&quot;);</span>
        }
<span class="nc" id="L260">        return roll;</span>
    }

    default PilotingRollData checkThrustSITotal(int thrust, EntityMovementType overallMoveType) {
<span class="nc" id="L264">        PilotingRollData roll = ((Entity) this).getBasePilotingRoll(overallMoveType);</span>

<span class="nc bnc" id="L266" title="All 2 branches missed.">        if (thrust &gt; getSI()) {</span>
            // append the reason modifier
<span class="nc" id="L268">            roll.append(new PilotingRollData(((Entity) this).getId(), 0, &quot;Thrust spent this turn exceeds current SI&quot;));</span>
        } else {
<span class="nc" id="L270">            roll.addModifier(TargetRoll.CHECK_FALSE, &quot;Check false: Entity is not exceeding SI&quot;);</span>
        }
<span class="nc" id="L272">        return roll;</span>
    }

    default PilotingRollData checkVelocityDouble(int velocity, EntityMovementType overallMoveType) {
<span class="nc" id="L276">        PilotingRollData roll = ((Entity) this).getBasePilotingRoll(overallMoveType);</span>

<span class="nc bnc" id="L278" title="All 4 branches missed.">        if ((velocity &gt; (2 * ((Entity) this).getWalkMP())) &amp;&amp; !((Entity) this).getGame().getBoard().inSpace()) {</span>
            // append the reason modifier
<span class="nc" id="L280">            roll.append(new PilotingRollData(((Entity) this).getId(), 0, &quot;Velocity greater than 2x safe thrust&quot;));</span>
        } else {
<span class="nc" id="L282">            roll.addModifier(TargetRoll.CHECK_FALSE, &quot;Check false: Entity is not exceeding 2x safe thrust&quot;);</span>
        }
<span class="nc" id="L284">        return roll;</span>
    }

    default PilotingRollData checkDown(int drop, EntityMovementType overallMoveType) {
<span class="nc" id="L288">        PilotingRollData roll = ((Entity) this).getBasePilotingRoll(overallMoveType);</span>

<span class="nc bnc" id="L290" title="All 2 branches missed.">        if (drop &gt; 2) {</span>
            // append the reason modifier
<span class="nc" id="L292">            roll.append(new PilotingRollData(((Entity) this).getId(), drop, &quot;lost more than two altitudes&quot;));</span>
        } else {
<span class="nc" id="L294">            roll.addModifier(TargetRoll.CHECK_FALSE, &quot;Check false: entity did not drop more than two altitudes&quot;);</span>
        }
<span class="nc" id="L296">        return roll;</span>
    }

    default PilotingRollData checkHover(MovePath md) {
<span class="nc" id="L300">        PilotingRollData roll = ((Entity) this).getBasePilotingRoll(md.getLastStepMovementType());</span>

<span class="nc bnc" id="L302" title="All 4 branches missed.">        if (md.contains(MoveStepType.HOVER) &amp;&amp; (md.getLastStepMovementType() == EntityMovementType.MOVE_OVER_THRUST)) {</span>
            // append the reason modifier
<span class="nc" id="L304">            roll.append(new PilotingRollData(((Entity) this).getId(), 0, &quot;hovering above safe thrust&quot;));</span>
        } else {
<span class="nc" id="L306">            roll.addModifier(TargetRoll.CHECK_FALSE, &quot;Check false: entity did not hover&quot;);</span>
        }
<span class="nc" id="L308">        return roll;</span>
    }

    default PilotingRollData checkStall(MovePath md) {
<span class="nc" id="L312">        PilotingRollData roll = ((Entity) this).getBasePilotingRoll(md.getLastStepMovementType());</span>

        // if the entity has already moved, its movement got interrupted (probably by a hidden unit, not much else can interrupt an aero unit)
        // in which case, the movement is complete. We just need to allow the user to hit 'done'.
<span class="nc bnc" id="L316" title="All 2 branches missed.">        if(((Entity) this).delta_distance &gt; 0) {</span>
<span class="nc" id="L317">            roll.addModifier(TargetRoll.CHECK_FALSE, &quot;Check false: aero has already moved&quot;);</span>
        // an airborne, aerodyne aero is considered to &quot;stall&quot; if it's not moving anywhere,
        // hovering, landing, or going off board
<span class="nc bnc" id="L320" title="All 8 branches missed.">        } else if ((md.getFinalVelocity() == 0) &amp;&amp; !md.contains(MoveStepType.HOVER) &amp;&amp; isAirborne() &amp;&amp; !isSpheroid()</span>
<span class="nc bnc" id="L321" title="All 4 branches missed.">                &amp;&amp; !((Entity) this).getGame().getBoard().inSpace() &amp;&amp; !md.contains(MoveStepType.LAND)</span>
<span class="nc bnc" id="L322" title="All 4 branches missed.">                &amp;&amp; !md.contains(MoveStepType.VLAND) &amp;&amp; !md.contains(MoveStepType.RETURN)</span>
<span class="nc bnc" id="L323" title="All 4 branches missed.">                &amp;&amp; !md.contains(MoveStepType.OFF) &amp;&amp; !md.contains(MoveStepType.FLEE)) {</span>
<span class="nc" id="L324">            roll.append(new PilotingRollData(((Entity) this).getId(), 0, &quot;stalled out&quot;));</span>
        } else {
<span class="nc" id="L326">            roll.addModifier(TargetRoll.CHECK_FALSE, &quot;Check false: entity not stalled out&quot;);</span>
        }
<span class="nc" id="L328">        return roll;</span>
    }

    default PilotingRollData checkRolls(MoveStep step, EntityMovementType overallMoveType) {
<span class="nc" id="L332">        PilotingRollData roll = ((Entity) this).getBasePilotingRoll(overallMoveType);</span>

<span class="nc bnc" id="L334" title="All 6 branches missed.">        if (((step.getType() == MoveStepType.ROLL) || (step.getType() == MoveStepType.YAW)) &amp;&amp; (step.getNRolls() &gt; 1)) {</span>
            // append the reason modifier
<span class="nc" id="L336">            roll.append(new PilotingRollData(((Entity) this).getId(), 0, &quot;More than one roll in the same turn&quot;));</span>
        } else {
<span class="nc" id="L338">            roll.addModifier(TargetRoll.CHECK_FALSE, &quot;Check false: Entity is not rolling more than once&quot;);</span>
        }
<span class="nc" id="L340">        return roll;</span>
    }

    default PilotingRollData checkVerticalTakeOff() {
<span class="nc" id="L344">        PilotingRollData roll = ((Entity) this).getBasePilotingRoll(EntityMovementType.MOVE_SAFE_THRUST);</span>

<span class="nc bnc" id="L346" title="All 2 branches missed.">        if (getLandingGearMod(true) &gt; 0) {</span>
<span class="nc" id="L347">            roll.addModifier(+1, &quot;landing gear damaged&quot;);</span>
        }

<span class="nc bnc" id="L350" title="All 2 branches missed.">        if (getLeftThrustHits() + getRightThrustHits() &gt; 0) {</span>
<span class="nc" id="L351">            roll.addModifier(+3, &quot;Maneuvering thrusters damaged&quot;);</span>
        }

        // Supposed to be -1 for lifting off from an &quot;airfield or landing pad.&quot;
        // We will just treat this as having paved terrain
<span class="nc" id="L356">        Coords pos = ((Entity) this).getPosition();</span>
<span class="nc" id="L357">        IHex hex = ((Entity) this).getGame().getBoard().getHex(pos);</span>
<span class="nc bnc" id="L358" title="All 6 branches missed.">        if ((null != hex) &amp;&amp; hex.containsTerrain(Terrains.PAVEMENT) &amp;&amp; !hex.containsTerrain(Terrains.RUBBLE)) {</span>
<span class="nc" id="L359">            roll.addModifier(-1, &quot;on landing pad&quot;);</span>
        }

<span class="nc bnc" id="L362" title="All 2 branches missed.">        if (!(this instanceof SmallCraft)) {</span>
<span class="nc" id="L363">            roll.addModifier(+2, &quot;Fighter making vertical liftoff&quot;);</span>
        }

        // Taking off from a crater
        // TW doesn't define what a crater is, assume it means that the hex
        // level of all surrounding hexes is greater than what we are sitting on
<span class="nc" id="L369">        boolean allAdjacentHigher = true;</span>
<span class="nc" id="L370">        Set&lt;Coords&gt; positions = new HashSet&lt;Coords&gt;(((Entity) this).getSecondaryPositions().values());</span>
<span class="nc" id="L371">        positions.add(pos);</span>
        IHex adjHex;
<span class="nc bnc" id="L373" title="All 2 branches missed.">        for (Coords currPos : positions) {</span>
<span class="nc" id="L374">            hex = ((Entity) this).getGame().getBoard().getHex(currPos);</span>
<span class="nc bnc" id="L375" title="All 2 branches missed.">            for (int dir = 0; dir &lt; 6; dir++) {</span>
<span class="nc" id="L376">                Coords adj = currPos.translated(dir);</span>
<span class="nc" id="L377">                adjHex = ((Entity) this).getGame().getBoard().getHex(adj);</span>
<span class="nc bnc" id="L378" title="All 6 branches missed.">                if (!positions.contains(adj) &amp;&amp; (adjHex != null) &amp;&amp; adjHex.getLevel() &lt;= hex.getLevel()) {</span>
<span class="nc" id="L379">                    allAdjacentHigher = false;</span>
<span class="nc" id="L380">                    break;</span>
                }
            }
<span class="nc bnc" id="L383" title="All 2 branches missed.">            if (!allAdjacentHigher) {</span>
<span class="nc" id="L384">                break;</span>
            }
<span class="nc" id="L386">        }</span>
<span class="nc bnc" id="L387" title="All 2 branches missed.">        if (allAdjacentHigher) {</span>
<span class="nc" id="L388">            roll.addModifier(+3, &quot;Taking off from crater&quot;);</span>
        }

<span class="nc" id="L391">        return roll;</span>
    }

    /**
     * Compute the PilotingRollData for a landing control roll (see TW pg 86).
     *
     * @param moveType
     * @param velocity
     *            Velocity when the check is to be made, this needs to be passed
     *            as the check could happen as part of a Move Path
     * @param landingPos
     *            The final position the Aero will land on.
     * @param isVertical
     *            If this a vertical or horizontal landing
     * @return A PilotingRollData tha represents the landing control roll that
     *         must be passed
     */
    default PilotingRollData checkLanding(EntityMovementType moveType, int velocity, Coords landingPos, int face,
            boolean isVertical) {
        // Base piloting skill
<span class="nc" id="L411">        PilotingRollData roll = new PilotingRollData(((Entity) this).getId(), ((Entity) this).getCrew().getPiloting(),</span>
                &quot;Base piloting skill&quot;);

        // Apply critical hit effects, TW pg 239
<span class="nc" id="L415">        int avihits = getAvionicsHits();</span>
<span class="nc bnc" id="L416" title="All 4 branches missed.">        if ((avihits &gt; 0) &amp;&amp; (avihits &lt; 3)) {</span>
<span class="nc" id="L417">            roll.addModifier(avihits, &quot;Avionics Damage&quot;);</span>
        }

        // this should probably be replaced with some kind of AVI_DESTROYED
        // boolean
<span class="nc bnc" id="L422" title="All 2 branches missed.">        if (avihits &gt;= 3) {</span>
<span class="nc" id="L423">            roll.addModifier(5, &quot;Avionics Destroyed&quot;);</span>
        }

<span class="nc bnc" id="L426" title="All 2 branches missed.">        if (!hasLifeSupport()) {</span>
<span class="nc" id="L427">            roll.addModifier(+2, &quot;No life support&quot;);</span>
        }

        // Landing Gear Partial Repairs, only apply if the landing gear isn't currently damaged
<span class="nc bnc" id="L431" title="All 2 branches missed.">        if (getLandingGearMod(false) == 0) {</span>
<span class="nc bnc" id="L432" title="All 2 branches missed.">        	if (getLandingGearPartialRepairs() == 2) {</span>
<span class="nc" id="L433">            roll.addModifier(getLandingGearPartialRepairs(), &quot;landing gear misrepaired&quot;);</span>
<span class="nc bnc" id="L434" title="All 2 branches missed.">        	} else if (getLandingGearPartialRepairs() == 1) {</span>
<span class="nc" id="L435">            roll.addModifier(getLandingGearPartialRepairs(), &quot;landing gear misreplaced&quot;);</span>
        	}
    	}

        //Avionics Partial Repairs, only apply if the Avionics package isn't destroyed
<span class="nc bnc" id="L440" title="All 2 branches missed.">        if (avihits &lt; 3) {</span>
<span class="nc bnc" id="L441" title="All 2 branches missed.">        	if (getAvionicsMisrepaired() == 1) {</span>
<span class="nc" id="L442">        	roll.addModifier(1, &quot;misrepaired avionics&quot;);</span>
<span class="nc bnc" id="L443" title="All 2 branches missed.">        	} if (getAvionicsMisreplaced() == 1) {</span>
<span class="nc" id="L444">            roll.addModifier(1, &quot;misreplaced avionics&quot;);</span>
        	}
        }
        // Landing Modifiers table, TW pg 86
        int velmod;
<span class="nc bnc" id="L449" title="All 2 branches missed.">        if (isVertical) {</span>
<span class="nc" id="L450">            velmod = Math.max(0, velocity - 1);</span>
        } else {
<span class="nc" id="L452">            velmod = Math.max(0, velocity - 2);</span>
        }
<span class="nc bnc" id="L454" title="All 2 branches missed.">        if (velmod &gt; 0) {</span>
<span class="nc" id="L455">            roll.addModifier(velmod, &quot;excess velocity&quot;);</span>
        }
<span class="nc bnc" id="L457" title="All 2 branches missed.">        if (getLeftThrustHits() + getRightThrustHits() &gt; 0) {</span>
<span class="nc" id="L458">            roll.addModifier(+4, &quot;Maneuvering thrusters damaged&quot;);</span>
        }
<span class="nc bnc" id="L460" title="All 2 branches missed.">        if (getLandingGearMod(false) &gt; 0) {</span>
<span class="nc" id="L461">            roll.addModifier(getLandingGearMod(false), &quot;landing gear damaged&quot;);</span>
        }
<span class="nc bnc" id="L463" title="All 2 branches missed.">        if (getNoseArmor() &lt;= 0) {</span>
<span class="nc" id="L464">            roll.addModifier(+2, &quot;nose armor destroyed&quot;);</span>
        }
        // Unit reduced to 50% or less of starting thrust
<span class="nc" id="L467">        double thrustPercent = ((double) ((Entity) this).getWalkMP()) / ((Entity) this).getOriginalWalkMP();</span>
<span class="nc bnc" id="L468" title="All 2 branches missed.">        if (thrustPercent &lt;= .5) {</span>
<span class="nc" id="L469">            roll.addModifier(+2, &quot;thrust reduced to 50% or less of original&quot;);</span>
        }
<span class="nc bnc" id="L471" title="All 2 branches missed.">        if (getCurrentThrust() &lt;= 0) {</span>
<span class="nc bnc" id="L472" title="All 2 branches missed.">            if (isSpheroid()) {</span>
<span class="nc" id="L473">                roll.addModifier(+8, &quot;no thrust&quot;);</span>
            } else {
<span class="nc" id="L475">                roll.addModifier(+4, &quot;no thrust&quot;);</span>
            }
        }
        // terrain mods
<span class="nc" id="L479">        boolean lightWoods = false;</span>
<span class="nc" id="L480">        boolean rough = false;</span>
<span class="nc" id="L481">        boolean heavyWoods = false;</span>
<span class="nc" id="L482">        boolean clear = false;</span>
<span class="nc" id="L483">        boolean paved = true;</span>

<span class="nc" id="L485">        Set&lt;Coords&gt; landingPositions = new HashSet&lt;Coords&gt;();</span>
<span class="nc" id="L486">        boolean isDropship = (this instanceof Dropship);</span>
        // Vertical landing just checks the landing hex
<span class="nc bnc" id="L488" title="All 2 branches missed.">        if (isVertical) {</span>
<span class="nc" id="L489">            landingPositions.add(landingPos);</span>
            // Dropships must also check the adjacent 6 hexes
<span class="nc bnc" id="L491" title="All 2 branches missed.">            if (isDropship) {</span>
<span class="nc bnc" id="L492" title="All 2 branches missed.">                for (int i = 0; i &lt; 6; i++) {</span>
<span class="nc" id="L493">                    landingPositions.add(landingPos.translated(i));</span>
                }
            }
            // Horizontal landing requires checking whole landing strip
        } else {
<span class="nc bnc" id="L498" title="All 2 branches missed.">            for (int i = 0; i &lt; getLandingLength(); i++) {</span>
<span class="nc" id="L499">                Coords pos = landingPos.translated(face, i);</span>
<span class="nc" id="L500">                landingPositions.add(pos);</span>
                // Dropships have to check the front adjacent hexes
<span class="nc bnc" id="L502" title="All 2 branches missed.">                if (isDropship) {</span>
<span class="nc" id="L503">                    landingPositions.add(pos.translated((face + 4) % 6));</span>
<span class="nc" id="L504">                    landingPositions.add(pos.translated((face + 2) % 6));</span>
                }
            }
        }

<span class="nc bnc" id="L509" title="All 2 branches missed.">        for (Coords pos : landingPositions) {</span>
<span class="nc" id="L510">            IHex hex = ((Entity) this).getGame().getBoard().getHex(pos);</span>
<span class="nc bnc" id="L511" title="All 4 branches missed.">            if (hex.containsTerrain(Terrains.ROUGH) || hex.containsTerrain(Terrains.RUBBLE)) {</span>
<span class="nc" id="L512">                rough = true;</span>
<span class="nc bnc" id="L513" title="All 2 branches missed.">            } else if (hex.containsTerrain(Terrains.WOODS, 2)) {</span>
<span class="nc" id="L514">                heavyWoods = true;</span>
<span class="nc bnc" id="L515" title="All 2 branches missed.">            } else if (hex.containsTerrain(Terrains.WOODS, 1)) {</span>
<span class="nc" id="L516">                lightWoods = true;</span>
<span class="nc bnc" id="L517" title="All 4 branches missed.">            } else if (!hex.containsTerrain(Terrains.PAVEMENT) &amp;&amp; !hex.containsTerrain(Terrains.ROAD)) {</span>
<span class="nc" id="L518">                paved = false;</span>
                // Landing in other terrains isn't allowed, so if we reach here
                // it must be a clear hex
<span class="nc" id="L521">                clear = true;</span>
            }
<span class="nc" id="L523">        }</span>

<span class="nc bnc" id="L525" title="All 2 branches missed.">        if (heavyWoods) {</span>
<span class="nc" id="L526">            roll.addModifier(+5, &quot;heavy woods in landing path&quot;);</span>
        }
<span class="nc bnc" id="L528" title="All 2 branches missed.">        if (lightWoods) {</span>
<span class="nc" id="L529">            roll.addModifier(+4, &quot;light woods in landing path&quot;);</span>
        }
<span class="nc bnc" id="L531" title="All 2 branches missed.">        if (rough) {</span>
<span class="nc" id="L532">            roll.addModifier(+3, &quot;rough/rubble in landing path&quot;);</span>
        }
<span class="nc bnc" id="L534" title="All 2 branches missed.">        if (paved) {</span>
<span class="nc" id="L535">            roll.addModifier(+0, &quot;paved/road landing strip&quot;);</span>
        }
<span class="nc bnc" id="L537" title="All 2 branches missed.">        if (clear) {</span>
<span class="nc" id="L538">            roll.addModifier(+2, &quot;clear hex in landing path&quot;);</span>
        }

<span class="nc" id="L541">        return roll;</span>
    }

    /**
     * Checks if a maneuver requires a control roll
     */
    default PilotingRollData checkManeuver(MoveStep step, EntityMovementType overallMoveType) {
<span class="nc" id="L548">        PilotingRollData roll = ((Entity) this).getBasePilotingRoll(overallMoveType);</span>

<span class="nc bnc" id="L550" title="All 4 branches missed.">        if ((step == null) || (step.getType() != MoveStepType.MANEUVER)) {</span>
<span class="nc" id="L551">            roll.addModifier(TargetRoll.CHECK_FALSE, &quot;Check false: Entity is not attempting to get up.&quot;);</span>
<span class="nc" id="L552">            return roll;</span>
        }
<span class="nc bnc" id="L554" title="All 4 branches missed.">        boolean sideSlipMod = (this instanceof ConvFighter) &amp;&amp; isVSTOL();</span>
<span class="nc" id="L555">        roll.append(</span>
<span class="nc" id="L556">                new PilotingRollData(((Entity) this).getId(), ManeuverType.getMod(step.getManeuverType(), sideSlipMod),</span>
<span class="nc" id="L557">                        ManeuverType.getTypeName(step.getManeuverType()) + &quot; maneuver&quot;));</span>

<span class="nc" id="L559">        return roll;</span>

    }

    /**
     * switches certain arcs due to rolling
     */
    default int rollArcs(int arc) {
<span class="nc bnc" id="L567" title="All 2 branches missed.">        if (isRolled()) {</span>
<span class="nc bnc" id="L568" title="All 2 branches missed.">            if (arc == Compute.ARC_LWING) {</span>
<span class="nc" id="L569">                return Compute.ARC_RWING;</span>
<span class="nc bnc" id="L570" title="All 2 branches missed.">            } else if (arc == Compute.ARC_RWING) {</span>
<span class="nc" id="L571">                return Compute.ARC_LWING;</span>
<span class="nc bnc" id="L572" title="All 2 branches missed.">            } else if (arc == Compute.ARC_LWINGA) {</span>
<span class="nc" id="L573">                return Compute.ARC_RWINGA;</span>
<span class="nc bnc" id="L574" title="All 2 branches missed.">            } else if (arc == Compute.ARC_RWINGA) {</span>
<span class="nc" id="L575">                return Compute.ARC_LWINGA;</span>
<span class="nc bnc" id="L576" title="All 2 branches missed.">            } else if (arc == Compute.ARC_LEFTSIDE_SPHERE) {</span>
<span class="nc" id="L577">                return Compute.ARC_RIGHTSIDE_SPHERE;</span>
<span class="nc bnc" id="L578" title="All 2 branches missed.">            } else if (arc == Compute.ARC_RIGHTSIDE_SPHERE) {</span>
<span class="nc" id="L579">                return Compute.ARC_LEFTSIDE_SPHERE;</span>
<span class="nc bnc" id="L580" title="All 2 branches missed.">            } else if (arc == Compute.ARC_LEFTSIDEA_SPHERE) {</span>
<span class="nc" id="L581">                return Compute.ARC_RIGHTSIDEA_SPHERE;</span>
<span class="nc bnc" id="L582" title="All 2 branches missed.">            } else if (arc == Compute.ARC_RIGHTSIDEA_SPHERE) {</span>
<span class="nc" id="L583">                return Compute.ARC_LEFTSIDEA_SPHERE;</span>
<span class="nc bnc" id="L584" title="All 2 branches missed.">            } else if (arc == Compute.ARC_LEFT_BROADSIDE) {</span>
<span class="nc" id="L585">                return Compute.ARC_RIGHT_BROADSIDE;</span>
<span class="nc bnc" id="L586" title="All 2 branches missed.">            } else if (arc == Compute.ARC_RIGHT_BROADSIDE) {</span>
<span class="nc" id="L587">                return Compute.ARC_LEFT_BROADSIDE;</span>
            }
        }
<span class="nc" id="L590">        return arc;</span>
    }

    default int getTakeOffLength() {
<span class="nc bnc" id="L594" title="All 4 branches missed.">        if (isVSTOL() || isSTOL()) {</span>
<span class="nc" id="L595">            return 10;</span>
        }
<span class="nc" id="L597">        return 20;</span>
    }

    default int getLandingLength() {
<span class="nc bnc" id="L601" title="All 4 branches missed.">        if (isVSTOL() || isSTOL()) {</span>
<span class="nc" id="L602">            return 5;</span>
        }
<span class="nc" id="L604">        return 8;</span>
    }

    default boolean canTakeOffHorizontally() {
<span class="nc bnc" id="L608" title="All 4 branches missed.">        return !isSpheroid() &amp;&amp; (getCurrentThrust() &gt; 0);</span>
    }

    default boolean canLandHorizontally() {
<span class="nc bnc" id="L612" title="All 2 branches missed.">        return !isSpheroid();</span>
    }

    default boolean canTakeOffVertically() {
<span class="nc bnc" id="L616" title="All 6 branches missed.">        return (isVSTOL() || isSpheroid()) &amp;&amp; (getCurrentThrust() &gt; 2);</span>
    }

    default boolean canLandVertically() {
<span class="nc bnc" id="L620" title="All 4 branches missed.">        return (isVSTOL() || isSpheroid());</span>
    }

    default String hasRoomForHorizontalTakeOff() {
        // walk along the hexes in the facing of the unit
<span class="nc" id="L625">        IHex hex = ((Entity) this).getGame().getBoard().getHex(((Entity) this).getPosition());</span>
<span class="nc" id="L626">        int elev = hex.getLevel();</span>
<span class="nc" id="L627">        int facing = ((Entity) this).getFacing();</span>
<span class="nc" id="L628">        String lenString = &quot; (&quot; + getTakeOffLength() + &quot; hexes required)&quot;;</span>
        // dropships need a strip three hexes wide
<span class="nc" id="L630">        Vector&lt;Coords&gt; startingPos = new Vector&lt;Coords&gt;();</span>
<span class="nc" id="L631">        startingPos.add(((Entity) this).getPosition());</span>
<span class="nc bnc" id="L632" title="All 2 branches missed.">        if (((Entity) this) instanceof Dropship) {</span>
<span class="nc" id="L633">            startingPos.add(((Entity) this).getPosition().translated((facing + 4) % 6));</span>
<span class="nc" id="L634">            startingPos.add(((Entity) this).getPosition().translated((facing + 2) % 6));</span>
        }
<span class="nc bnc" id="L636" title="All 2 branches missed.">        for (Coords pos : startingPos) {</span>
<span class="nc bnc" id="L637" title="All 2 branches missed.">            for (int i = 0; i &lt; getTakeOffLength(); i++) {</span>
<span class="nc" id="L638">                pos = pos.translated(facing);</span>
                // check for buildings
<span class="nc bnc" id="L640" title="All 2 branches missed.">                if (((Entity) this).getGame().getBoard().getBuildingAt(pos) != null) {</span>
<span class="nc" id="L641">                    return &quot;Buildings in the way&quot; + lenString;</span>
                }
                // no units in the way
<span class="nc bnc" id="L644" title="All 2 branches missed.">                for (Entity en : ((Entity) this).getGame().getEntitiesVector(pos)) {</span>
<span class="nc bnc" id="L645" title="All 2 branches missed.">                    if (en.equals((Entity) this)) {</span>
<span class="nc" id="L646">                        continue;</span>
                    }
<span class="nc bnc" id="L648" title="All 2 branches missed.">                    if (!en.isAirborne()) {</span>
<span class="nc" id="L649">                        return &quot;Ground units in the way&quot; + lenString;</span>
                    }
<span class="nc" id="L651">                }</span>
<span class="nc" id="L652">                hex = ((Entity) this).getGame().getBoard().getHex(pos);</span>
                // if the hex is null, then we are offboard. Don't let units
                // take off offboard.
<span class="nc bnc" id="L655" title="All 2 branches missed.">                if (null == hex) {</span>
<span class="nc" id="L656">                    return &quot;Not enough room on map&quot; + lenString;</span>
                }
<span class="nc bnc" id="L658" title="All 2 branches missed.">                if (!hex.isClearForTakeoff()) {</span>
<span class="nc" id="L659">                    return &quot;Unacceptable terrain for landing&quot; + lenString;</span>
                }
<span class="nc bnc" id="L661" title="All 2 branches missed.">                if (hex.getLevel() != elev) {</span>
<span class="nc" id="L662">                    return &quot;Runway must contain no elevation change&quot; + lenString;</span>
                }
            }
<span class="nc" id="L665">        }</span>

<span class="nc" id="L667">        return null;</span>
    }

    default String hasRoomForHorizontalLanding() {
        // walk along the hexes in the facing of the unit
<span class="nc" id="L672">        IHex hex = ((Entity) this).getGame().getBoard().getHex(((Entity) this).getPosition());</span>
<span class="nc" id="L673">        int elev = hex.getLevel();</span>
<span class="nc" id="L674">        int facing = ((Entity) this).getFacing();</span>
<span class="nc" id="L675">        String lenString = &quot; (&quot; + getLandingLength() + &quot; hexes required)&quot;;</span>
        // dropships need a a landing strip three hexes wide
<span class="nc" id="L677">        Vector&lt;Coords&gt; startingPos = new Vector&lt;Coords&gt;();</span>
<span class="nc" id="L678">        startingPos.add(((Entity) this).getPosition());</span>
<span class="nc bnc" id="L679" title="All 2 branches missed.">        if (this instanceof Dropship) {</span>
<span class="nc" id="L680">            startingPos.add(((Entity) this).getPosition().translated((facing + 5) % 6));</span>
<span class="nc" id="L681">            startingPos.add(((Entity) this).getPosition().translated((facing + 1) % 6));</span>
        }
<span class="nc bnc" id="L683" title="All 2 branches missed.">        for (Coords pos : startingPos) {</span>
<span class="nc bnc" id="L684" title="All 2 branches missed.">            for (int i = 0; i &lt; getLandingLength(); i++) {</span>
<span class="nc" id="L685">                pos = pos.translated(facing);</span>
                // check for buildings
<span class="nc bnc" id="L687" title="All 2 branches missed.">                if (((Entity) this).getGame().getBoard().getBuildingAt(pos) != null) {</span>
<span class="nc" id="L688">                    return &quot;Buildings in the way&quot; + lenString;</span>
                }
                // no units in the way
<span class="nc bnc" id="L691" title="All 2 branches missed.">                for (Entity en : ((Entity) this).getGame().getEntitiesVector(pos)) {</span>
<span class="nc bnc" id="L692" title="All 2 branches missed.">                    if (!en.isAirborne()) {</span>
<span class="nc" id="L693">                        return &quot;Ground units in the way&quot; + lenString;</span>
                    }
<span class="nc" id="L695">                }</span>
<span class="nc" id="L696">                hex = ((Entity) this).getGame().getBoard().getHex(pos);</span>
                // if the hex is null, then we are offboard. Don't let units
                // land offboard.
<span class="nc bnc" id="L699" title="All 2 branches missed.">                if (null == hex) {</span>
<span class="nc" id="L700">                    return &quot;Not enough room on map&quot; + lenString;</span>
                }
                // landing must contain only acceptable terrain
<span class="nc bnc" id="L703" title="All 2 branches missed.">                if (!hex.isClearForLanding()) {</span>
<span class="nc" id="L704">                    return &quot;Unacceptable terrain for landing&quot; + lenString;</span>
                }

<span class="nc bnc" id="L707" title="All 2 branches missed.">                if (hex.getLevel() != elev) {</span>
<span class="nc" id="L708">                    return &quot;Landing strip must contain no elevation change&quot; + lenString;</span>
                }
            }
<span class="nc" id="L711">        }</span>
<span class="nc" id="L712">        return null;</span>
    }

    default String hasRoomForVerticalLanding() {
<span class="nc" id="L716">        Coords pos = ((Entity) this).getPosition();</span>
<span class="nc" id="L717">        IHex hex = ((Entity) this).getGame().getBoard().getHex(((Entity) this).getPosition());</span>
<span class="nc bnc" id="L718" title="All 2 branches missed.">        if (((Entity) this).getGame().getBoard().getBuildingAt(pos) != null) {</span>
<span class="nc" id="L719">            return &quot;Buildings in the way&quot;;</span>
        }
        // no units in the way
<span class="nc bnc" id="L722" title="All 2 branches missed.">        for (Entity en : ((Entity) this).getGame().getEntitiesVector(pos)) {</span>
<span class="nc bnc" id="L723" title="All 2 branches missed.">            if (!en.isAirborne()) {</span>
<span class="nc" id="L724">                return &quot;Ground units in the way&quot;;</span>
            }
<span class="nc" id="L726">        }</span>
<span class="nc" id="L727">        hex = ((Entity) this).getGame().getBoard().getHex(pos);</span>
        // if the hex is null, then we are offboard. Don't let units
        // land offboard.
<span class="nc bnc" id="L730" title="All 2 branches missed.">        if (null == hex) {</span>
<span class="nc" id="L731">            return &quot;landing area not on the map&quot;;</span>
        }
        // landing must contain only acceptable terrain
<span class="nc bnc" id="L734" title="All 2 branches missed.">        if (!hex.isClearForLanding()) {</span>
<span class="nc" id="L735">            return &quot;Unacceptable terrain for landing&quot;;</span>
        }

<span class="nc" id="L738">        return null;</span>
    }

    default void liftOff(int altitude) {
<span class="nc bnc" id="L742" title="All 2 branches missed.">        if (isSpheroid()) {</span>
<span class="nc" id="L743">            ((Entity) this).setMovementMode(EntityMovementMode.SPHEROID);</span>
        } else {
<span class="nc" id="L745">            ((Entity) this).setMovementMode(EntityMovementMode.AERODYNE);</span>
        }
<span class="nc" id="L747">        ((Entity) this).setAltitude(altitude);</span>

<span class="nc" id="L749">        HashSet&lt;Coords&gt; positions = ((Entity) this).getOccupiedCoords();</span>
<span class="nc" id="L750">        ((Entity) this).getSecondaryPositions().clear();</span>
<span class="nc bnc" id="L751" title="All 2 branches missed.">        if (((Entity) this).getGame() != null) {</span>
<span class="nc" id="L752">            ((Entity) this).getGame().updateEntityPositionLookup((Entity) this, positions);</span>
        }
<span class="nc" id="L754">    }</span>

    default void land() {
<span class="nc" id="L757">        ((Entity) this).setMovementMode(EntityMovementMode.WHEELED);</span>
<span class="nc" id="L758">        ((Entity) this).setAltitude(0);</span>
<span class="nc" id="L759">        ((Entity) this).setElevation(0);</span>
<span class="nc" id="L760">        setCurrentVelocity(0);</span>
<span class="nc" id="L761">        setNextVelocity(0);</span>
<span class="nc" id="L762">        setOutControl(false);</span>
<span class="nc" id="L763">        setOutCtrlHeat(false);</span>
<span class="nc" id="L764">        setRandomMove(false);</span>
<span class="nc" id="L765">        ((Entity) this).delta_distance = 0;</span>
<span class="nc" id="L766">    }</span>

    default int getFuelUsed(int thrust) {
<span class="nc" id="L769">        int overThrust = Math.max(thrust - ((Entity) this).getWalkMP(), 0);</span>
<span class="nc" id="L770">        int safeThrust = thrust - overThrust;</span>
<span class="nc" id="L771">        int used = safeThrust + (2 * overThrust);</span>
<span class="nc" id="L772">        return used;</span>
    }

    /***
     * use the specified amount of fuel for this Aero. The amount may be
     * adjusted by certain game options
     *
     * @param fuelUsed
     *            The number of fuel points to use
     */
    default void useFuel(int fuelUsed) {
<span class="nc" id="L783">        setCurrentFuel(Math.max(0, getCurrentFuel() - fuelUsed));</span>
<span class="nc" id="L784">    }</span>

    /**
     * A method to add/remove sensors that only work in space as we transition in and out of an atmosphere
     */
    default void updateSensorOptions() {
<span class="nc" id="L790">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.4.201905082037</span></div></body></html>