<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Precognition.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">megamek</a> &gt; <a href="index.source.html" class="el_package">megamek.client.bot.princess</a> &gt; <span class="el_source">Precognition.java</span></div><h1>Precognition.java</h1><pre class="source lang-java linenums">/*
 * MegaMek - Copyright (C) 2000-2011 Ben Mazur (bmazur@sev.org)
 *
 *  This program is free software; you can redistribute it and/or modify it
 *  under the terms of the GNU General Public License as published by the Free
 *  Software Foundation; either version 2 of the License, or (at your option)
 *  any later version.
 *
 *  This program is distributed in the hope that it will be useful, but
 *  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 *  or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 *  for more details.
 */
package megamek.client.bot.princess;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;
import java.util.Vector;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ConcurrentSkipListSet;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

import megamek.client.bot.princess.BotGeometry.CoordFacingCombo;
import megamek.common.Board;
import megamek.common.Building;
import megamek.common.ComputeECM;
import megamek.common.Coords;
import megamek.common.ECMInfo;
import megamek.common.Entity;
import megamek.common.Flare;
import megamek.common.Game;
import megamek.common.GameTurn;
import megamek.common.IGame;
import megamek.common.IHex;
import megamek.common.IPlayer;
import megamek.common.Minefield;
import megamek.common.Mounted;
import megamek.common.PlanetaryConditions;
import megamek.common.Report;
import megamek.common.SpecialHexDisplay;
import megamek.common.TagInfo;
import megamek.common.UnitLocation;
import megamek.common.actions.ArtilleryAttackAction;
import megamek.common.actions.AttackAction;
import megamek.common.actions.ClubAttackAction;
import megamek.common.actions.DodgeAction;
import megamek.common.actions.EntityAction;
import megamek.common.actions.FlipArmsAction;
import megamek.common.actions.TorsoTwistAction;
import megamek.common.actions.WeaponAttackAction;
import megamek.common.event.GameBoardChangeEvent;
import megamek.common.event.GameCFREvent;
import megamek.common.event.GameEntityChangeEvent;
import megamek.common.event.GameEvent;
import megamek.common.event.GameListenerAdapter;
import megamek.common.event.GamePhaseChangeEvent;
import megamek.common.event.GamePlayerChatEvent;
import megamek.common.event.GameSettingsChangeEvent;
import megamek.common.event.GameVictoryEvent;
import megamek.common.net.Packet;
import megamek.common.options.GameOptions;
import megamek.common.preference.PreferenceManager;
import megamek.server.SmokeCloud;

/**
 * unit_potential_locations keeps track of all the potential coordinates and
 * facings a unit could reach It tries to keep all the calculations up to date,
 * and do most of the work when the opponent is moving
 */
<span class="pc bpc" id="L80" title="1 of 2 branches missed.">public class Precognition implements Runnable {</span>

    private final Princess owner;
    
    /**
     *  Precognition's version of the game, which should mirror the game in
     *  Princess, but should not be the same reference.  If Precognition and
     *  Princess share the same game reference, than this will cause concurrency
     *  issues. 
     */
    private IGame game;
<span class="fc" id="L91">    private final ReentrantLock GAME_LOCK = new ReentrantLock();</span>

    /**
     * Computing ECMInfo requires iterating over all Entities in the Game and 
     * this can be an expensive operation, so it's cheaper to use cache it and
     * re-use the cache.
     */
    private List&lt;ECMInfo&gt; ecmInfo;
        
    private PathEnumerator pathEnumerator;
<span class="fc" id="L101">    private final ReentrantReadWriteLock PATH_ENUMERATOR_LOCK = new ReentrantReadWriteLock();</span>


    // units who's path I need to update
<span class="fc" id="L105">    private final ConcurrentSkipListSet&lt;Integer&gt; dirtyUnits = new ConcurrentSkipListSet&lt;&gt;();</span>

    // events that may affect which units are dirty
<span class="fc" id="L108">    private final ConcurrentLinkedQueue&lt;GameEvent&gt; eventsToProcess = new ConcurrentLinkedQueue&lt;&gt;();</span>

<span class="fc" id="L110">    private final AtomicBoolean waitWhenDone = new AtomicBoolean(false); // used for pausing</span>
<span class="fc" id="L111">    private final AtomicBoolean waiting = new AtomicBoolean(false);</span>
<span class="fc" id="L112">    private final AtomicBoolean done = new AtomicBoolean(false);</span>

<span class="fc" id="L114">    public Precognition(Princess owner) {</span>
<span class="fc" id="L115">        this.owner = owner;</span>
<span class="fc" id="L116">        this.game = new Game();</span>
<span class="fc" id="L117">        getGame().addGameListener(new GameListenerAdapter() {</span>
            @Override
            public void gameEntityChange(GameEntityChangeEvent changeEvent) {
<span class="nc" id="L120">                getEventsToProcess().add(changeEvent);</span>
<span class="nc" id="L121">                wakeUp();</span>
<span class="nc" id="L122">            }</span>

            @Override
            public void gamePhaseChange(GamePhaseChangeEvent changeEvent) {
<span class="nc" id="L126">                getEventsToProcess().add(changeEvent);</span>
<span class="nc" id="L127">                wakeUp();</span>
<span class="nc" id="L128">            }</span>
        });
<span class="fc" id="L130">        setPathEnumerator(new PathEnumerator(owner, getGame()));</span>
        // Initialize ECM Info, especially important if Princess added mid-game
<span class="fc" id="L132">        ecmInfo = ComputeECM.computeAllEntitiesECMInfo(</span>
<span class="fc" id="L133">                getGame().getEntitiesVector());</span>
<span class="fc" id="L134">    }</span>
    
    /**
     * Pared down version of Client.handlePacket; essentially it's only looking
     * for packets that update Game.  This ensures that Precognition's Game
     * instance stays up-to-date with Princess's instance of Game.
     * @param c The packet to be handled.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    void handlePacket(Packet c) {
<span class="nc bnc" id="L144" title="All 2 branches missed.">        if (c == null) {</span>
<span class="nc" id="L145">            getOwner().getLogger().warning(&quot;Client: got null packet&quot;);</span>
<span class="nc" id="L146">            return;</span>
        }
        // Game isn't thread safe; other threads shouldn't use  game while
        // it may be being updated
<span class="nc" id="L150">        GAME_LOCK.lock();</span>
        try {
<span class="nc bnc" id="L152" title="All 41 branches missed.">        switch (c.getCommand()) {</span>
            case Packet.COMMAND_PLAYER_UPDATE:
<span class="nc" id="L154">                receivePlayerInfo(c);</span>
<span class="nc" id="L155">                break;</span>
            case Packet.COMMAND_PLAYER_READY:
<span class="nc" id="L157">                getPlayer(c.getIntValue(0)).setDone(c.getBooleanValue(1));</span>
<span class="nc" id="L158">                break;</span>
            case Packet.COMMAND_PLAYER_ADD:
<span class="nc" id="L160">                receivePlayerInfo(c);</span>
<span class="nc" id="L161">                break;</span>
            case Packet.COMMAND_PLAYER_REMOVE:
<span class="nc" id="L163">                getGame().removePlayer(c.getIntValue(0));</span>
<span class="nc" id="L164">                break;</span>
            case Packet.COMMAND_CHAT:
<span class="nc" id="L166">                getGame().processGameEvent(new GamePlayerChatEvent(this, null, </span>
<span class="nc" id="L167">                        (String) c.getObject(0)));</span>
<span class="nc" id="L168">                break;</span>
            case Packet.COMMAND_ENTITY_ADD:
<span class="nc" id="L170">                receiveEntityAdd(c);</span>
<span class="nc" id="L171">                break;</span>
            case Packet.COMMAND_ENTITY_UPDATE:
<span class="nc" id="L173">                receiveEntityUpdate(c);</span>
<span class="nc" id="L174">                break;</span>
            case Packet.COMMAND_ENTITY_REMOVE:
<span class="nc" id="L176">                receiveEntityRemove(c);</span>
<span class="nc" id="L177">                break;</span>
            case Packet.COMMAND_ENTITY_VISIBILITY_INDICATOR:
<span class="nc" id="L179">                receiveEntityVisibilityIndicator(c);</span>
<span class="nc" id="L180">                break;</span>
            case Packet.COMMAND_SENDING_MINEFIELDS:
<span class="nc" id="L182">                receiveSendingMinefields(c);</span>
<span class="nc" id="L183">                break;</span>
            case Packet.COMMAND_SENDING_ILLUM_HEXES:
<span class="nc" id="L185">                receiveIlluminatedHexes(c);</span>
<span class="nc" id="L186">                break;</span>
            case Packet.COMMAND_CLEAR_ILLUM_HEXES:
<span class="nc" id="L188">                getGame().clearIlluminatedPositions();</span>
<span class="nc" id="L189">                break;</span>
            case Packet.COMMAND_UPDATE_MINEFIELDS:
<span class="nc" id="L191">                receiveUpdateMinefields(c);</span>
<span class="nc" id="L192">                break;</span>
            case Packet.COMMAND_DEPLOY_MINEFIELDS:
<span class="nc" id="L194">                receiveDeployMinefields(c);</span>
<span class="nc" id="L195">                break;</span>
            case Packet.COMMAND_REVEAL_MINEFIELD:
<span class="nc" id="L197">                receiveRevealMinefield(c);</span>
<span class="nc" id="L198">                break;</span>
            case Packet.COMMAND_REMOVE_MINEFIELD:
<span class="nc" id="L200">                receiveRemoveMinefield(c);</span>
<span class="nc" id="L201">                break;</span>
            case Packet.COMMAND_ADD_SMOKE_CLOUD:
<span class="nc" id="L203">                SmokeCloud cloud = (SmokeCloud) c.getObject(0);</span>
<span class="nc" id="L204">                getGame().addSmokeCloud(cloud);</span>
<span class="nc" id="L205">                break;</span>
            case Packet.COMMAND_CHANGE_HEX:
<span class="nc" id="L207">                getGame().getBoard().setHex((Coords) c.getObject(0),</span>
<span class="nc" id="L208">                                       (IHex) c.getObject(1));</span>
<span class="nc" id="L209">                break;</span>
            case Packet.COMMAND_CHANGE_HEXES:
<span class="nc" id="L211">                List&lt;Coords&gt; coords = new ArrayList&lt;&gt;(</span>
<span class="nc" id="L212">                        (Set&lt;Coords&gt;) c.getObject(0));</span>
<span class="nc" id="L213">                List&lt;IHex&gt; hexes = new ArrayList&lt;&gt;(</span>
<span class="nc" id="L214">                        (Set&lt;IHex&gt;) c.getObject(1));</span>
<span class="nc" id="L215">                getGame().getBoard().setHexes(coords, hexes);</span>
<span class="nc" id="L216">                break;</span>
            case Packet.COMMAND_BLDG_UPDATE:
<span class="nc" id="L218">                receiveBuildingUpdate(c);</span>
<span class="nc" id="L219">                break;</span>
            case Packet.COMMAND_BLDG_COLLAPSE:
<span class="nc" id="L221">                receiveBuildingCollapse(c);</span>
<span class="nc" id="L222">                break;</span>
            case Packet.COMMAND_PHASE_CHANGE:
<span class="nc" id="L224">                getGame().setPhase((IGame.Phase) c.getObject(0));</span>
<span class="nc" id="L225">                break;</span>
            case Packet.COMMAND_TURN:
<span class="nc" id="L227">                getGame().setTurnIndex(c.getIntValue(0), c.getIntValue(1));</span>
<span class="nc" id="L228">                break;</span>
            case Packet.COMMAND_ROUND_UPDATE:
<span class="nc" id="L230">                getGame().setRoundCount(c.getIntValue(0));</span>
<span class="nc" id="L231">                break;</span>
            case Packet.COMMAND_SENDING_TURNS:
<span class="nc" id="L233">                receiveTurns(c);</span>
<span class="nc" id="L234">                break;</span>
            case Packet.COMMAND_SENDING_BOARD:
<span class="nc" id="L236">                receiveBoard(c);</span>
<span class="nc" id="L237">                break;</span>
            case Packet.COMMAND_SENDING_ENTITIES:
<span class="nc" id="L239">                receiveEntities(c);</span>
<span class="nc" id="L240">                break;</span>
            case Packet.COMMAND_SENDING_REPORTS:
            case Packet.COMMAND_SENDING_REPORTS_TACTICAL_GENIUS:
<span class="nc" id="L243">                getGame().addReports((Vector&lt;Report&gt;) c.getObject(0));</span>
<span class="nc" id="L244">                break;</span>
            case Packet.COMMAND_SENDING_REPORTS_ALL:
<span class="nc" id="L246">                Vector&lt;Vector&lt;Report&gt;&gt; allReports = (Vector&lt;Vector&lt;Report&gt;&gt;) c</span>
<span class="nc" id="L247">                        .getObject(0);</span>
<span class="nc" id="L248">                getGame().setAllReports(allReports);</span>
<span class="nc" id="L249">                break;</span>
            case Packet.COMMAND_ENTITY_ATTACK:
<span class="nc" id="L251">                receiveAttack(c);</span>
<span class="nc" id="L252">                break;</span>
            case Packet.COMMAND_SENDING_GAME_SETTINGS:
<span class="nc" id="L254">                getGame().setOptions((GameOptions) c.getObject(0));</span>
<span class="nc" id="L255">                break;</span>
            case Packet.COMMAND_SENDING_PLANETARY_CONDITIONS:
<span class="nc" id="L257">                getGame().setPlanetaryConditions((PlanetaryConditions) c</span>
<span class="nc" id="L258">                        .getObject(0));</span>
<span class="nc" id="L259">                getGame().processGameEvent(new GameSettingsChangeEvent(this));</span>
<span class="nc" id="L260">                break;</span>
            case Packet.COMMAND_SENDING_TAGINFO:
<span class="nc" id="L262">                Vector&lt;TagInfo&gt; vti = (Vector&lt;TagInfo&gt;) c.getObject(0);</span>
<span class="nc bnc" id="L263" title="All 2 branches missed.">                for (TagInfo ti : vti) {</span>
<span class="nc" id="L264">                    getGame().addTagInfo(ti);</span>
<span class="nc" id="L265">                }</span>
<span class="nc" id="L266">                break;</span>
            case Packet.COMMAND_RESET_TAGINFO:
<span class="nc" id="L268">                getGame().resetTagInfo();</span>
<span class="nc" id="L269">                break;</span>
            case Packet.COMMAND_SENDING_ARTILLERYATTACKS:
<span class="nc" id="L271">                Vector&lt;ArtilleryAttackAction&gt; v = (Vector&lt;ArtilleryAttackAction&gt;) c</span>
<span class="nc" id="L272">                        .getObject(0);</span>
<span class="nc" id="L273">                getGame().setArtilleryVector(v);</span>
<span class="nc" id="L274">                break;</span>
            case Packet.COMMAND_SENDING_FLARES:
<span class="nc" id="L276">                Vector&lt;Flare&gt; v2 = (Vector&lt;Flare&gt;) c.getObject(0);</span>
<span class="nc" id="L277">                getGame().setFlares(v2);</span>
<span class="nc" id="L278">                break;</span>
            case Packet.COMMAND_SENDING_SPECIAL_HEX_DISPLAY:
<span class="nc" id="L280">                getGame().getBoard().setSpecialHexDisplayTable(</span>
                        (Hashtable&lt;Coords, Collection&lt;SpecialHexDisplay&gt;&gt;) c
<span class="nc" id="L282">                                .getObject(0));</span>
<span class="nc" id="L283">                getGame().processGameEvent(new GameBoardChangeEvent(this));</span>
<span class="nc" id="L284">                break;</span>
            case Packet.COMMAND_ENTITY_NOVA_NETWORK_CHANGE:
<span class="nc" id="L286">                receiveEntityNovaNetworkModeChange(c);</span>
<span class="nc" id="L287">                break;</span>
            case Packet.COMMAND_CLIENT_FEEDBACK_REQUEST:
<span class="nc" id="L289">                int cfrType = (int) c.getData()[0];</span>
<span class="nc" id="L290">                GameCFREvent cfrEvt = new GameCFREvent(this, cfrType);</span>
<span class="nc bnc" id="L291" title="All 4 branches missed.">                switch (cfrType) {</span>
                    case (Packet.COMMAND_CFR_DOMINO_EFFECT):
<span class="nc" id="L293">                        cfrEvt.setEntityId((int) c.getData()[1]);</span>
<span class="nc" id="L294">                        break;</span>
                    case Packet.COMMAND_CFR_AMS_ASSIGN:
<span class="nc" id="L296">                        cfrEvt.setEntityId((int) c.getData()[1]);</span>
<span class="nc" id="L297">                        cfrEvt.setAmsEquipNum((int) c.getData()[2]);</span>
<span class="nc" id="L298">                        cfrEvt.setWAAs((List&lt;WeaponAttackAction&gt;) c.getData()[3]);</span>
<span class="nc" id="L299">                        break;</span>
                    case Packet.COMMAND_CFR_APDS_ASSIGN:
<span class="nc" id="L301">                        cfrEvt.setEntityId((int) c.getData()[1]);</span>
<span class="nc" id="L302">                        cfrEvt.setApdsDists((List&lt;Integer&gt;) c.getData()[2]);</span>
<span class="nc" id="L303">                        cfrEvt.setWAAs((List&lt;WeaponAttackAction&gt;) c.getData()[3]);</span>
                        break;
                }
<span class="nc" id="L306">                getGame().processGameEvent(cfrEvt);</span>
<span class="nc" id="L307">                break;</span>
            case Packet.COMMAND_GAME_VICTORY_EVENT:
<span class="nc" id="L309">                GameVictoryEvent gve = new GameVictoryEvent(this, getGame());</span>
<span class="nc" id="L310">                getGame().processGameEvent(gve);</span>
                break;
        }
        } finally {
<span class="nc" id="L314">            GAME_LOCK.unlock();</span>
        }
<span class="nc" id="L316">    }</span>

    private void pause() {
<span class="nc" id="L319">        getOwner().getLogger().methodBegin();</span>

        try {
<span class="nc" id="L322">            getWaitWhenDone().set(true);</span>
<span class="nc bnc" id="L323" title="All 4 branches missed.">            while (!getWaiting().get() &amp;&amp; !getDone().get()) {</span>
                try {
<span class="nc" id="L325">                    Thread.sleep(100);</span>
<span class="nc" id="L326">                } catch (InterruptedException ignored) {</span>
<span class="nc" id="L327">                }</span>
            }
        } finally {
<span class="nc" id="L330">            getOwner().getLogger().methodEnd();</span>
        }
<span class="nc" id="L332">    }</span>

    synchronized void unPause() {
<span class="nc" id="L335">        getOwner().getLogger().methodBegin();</span>

        try {
<span class="nc" id="L338">            getWaitWhenDone().set(false);</span>
<span class="nc" id="L339">            notifyAll();</span>
        } finally {
<span class="nc" id="L341">            getOwner().getLogger().methodEnd();</span>
        }
<span class="nc" id="L343">    }</span>

    /**
     * Tells the thread there's something to do Note, you can't just call
     * notifyAll in the event listener because it doesn't have the thread
     * something something.
     */
    private synchronized void wakeUp() {
<span class="nc" id="L351">        getOwner().getLogger().methodBegin();</span>

        try {
<span class="nc" id="L354">            notifyAll();</span>
        } finally {
<span class="nc" id="L356">            getOwner().getLogger().methodEnd();</span>
        }
<span class="nc" id="L358">    }</span>

    private boolean isEntityOnMap(final Entity entity) {
<span class="nc bnc" id="L361" title="All 4 branches missed.">        return entity.isDeployed() &amp;&amp; !entity.isOffBoard();</span>
    }

    /**
     * Makes sure pathEnumerator has up to date information about other units
     * locations call this right before making a move. automatically pauses.
     */
    void ensureUpToDate() {
<span class="nc" id="L369">        getOwner().getLogger().methodBegin();</span>

        try {
<span class="nc" id="L372">            pause();</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">            for (Entity entity : getGame().getEntitiesVector()) {</span>
                // If Precog is done, just exit
<span class="nc bnc" id="L375" title="All 2 branches missed.">                if (getDone().get()) {</span>
<span class="nc" id="L376">                    return;</span>
                }
<span class="nc bnc" id="L378" title="All 2 branches missed.">                if (!isEntityOnMap(entity)) {</span>
<span class="nc" id="L379">                    continue;</span>
                }
<span class="nc bnc" id="L381" title="All 2 branches missed.">                if (((!getPathEnumerator().getLastKnownLocations().containsKey(entity.getId()))</span>
<span class="nc" id="L382">                     || (!getPathEnumerator().getLastKnownLocations().get(entity.getId())</span>
<span class="nc bnc" id="L383" title="All 2 branches missed.">                                             .equals(CoordFacingCombo.createCoordFacingCombo(entity))))) {</span>
                    // System.err.println(&quot;entity &quot;+entity.getDisplayName()+&quot; not where I left it&quot;);
                    // if(pathEnumerator.last_known_location.containsKey(entity.getId()))
                    // System.err.println(&quot;  I thought it was at &quot;+pathEnumerator.last_known_location.get(entity
                    // .getId()).coords+&quot; but its actually at &quot;+entity.getPosition());
                    // else
                    // System.err.println(&quot;  I had no idea where it was&quot;);
<span class="nc" id="L390">                    dirtifyUnit(entity.getId());</span>
                }
<span class="nc" id="L392">            }</span>
<span class="nc bnc" id="L393" title="All 2 branches missed.">            while (!getDirtyUnits().isEmpty()) {</span>
                // If Precog is done, just exit
<span class="nc bnc" id="L395" title="All 2 branches missed.">                if (getDone().get()) {</span>
<span class="nc" id="L396">                    return;</span>
                }
                
<span class="nc" id="L399">                Integer entityId = getDirtyUnits().pollFirst();</span>
<span class="nc" id="L400">                Entity entity = getGame().getEntity(entityId);</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">                if (entity != null) {</span>
<span class="nc" id="L402">                    getOwner().getLogger().debug(&quot;recalculating paths for &quot; + entity.getDisplayName());</span>
<span class="nc" id="L403">                    getPathEnumerator().recalculateMovesFor(entity);</span>
<span class="nc" id="L404">                    getOwner().getLogger().debug(&quot;finished recalculating paths for &quot; + entity.getDisplayName());</span>
                }
<span class="nc" id="L406">            }</span>
        } finally {
<span class="nc" id="L408">            getOwner().getLogger().methodEnd();</span>
        }
<span class="nc" id="L410">    }</span>

    public void run() {
<span class="fc" id="L413">        getOwner().getLogger().methodBegin();</span>

        try {
            // todo There's probably a better way to handle this than a loop that only exits on an error.
            //noinspection InfiniteLoopStatement
<span class="pc bpc" id="L418" title="1 of 2 branches missed.">            while (!getDone().get()) {</span>
<span class="nc bnc" id="L419" title="All 2 branches missed.">                if (!getEventsToProcess().isEmpty()) {</span>
<span class="nc" id="L420">                    processGameEvents();</span>
<span class="nc" id="L421">                    ecmInfo = ComputeECM.computeAllEntitiesECMInfo(</span>
<span class="nc" id="L422">                            getGame().getEntitiesVector());</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">                } else if (!getDirtyUnits().isEmpty()) {</span>
<span class="nc" id="L424">                    Entity entity = getGame().getEntity(getDirtyUnits().pollFirst());</span>
<span class="nc bnc" id="L425" title="All 4 branches missed.">                    if ((entity != null) &amp;&amp; isEntityOnMap(entity)) {</span>
<span class="nc" id="L426">                        unPause();</span>
<span class="nc" id="L427">                        getOwner().getLogger().debug(&quot;recalculating paths for &quot; + entity.getDisplayName());</span>
<span class="nc" id="L428">                        getPathEnumerator().recalculateMovesFor(entity);</span>
<span class="nc" id="L429">                        getOwner().getLogger().debug(&quot;finished recalculating paths for &quot; + entity.getDisplayName());</span>
                    }
<span class="nc bnc" id="L431" title="All 2 branches missed.">                } else if (getWaitWhenDone().get()) {</span>
<span class="nc" id="L432">                    waitForUnpause(); // paused for a reason</span>
                } else {
<span class="nc" id="L434">                    waitForUnpause(); // idling because there's nothing to do</span>
                }
            }
        } finally {
<span class="nc" id="L438">            getOwner().getLogger().methodEnd();</span>
        }
<span class="nc" id="L440">    }</span>

    void signalDone() {
<span class="nc" id="L443">        getDone().set(true);</span>
<span class="nc" id="L444">    }</span>

    /**
     * Waits until the thread is not paused, and there's indication that it has
     * something to do
     */
    private synchronized void waitForUnpause() {
<span class="fc" id="L451">        getOwner().getLogger().methodBegin();</span>

        try {
<span class="pc bpc" id="L454" title="1 of 2 branches missed.">            while (!getDone().get() &amp;&amp;</span>
<span class="pc bpc" id="L455" title="1 of 2 branches missed.">                   (getWaitWhenDone().get() ||</span>
<span class="pc bpc" id="L456" title="1 of 2 branches missed.">                    (getEventsToProcess().isEmpty() &amp;&amp;</span>
<span class="pc bpc" id="L457" title="1 of 2 branches missed.">                     getDirtyUnits().isEmpty()))) {</span>
<span class="fc" id="L458">                getOwner().getLogger().debug(&quot;waitWhenDone = &quot; + getWaitWhenDone() +</span>
<span class="fc" id="L459">                               &quot; :: eventsToProcess = &quot; + getEventsToProcess().size() +</span>
<span class="fc" id="L460">                               &quot; :: dirtyUnits = &quot; + getDirtyUnits().size());</span>
<span class="fc" id="L461">                getWaiting().set(true);</span>
                try {
<span class="nc" id="L463">                    wait();</span>
<span class="nc" id="L464">                } catch (InterruptedException ignored) {</span>
<span class="nc" id="L465">                }</span>
                // System.err.println(&quot;checking WAIT conditions&quot;);
            }
<span class="nc" id="L468">            getWaiting().set(false);</span>
        } finally {
<span class="nc" id="L470">            getOwner().getLogger().methodEnd();</span>
        }
<span class="nc" id="L472">    }</span>

    /**
     * Process game events that have happened since the thread last checked i.e.
     * if a unit has moved, my precaculated paths are no longer valid
     */
    private void processGameEvents() {
<span class="nc" id="L479">        getOwner().getLogger().methodBegin();</span>

        // We don't want Game to change while this is happening
<span class="nc" id="L482">        GAME_LOCK.lock();</span>
        try {
<span class="nc" id="L484">            LinkedList&lt;GameEvent&gt; eventsToProcessIterator = new LinkedList&lt;&gt;(getEventsToProcess());</span>
<span class="nc" id="L485">            int numEvents = eventsToProcessIterator.size();</span>
<span class="nc bnc" id="L486" title="All 2 branches missed.">            for (int count = 0; count &lt; numEvents; count++) {</span>
<span class="nc" id="L487">                getOwner().getLogger().debug(&quot;Processing event &quot; + (count + 1) + &quot; out of &quot; + numEvents);</span>
<span class="nc" id="L488">                GameEvent event = eventsToProcessIterator.get(count);</span>
<span class="nc bnc" id="L489" title="All 2 branches missed.">                if (event == null) {</span>
<span class="nc" id="L490">                    continue;</span>
                }
<span class="nc" id="L492">                getOwner().getLogger().debug(&quot;Processing &quot; + event.toString());</span>
<span class="nc" id="L493">                getEventsToProcess().remove(event);</span>
<span class="nc bnc" id="L494" title="All 2 branches missed.">                if (event instanceof GameEntityChangeEvent) {</span>
                    // Ignore entity changes that don't happen during movement
<span class="nc bnc" id="L496" title="All 2 branches missed.">                    if (getGame().getPhase() != IGame.Phase.PHASE_MOVEMENT) {</span>
<span class="nc" id="L497">                        continue;</span>
                    }
<span class="nc" id="L499">                    GameEntityChangeEvent changeEvent = (GameEntityChangeEvent) event;</span>
<span class="nc bnc" id="L500" title="All 2 branches missed.">                    if (changeEvent.getEntity() == null) {</span>
<span class="nc" id="L501">                        continue; // just to be safe</span>
                    }
<span class="nc" id="L503">                    Entity entity = getGame().getEntity(changeEvent.getEntity().getId());</span>
<span class="nc bnc" id="L504" title="All 2 branches missed.">                    if (entity == null) {</span>
<span class="nc" id="L505">                        continue; // not sure how this can happen, but just to be</span>
                        // safe
                    }
                    // a lot of odd entity changes are send during the firing phase,
                    // none of which are relevant
<span class="nc bnc" id="L510" title="All 2 branches missed.">                    if (getGame().getPhase() == IGame.Phase.PHASE_FIRING) {</span>
<span class="nc" id="L511">                        continue;</span>
                    }
<span class="nc" id="L513">                    Coords position = entity.getPosition();</span>
<span class="nc bnc" id="L514" title="All 2 branches missed.">                    if (position == null) {</span>
<span class="nc" id="L515">                        continue;</span>
                    }
<span class="nc bnc" id="L517" title="All 2 branches missed.">                    if (position.equals(getPathEnumerator().getLastKnownCoords(entity.getId()))) {</span>
<span class="nc" id="L518">                        continue; // no sense in updating a unit if it hasn't moved</span>
                    }
<span class="nc" id="L520">                    getOwner().getLogger().debug(&quot;Received entity change event for &quot;</span>
<span class="nc" id="L521">                                    + changeEvent.getEntity().getDisplayName()</span>
<span class="nc" id="L522">                                    + &quot; (ID &quot; + entity.getId() + &quot;)&quot;);</span>
<span class="nc" id="L523">                    Integer entityId = changeEvent.getEntity().getId();</span>
<span class="nc" id="L524">                    dirtifyUnit(entityId);</span>

<span class="nc bnc" id="L526" title="All 2 branches missed.">                } else if (event instanceof GamePhaseChangeEvent) {</span>
<span class="nc" id="L527">                    GamePhaseChangeEvent phaseChange = (GamePhaseChangeEvent) event;</span>
<span class="nc" id="L528">                    getOwner().getLogger().debug(&quot;Phase change detected: &quot; + phaseChange.getNewPhase().name());</span>
                    // this marks when I can all I can start recalculating paths.
                    // All units are dirty
<span class="nc bnc" id="L531" title="All 2 branches missed.">                    if (phaseChange.getNewPhase() == IGame.Phase.PHASE_MOVEMENT) {</span>
<span class="nc" id="L532">                        getPathEnumerator().clear();</span>
<span class="nc bnc" id="L533" title="All 2 branches missed.">                        for (Entity entity : getGame().getEntitiesVector()) {</span>
<span class="nc bnc" id="L534" title="All 6 branches missed.">                            if (entity.isActive() &amp;&amp; entity.isDeployed() &amp;&amp; entity.getPosition() != null) {</span>
<span class="nc" id="L535">                                getDirtyUnits().add(entity.getId());</span>
                            }
<span class="nc" id="L537">                        }</span>
                    }
                }
            }
<span class="nc" id="L541">            getOwner().getLogger().debug(&quot;Events still to process: &quot; + getEventsToProcess().size());</span>
        } finally {
<span class="nc" id="L543">            GAME_LOCK.unlock();</span>
<span class="nc" id="L544">            getOwner().getLogger().methodEnd();</span>
        }
<span class="nc" id="L546">    }</span>

    /**
     * Called when a unit has moved and should be put on the dirty list, as well
     * as any units who's moves contain that unit
     */
    private void dirtifyUnit(int id) {
<span class="nc" id="L553">        getOwner().getLogger().methodBegin();</span>
        // Prevent Game from changing while processing
<span class="nc" id="L555">        GAME_LOCK.lock();</span>
        try {
            // first of all, if a unit has been removed, remove it from the list and
            // stop
<span class="nc bnc" id="L559" title="All 2 branches missed.">            if (getGame().getEntity(id) == null) {</span>
<span class="nc" id="L560">                getPathEnumerator().getLastKnownLocations().remove(id);</span>
<span class="nc" id="L561">                getPathEnumerator().getUnitMovableAreas().remove(id);</span>
<span class="nc" id="L562">                getPathEnumerator().getUnitPaths().remove(id);</span>
<span class="nc" id="L563">                getPathEnumerator().getUnitPotentialLocations().remove(id);</span>
<span class="nc" id="L564">                return;</span>
            }
            // if a unit has moved or deployed, then it becomes dirty, and any units
            // with its initial or final position
            // in their list become dirty
<span class="nc bnc" id="L569" title="All 2 branches missed.">            if (!getGame().getEntity(id).isAero()) {</span>
<span class="nc" id="L570">                TreeSet&lt;Integer&gt; toDirty = new TreeSet&lt;&gt;(</span>
<span class="nc" id="L571">                        getPathEnumerator().getEntitiesWithLocation(</span>
<span class="nc" id="L572">                                getGame().getEntity(id).getPosition(), true));</span>
<span class="nc" id="L573">                if (getPathEnumerator().getLastKnownLocations()</span>
<span class="nc bnc" id="L574" title="All 2 branches missed.">                        .containsKey(id)) {</span>
<span class="nc bnc" id="L575" title="All 2 branches missed.">                    if ((getGame().getEntity(id) != null)</span>
<span class="nc bnc" id="L576" title="All 2 branches missed.">                            &amp;&amp; getGame().getEntity(id).isSelectableThisTurn()) {</span>
<span class="nc" id="L577">                        toDirty.addAll(getPathEnumerator()</span>
<span class="nc" id="L578">                                .getEntitiesWithLocation(getPathEnumerator()</span>
<span class="nc" id="L579">                                        .getLastKnownLocations().get(id)</span>
<span class="nc" id="L580">                                        .getCoords(), true));</span>
                    }
                }
                // no need to dirty units that aren't selectable this turn
<span class="nc" id="L584">                List&lt;Integer&gt; toRemove = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L585" title="All 2 branches missed.">                for (Integer index : toDirty) {</span>
<span class="nc bnc" id="L586" title="All 2 branches missed.">                    if ((getGame().getEntity(index) == null) || (!getGame()</span>
<span class="nc bnc" id="L587" title="All 2 branches missed.">                            .getEntity(index).isSelectableThisTurn())</span>
<span class="nc" id="L588">                            &amp;&amp; (getGame()</span>
<span class="nc bnc" id="L589" title="All 2 branches missed.">                                    .getPhase() == IGame.Phase.PHASE_MOVEMENT)) {</span>
<span class="nc" id="L590">                        toRemove.add(index);</span>
                    }
<span class="nc" id="L592">                }</span>
<span class="nc bnc" id="L593" title="All 2 branches missed.">                for (Integer i : toRemove) {</span>
<span class="nc" id="L594">                    toDirty.remove(i);</span>
<span class="nc" id="L595">                }</span>

<span class="nc bnc" id="L597" title="All 2 branches missed.">                if (toDirty.size() != 0) {</span>
<span class="nc" id="L598">                    StringBuilder msg = new StringBuilder(&quot;The following units have become dirty&quot;);</span>
<span class="nc bnc" id="L599" title="All 2 branches missed.">                    if (getGame().getEntity(id) != null) {</span>
<span class="nc" id="L600">                        msg.append(&quot; as a result of a nearby move of &quot;)</span>
<span class="nc" id="L601">                           .append(getGame().getEntity(id).getDisplayName());</span>
                    }

<span class="nc" id="L604">                    Iterator&lt;Integer&gt; dirtyIterator = toDirty.descendingIterator();</span>
<span class="nc bnc" id="L605" title="All 2 branches missed.">                    while (dirtyIterator.hasNext()) {</span>
<span class="nc" id="L606">                        Integer i = dirtyIterator.next();</span>
<span class="nc" id="L607">                        Entity e = getGame().getEntity(i);</span>
<span class="nc bnc" id="L608" title="All 2 branches missed.">                        if (e != null) {</span>
<span class="nc" id="L609">                            msg.append(&quot;\n  &quot;).append(e.getDisplayName());</span>
                        }
<span class="nc" id="L611">                    }</span>
<span class="nc" id="L612">                    getOwner().getLogger().debug(msg.toString());</span>
                }
<span class="nc" id="L614">                getDirtyUnits().addAll(toDirty);</span>
            }
<span class="nc" id="L616">            Entity entity = getGame().getEntity(id);</span>
<span class="nc bnc" id="L617" title="All 4 branches missed.">            if ((entity != null) &amp;&amp; (entity.isSelectableThisTurn()) ||</span>
<span class="nc bnc" id="L618" title="All 2 branches missed.">                (getGame().getPhase() != IGame.Phase.PHASE_MOVEMENT)) {</span>
<span class="nc" id="L619">                getDirtyUnits().add(id);</span>
<span class="nc bnc" id="L620" title="All 2 branches missed.">            } else if (entity != null) {</span>
<span class="nc" id="L621">                getPathEnumerator().getLastKnownLocations().put(id,</span>
<span class="nc" id="L622">                        CoordFacingCombo.createCoordFacingCombo(entity));</span>
            }
        } finally {
<span class="nc" id="L625">            GAME_LOCK.unlock();</span>
<span class="nc" id="L626">            getOwner().getLogger().methodEnd();</span>
        }
<span class="nc" id="L628">    }</span>

    PathEnumerator getPathEnumerator() {
<span class="nc" id="L631">        PATH_ENUMERATOR_LOCK.readLock().lock();</span>
        try {
<span class="nc" id="L633">            getOwner().getLogger().debug(&quot;PATH_ENUMERATOR_LOCK read locked.&quot;);</span>
<span class="nc" id="L634">            return pathEnumerator;</span>
        } finally {
<span class="nc" id="L636">            PATH_ENUMERATOR_LOCK.readLock().unlock();</span>
<span class="nc" id="L637">            getOwner().getLogger().debug(&quot;PATH_ENUMERATOR_LOCK read unlocked.&quot;);</span>
        }
    }

    private void setPathEnumerator(PathEnumerator pathEnumerator) {
<span class="fc" id="L642">        PATH_ENUMERATOR_LOCK.writeLock().lock();</span>
        try {
<span class="fc" id="L644">            getOwner().getLogger().debug(&quot;PATH_ENUMERATOR_LOCK write locked.&quot;);</span>
<span class="fc" id="L645">            this.pathEnumerator = pathEnumerator;</span>
        } finally {
<span class="fc" id="L647">            getOwner().getLogger().debug(&quot;PATH_ENUMERATOR_LOCK write unlocked.&quot;);</span>
<span class="fc" id="L648">            PATH_ENUMERATOR_LOCK.writeLock().unlock();</span>
        }
<span class="fc" id="L650">    }</span>
    
    public List&lt;ECMInfo&gt; getECMInfo() {
<span class="nc" id="L653">        return Collections.unmodifiableList(ecmInfo);</span>
    }

    private ConcurrentSkipListSet&lt;Integer&gt; getDirtyUnits() {
<span class="fc" id="L657">        return dirtyUnits;</span>
    }

    private ConcurrentLinkedQueue&lt;GameEvent&gt; getEventsToProcess() {
<span class="fc" id="L661">        return eventsToProcess;</span>
    }

    private AtomicBoolean getWaitWhenDone() {
<span class="fc" id="L665">        return waitWhenDone;</span>
    }

    private AtomicBoolean getWaiting() {
<span class="fc" id="L669">        return waiting;</span>
    }

    private AtomicBoolean getDone() {
<span class="fc" id="L673">        return done;</span>
    }

    private Princess getOwner() {
<span class="fc" id="L677">        return owner;</span>
    }

    void resetGame() {
<span class="nc" id="L681">        GAME_LOCK.lock();</span>
        try {
<span class="nc" id="L683">            getOwner().getLogger().debug(&quot;GAME_LOCK write locked.&quot;);</span>
<span class="nc" id="L684">            game.reset();</span>
        } finally {
<span class="nc" id="L686">            GAME_LOCK.unlock();</span>
<span class="nc" id="L687">            getOwner().getLogger().debug(&quot;GAME_LOCK write unlocked.&quot;);</span>
        }
<span class="nc" id="L689">    }</span>

    private IGame getGame() {
<span class="fc" id="L692">        GAME_LOCK.lock();</span>
        try {
<span class="fc" id="L694">            getOwner().getLogger().debug(&quot;GAME_LOCK read locked.&quot;);</span>
<span class="fc" id="L695">            return game;</span>
        } finally {
<span class="fc" id="L697">            GAME_LOCK.unlock();</span>
<span class="fc" id="L698">            getOwner().getLogger().debug(&quot;GAME_LOCK read unlocked.&quot;);</span>
        }
    }
   
    /**
     * Returns the individual player assigned the index parameter.
     */
    protected IPlayer getPlayer(int idx) {
<span class="nc" id="L706">        return getGame().getPlayer(idx);</span>
    }

    /**
     * Receives player information from the message packet.
     */
    private void receivePlayerInfo(Packet c) {
<span class="nc" id="L713">        int pindex = c.getIntValue(0);</span>
<span class="nc" id="L714">        IPlayer newPlayer = (IPlayer) c.getObject(1);</span>
<span class="nc bnc" id="L715" title="All 2 branches missed.">        if (getPlayer(newPlayer.getId()) == null) {</span>
<span class="nc" id="L716">            getGame().addPlayer(pindex, newPlayer);</span>
        } else {
<span class="nc" id="L718">            getGame().setPlayer(pindex, newPlayer);</span>
        }
<span class="nc" id="L720">    }</span>

    /**
     * Loads the turn list from the data in the packet
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    private void receiveTurns(Packet packet) {
<span class="nc" id="L727">        getGame().setTurnVector((List&lt;GameTurn&gt;) packet.getObject(0));</span>
<span class="nc" id="L728">    }</span>

    /**
     * Loads the board from the data in the net command.
     */
    private void receiveBoard(Packet c) {
<span class="nc" id="L734">        Board newBoard = (Board) c.getObject(0);</span>
<span class="nc" id="L735">        getGame().setBoard(newBoard);</span>
<span class="nc" id="L736">    }</span>

    /**
     * Loads the entities from the data in the net command.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    private void receiveEntities(Packet c) {
<span class="nc" id="L743">        List&lt;Entity&gt; newEntities = (List&lt;Entity&gt;) c.getObject(0);</span>
<span class="nc" id="L744">        List&lt;Entity&gt; newOutOfGame = (List&lt;Entity&gt;) c.getObject(1);</span>

        // Replace the entities in the game.
<span class="nc" id="L747">        getGame().setEntitiesVector(newEntities);</span>
<span class="nc bnc" id="L748" title="All 2 branches missed.">        if (newOutOfGame != null) {</span>
<span class="nc" id="L749">            getGame().setOutOfGameEntitiesVector(newOutOfGame);</span>
        }
<span class="nc" id="L751">    }</span>

    /**
     * Loads entity update data from the data in the net command.
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    private void receiveEntityUpdate(Packet c) {
<span class="nc" id="L758">        int eindex = c.getIntValue(0);</span>
<span class="nc" id="L759">        Entity entity = (Entity) c.getObject(1);</span>
<span class="nc" id="L760">        Vector&lt;UnitLocation&gt; movePath = (Vector&lt;UnitLocation&gt;) c.getObject(2);</span>
        // Replace this entity in the game.
<span class="nc" id="L762">        getGame().setEntity(eindex, entity, movePath);</span>
<span class="nc" id="L763">    }</span>

    private void receiveEntityAdd(Packet packet) {
        @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L767">        List&lt;Integer&gt; entityIds = (List&lt;Integer&gt;) packet.getObject(0);</span>
        @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L769">        List&lt;Entity&gt; entities = (List&lt;Entity&gt;) packet.getObject(1);</span>

<span class="nc bnc" id="L771" title="All 4 branches missed.">        assert (entityIds.size() == entities.size());</span>
<span class="nc bnc" id="L772" title="All 2 branches missed.">        for (int i = 0; i &lt; entityIds.size(); i++) {</span>
<span class="nc bnc" id="L773" title="All 4 branches missed.">            assert (entityIds.get(i) == entities.get(i).getId());</span>
        }
<span class="nc" id="L775">        getGame().addEntities(entities);</span>
<span class="nc" id="L776">    }</span>

    private void receiveEntityRemove(Packet packet) {
        @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L780">        List&lt;Integer&gt; entityIds = (List&lt;Integer&gt;) packet.getObject(0);</span>
<span class="nc" id="L781">        int condition = packet.getIntValue(1);</span>
        // Move the unit to its final resting place.
<span class="nc" id="L783">        getGame().removeEntities(entityIds, condition);</span>
<span class="nc" id="L784">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    private void receiveEntityVisibilityIndicator(Packet packet) {
<span class="nc" id="L788">        Entity e = getGame().getEntity(packet.getIntValue(0));</span>
<span class="nc bnc" id="L789" title="All 2 branches missed.">        if (e != null) { // we may not have this entity due to double blind</span>
<span class="nc" id="L790">            e.setEverSeenByEnemy(packet.getBooleanValue(1));</span>
<span class="nc" id="L791">            e.setVisibleToEnemy(packet.getBooleanValue(2));</span>
<span class="nc" id="L792">            e.setDetectedByEnemy(packet.getBooleanValue(3));</span>
<span class="nc" id="L793">            e.setWhoCanSee((Vector&lt;IPlayer&gt;)packet.getObject(4));</span>
<span class="nc" id="L794">            e.setWhoCanDetect((Vector&lt;IPlayer&gt;)packet.getObject(5));</span>
            // this next call is only needed sometimes, but we'll just
            // call it everytime
<span class="nc" id="L797">            getGame().processGameEvent(new GameEntityChangeEvent(this, e));</span>
        }
<span class="nc" id="L799">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    private void receiveDeployMinefields(Packet packet) {
<span class="nc" id="L803">        getGame().addMinefields((Vector&lt;Minefield&gt;) packet.getObject(0));</span>
<span class="nc" id="L804">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    private void receiveSendingMinefields(Packet packet) {
<span class="nc" id="L808">        getGame().setMinefields((Vector&lt;Minefield&gt;) packet.getObject(0));</span>
<span class="nc" id="L809">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    private void receiveIlluminatedHexes(Packet p) {
<span class="nc" id="L813">        getGame().setIlluminatedPositions((HashSet&lt;Coords&gt;) p.getObject(0));</span>
<span class="nc" id="L814">    }</span>

    private void receiveRevealMinefield(Packet packet) {
<span class="nc" id="L817">        getGame().addMinefield((Minefield) packet.getObject(0));</span>
<span class="nc" id="L818">    }</span>

    private void receiveRemoveMinefield(Packet packet) {
<span class="nc" id="L821">        getGame().removeMinefield((Minefield) packet.getObject(0));</span>
<span class="nc" id="L822">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    private void receiveUpdateMinefields(Packet packet) {
        // only update information if you know about the minefield
<span class="nc" id="L827">        Vector&lt;Minefield&gt; newMines = new Vector&lt;&gt;();</span>
<span class="nc bnc" id="L828" title="All 2 branches missed.">        for (Minefield mf : (Vector&lt;Minefield&gt;) packet.getObject(0)) {</span>
<span class="nc bnc" id="L829" title="All 2 branches missed.">            if (getOwner().getLocalPlayer().containsMinefield(mf)) {</span>
<span class="nc" id="L830">                newMines.add(mf);</span>
            }
<span class="nc" id="L832">        }</span>
<span class="nc bnc" id="L833" title="All 2 branches missed.">        if (newMines.size() &gt; 0) {</span>
<span class="nc" id="L834">            getGame().resetMinefieldDensity(newMines);</span>
        }
<span class="nc" id="L836">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    private void receiveBuildingUpdate(Packet packet) {
<span class="nc" id="L840">        getGame().getBoard().updateBuildings((Vector&lt;Building&gt;) packet.getObject(0));</span>
<span class="nc" id="L841">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    private void receiveBuildingCollapse(Packet packet) {
<span class="nc" id="L845">        getGame().getBoard().collapseBuilding((Vector&lt;Coords&gt;) packet.getObject(0));</span>
<span class="nc" id="L846">    }</span>

    /**
     * Loads entity firing data from the data in the net command
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    private void receiveAttack(Packet c) {
<span class="nc" id="L853">        List&lt;EntityAction&gt; vector = (List&lt;EntityAction&gt;) c.getObject(0);</span>
<span class="nc" id="L854">        int charge = c.getIntValue(1);</span>
<span class="nc" id="L855">        boolean addAction = true;</span>
<span class="nc bnc" id="L856" title="All 2 branches missed.">        for (EntityAction ea : vector) {</span>
<span class="nc" id="L857">            int entityId = ea.getEntityId();</span>
<span class="nc bnc" id="L858" title="All 4 branches missed.">            if ((ea instanceof TorsoTwistAction) &amp;&amp; getGame().hasEntity(entityId)) {</span>
<span class="nc" id="L859">                TorsoTwistAction tta = (TorsoTwistAction) ea;</span>
<span class="nc" id="L860">                Entity entity = getGame().getEntity(entityId);</span>
<span class="nc" id="L861">                entity.setSecondaryFacing(tta.getFacing());</span>
<span class="nc bnc" id="L862" title="All 2 branches missed.">            } else if ((ea instanceof FlipArmsAction)</span>
<span class="nc bnc" id="L863" title="All 2 branches missed.">                    &amp;&amp; getGame().hasEntity(entityId)) {</span>
<span class="nc" id="L864">                FlipArmsAction faa = (FlipArmsAction) ea;</span>
<span class="nc" id="L865">                Entity entity = getGame().getEntity(entityId);</span>
<span class="nc" id="L866">                entity.setArmsFlipped(faa.getIsFlipped());</span>
<span class="nc bnc" id="L867" title="All 4 branches missed.">            } else if ((ea instanceof DodgeAction) &amp;&amp; getGame().hasEntity(entityId)) {</span>
<span class="nc" id="L868">                Entity entity = getGame().getEntity(entityId);</span>
<span class="nc" id="L869">                entity.dodging = true;</span>
<span class="nc" id="L870">                addAction = false;</span>
<span class="nc bnc" id="L871" title="All 2 branches missed.">            } else if (ea instanceof AttackAction) {</span>
                // The equipment type of a club needs to be restored.
<span class="nc bnc" id="L873" title="All 2 branches missed.">                if (ea instanceof ClubAttackAction) {</span>
<span class="nc" id="L874">                    ClubAttackAction caa = (ClubAttackAction) ea;</span>
<span class="nc" id="L875">                    Mounted club = caa.getClub();</span>
<span class="nc" id="L876">                    club.restore();</span>
                }
            }

<span class="nc bnc" id="L880" title="All 2 branches missed.">            if (addAction) {</span>
                // track in the appropriate list
<span class="nc bnc" id="L882" title="All 2 branches missed.">                if (charge == 0) {</span>
<span class="nc" id="L883">                    getGame().addAction(ea);</span>
<span class="nc bnc" id="L884" title="All 4 branches missed.">                } else if ((charge == 1) &amp;&amp; (ea instanceof AttackAction)) {</span>
<span class="nc" id="L885">                    getGame().addCharge((AttackAction) ea);</span>
                }
            }
<span class="nc" id="L888">        }</span>
<span class="nc" id="L889">    }</span>
    
    /**
     * receive and process an entity nova network mode change packet
     *
     * @param c The packet containing the change.
     */
    private void receiveEntityNovaNetworkModeChange(Packet c) {
        try {
<span class="nc" id="L898">            int entityId = c.getIntValue(0);</span>
<span class="nc" id="L899">            String networkID = c.getObject(1).toString();</span>
<span class="nc" id="L900">            Entity e = getGame().getEntity(entityId);</span>
<span class="nc bnc" id="L901" title="All 2 branches missed.">            if (e != null) {</span>
<span class="nc" id="L902">                e.setNewRoundNovaNetworkString(networkID);</span>
            }
<span class="nc" id="L904">        } catch (Exception ex) {</span>
<span class="nc" id="L905">            getOwner().getLogger().error(ex);</span>
<span class="nc" id="L906">        }</span>

<span class="nc" id="L908">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.4.201905082037</span></div></body></html>